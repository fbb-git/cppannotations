<!DOCTYPE html><html><head>
<meta charset="UTF-8">
<title> C++ Annotations Version 10.4.1-pre </title>
<link rel="stylesheet" type="text/css" href="cplusplus.css"><style type="text/css">
    figure {text-align: center;}
    img {vertical-align: center;}
</style>
<link rel="stylesheet" type="text/css" href="cplusplus.css"></head>
<body >
<hr>
<ul>
    <li> <a href="cplusplus.html">Table of Contents</a>
    <li> <a href="cplusplus11.html">Previous Chapter</a>
    <li> <a href="cplusplus13.html">Next Chapter</a>
</ul>
<hr>
<a name="CONTAINERS"></a><a name="l221"></a>
<h1>Chapter 12: Abstract Containers</h1>
<strong>C++</strong> offers several predefined datatypes, all part of the
 <a href="cplusplus18.html#STL">Standard Template Library</a>,
which can be used to implement solutions to frequently occurring problems. The
datatypes discussed in this chapter are all
 <a name="an1188"></a> <em>containers</em>: you can put stuff inside them, and you can
retrieve the stored information from them.
<p>
The interesting part is that the kind of data that can be stored inside these
containers has been left unspecified at the time the containers were
constructed. That's why they are spoken of as <em>abstract</em> containers.
<p>
Abstract containers rely heavily on <em>templates</em>, covered in chapter
<a href="cplusplus21.html#TEMPLATES">21</a> and beyond. To use abstract containers, only a minimal grasp of
the template concept is required. In <strong>C++</strong> a template is in fact a recipe
for constructing a function or a complete class. The recipe tries to abstract
the functionality of the class or function as much as possible from the data
on which the class or function operates. As the data types on which the
templates operate were not known when the template was implemented, the
datatypes are either inferred from the context in which a function template is
used, or they are mentioned explicitly when a class template is used (the term
that's used here is <em>instantiated</em>). In situations where the types are
explicitly mentioned, the <em>angle bracket notation</em> is used to indicate
which data types are required. For example, below (in section <a href="cplusplus12.html#PAIR">12.2</a>) we'll
encounter the <a name="an1189"></a><code>pair</code> container, which requires the
explicit mentioning of two data types. Here is a <code>pair</code> object
containing both an <code>int</code> and a <code>string</code>:
        <pre>
    pair&lt;int, string&gt; myPair;
</pre>
    The object <code>myPair</code> is defined as an object holding both an <code>int</code> and
a <code>string</code>.
<p>
The angle bracket notation is used intensively in the upcoming
discussion of abstract containers. Actually, understanding this part of
templates is the only real requirement for using abstract containers. Now
that we've introduced this notation, we can postpone the more thorough
discussion of templates to chapter <a href="cplusplus21.html#TEMPLATES">21</a>, and concentrate on
their use in this chapter.
<p>
Most of the abstract containers are <em>sequential</em> containers: they contain
data that can be stored and retrieved in some sequential
way. Examples are the <code>array</code>, implementing a fixed-sized array; a 
<code>vector</code>, implementing an extendable array; the
<code>list</code>, implementing a data structure that allows for the easy insertion or
deletion of  data; the <code>queue</code>, also called a <a name="an1190"></a><em>FIFO</em>
    (<a name="an1191"></a>first in, first out) structure, in which the first element that is
entered is the first element to be retrieved again; and the <code>stack</code>,
which is a
    <a name="an1192"></a><em>first in, last out</em> (<a name="an1193"></a>FILO or <a name="an1194"></a>LIFO) structure.
<p>
In addition to sequential containers several special containers are
available. The <code>pair</code> is a basic container in which a pair of values (of
types that are left open for further specification) can be stored, like two
strings, two ints, a string and a double, etc.. Pairs are often used to return
data elements that naturally come in pairs. For example, the <code>map</code> is an
abstract container storing keys and their associated values. Elements
of these maps are returned as <code>pairs</code>.
<p>
A variant of the <code>pair</code> is the <code>complex</code> container, implementing
operations that are defined on complex numbers.
<p>
A <code>tuple</code> (cf. section <a href="cplusplus22.html#TUPLES">22.6</a>) generalizes the <code>pair</code> container to a
data structure accomodating any number of different data types.
<p>
All abstract containers described in this chapter as well as the <code>string</code>
and stream datatypes (cf. chapters <a href="cplusplus05.html#String">5</a> and <a href="cplusplus06.html#IOStreams">6</a>) are part of
the Standard Template Library.
<p>
All but the unordered containers support
        <a name="an1195"></a>
        <a name="an1196"></a>
        <a name="an1197"></a>
    the following basic set of operators:
    <ul>
    <li> The <a name="an1198"></a>overloaded assignment operator, so we can assign two
containers of the same types to each other. If the container's data type
supports move assignment, then assignment of an anonymous temporary container
to a destination container will use move assignment when assigning new values
to the destination container's element. Overloaded assignment is <em>also</em>
supported by the unordered containers;
    <li> <a name="an1199"></a> Tests for equality: <a name="an1200"></a><code>==</code> and <a name="an1201"></a><code>!=</code>
The <a name="an1202"></a>equality operator applied to two containers returns <code>true</code> if the two
containers have the same number of elements, which are pairwise equal
according to the equality operator of the contained data type. The
<a name="an1203"></a>inequality operator does the opposite;
    <li> <a name="an1204"></a> Ordering operators: <a name="an1205"></a><code>&lt;</code>, <a name="an1206"></a><code>&lt;=</code>, <a name="an1207"></a><code>&gt;</code> and
<a name="an1208"></a><code>&gt;=</code>.  The <code>&lt;</code> operator returns <code>true</code> if each element in the
<a name="an1209"></a>left-hand side container is less than each corresponding element in the
<a name="an1210"></a>right-hand side container. Additional elements in either the left-hand side
container or the right-hand side container are ignored.
    <pre>
container left;
container right;

left = {0, 2, 4};
right = {1, 3};             // left &lt; right

right = {1, 3, 6, 1, 2};    // left &lt; right
</pre>
        </ul>
    Note that <a name="an1211"></a> before a
user-defined type (usually a <code>class</code>-type) can be stored in a container, the
user-defined type should at least support:
    <ul>
    <li> A default value (e.g., a <a name="an1212"></a>default constructor)
    <li> The <a name="an1213"></a>equality operator (<a name="an1214"></a><code>==</code>)
    <li> The <a name="an1215"></a>less-than operator (<a name="an1216"></a><code>&lt;</code>)
    </ul>
    Sequential containers can also be initialized using <em>initializer lists</em>.
<p>
Most containers (exceptions are the <a href="cplusplus12.html#STACK">stack</a> (section
<a href="cplusplus12.html#STACK">12.4.11</a>), <a href="cplusplus12.html#PRIQUEUE">priority_queue</a> (section
<a href="cplusplus12.html#PRIQUEUE">12.4.5</a>), and <a href="cplusplus12.html#QUEUE">queue</a> (section
<a href="cplusplus12.html#QUEUE">12.4.4</a>) containers) support members to determine their maximum sizes
(through their member function <a name="an1217"></a>max_size).
<p>
Virtually all containers support copy construction.  If the container
supports copy construction and the container's data type supports move
construction, then move construction is automatically used for the container's
data elements when a container is initialized with an anonymous temporary
container.
<p>
Closely linked to the standard template library are the
    <a name="an1218"></a><em>generic algorithms</em>. These algorithms may be used to perform
frequently occurring tasks or more complex tasks than is possible with the
containers themselves, like counting, filling, merging, filtering etc.. An
<a name="an1219"></a>overview of generic algorithms and their applications is given in chapter
<a href="cplusplus19.html#GENERIC">19</a>. Generic algorithms usually rely on the availability of
    <a name="an1220"></a><a href="cplusplus18.html#ITERATORS"><em>iterators</em></a>, representing begin and
end-points for processing data stored inside containers. The abstract
containers usually support constructors and members expecting iterators, and
they often have members returning iterators (comparable to the
<code>string::begin</code> and <code>string::end</code> members). In this chapter the
iterator concept is not further investigated. Refer to chapter <a href="cplusplus18.html#STL">18</a> for
this.
<p>
The url <a name="an1221"></a>
<a target=_top href="http://www.sgi.com/Technology/STL">http://www.sgi.com/Technology/STL</a> is worth visiting as it offers more
extensive coverage of abstract containers and the standard template library
than can be provided by the <strong>C++</strong> annotations.
<p>
Containers often collect data during their lifetimes. When a container
goes out of scope, its destructor tries to destroy its data elements. This
only succeeds if the data elements themselves are stored inside the
container. If the <a name="an1222"></a> data elements of containers
are pointers to dynamically allocated memory then the memory pointed to by
these pointers is not destroyed, resulting in a <a name="an1223"></a>memory leak. A consequence
of this scheme is that the data stored in a container should often be
considered the `property' of the container: the container should be able to
destroy its data elements when the container's destructor is called. So,
normally containers should not contain pointers to data. Also, a container
should not be required <a name="an1224"></a>
    <a name="an1225"></a> to contain <code>const</code> data, as <code>const</code> data
prevent the use of many of the container's members, like the assignment
operator.
<p>
<a name="l222"></a>
<h2>12.1: Notations used in this chapter</h2>
    In this chapter about containers, the following notational conventions are
used:
    <ul>
    <li> Containers live in the standard namespace. In code examples this will
be clearly visible, but in the text <code>std::</code> is usually omitted.
    <li> A <a name="an1226"></a>container without angle brackets represents any container of
that type. Mentally add the required type in
    <a name="an1227"></a>angle bracket notation. E.g., <code>pair</code> may represent <code>pair&lt;string,
int&gt;</code>.
    <li> The notation <a name="an1228"></a><code>Type</code> represents the <a name="an1229"></a>generic type. <code>Type</code> could
be <code>int</code>, <code>string</code>, etc.
    <li> Identifiers <code>object</code> and <code>container</code> represent objects of the
container type under discussion.
    <li> The identifier <code>value</code> represents a value of the type that is
stored in the container.
    <li> Simple, one-letter identifiers, like <code>n</code> represent unsigned
values.
    <li> Longer identifiers represent <a name="an1230"></a>iteratoriterators. Examples
are <code>pos</code>, <code>from</code>, <code>beyond</code>
    </ul>
    Some containers, e.g., the <code>map</code> container, contain pairs of
values, usually called `keys' and `values'. For such containers the following
notational convention is used in addition:
    <ul>
    <li> The identifier <code>key</code> indicates a value of the used key-type
    <li> The identifier <code>keyvalue</code> indicates a value of the `<code>value_type</code>'
used with the particular container.
    </ul>
<p>
<a name="PAIR"></a><a name="l223"></a>
<h2>12.2: The `pair' container</h2>
The <a name="an1231"></a> <a name="an1232"></a><code>pair</code> container is a rather basic container. It is
used to store two elements, called <a name="an1233"></a><code>first</code> and <a name="an1234"></a><code>second</code>, and that's about
it. Before using <code>pair</code> containers the header file <a name="an1235"></a><code>&lt;utility&gt;</code> must be
included.
<p>
The <code>pair</code>'s data types are specified when the <code>pair</code> object is
defined (or declared) using the template's angle bracket notation (cf. chapter
<a href="cplusplus21.html#TEMPLATES">21</a>). Examples:
        <pre>
    pair&lt;string, string&gt; piper("PA28", "PH-ANI");
    pair&lt;string, string&gt; cessna("C172", "PH-ANG");
</pre>
    here, the variables <code>piper</code> and <code>cessna</code> are defined as <code>pair</code>
variables containing two <code>strings</code>. Both strings can be retrieved using the
<code>first</code> and <code>second</code> fields of the <code>pair</code> type:
        <pre>
    cout &lt;&lt; piper.first &lt;&lt; '\n' &lt;&lt;      // shows 'PA28'
            cessna.second &lt;&lt; '\n';      // shows 'PH-ANG'
</pre>
    The <code>first</code> and <code>second</code> members can also be used to reassign values:
        <pre>
    cessna.first = "C152";
    cessna.second = "PH-ANW";
</pre>
    If a <code>pair</code> object must be completely reassigned, an <em>anonymous</em>
<a name="an1236"></a> pair object can be used as the <a name="an1237"></a>right-hand operand of
the assignment. An anonymous variable defines a temporary variable (which
receives no name) solely for the purpose of (re)assigning another variable of
the same type. Its <a name="an1238"></a> generic form is
        <pre>
    type(initializer list)
</pre>
    Note that when a <code>pair</code> object is used the type specification is not
completed by just mentioning the containername <code>pair</code>. It also requires the
specification of the data types which are stored within the pair. For this the
(template) <a name="an1239"></a>angle bracket notation is used again. E.g., the reassignment
of the <code>cessna</code> pair variable could have been accomplished as follows:
        <pre>
    cessna = pair&lt;string, string&gt;("C152", "PH-ANW");
</pre>
    In cases like these, the <code>type</code> specification can become quite
elaborate, which has caused a revival of interest in the possibilities offered
by the <a name="an1240"></a><code>typedef</code> keyword. If many <a name="an1241"></a><code>pair&lt;type1, type2&gt;</code> clauses are
used in a source, the typing effort may be reduced and readability might be
improved by first defining a name for the clause, and then using the defined
name later. E.g.,
        <pre>
    typedef pair&lt;string, string&gt; pairStrStr;

    cessna = pairStrStr("C152", "PH-ANW");
</pre>
    Apart from this (and the basic set of operations (assignment and
comparisons)) the <code>pair</code> offers no further <a name="an1242"></a>functionality. It is, however,
a basic ingredient of the upcoming abstract containers <code>map, multimap</code> and
<code>hash_map</code>.
<p>
<strong>C++</strong> also offers a <a name="an1243"></a><em>generalized pair</em> container: the <em>tuple</em>, covered
in section <a href="cplusplus22.html#TUPLES">22.6</a>.
<p>
<a name="l224"></a>
<h2>12.3: Allocators</h2>
Most containers use a special object for allocating the memory that is managed
by them. This object is called an <a name="an1244"></a>allocator, and it's type is (usually by
default) specified when a container is constructed. A container's allocator
can be obtained using the container's <code>get_allocator</code> member, which returns
a copy of the allocator used by the container. Allocators offer the following
members:
    <ul>
    <li><a name="an1245"></a><code>value_type *address(value_type &amp;object)</code>
        <blockquote>returns the address of <code>object</code>.</blockquote>
    <li><a name="an1246"></a><code>value_type *allocate(size_t count)</code>
        <blockquote>allocates raw memory for holding <code>count</code> values of the
container's <code>value_type</code>.</blockquote>
    <li><a name="an1247"></a><code>void construct(value_type *object, Arg &amp;&amp;...args)</code>
        <blockquote>using placement new, uses the arguments following <code>object</code> to
install a value at <code>object</code>.</blockquote>
    <li><a name="an1248"></a><code>void destroy(value_type *object)</code>
        <blockquote>calls <code>object</code>'s destructor (but doesn't deallocate
<code>object</code>'s own memory).</blockquote>
    <li><a name="an1249"></a><code>void deallocate(value_type *object, size_t count)</code>
        <blockquote>calls <code>operator delete</code> to delete object's memory, previously
allocated by <code>allocate</code>.</blockquote>
    <li><a name="an1250"></a><code>size_t max_size()</code>
        <blockquote>returns the maximum number of elements that <code>allocate</code> can
allocate.</blockquote>
    </ul>
<p>
Here is an example, using the allocator of a vector of strings (see
section <a href="cplusplus12.html#VECTOR">12.4.2</a> below for a description of the <code>vector</code> container):
    <pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;

using namespace std;

int main()
{
    vector&lt;string&gt; vs;

    auto allocator = vs.get_allocator();        // get the allocator

    string *sp = allocator.allocate(3);         // alloc. space for 3 strings

    allocator.construct(&amp;sp[0], "hello world"); // initialize 1st string
    allocator.construct(&amp;sp[1], sp[0]);         // use the copy constructor
    allocator.construct(&amp;sp[2], 12, '=');       // string of 12 = chars

    cout &lt;&lt; sp[0] &lt;&lt; '\n' &lt;&lt;                    // show the strings
            sp[1] &lt;&lt; '\n' &lt;&lt;
            sp[2] &lt;&lt; '\n' &lt;&lt;
            "could have allocated " &lt;&lt; allocator.max_size() &lt;&lt; " strings\n";

    for (size_t idx = 0; idx != 3; ++idx)
        allocator.destroy(sp + idx);            // delete the string's
                                                // contents

    allocator.deallocate(sp, 3);                // and delete sp itself again.
}
</pre>
<p>
<a name="l225"></a>
<h2>12.4: Available Containers</h2>
<p>
<a name="l226"></a>
<h3>12.4.1: The `array' container</h3>
    The <a name="an1251"></a><code>array</code> class implements a 
    <a name="an1252"></a> <a name="an1253"></a>fixed-size array.  Before using the <code>array</code>
container the <a name="an1254"></a><code>&lt;array&gt;</code> header file must be included.
<p>
To define a <code>std::array</code> both the data type of its elements and its size
must be specified: the data type is given after an opening angular bracket,
immediately following the `<code>array</code>' container name. The array's size is
provided after the data type specification. Finally, a closing angular bracket
completes the array's type. Specifications like this are common practice with
containers.  The combination of <code>array</code>, type and size defines a
<em>type</em>. As a result, <code>array&lt;string, 4&gt;</code> defines another type than
<code>array&lt;string, 5&gt;</code>, and a function explicitly defining an <code>array&lt;Type, N&gt;</code>
parameter will not accept an <code>array&lt;Type, M&gt;</code> argument if <code>N</code> and <code>M</code>
are unequal.
<p>
The array's size may may be defined as 0 (although such an array probably has
little use as it cannot store any element). The elements of an array are
stored contiguously. If <code>array&lt;Type, N&gt; arr</code> has been defined, then
<code>&amp;arr[n] + m == &amp;arr[n + m</code>, assuming <code>0 &lt;= n &lt; N</code> and assuming <code>0 &lt;= n
+ m &lt; N</code>.
<p>
The following constructors, operators, and member functions are available:
    <ul>
    <li> <a name="an1255"></a> Constructors:
        <ul>
        <li> The copy and move constructors are available;
        <li> A <code>array</code> may be constructed with a fixed number <code>N</code> of
default elements:
        <pre>
array&lt;string, N&gt; object;
</pre>
        <li> An initial subset of the elements of an array may be 
initialized using a brace delimited initializer list:
    <pre>
array&lt;double, 4&gt; dArr = {1.2, 2.4};
</pre>
    Here <code>dArr</code> is defined as an array of 4 element, with <code>dArr[0]</code> and
<code>dArr[1]</code> initialized to, respectively 1.2 and 2.4, and <code>dArr[2]</code> and
<code>dArr[3]</code> initialized to 0.  A attractive characteristic of arrays (and
other containers) is that containers initialize <a name="an1256"></a>
their data elements to the data type's default value. The data type's
<em>default constructor</em> is used for this <a name="an1257"></a>initialization. With non-class
data types the value 0 is used.  So, for an <code>array&lt;double, 4&gt;</code> array we know
that all but its explicitly initialized elements are initialized to
zero. 
        </ul>
    <li> In addition to the standard operators for containers, the <code>array</code>
supports the <a name="an1258"></a>index operator, which can be used to retrieve or reassign
individual elements of the array. Note that the elements which are indexed
must exist. For example, having defined an empty array a statement like
<code>iarr[0] = 18</code> produces an error, as the array is empty. Note that 
<code>operator[]</code> does <em>not</em> respect its
 <a name="an1259"></a>array bounds. If you want run-time array bound checking, use the array's
<code>at</code> member.
    <li> The <code>array</code> class offers the following
 <a name="an1260"></a> member functions:
        <ul>
        <li><a name="an1261"></a><code>Type &amp;at(size_t idx)</code>:<blockquote>returns a reference to the array's element at index position
            <code>idx</code>. If <code>idx</code> exceeds the array's size a
            <code>std::out_of_range</code> exception is thrown.</blockquote>
        <li><a name="an1262"></a><code>Type &amp;back()</code>:<blockquote>returns a reference to the last element in the array. It is the
            <a name="an1263"></a>responsibility of the programmer to use the member only if the
            array is not empty.</blockquote>
        <li><a name="an1264"></a><code>array::iterator begin()</code>:<blockquote>returns an <a name="an1265"></a>iterator pointing to the first
            element in the array, returning <code>end</code> if the array is empty.</blockquote>
        <li><a name="an1266"></a><code>array::const_iterator cbegin()</code>:<blockquote>returns a <a name="an1267"></a>const_iterator pointing to the first element in the
            array, returning <code>cend</code> if the array is empty.</blockquote>
        <li><a name="an1268"></a><code>array::const_iterator cend()</code>:<blockquote>returns a <a name="an1269"></a>const_iterator pointing just beyond the array's last
            element.</blockquote>
        <li><a name="an1270"></a><code>array::const_reverse_iterator crbegin()</code>:<blockquote>returns a <a name="an1271"></a>const_reverse_iterator pointing to the last element
            in the array, returning <code>crend</code> if the array is empty.</blockquote>
        <li><a name="an1272"></a><code>array::const_reverse_iterator crend()</code>:<blockquote>returns a <a name="an1273"></a>const_reverse_iterator pointing just before the
            array's first element.</blockquote>
        <li><a name="an1274"></a><code>value_type *data()</code>:<blockquote>returns a pointer to the array's first data element. With a const
            array a <code>value_type const *</code> is returned.</blockquote>
        <li><a name="an1275"></a><code>bool empty()</code>:<blockquote>returns <code>true</code> if the array contains no elements.</blockquote>
        <li><a name="an1276"></a><code>array::iterator end()</code>:<blockquote>returns an iterator pointing beyond the last element in the
            array.</blockquote>
        <li><a name="an1277"></a><code>void fill(Type const &amp;item)</code>:<blockquote>fills all the array's elements with a copy of <code>item</code></blockquote>
        <li><a name="an1278"></a><code>Type &amp;front()</code>:<blockquote>returns a reference to the first element in the array. It is the
            responsibility of the programmer to use the member only if
            the array is not empty.</blockquote>
        <li><a name="an1279"></a><code>array::reverse_iterator rbegin()</code>:<blockquote><a name="an1280"></a> this member returns an iterator pointing to
            the last element in the array.</blockquote>
        <li><a name="an1281"></a><code>array::reverse_iterator rend()</code>:<blockquote>returns an iterator pointing before the first element in the
            array.</blockquote>
        <li><a name="an1282"></a><code>constexpr size_t size()</code>:<blockquote>returns the number of elements the array contains.</blockquote>
        <li><a name="an1283"></a><code>void swap(&lt;array&lt;Type, N&gt; &amp;other)</code>:<blockquote>swaps the contents of the current and other array. The array
            other's data type and size must be equal to the data type and size
            of the object calling <code>swap</code>.</blockquote>
        </ul>
    </ul>
    Using an <code>array</code> rather than a standard <strong>C</strong> style array offers several
advantages:
    <ul>
    <li> All its elements are immediately initialized;
    <li> Introspection is possible (e.g., <code>size</code> can be used);
    <li> The <code>array</code> container can be used in the context of templates,
        there code is developed that operates on data types that become
        available only after the code itself has been developed;
    <li> Since <code>array</code> supports reverse iterators, it can be immediately be
        used with generic algorithms performing `reversed' operations (e.g.,
        to perform a descending rather than ascending sort (cf. section
        <a href="cplusplus19.html#SORT">19.1.58</a>))
    </ul>
    In general, when looking for a sequential data structure, the <code>array</code> or
<code>vector</code> (introduced in the next section) should be your `weapon of
choice'. Only if these containers demonstrably do not fit the problem at hand
you should use another type of container.
<p>
<a name="VECTOR"></a><a name="l227"></a>
<h3>12.4.2: The `vector' container</h3>
    The <a name="an1284"></a><code>vector</code> class implements an 
    <a name="an1285"></a><a name="an1286"></a>expandable array.  Before using the <code>vector</code>
container the <a name="an1287"></a><code>&lt;vector&gt;</code> header file must be included.
<p>
The following constructors, operators, and member functions are available:
    <ul>
    <li> <a name="an1288"></a> Constructors:
        <ul>
        <li> The copy and move constructors are available;
        <li> A <code>vector</code> may be constructed empty:
        <pre>
vector&lt;string&gt; object;
</pre>
        <li> A vector may be initialized to a certain number of elements:
    <pre>
vector&lt;string&gt; object(5, string("Hello")); // initialize to 5 Hello's,
vector&lt;string&gt; container(10);              // and to 10 empty strings
vector&lt;string&gt; names = {"george", "frank", "tony", "karel"}; 
</pre>
        <li> A vector may be initialized using iterators. To
initialize a vector with elements 5 until 10 (including the last one) of an
existing <code>vector&lt;string&gt;</code> the following construction may be used:
    <pre>
extern vector&lt;string&gt; container;
vector&lt;string&gt; object(&amp;container[5], &amp;container[11]);
</pre>
<p>
Note here that the last element pointed to by the second iterator
(<code>&amp;container[11]</code>) is <em>not</em> stored in <code>object</code>.  This is a simple
example of the use of <a name="an1289"></a><em>iterators</em>, in which the 
    <a name="an1290"></a>range of values that is used starts at the first value, and includes
all elements up to but not including the element to which the second iterator
refers. The standard <a name="an1291"></a>notation for this is <a name="an1292"></a><code>[begin, end)</code>.
        </ul>
    <li> In addition to the standard operators for containers, the <code>vector</code>
supports the <a name="an1293"></a>index operator, which can be used to retrieve or reassign
individual elements of the vector. Note that the elements which are indexed
must exist. For example, having defined an empty vector a statement like
<code>ivect[0] = 18</code> produces an error, as the vector is empty.  So, the vector
is <em>not</em> automatically
 <a name="an1294"></a> expanded, and <code>operator[]</code> does <em>not</em> respect its
 <a name="an1295"></a>array bounds. In this case the vector should be resized first, or
<code>ivect.push_back(18)</code> should be used (see below). If you need run-time array
bound checking, use the vector's <code>at</code> member.
    <li> The <code>vector</code> class offers the following
 <a name="an1296"></a> member functions:
        <ul>
        <li><a name="an1297"></a><code>void assign(...)</code>:<blockquote>assigns new contents to the vector:</blockquote>
            <ul>
            <li><code>assign(iterator begin, iterator end)</code> assigns the values at
the iterator range <code>[begin, end)</code> to the vector;
            <li><code>assign(size_type n, value_type const &amp;val)</code> assigns <code>n</code>
copies of <code>val</code> to the vector;
            <li><code>assign(initializer_list&lt;value_type&gt; values)</code> assigns the
values in the initializer list to the vector.
                </ul>
<p>
<li><a name="an1298"></a><code>Type &amp;at(size_t idx)</code>:<blockquote>returns a reference to the vector's element at
index position <code>idx</code>. If <code>idx</code> exceeds the vector's size a
<code>std::out_of_range</code> exception is thrown.</blockquote>
        <li><a name="an1299"></a><code>Type &amp;back()</code>:<blockquote>returns a reference to the last element in the
vector. It is the <a name="an1300"></a>responsibility of the programmer to use the member only
if the vector is not empty.</blockquote>
        <li><a name="an1301"></a><code>vector::iterator begin()</code>:<blockquote>returns an <a name="an1302"></a>iterator pointing to the first
element in the vector, returning <code>end</code> if the vector is empty.</blockquote>
        <li><a name="an1303"></a><code>size_t capacity()</code>:<blockquote>Number of elements for which memory has been
allocated. It returns at least the value returned by <code>size</code></blockquote>
        <li><a name="an1304"></a><code>vector::const_iterator cbegin()</code>:<blockquote>returns a <a name="an1305"></a>const_iterator pointing to the first
element in the vector, returning <code>cend</code> if the vector is empty.</blockquote>
        <li><a name="an1306"></a><code>vector::const_iterator cend()</code>:<blockquote>returns a <a name="an1307"></a>const_iterator pointing just beyond the
vector's last element.</blockquote>
        <li><a name="an1308"></a><code>void clear()</code>:<blockquote>erases all the vector's elements.</blockquote>
        <li><a name="an1309"></a><code>vector::const_reverse_iterator crbegin()</code>:<blockquote>returns a <a name="an1310"></a>const_reverse_iterator pointing to the last
element in the vector, returning <code>crend</code> if the vector is empty.</blockquote>
        <li><a name="an1311"></a><code>vector::const_reverse_iterator crend()</code>:<blockquote>returns a <a name="an1312"></a>const_reverse_iterator pointing just before the
vector's first element.</blockquote>
        <li><a name="an1313"></a><code>value_type *data()</code>:<blockquote>returns a pointer to the vector's first data element.</blockquote>
        <li><a name="an1314"></a><code>iterator emplace(const_iterator position, Args &amp;&amp;...args)</code>:<blockquote>a <code>value_type</code> object is constructed from the arguments
specified after <code>position</code>, and the newly created element is inserted at
<code>position</code>.</blockquote>
        <li><a name="an1315"></a><code>void emplace_back(Args &amp;&amp;...args)</code>:<blockquote>a <code>value_type</code> object is constructed from the member's
arguments, and the newly created element is inserted beyond the vector's last
element.</blockquote>
        <li><a name="an1316"></a><code>bool empty()</code>:<blockquote>returns <code>true</code> if the vector contains no
elements.</blockquote>
        <li><a name="an1317"></a><code>vector::iterator end()</code>:<blockquote>returns an iterator pointing beyond the last
element in the vector.</blockquote>
        <li><a name="an1318"></a><code>vector::iterator erase()</code>:<blockquote>erases a specific range of elements in the vector:</blockquote>
            <ul>
            <li><code>erase(pos)</code> erases the element pointed to by the iterator
<code>pos</code>. The iterator <code>++pos</code> is returned.
            <li><code>erase(first, beyond)</code> erases elements indicated by the iterator
range <code>[first, beyond)</code>, returning <code>beyond</code>.
            </ul>
<p>
<li><a name="an1319"></a><code>Type &amp;front()</code>:<blockquote>returns a reference to the first element in the
vector. It is the responsibility of the programmer to use the member only if
the vector is not empty.</blockquote>
        <li><a name="an1320"></a><code>allocator_type get_allocator() const</code>:<blockquote>returns a
copy of the allocator object used by the <code>vector</code> object.</blockquote>
        <li><a name="an1321"></a><code>... insert()</code>:<blockquote>elements may be inserted starting at a certain position. The
return value depends on the version of <code>insert()</code> that is called:</blockquote>
            <ul>
            <li><code>vector::iterator insert(pos)</code> inserts a default value of type
<code>Type</code> at <code>pos</code>, <code>pos</code> is returned.
            <li><code>vector::iterator insert(pos, value)</code> inserts <code>value</code> at
<code>pos</code>, <code>pos</code> is returned.
            <li><code>void insert(pos, first, beyond)</code> inserts the elements in the
                <a name="an1322"></a>iterator range <a name="an1323"></a><code>[first, beyond)</code>.
            <li><code>void insert(pos, n, value)</code> inserts <code>n</code> elements having value
<code>value</code> at position <code>pos</code>.
            </ul>
<p>
<li><a name="an1324"></a><code>size_t max_size()</code>:<blockquote>returns the maximum number of
elements this <code>vector</code> may contain.</blockquote>
        <li><a name="an1325"></a><code>void pop_back()</code>:<blockquote>removes the last element from the vector. With
an <a name="an1326"></a>empty vector nothing happens.</blockquote>
        <li><a name="an1327"></a><code>void push_back(value)</code>:<blockquote>adds <code>value</code> to the end of the vector.</blockquote>
        <li><a name="an1328"></a><code>vector::reverse_iterator rbegin()</code>:<blockquote><a name="an1329"></a> this member returns an iterator
pointing to the last element in the vector.</blockquote>
        <li><a name="an1330"></a><code>vector::reverse_iterator rend()</code>:<blockquote>returns an iterator pointing before the first
element in the vector.</blockquote>
        <li><a name="an1331"></a><code>void reserve(size_t request)</code>:<blockquote>if <code>request</code> is less than or equal to <code>capacity</code>, this
call has no effect. Otherwise, it is a request to allocate additional
memory. If the call is successful, then <code>capacity</code> returns a value of at
least <code>request</code>. Otherwise, <code>capacity</code> is unchanged. In either case,
<code>size</code>'s return value won't change, until a function like <code>resize</code> is
called, actually changing the number of accessible elements.</blockquote>
        <li><a name="an1332"></a><code>void resize()</code>:<blockquote>can be used to alter the number of elements that
are currently stored in the vector:</blockquote>
            <ul>
            <li><code>resize(n, value)</code> may be used to resize the vector to a size
of <code>n</code>. <code>Value</code> is optional. If the vector is expanded and <code>value</code> is
not provided, the additional elements are initialized to the <a name="an1333"></a>default value
of the used data type, otherwise <code>value</code> is used to initialize extra
elements.
            </ul>
<p>
<li><a name="an1334"></a><code>void shrink_to_fit()</code>:<blockquote>optionally reduces the
amount of memory allocated by a vector to its current size. The
implementor is free to ignore or otherwise optimize this request. In order to
guarantee a `shrink to fit' operation the
    <pre>
vector&lt;Type&gt;(vectorObject).swap(vectorObject)
</pre>
        idiom can be used.</blockquote>
        <li><a name="an1335"></a><code>size_t size()</code>:<blockquote>returns the number of elements in the vector.</blockquote>
        <li><a name="an1336"></a><code>void swap()</code>:<blockquote>swaps two vectors using identical data types. Example:</blockquote>
    <pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

int main()
{
    vector&lt;int&gt; v1(7);
    vector&lt;int&gt; v2(10);

    v1.swap(v2);
    cout &lt;&lt; v1.size() &lt;&lt; " " &lt;&lt; v2.size() &lt;&lt; '\n';
}
/*
    Produced output:
10 7
*/
</pre>
        </ul>
    </ul>
<p>
<a name="l228"></a>
<h3>12.4.3: The `list' container</h3>
    The <a name="an1337"></a><code>list</code> container <a name="an1338"></a> implements a list data structure.
Before using a <code>list</code> container the header file <a name="an1339"></a><code>&lt;list&gt;</code> must be included.
<p>
The organization of a <code>list</code> is shown  in figure <a href="cplusplus12.html#listFig">8</a>.
        <a name="listFig"></a><p><figure><img src="containers/list.gif" alt="Figure 8 is shown here."/><br/>
<figcaption>Figure 8: A list data-structure</figcaption>
</figure></p>

    Figure <a href="cplusplus12.html#listFig">8</a>  shows that a list consists of separate
list-elements, connected by pointers. The list can be
    <a name="an1340"></a> traversed in two directions: starting at <em>Front</em> the
list may be traversed from left to right, until the 0-pointer is reached at
the end of the rightmost list-element. The list can also be traversed from
right to left: starting at <em>Back</em>, the list is traversed from right to left,
until eventually the 0-pointer emanating from the leftmost list-element is
reached.
<p>
As a subtlety note that the representation given in figure <a href="cplusplus12.html#listFig">8</a> is not
necessarily used in actual implementations of the list. For example, consider
the following little program:
        <pre>
    int main()
    {
        list&lt;int&gt; l;
        cout &lt;&lt; "size: " &lt;&lt; l.size() &lt;&lt; ", first element: " &lt;&lt;
                l.front() &lt;&lt; '\n';
    }
</pre>
    When this program is run it might actually produce the output:
        <pre>
    size: 0, first element: 0
</pre>
    Its front element can even be assigned a value. In this case the
implementor has chosen to provide the list with a hidden element. The list
actually is a <em>circular</em>
 <a name="an1341"></a> list, where the hidden element serves as terminating
element, replacing the 0-pointers in figure <a href="cplusplus12.html#listFig">8</a>. As noted, this is a
subtlety, which doesn't affect the conceptual notion of a list as a data
structure ending in 0-pointers. Note also that it is well known that various
implementations of list-structures are possible (cf.
    <a name="an1342"></a>Aho, A.V., <a name="an1343"></a>Hopcroft J.E. and <a name="an1344"></a>Ullman, J.D., (1983)
    <a name="an1345"></a><em>Data Structures and Algorithms</em> (Addison-Wesley)).
<p>
Both lists and vectors are often appropriate data structures in situations
where an <a name="an1346"></a> unknown number of data elements must be
stored. However, there are some <a name="an1347"></a> rules of thumb to follow
when selecting the appropriate  data structure.
    <ul>
    <li> When most accesses are <a name="an1348"></a>random, a <code>vector</code> is
the preferred data structure. Example: in a program counting
character frequencies in a textfile, a <code>vector&lt;int&gt; frequencies(256)</code> is the
datastructure of choice, as the values of the received characters can be
used as indices into the <code>frequencies</code> vector.
    <li> The previous example illustrates a second rule of thumb, also
favoring the <code>vector</code>: if the number of elements is known in advance (and
does not notably change during the lifetime of the program), the vector
is also preferred over the list.
    <li> In cases where <a name="an1349"></a>insertions or <a name="an1350"></a>deletions prevail and the data
structure is large the list is generally preferred.
    </ul>
    At present lists aren't as useful anymore as they used to be (when
computers were much slower and more memory-constrained).  Except maybe for
some rare cases, a <code>vector</code> should be the preferred container; even when
implementing algorithms traditionally using lists.
<p>
Other considerations related to the choice between lists and vectors
should also be given some thought. Although it is true that the vector is able
to grow dynamically, the <a name="an1351"></a>dynamic growth requires data-copying.
Clearly, copying a million large data structures takes a considerable amount
of time, even on fast computers. On the other hand, inserting a large number
of elements in a list doesn't require us to
    <a name="an1352"></a>copy non-involved data. Inserting a new element in a list merely
requires us to juggle some pointers. In figure <a href="cplusplus12.html#listAdd">9</a> this is shown: a
new element is inserted between the second and third element, creating a new
list of four elements.
        <a name="listAdd"></a><p><figure><img src="containers/insertlist.gif" alt="Figure 9 is shown here."/><br/>
<figcaption>Figure 9: Adding a new element to a list</figcaption>
</figure></p>

    Removing an element from a list is also fairly easy. Starting again
from the situation shown in figure <a href="cplusplus12.html#listFig">8</a>, figure <a href="cplusplus12.html#listDel">10</a> shows
what happens if element two is removed from our list. Again: only pointers
need to be juggled. In this case it's even simpler than adding an element:
only two pointers need to be rerouted.
        <a name="listDel"></a><p><figure><img src="containers/dellist.gif" alt="Figure 10 is shown here."/><br/>
<figcaption>Figure 10: Removing an element from a list</figcaption>
</figure></p>

    To summarize the comparison between lists and vectors: it's probably best
to conclude that there is no clear-cut answer to the question what data
structure to prefer. There are rules of thumb, which may be adhered to. But if
worse comes to worst, a <a name="an1353"></a>profiler may be required to find out what's best.
<p>
The <code>list</code> container offers the following constructors, operators, and
member functions:
    <ul>
    <li> <a name="an1354"></a> Constructors:
        <ul>
        <li> The copy and move constructors are available;
        <li> A <code>list</code> may be constructed empty:
    <pre>
list&lt;string&gt; object;
</pre>
<p>
As with the <code>vector</code>, it is an error to refer to an element of an
empty list.
        <li> A list may be initialized to a certain number of
elements. By default, if the initialization value is not explicitly mentioned,
the default value or default constructor for the actual data type is used. For
example:
    <pre>
list&lt;string&gt; object(5, string("Hello")); // initialize to 5 Hello's
list&lt;string&gt; container(10);              // and to 10 empty strings
</pre>
        <li> A list may be initialized using a two iterators. To
initialize a list with elements 5 until 10 (including the last one) of a
<code>vector&lt;string&gt;</code> the following construction may be used:
    <pre>
extern vector&lt;string&gt; container;
list&lt;string&gt; object(&amp;container[5], &amp;container[11]);
</pre>
    </ul>
    <li> The <code>list</code> does not offer specialized operators, apart from the
standard operators for containers.
    <li> The following <a name="an1355"></a>member functions are available:
        <ul>
        <li><a name="an1356"></a><code>void assign(...)</code>:
            <blockquote>assigns new contents to the list:</blockquote>
            <ul>
            <li><code>assign(iterator begin, iterator end)</code> assigns the values at
the iterator range <code>[begin, end)</code> to the list;
            <li><code>assign(size_type n, value_type const &amp;val)</code> assigns <code>n</code>
copies of <code>val</code> to the list;
            </ul>
<p>
<li><a name="an1357"></a><code>Type &amp;back()</code>:<blockquote>returns a
reference to the last element in the list. It is the
    <a name="an1358"></a>responsibility of the programmer to use this member only if the list is
not empty.</blockquote>
        <li><a name="an1359"></a><code>list::iterator begin()</code>:<blockquote>returns an <a name="an1360"></a>iterator pointing
to the first element in the list, returning <code>end</code> if the list is empty.</blockquote>
        <li><a name="an1361"></a><code>void clear()</code>:<blockquote>erases all elements from the
list.</blockquote>
        <li><a name="an1362"></a><code>bool empty()</code>:<blockquote>returns <code>true</code>
if the list contains no elements.</blockquote>
        <li><a name="an1363"></a><code>list::iterator end()</code>:<blockquote>returns an iterator pointing beyond
the last element in the list.</blockquote>
        <li><a name="an1364"></a><code>list::iterator erase()</code>:<blockquote>erases a specific range of
elements in the list:</blockquote>
            <ul>
            <li><code>erase(pos)</code> erases the element pointed to by <code>pos</code>. The
iterator <code>++pos</code> is returned.
            <li><code>erase(first, beyond)</code> erases elements indicated by the iterator
range <code>[first, beyond)</code>. <code>Beyond</code> is returned.
            </ul>
<p>
<li><a name="an1365"></a><code>Type &amp;front()</code>:<blockquote>returns a
reference to the first element in the list. It is the responsibility of the
programmer to use this member only if the list is not empty.</blockquote>
        <li><a name="an1366"></a><code>allocator_type get_allocator() const</code>:<blockquote>returns a
copy of the allocator object used by the <code>list</code> object.</blockquote>
        <li><a name="an1367"></a><code>... insert()</code>:<blockquote>inserts elements into the list. The return
value depends on the version of <code>insert</code> that is called:</blockquote>
            <ul>
            <li><code>list::iterator insert(pos)</code> inserts a default value of type
<code>Type</code> at <code>pos</code>, <code>pos</code> is returned.
            <li><code>list::iterator insert(pos, value)</code> inserts <code>value</code> at
<code>pos</code>, <code>pos</code> is returned.
            <li><code>void insert(pos, first, beyond)</code> inserts the elements in the
                <a name="an1368"></a>iterator range <a name="an1369"></a><code>[first, beyond)</code>.
            <li><code>void insert(pos, n, value)</code> inserts <code>n</code> elements having value
<code>value</code> at position <code>pos</code>.
            </ul>
<p>
<li><a name="an1370"></a><code>size_t max_size()</code>:<blockquote>returns the maximum number of
elements this <code>list</code> may contain.</blockquote>
        <li><a name="an1371"></a><code>void merge(list&lt;Type&gt; other)</code>:<blockquote>this
member function assumes that the current and other lists are sorted (see
below, the member <code>sort</code>). Based on that assumption, it inserts the
elements of <code>other</code> into the current list in such a way that the modified
list remains sorted.  If both list are not sorted, the resulting list will be
ordered `as much as possible', given the initial ordering of the elements in
the two lists. <code>list&lt;Type&gt;::merge</code> uses <code>Type::operator&lt;</code> to sort the
data in the list, which operator must therefore be available.  The next
example illustrates the use of the <code>merge</code> member: the list `<code>object</code>'
is not sorted, so the resulting list is ordered 'as much as possible'.
            <pre>
    #include &lt;iostream&gt;
    #include &lt;string&gt;
    #include &lt;list&gt;
    using namespace std;

    void showlist(list&lt;string&gt; &amp;target)
    {
        for
        (
            list&lt;string&gt;::iterator from = target.begin();
            from != target.end();
            ++from
        )
            cout &lt;&lt; *from &lt;&lt; " ";

        cout &lt;&lt; '\n';
    }

    int main()
    {
        list&lt;string&gt; first;
        list&lt;string&gt; second;

        first.push_back(string("alpha"));
        first.push_back(string("bravo"));
        first.push_back(string("golf"));
        first.push_back(string("quebec"));

        second.push_back(string("oscar"));
        second.push_back(string("mike"));
        second.push_back(string("november"));
        second.push_back(string("zulu"));

        first.merge(second);
        showlist(first);
    }
</pre>
<p>
A subtlety is that <code>merge</code> doesn't alter the list if the list itself
is used as argument: <code>object.merge(object)</code> won't change the list
`<code>object</code>'.</blockquote>
        <li><a name="an1372"></a><code>void pop_back()</code>:<blockquote>removes
the last element from the list. With an <a name="an1373"></a>empty list nothing happens.</blockquote>
        <li><a name="an1374"></a><code>void pop_front()</code>:<blockquote>removes
the first element from the list. With an <a name="an1375"></a>empty list nothing happens.</blockquote>
        <li><a name="an1376"></a><code>void push_back(value)</code>:<blockquote>adds <code>value</code> to the end of
the list.</blockquote>
        <li><a name="an1377"></a><code>void push_front(value)</code>:<blockquote>adds <code>value</code> before the
first element of the list.</blockquote>
        <li><a name="an1378"></a><code>list::reverse_iterator rbegin()</code>:<blockquote>
    <a name="an1379"></a> returns an iterator pointing to the last element in
the list.</blockquote>
        <li><a name="an1380"></a><code>void remove(value)</code>:<blockquote>removes
all occurrences of <code>value</code> from the list. In the following example, the two
strings `<code>Hello</code>' are removed from the list <code>object</code>:
            <pre>
    #include &lt;iostream&gt;
    #include &lt;string&gt;
    #include &lt;list&gt;
    using namespace std;

    int main()
    {
        list&lt;string&gt; object;

        object.push_back(string("Hello"));
        object.push_back(string("World"));
        object.push_back(string("Hello"));
        object.push_back(string("World"));

        object.remove(string("Hello"));

        while (object.size())
        {
            cout &lt;&lt; object.front() &lt;&lt; '\n';
            object.pop_front();
        }
    }
    /*
            Generated output:
        World
        World
    */
</pre>
</blockquote>
        <li><a name="an1381"></a><code>void remove_if(Predicate pred)</code>:<blockquote>removes
all occurrences from the list for which the predicate function or function
object <code>pred</code> returns <code>true</code>. For each of the objects stored in the list
the  predicate is called as <code>pred(*iter)</code>, where <code>iter</code> represents the
iterator used internally by <code>remove_if</code>. If a function <code>pred</code> is used, its
prototype should be <code>bool pred(value_type const &amp;object)</code>.
        <li><a name="an1382"></a><code>list::reverse_iterator rend()</code>:<blockquote>this
member returns an iterator pointing before the first element in the list.</blockquote>
        <li><a name="an1383"></a><code>void resize()</code>:<blockquote>alters the number of elements that are
currently stored in the list:</blockquote>
            <ul>
            <li><code>resize(n, value)</code> may be used to resize the list to a size of
<code>n</code>. <code>Value</code> is optional. If the list is expanded and <code>value</code> is not
provided, the extra elements are initialized to the <a name="an1384"></a>default value of the
used data type, otherwise <code>value</code> is used to initialize extra elements.
            </ul>
<p>
<li><a name="an1385"></a><code>void reverse()</code>:<blockquote>reverses the order of the
elements in the list. The element <code>back</code> becomes <code>front</code> and <em>vice
versa</em>.</blockquote>
        <li><a name="an1386"></a><code>size_t size()</code>:<blockquote>returns the number of elements in the
list.</blockquote>
        <li><a name="an1387"></a><code>void sort()</code>:<blockquote>sorts the
list. Once the list has been sorted, An example of its use is given at the
description of the <code>unique</code> member function below. <code>list&lt;Type&gt;::sort</code>
uses <code>Type::operator&lt;</code> to sort the data in the list, which operator must
therefore be available.</blockquote>
        <li><a name="an1388"></a><code>void splice(pos, object)</code>:<blockquote>transfers the contents of
<code>object</code> to the current list, starting the insertion at the iterator
position <code>pos</code> of the object using the <code>splice</code> member. Following
<code>splice</code>, <code>object</code> is empty. For example:
         <pre>
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;list&gt;
using namespace std;

int main()
{
    list&lt;string&gt; object;

    object.push_front(string("Hello"));
    object.push_back(string("World"));

    list&lt;string&gt; argument(object);

    object.splice(++object.begin(), argument);

    cout &lt;&lt; "Object contains " &lt;&lt; object.size() &lt;&lt; " elements, " &lt;&lt;
            "Argument contains " &lt;&lt; argument.size() &lt;&lt;
            " elements,\n";

    while (object.size())
    {
        cout &lt;&lt; object.front() &lt;&lt; '\n';
        object.pop_front();
    }
}
</pre>
<p>
Alternatively, <code>argument</code> may be followed by an iterator of <code>argument</code>,
indicating the first element of <code>argument</code> that should be spliced, or by two
iterators <code>begin</code> and <code>end</code> defining the iterator-range
 <code>[begin, end)</code> on <code>argument</code> that should be spliced into <code>object</code>.</blockquote>
        <li><a name="an1389"></a><code>void swap()</code>:<blockquote>swaps two lists using identical data types.</blockquote>
        <li><a name="an1390"></a><code>void unique()</code>:<blockquote>operating on a sorted list,
this member function removes all consecutively identical elements from the
list. <code>list&lt;Type&gt;::unique</code> uses <code>Type::operator==</code> to identify
identical data elements, which operator must therefore be available.  Here's
an example removing all multiply occurring words from the list:
            <pre>
    #include &lt;iostream&gt;
    #include &lt;string&gt;
    #include &lt;list&gt;
    using namespace std;
                            // see the merge() example
    void showlist(list&lt;string&gt; &amp;target)
    {
        for
        (
            list&lt;string&gt;::iterator from = target.begin();
            from != target.end();
            ++from
        )
            cout &lt;&lt; *from &lt;&lt; " ";

        cout &lt;&lt; '\n';
    }


    int main()
    {
        string
            array[] =
            {
                "charley",
                "alpha",
                "bravo",
                "alpha"
            };

        list&lt;string&gt;
            target
            (
                array, array + sizeof(array)
                / sizeof(string)
            );

        cout &lt;&lt; "Initially we have:\n";
        showlist(target);

        target.sort();
        cout &lt;&lt; "After sort() we have:\n";
        showlist(target);

        target.unique();
        cout &lt;&lt; "After unique() we have:\n";
        showlist(target);
    }
    /*
        Generated output:

        Initially we have:
        charley alpha bravo alpha
        After sort() we have:
        alpha alpha bravo charley
        After unique() we have:
        alpha bravo charley
    */
</pre>
</blockquote>
        </blockquote>
    </ul>
</ul>
<p>
<a name="QUEUE"></a><a name="l229"></a>
<h3>12.4.4: The `queue' container</h3>
    The <a name="an1391"></a><code>queue</code> class implements a <a name="an1392"></a>queue data structure.  Before using a
<code>queue</code> container the header file <a name="an1393"></a><code>&lt;queue&gt;</code> must be included.
<p>
A queue is depicted in figure <a href="cplusplus12.html#queueFig">11</a>.
        <a name="queueFig"></a><p><figure><img src="containers/queue.gif" alt="Figure 11 is shown here."/><br/>
<figcaption>Figure 11: A queue data-structure</figcaption>
</figure></p>

    In figure <a href="cplusplus12.html#queueFig">11</a> it is shown that a queue has one point (the
<em>back</em>) where items can be added to the queue, and one point (the <em>front</em>)
where items can be removed (read) from the queue. A <code>queue</code> is therefore
also called a <a name="an1394"></a><em>FIFO</em> data structure, for <a name="an1395"></a><em>first in, first out</em>. It is
most often used in situations where events should be handled in the same order
as they are generated.
<p>
The following constructors, operators, and member functions are available
for the <code>queue</code> container:
    <ul>
    <li> <a name="an1396"></a> Constructors:
        <ul>
        <li> The copy and move constructors are available;
        <li> A <code>queue</code> may be constructed empty:
        <pre>
    queue&lt;string&gt; object;
</pre>
<p>
As with the <code>vector</code>, it is an error to refer to an element of an
empty queue.
    </ul>
    <li> The <code>queue</code> container only supports the basic container operators.
    <li> The following <a name="an1397"></a>member functions are available for
queues:
        <ul>
        <li><a name="an1398"></a><code>Type &amp;back()</code>:<blockquote>returns a
reference to the last element in the queue. It is the
    <a name="an1399"></a>responsibility of the programmer to use the member only if the queue is
not empty.</blockquote>
<p>
<li><a name="an1400"></a><code>bool empty()</code>:<blockquote>returns
<code>true</code> if the queue contains no elements.</blockquote>
        <li><a name="an1401"></a><code>Type &amp;front()</code>:<blockquote>returns a
reference to the first element in the queue. It is the responsibility of the
programmer to use the member only if the queue is not empty.</blockquote>
        
        <li><a name="an1402"></a><code>void pop()</code>:<blockquote>removes the element at the front of
the queue. Note that the element is <em>not</em> returned by this member. Nothing
happens if the member is called for an empty queue.  One might wonder why
<code>pop</code> returns <code>void</code>, instead of a value of type <code>Type</code>
(cf. <code>front</code>). One reason is found in the principles of good software
design: functions should perform one task. Combining the removal and return of
the removed element breaks this principle. Moreover, when this principle is
abandoned <code>pop</code>'s implementation is always flawed. Consider the
prototypical implementation of a <code>pop</code> member that is supposed to return the
just popped value:
    <pre>
        Type queue::pop()
        {
            Type ret(front());
            erase_front();
            return ret;
        }
</pre>
    The venom, as usual, is in the tail: since <code>queue</code> has no control over
<code>Type</code>'s behavior the final statement (<code>return ret</code>) might throw. By that
time the queue's front element has already been removed from the queue and
so it is lost. Thus, a <code>Type</code> returning <code>pop</code> member cannot offer the
<em>strong guarantee</em> and consequently <code>pop</code> should not return the former
<code>front</code> element. Because of all this, we must first use <code>front</code> and
then <code>pop</code> to obtain and remove the queue's front element.</blockquote>
        <li><a name="an1403"></a><code>void push(value)</code>:<blockquote>this member
adds <code>value</code> to the back of the queue.</blockquote>
        <li><a name="an1404"></a><code>size_t size()</code>:<blockquote>returns the
number of elements in the queue.</blockquote>
        </ul>
    </ul>
    Note that the queue does not support iterators or a subscript
operator. The only elements that can be accessed are its front and back
element.  A queue can be emptied by:
    <ul>
    <li> repeatedly removing its front element;
    <li> assigning an empty queue using the same data type to it;
    <li> having its destructor called.
    </ul>
<p>
<a name="PRIQUEUE"></a><a name="l230"></a>
<h3>12.4.5: The `priority_queue' container</h3>
    The <a name="an1405"></a><code>priority_queue</code> class implements a <a name="an1406"></a>priority queue data structure.
Before using a <code>priority_queue</code> container the <a name="an1407"></a><code>&lt;queue&gt;</code> header file must
have been included.
<p>
A priority queue is identical to a <code>queue</code>, but allows the entry of data
elements according to <a name="an1408"></a><em>priority rules</em>. A real-life priority queue is
found, e.g., at airport check-in terminals. At a terminal the passengers
normally stand in line to wait for their turn to check in, but late passengers
are usually allowed to jump the queue: they receive a higher priority than
other passengers.
<p>
The priority queue uses <code>operator&lt;</code> of the data type stored in the
priority queue to decide about the priority of the data elements. The
<em>smaller</em> the value, the <em>lower</em> the priority. So, the priority queue
<em>could</em> be used to sort values while they arrive.  A simple example of such
a priority queue application is the following program: it reads words from
<code>cin</code> and writes a sorted list of words to <code>cout</code>:
        <pre>
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;queue&gt;
using namespace std;

int main()
{
    priority_queue&lt;string&gt; q;
    string word;

    while (cin &gt;&gt; word)
        q.push(word);

    while (q.size())
    {
        cout &lt;&lt; q.top() &lt;&lt; '\n';
        q.pop();
    }
}
</pre>
<p>
Unfortunately, the words are listed in reversed order: because of the
underlying <code>&lt;</code>-operator the words appearing later in the <a name="an1409"></a>ASCII-sequence
appear first in the priority queue. A solution to that problem is to define a
<em>wrapper class</em> around the <code>string</code> datatype, reversing <code>string</code>'s
<code>operator&lt;</code>. Here is the modified program:
        <pre>
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;queue&gt;

class Text
{
    std::string d_s;

    public:
        Text(std::string const &amp;str)
        :
            d_s(str)
        {}
        operator std::string const &amp;() const
        {
            return d_s;
        }
        bool operator&lt;(Text const &amp;right) const
        {
            return d_s &gt; right.d_s;
        }
};

using namespace std;

int main()
{
    priority_queue&lt;Text&gt; q;
    string word;

    while (cin &gt;&gt; word)
        q.push(word);

    while (q.size())
    {
        word = q.top();
        cout &lt;&lt; word &lt;&lt; '\n';
        q.pop();
    }
}
</pre>
<p>
Other possibilities to achieve the same exist. One would be to store the
contents of the priority queue in, e.g., a vector, from which the elements can
be read in reversed order.
<p>
The following constructors, operators, and member functions are available
for the <code>priority_queue</code> container:
    <ul>
    <li> <a name="an1410"></a> Constructors:
        <ul>
        <li> The copy and move constructors are available;
        <li> A <code>priority_queue</code> may be constructed empty:
    <pre>
priority_queue&lt;string&gt; object;
</pre>
<p>
As with the <code>vector</code>, it is an error to refer to an element of an
empty priority queue.
    </ul>
    <li> The <code>priority_queue</code> only supports the basic operators of
containers.
    <li> The following <a name="an1411"></a>member functions are available for priority queues:
        <ul>
        <li><a name="an1412"></a><code>bool empty()</code>:<blockquote>returns <code>true</code> if the
priority queue contains no elements.</blockquote>
        <li><a name="an1413"></a><code>void pop()</code>:<blockquote>removes the element at the top of
the priority queue. Note that the element is <em>not</em> returned by this
member. Nothing happens if this member is called for an empty priority
queue. See section <a href="cplusplus12.html#QUEUE">12.4.4</a> for a discussion about the reason why <code>pop</code>
has return type <code>void</code>.</blockquote>
        <li><a name="an1414"></a><code>void push(value)</code>:<blockquote>inserts <code>value</code> at the
appropriate position in the priority queue.</blockquote>
        <li><a name="an1415"></a><code>size_t size()</code>:<blockquote>returns the number of elements
in the priority queue.</blockquote>
        <li><a name="an1416"></a><code>Type &amp;top()</code>:<blockquote>returns a reference to the first
element of the priority queue. It is the
    responsibility of the programmer to use the member only if the priority
queue is not empty.</blockquote>
        </ul>
    </ul>
    Note that the priority queue does not support iterators or a subscript
operator. The only element that can be accessed is its top element.  A
priority queue can be emptied by:
    <ul>
    <li> repeatedly removing its top element;
    <li> assigning an empty queue using the same data type to it;
    <li> having its destructor called.
    </ul>
<p>
<a name="l231"></a>
<h3>12.4.6: The `deque' container</h3>
    The <a name="an1417"></a><code>deque</code> (pronounce: `deck') class implements a
    <a name="an1418"></a>doubly ended queue data structure (deque).  Before using a <code>deque</code>
container the header file <a name="an1419"></a><code>&lt;deque&gt;</code> must be included.
<p>
A <code>deque</code> is comparable to a queue, but it allows for reading and
writing at both ends. Actually, the <code>deque</code> data type supports a lot more
functionality than the <code>queue</code>, as illustrated by the following overview of
available member functions. A <code>deque</code> is a combination of a <code>vector</code> and
two queues, operating at both ends of the vector. In situations where random
insertions and the addition and/or removal of elements at one or both sides of
the vector occurs frequently using a <code>deque</code> should be considered.
<p>
The following constructors, operators, and member functions are available for
deques:
    <ul>
    <li> <a name="an1420"></a> Constructors:
        <ul>
        <li> The copy and move constructors are available;
        <li> A <code>deque</code> may be constructed empty:
    <pre>
deque&lt;string&gt; object;
</pre>
<p>
As with the <code>vector</code>, it is an error to refer to an element of an
empty deque.
        <li> A deque may be initialized to  a certain number of
elements. By default, if the initialization value is not explicitly mentioned,
the default value or default constructor for the actual data type is used. For
example:
    <pre>
deque&lt;string&gt; object(5, string("Hello")), // initialize to 5 Hello's
deque&lt;string&gt; container(10);              // and to 10 empty strings
</pre>
        <li> A deque may be initialized using two iterators. To
initialize a deque with elements 5 until 10 (including the last one) of a
<code>vector&lt;string&gt;</code> the following construction may be used:
    <pre>
extern vector&lt;string&gt; container;
deque&lt;string&gt; object(&amp;container[5], &amp;container[11]);
</pre>
    </ul>
    <li> In addition to the standard operators for containers, the deque
supports the <a name="an1421"></a>index operator, which may be used to retrieve or reassign
random elements of the deque. Note that the indexed elements must exist.
    <li> The following member functions are available for deques:
        <ul>
        <li><a name="an1422"></a><code>void assign(...)</code>:
            <blockquote>assigns new contents to the deque:</blockquote>
            <ul>
            <li><code>assign(iterator begin, iterator end)</code> assigns the values at
the iterator range <code>[begin, end)</code> to the deque;
            <li><code>assign(size_type n, value_type const &amp;val)</code> assigns <code>n</code>
copies of <code>val</code> to the deque;
            </ul>
<p>
<li><a name="an1423"></a><code>Type &amp;at(size_t idx)</code>:
            <blockquote>returns a reference to the deque's element at index position
<code>idx</code>. If <code>idx</code> exceeds the deque's size a <code>std::out_of_range</code> exception
is thrown.</blockquote>
        <li><a name="an1424"></a><code>Type &amp;back()</code>:<blockquote>returns a
reference to the last element in the deque. It is the
    <a name="an1425"></a>responsibility of the programmer to use the member only if the deque is
not empty.</blockquote>
        <li><a name="an1426"></a><code>deque::iterator begin()</code>:<blockquote>returns an <a name="an1427"></a>iterator pointing
to the first element in the deque. </blockquote>
        <li><a name="an1428"></a><code>deque::const_iterator cbegin()</code>:
            <blockquote>returns a <a name="an1429"></a>const_iterator pointing to the first
element in the deque, returning <code>cend</code> if the deque is empty.</blockquote>
        <li><a name="an1430"></a><code>deque::const_iterator cend()</code>:
            <blockquote>returns a <a name="an1431"></a>const_iterator pointing just beyond the
deque's last element.</blockquote>
        <li><a name="an1432"></a><code>void clear()</code>:<blockquote>erases all
elements in the deque.</blockquote>
        <li><a name="an1433"></a><code>deque::const_reverse_iterator crbegin()</code>:
            <blockquote>returns a <a name="an1434"></a>const_reverse_iterator pointing to the last
element in the deque, returning <code>crend</code> if the deque is empty.</blockquote>
        <li><a name="an1435"></a><code>deque::const_reverse_iterator crend()</code>:
            <blockquote>returns a <a name="an1436"></a>const_reverse_iterator pointing just before the
deque's first element.</blockquote>
        <li><a name="an1437"></a><code>iterator emplace(const_iterator position, Args &amp;&amp;...args)</code>
            <blockquote>a <code>value_type</code> object is constructed from the arguments
specified after <code>position</code>, and the newly created element is inserted at
<code>position</code>.</blockquote>
        <li><a name="an1438"></a><code>void emplace_back(Args &amp;&amp;...args)</code>
            <blockquote>a <code>value_type</code> object is constructed from the member's
arguments, and the newly created element is inserted beyond the deque's last
element.</blockquote>
        <li><a name="an1439"></a><code>void emplace_front(Args &amp;&amp;...args)</code>
            <blockquote>a <code>value_type</code> object is constructed from the member's
arguments, and the newly created element is inserted before the deque's first
element.</blockquote>
        <li><a name="an1440"></a><code>bool empty()</code>:<blockquote>returns
<code>true</code> if the deque contains no elements.</blockquote>
        <li><a name="an1441"></a><code>deque::iterator end()</code>:<blockquote>returns an iterator pointing beyond
the last element in the deque. </blockquote>
        <li><a name="an1442"></a><code>deque::iterator erase()</code>:<blockquote>the member can
be used to erase a specific range of elements in the deque:</blockquote>
            <ul>
            <li><code>erase(pos)</code> erases the element pointed to by <code>pos</code>. The
iterator <code>++pos</code> is returned.
            <li><code>erase(first, beyond)</code> erases elements indicated by the iterator
range <code>[first, beyond)</code>. <code>Beyond</code> is returned.
            </ul>
        <li><a name="an1443"></a><code>Type &amp;front()</code>:<blockquote>returns a
reference to the first element in the deque. It is the responsibility of the
programmer to use the member only if the deque is not empty.</blockquote>
        <li><a name="an1444"></a><code>allocator_type get_allocator() const</code>:<blockquote>returns a
copy of the allocator object used by the <code>deque</code> object.</blockquote>
<p>
<li><a name="an1445"></a><code>... insert()</code>:<blockquote>inserts elements starting at a certain
position. The return value depends on the version of <code>insert</code> that is
called:</blockquote>
            <ul>
            <li><code>deque::iterator insert(pos)</code> inserts a default value of type
<code>Type</code> at <code>pos</code>, <code>pos</code> is returned.
            <li><code>deque::iterator insert(pos, value)</code> inserts <code>value</code> at
<code>pos</code>, <code>pos</code> is returned.
            <li><code>void insert(pos, first, beyond)</code> inserts the elements in the
                <a name="an1446"></a>iterator range <a name="an1447"></a><code>[first, beyond)</code>.
            <li><code>void insert(pos, n, value)</code> inserts <code>n</code> elements having value
<code>value</code> starting at iterator position <code>pos</code>.
            </ul>
        <li><a name="an1448"></a><code>size_t max_size()</code>:<blockquote>returns the maximum number of
elements this <code>deque</code> may contain.</blockquote>
        <li><a name="an1449"></a><code>void pop_back()</code>:<blockquote>removes
the last element from the deque. With an <a name="an1450"></a>empty deque nothing happens.</blockquote>
        <li><a name="an1451"></a><code>void pop_front()</code>:<blockquote>removes
the first element from the deque. With an <a name="an1452"></a>empty deque nothing happens.</blockquote>
        <li><a name="an1453"></a><code>void push_back(value)</code>:<blockquote>adds <code>value</code> to the end of
the deque.</blockquote>
        <li><a name="an1454"></a><code>void push_front(value)</code>:<blockquote>adds <code>value</code> before the
first element of the deque.</blockquote>
        <li><a name="an1455"></a><code>deque::reverse_iterator rbegin()</code>:<blockquote>
    <a name="an1456"></a> returns an iterator pointing to the last element in
the deque.</blockquote>
        <li><a name="an1457"></a><code>deque::reverse_iterator rend()</code>:<blockquote>this
member returns an iterator pointing before the first element in the deque.</blockquote>
        <li><a name="an1458"></a><code>void resize()</code>:<blockquote>alters the number of elements that are
currently stored in the deque:</blockquote>
            <ul>
            <li><code>resize(n, value)</code> may be used to resize the deque to a size of
<code>n</code>. <code>Value</code> is optional. If the deque is expanded and <code>value</code> is not
provided, the additional elements are initialized to the <a name="an1459"></a>default value of
the used data type, otherwise <code>value</code> is used
to initialize extra elements.
            </ul>
        <li><a name="an1460"></a><code>void shrink_to_fit()</code>:<blockquote>optionally reduces the
amount of memory allocated by a deque to its current size. The implementor is
free to ignore or otherwise optimize this request. In order to guarantee a
`shrink to fit' operation <code>deque&lt;Type&gt;(dequeObject).swap(dequeObject)</code> idiom
can be used.</blockquote>
        <li><a name="an1461"></a><code>size_t size()</code>:<blockquote>returns the
number of elements in the deque.</blockquote>
        <li><a name="an1462"></a><code>void swap(argument)</code>:<blockquote>swaps two deques using identical data
types.</blockquote>
<p>
</ul>
</ul>
<p>
<a name="MAP"></a><a name="l232"></a>
<h3>12.4.7: The `map' container</h3>
    The <a name="an1463"></a><code>map</code> class offers a (sorted) <a name="an1464"></a>associative array. Before using a
<code>map</code> container the <a name="an1465"></a><code>&lt;map&gt;</code> header file must be included.
<p>
A <code>map</code> is filled with <a name="an1466"></a><em>key/value</em> pairs, which may be of any
container-accepted type. Since types are associated with both the key and the
value, we must specify <em>two types</em> in the angle bracket notation, comparable
to the specification we've seen with the <code>pair</code> container (cf. section
<a href="cplusplus12.html#PAIR">12.2</a>). The first type represents the key's type, the second type
represents the value's type. For example, a <code>map</code> in which the key is a
<code>string</code> and the value is a <code>double</code> can be defined as follows:
        <pre>
    map&lt;string, double&gt; object;
</pre>
    The <a name="an1467"></a><em>key</em> is used to access its associated information. That
information is called the <a name="an1468"></a><em>value</em>. For example, a phone book uses the
names of people as the key, and uses the telephone number and maybe other
information (e.g., the zip-code, the address, the profession) as
value. Since a <code>map</code> sorts its keys, the <code>key</code>'s <a name="an1469"></a><code>operator&lt;</code> must be
defined, and it must be sensible to use it. For example, it is generally a bad
idea to use pointers for keys, as sorting pointers is something different than
sorting the values pointed at by those pointers.
<p>
The two fundamental operations on maps are the storage of <em>Key/Value</em>
combinations, and the retrieval of values, given their keys. The index
operator using a key as the index, can be used for both. If the index operator
is used as <em>lvalue</em>, the expression's <code>rvalue</code> is inserted into the
map. If it is used as <em>rvalue</em>, the key's associated value is retrieved.
Each key can be stored only once in a <code>map</code>. If the same key is entered
again, the new value replaces the formerly stored value, which is lost.
<p>
A specific key/value combination can implicitly or explicitly be inserted into
a <code>map</code>. If explicit insertion is required, the key/value combination
must be constructed first. For this, every <code>map</code> defines a <a name="an1470"></a><code>value_type</code>
which may be used to create values that can be stored in the <code>map</code>. For
example, a value for a <code>map&lt;string, int&gt;</code> can be constructed as follows:
        <pre>
    map&lt;string, int&gt;::value_type siValue("Hello", 1);
</pre>
    The <code>value_type</code> is associated with the <code>map&lt;string, int&gt;</code>: the
type of the key is <code>string</code>, the type of the value is <code>int</code>. Anonymous
<code>value_type</code> objects are also often used. E.g.,
        <pre>
    map&lt;string, int&gt;::value_type("Hello", 1);
</pre>
    Instead of using the line <code>map&lt;string, int&gt;::value_type(...)</code> over and
over again, a <a name="an1471"></a><code>typedef</code> is frequently used to reduce typing and to improve
readability:
        <pre>
    typedef map&lt;string, int&gt;::value_type StringIntValue
</pre>
    Using this typedef, values for the <code>map&lt;string, int&gt;</code> may now be
constructed using:
        <pre>
    StringIntValue("Hello", 1);
</pre>
    Alternatively, <code>pairs</code> may be used to represent key/value combinations
used by maps:
        <pre>
    pair&lt;string, int&gt;("Hello", 1);
</pre>
<p>
<a name="l233"></a>
<h4>12.4.7.1: The `map' constructors</h4>
            The following <a name="an1472"></a> constructors are available for the
<code>map</code> container:
    <ul>
    <li> The copy and move constructors are available;
    <li> A <code>map</code> may be constructed empty:
    <pre>
map&lt;string, int&gt; object;
</pre>
<p>
Note that the values stored in maps may be containers themselves. For
example, the following defines a <code>map</code> in which the value is a <code>pair</code>: a
container
 <a name="an1473"></a> <a name="an1474"></a> nested under another container:
        <pre>
    map&lt;string, pair&lt;string, string&gt;&gt; object;
</pre>
    Note the use of the two
 <a name="an1475"></a><a name="an1476"></a>
 <a name="an1477"></a>consecutive closing angle brackets, which does not result in ambiguities
as their syntactical context differs from their use as binary operators in
expressions.
    <li> A map may be initialized using two iterators.  The iterators may
either point to <code>value_type</code> values for the map to be constructed, or to
plain <a name="an1478"></a><code>pair</code> objects. If pairs are used, their <code>first</code> element represents
the type of the keys, and their <code>second</code> element represents the type of the
values. Example:
    <pre>
pair&lt;string, int&gt; pa[] =
{
    pair&lt;string,int&gt;("one", 1),
    pair&lt;string,int&gt;("two", 2),
    pair&lt;string,int&gt;("three", 3),
};

map&lt;string, int&gt; object(&amp;pa[0], &amp;pa[3]);
</pre>
    In this example, <code>map&lt;string, int&gt;::value_type</code> could have been written
instead of <code>pair&lt;string, int&gt;</code> as well.
<p>
If <code>begin</code> represents the first iterator that is used to construct a map
and if <code>end</code> represents the second iterator, <code>[begin, end)</code> will be
used to initialize the map. Maybe contrary to intuition, the <code>map</code>
constructor only enters <em>new</em> keys.  If the last element of <code>pa</code> would
have been <code>"one", 3</code>, only <em>two</em> elements would have entered the <code>map</code>:
<code>"one", 1</code> and <code>"two", 2</code>. The value <code>"one", 3</code> would silently have been
ignored.
<p>
The <code>map</code> receives its own copies of the data to which the iterators
point as illustrated by the following example:
        <pre>
    #include &lt;iostream&gt;
    #include &lt;map&gt;
    using namespace std;

    class MyClass
    {
        public:
            MyClass()
            {
                cout &lt;&lt; "MyClass constructor\n";
            }
            MyClass(MyClass const &amp;other)
            {
                cout &lt;&lt; "MyClass copy constructor\n";
            }
            ~MyClass()
            {
                cout &lt;&lt; "MyClass destructor\n";
            }
    };

    int main()
    {
        pair&lt;string, MyClass&gt; pairs[] =
        {
            pair&lt;string, MyClass&gt;("one", MyClass())
        };
        cout &lt;&lt; "pairs constructed\n";

        map&lt;string, MyClass&gt; mapsm(&amp;pairs[0], &amp;pairs[1]);
        cout &lt;&lt; "mapsm constructed\n";
    }
    /*
        Generated output:
    MyClass constructor
    MyClass copy constructor
    MyClass destructor
    pairs constructed
    MyClass copy constructor
    MyClass copy constructor
    MyClass destructor
    mapsm constructed
    MyClass destructor
    MyClass destructor
    */
</pre>
<p>
When tracing the output of this program, we see that, first, the
constructor of a <code>MyClass</code> object is called to initialize the anonymous
element of the array <code>pairs</code>. This object is then copied into the first
element of the array <code>pairs</code> by the copy constructor. Next, the original
element is not required anymore and is destroyed. At that point the array
<code>pairs</code> has been constructed. Thereupon, the <code>map</code> constructs a temporary
<code>pair</code> object, which is used to construct the map element. Having
constructed the map element, the temporary <code>pair</code> object is
destroyed. Eventually, when the program terminates, the <code>pair</code> element
stored in the <code>map</code> is destroyed too.
    </ul>
<p>
<a name="l234"></a>
<h4>12.4.7.2: The `map' operators</h4>
            The map supports, in addition to the standard operators for containers,
the <a name="an1479"></a>index operator.
<p>
The index operator may be used to retrieve or reassign individual elements of
the map. The argument of the index operator is called a <em>key</em>.
<p>
If the provided key is not available in the <code>map</code>, a new data element is
automatically added to the <code>map</code> using the default value or default
constructor to initialize the value part of the new element. This default
value is returned if the index operator is used as an rvalue.
<p>
When initializing a new or reassigning another element of the map, the type of
the right-hand side of the assignment operator must be equal to (or promotable
to) the type of the map's value part. E.g., to add or change the value of
element <code>"two"</code> in a map, the following statement can be used:
        <pre>
    mapsm["two"] = MyClass();
</pre>
<p>
<a name="l235"></a>
<h4>12.4.7.3: The `map' public members</h4>
        The following member functions are available for the <code>map</code> container:
    <ul>
        <li><a name="an1480"></a><code>mapped_type &amp;at(key_type const &amp;key)</code>:<blockquote>returns a reference to the map's <code>mapped_type</code>
associated with <code>key</code>. If the key is not stored in the <code>map</code> an
<code>std::out_of_range</code> exception is thrown.</blockquote>
    <li><a name="an1481"></a><code>map::iterator begin()</code>:<blockquote>returns an iterator pointing to the
first element of the map. </blockquote>
        <li><a name="an1482"></a><code>map::const_iterator cbegin()</code>:<blockquote>returns a <a name="an1483"></a>const_iterator pointing to the first
element in the map, returning <code>cend</code> if the map is empty.</blockquote>
        <li><a name="an1484"></a><code>map::const_iterator cend()</code>:<blockquote>returns a <a name="an1485"></a>const_iterator pointing just beyond the
map's last element.</blockquote>
    <li><a name="an1486"></a><code>void clear()</code>:<blockquote>erases all elements from
the map.</blockquote>
    <li><a name="an1487"></a><code>size_t count(key)</code>:<blockquote>returns 1 if
the provided key is available in the <code>map</code>, otherwise 0 is returned.</blockquote>
    <li><a name="an1488"></a><code>map::reverse_iterator crbegin() const</code>:<blockquote>
    <a name="an1489"></a> returns an iterator pointing to the last
element of the map.</blockquote>
    <li><a name="an1490"></a><code>map::reverse_iterator crend()</code>:<blockquote>returns an iterator pointing
before the first element of the map.</blockquote>
        <li><a name="an1491"></a><code>pair&lt;iterator, bool&gt; emplace(Args &amp;&amp;...args)</code>:<blockquote>a <code>value_type</code> object is constructed from <code>emplace</code>'s
arguments. If the <code>map</code> already contained an object using the same
<code>key_type</code> value, then a <code>std::pair</code> is returned containing an iterator
pointing to the object using the same <code>key_type</code> value and the value
<code>false</code>. If no such <code>key_type</code> value was found, the newly constructed
object is inserted into the <code>map</code>, and the returned <code>std::pair</code>
contains an iterator pointing to the newly inserted inserted <code>value_type</code>
as well as the value <code>true</code>.</blockquote>
        <li><a name="an1492"></a><code>iterator emplace_hint(const_iterator position,
                            Args &amp;&amp;...args)</code>:<blockquote>a <code>value_type</code> object is constructed from the member's
arguments, and the newly created element is inserted into the
<code>map</code>, unless the (at <code>args</code>) provided key already exists. The
implementation may or may not use <code>position</code> as a <em>hint</em> to start looking
for an insertion point. The returned <code>iterator</code> points to the <code>value_type</code>
using the provided key. It may refer to an already existing <code>value_type</code> or
to a newly added <code>value_type</code>; an existing <code>value_type</code> is not
replaced. If a new value <em>was</em> added, then the container's size has been
incremented when <code>emplace_hint</code> returns.</blockquote>
    <li><a name="an1493"></a><code>bool empty()</code>:<blockquote>returns <code>true</code> if
the map contains no elements.</blockquote>
    <li><a name="an1494"></a><code>map::iterator end()</code>:<blockquote>returns an iterator pointing beyond the
last element of the map.</blockquote>
    <li><a name="an1495"></a><code>pair&lt;map::iterator, map::iterator&gt; equal_range(key)</code>:<blockquote>this
member returns a pair of iterators, being respectively the return values of
the member functions <code>lower_bound</code> and <code>upper_bound</code>, introduced below.
An example illustrating these member functions is given at the
discussion of the member function <code>upper_bound</code>.</blockquote>
    <li><a name="an1496"></a><code>... erase()</code>:<blockquote>erases a specific element or range of elements
from the map:</blockquote>
        <ul>
        <li><code>bool erase(key)</code> erases the element having the
given <code>key</code> from the <code>map</code>. <code>True</code> is returned if the value was removed,
<code>false</code> if the map did not contain an element using the given <code>key</code>.
        <li><code>void erase(pos)</code> erases the element pointed to by the iterator
<code>pos</code>.
        <li><code>void erase(first, beyond)</code> erases all elements indicated by
the iterator range <code>[first, beyond)</code>.
        </ul>
<p>
<li><a name="an1497"></a><code>map::iterator find(key)</code>:<blockquote>returns
an iterator to the element having the given key. If the element isn't
available, <code>end</code> is returned. The following example illustrates the use of
the <code>find</code> member function:</blockquote>
        <pre>
    #include &lt;iostream&gt;
    #include &lt;map&gt;
    using namespace std;

    int main()
    {
        map&lt;string, int&gt; object;

        object["one"] = 1;

        map&lt;string, int&gt;::iterator it = object.find("one");

        cout &lt;&lt; "`one' " &lt;&lt;
                (it == object.end() ? "not " : "") &lt;&lt; "found\n";

        it = object.find("three");

        cout &lt;&lt; "`three' " &lt;&lt;
                (it == object.end() ? "not " : "") &lt;&lt; "found\n";
    }
    /*
        Generated output:
    `one' found
    `three' not found
    */
</pre>
<p>
<li><a name="an1498"></a><code>allocator_type get_allocator() const</code>:<blockquote>returns a
copy of the allocator object used by the <code>map</code> object.</blockquote>
    <li><a name="an1499"></a><code>... insert()</code>:<blockquote>inserts elements into the map. Values
associated with already existing keys, however, are not replaced by new
values. Its return value depends on the version of <code>insert</code> that is called:</blockquote>
        <ul>
        <li><code>pair&lt;map::iterator, bool&gt; insert(keyvalue)</code> inserts
a new <code>value_type</code> into the map. The return value is a
<a name="an1500"></a><code>pair&lt;map::iterator, bool&gt;</code>.  If the returned <a name="an1501"></a><code>bool</code> field is <code>true</code>,
<code>keyvalue</code> was inserted into the map. The value <code>false</code> indicates that the
key that was specified in <code>keyvalue</code> was already available in the map, and
so <code>keyvalue</code> was not inserted into the map.  In both cases the
<code>map::iterator</code> field points to the data element having the
<code>key</code> that was specified in <code>keyvalue</code>. The use of this variant of
<code>insert</code> is illustrated by the following example:
        <pre>
    #include &lt;iostream&gt;
    #include &lt;string&gt;
    #include &lt;map&gt;
    using namespace std;

    int main()
    {
        pair&lt;string, int&gt; pa[] =
        {
            pair&lt;string,int&gt;("one", 10),
            pair&lt;string,int&gt;("two", 20),
            pair&lt;string,int&gt;("three", 30),
        };
        map&lt;string, int&gt; object(&amp;pa[0], &amp;pa[3]);

                // {four, 40} and `true' is returned
        pair&lt;map&lt;string, int&gt;::iterator, bool&gt;
            ret = object.insert
                    (
                        map&lt;string, int&gt;::value_type
                        ("four", 40)
                    );

        cout &lt;&lt; boolalpha;

        cout &lt;&lt; ret.first-&gt;first &lt;&lt; " " &lt;&lt;
            ret.first-&gt;second &lt;&lt; " " &lt;&lt;
            ret.second &lt;&lt; " " &lt;&lt; object["four"] &lt;&lt; '\n';

                // {four, 40} and `false' is returned
        ret = object.insert
                    (
                        map&lt;string, int&gt;::value_type
                        ("four", 0)
                    );

        cout &lt;&lt; ret.first-&gt;first &lt;&lt; " " &lt;&lt;
            ret.first-&gt;second &lt;&lt; " " &lt;&lt;
            ret.second &lt;&lt; " " &lt;&lt; object["four"] &lt;&lt; '\n';
    }
    /*
        Generated output:

        four 40 true 40
        four 40 false 40
    */
</pre>
<p>
Note the somewhat peculiar constructions like
        <pre>
    cout &lt;&lt; ret.first-&gt;first &lt;&lt; " " &lt;&lt; ret.first-&gt;second &lt;&lt; ...
</pre>
    Note that `<code>ret</code>' is equal to the <code>pair</code> returned by the
<code>insert</code> member function. Its `<code>first</code>' field is an iterator into the
<code>map&lt;string, int&gt;</code>, so it can be considered a pointer to a <code>map&lt;string,
int&gt;::value_type</code>. These value types themselves are pairs too, having
`<code>first</code>' and `<code>second</code>' fields. Consequently, `<code>ret.first-&gt;first</code>' is
the <em>key</em> of the map value (a <code>string</code>), and `<code>ret.first-&gt;second</code>' is
the <em>value</em> (an <code>int</code>).
        <li><code>map::iterator insert(pos, keyvalue)</code>. This way a
<code>map::value_type</code> may also be inserted into the map. <code>pos</code> is ignored, and
an iterator to the inserted element is returned.
        <li><code>void insert(first, beyond)</code> inserts the (<code>map::value_type</code>)
elements pointed to by the iterator range <code>[first, beyond)</code>.
        </ul>
<p>
<li><a name="an1502"></a><code>key_compare key_comp()</code>:<blockquote>returns a copy of the object used by the <code>map</code> to compare keys. The
        type <code>map&lt;KeyType, ValueType&gt;::key_compare</code> is defined by the map
        container and <code>key_compare</code>'s parameters have types <code>KeyType const
        &amp;</code>. The comparison function returns <code>true</code> if the first key
        argument should be ordered before the second key argument. To compare
        keys <em>and</em> values, use <code>value_comp</code>, listed below.</blockquote>
    <li><a name="an1503"></a><code>map::iterator lower_bound(key)</code>:<blockquote>returns an iterator pointing to the first
<code>keyvalue</code> element of which the <code>key</code> is at least equal to the specified
<code>key</code>.  If no such element exists, the function returns <code>end</code>.</blockquote>
    <li><a name="an1504"></a><code>size_t max_size()</code>:<blockquote>returns the maximum number of
elements this <code>map</code> may contain.</blockquote>
    <li><a name="an1505"></a><code>map::reverse_iterator rbegin()</code>:<blockquote>
    <a name="an1506"></a> returns an iterator pointing to the last
element of the map.</blockquote>
    <li><a name="an1507"></a><code>map::reverse_iterator rend()</code>:<blockquote>returns an iterator pointing
before the first element of the map.</blockquote>
    <li><a name="an1508"></a><code>size_t size()</code>:<blockquote>returns the
number of elements in the map.</blockquote>
    <li><a name="an1509"></a><code>void swap(argument)</code>:<blockquote>swaps two maps using identical key/value
types.</blockquote>
    <li><a name="an1510"></a><code>map::iterator upper_bound(key)</code>:<blockquote>returns an iterator pointing to the first
<code>keyvalue</code> element having a <code>key</code> exceeding the specified <code>key</code>.  If no
such element exists, the function returns <code>end</code>.  The following
example illustrates the member functions <code>equal_range</code>, <code>lower_bound</code>
and <code>upper_bound</code>:
        <pre>
    #include &lt;iostream&gt;
    #include &lt;map&gt;
    using namespace std;

    int main()
    {
        pair&lt;string, int&gt; pa[] =
        {
            pair&lt;string,int&gt;("one", 10),
            pair&lt;string,int&gt;("two", 20),
            pair&lt;string,int&gt;("three", 30),
        };
        map&lt;string, int&gt; object(&amp;pa[0], &amp;pa[3]);
        map&lt;string, int&gt;::iterator it;

        if ((it = object.lower_bound("tw")) != object.end())
            cout &lt;&lt; "lower-bound `tw' is available, it is: " &lt;&lt;
                    it-&gt;first &lt;&lt; '\n';

        if (object.lower_bound("twoo") == object.end())
            cout &lt;&lt; "lower-bound `twoo' not available" &lt;&lt; '\n';

        cout &lt;&lt; "lower-bound two: " &lt;&lt;
                object.lower_bound("two")-&gt;first &lt;&lt;
                " is available\n";

        if ((it = object.upper_bound("tw")) != object.end())
            cout &lt;&lt; "upper-bound `tw' is available, it is: " &lt;&lt;
                    it-&gt;first &lt;&lt; '\n';

        if (object.upper_bound("twoo") == object.end())
            cout &lt;&lt; "upper-bound `twoo' not available" &lt;&lt; '\n';

        if (object.upper_bound("two") == object.end())
            cout &lt;&lt; "upper-bound `two' not available" &lt;&lt; '\n';

        pair
        &lt;
            map&lt;string, int&gt;::iterator,
            map&lt;string, int&gt;::iterator
        &gt;
            p = object.equal_range("two");

        cout &lt;&lt; "equal range: `first' points to " &lt;&lt;
                    p.first-&gt;first &lt;&lt; ", `second' is " &lt;&lt;
            (
                p.second == object.end() ?
                    "not available"
                :
                    p.second-&gt;first
            ) &lt;&lt;
            '\n';
    }
    /*
        Generated output:

            lower-bound `tw' is available, it is: two
            lower-bound `twoo' not available
            lower-bound two: two is available
            upper-bound `tw' is available, it is: two
            upper-bound `twoo' not available
            upper-bound `two' not available
            equal range: `first' points to two, `second' is not available
    */
</pre>
<p>
</blockquote>
    <li><a name="an1511"></a><code>value_compare value_comp()</code>:<blockquote>returns a copy of the object used by the <code>map</code> to compare keys. The
        type <code>map&lt;KeyType, ValueType&gt;::value_compare</code> is defined by the map
        container and <code>value_compare</code>'s parameters have types <code>value_type
        const &amp;</code>. The comparison function returns <code>true</code> if the first
        key argument should be ordered before the second key argument. The
        <code>Value_Type</code> elements of the <code>value_type</code> objects passed to this
        member are not used by the returned function.</blockquote>
    </ul>
<p>
<a name="l236"></a>
<h4>12.4.7.4: The `map': a simple example</h4>
            As mentioned at the beginning of section <a href="cplusplus12.html#MAP">12.4.7</a>, the <code>map</code> represents
a sorted associative array. In a <code>map</code> the keys are sorted. If an
application must visit all elements in a map the <code>begin</code> and <code>end</code>
iterators must be used.
<p>
The following example illustrates how to make a simple table listing all keys
and values found in a map:
        <pre>
    #include &lt;iostream&gt;
    #include &lt;iomanip&gt;
    #include &lt;map&gt;

    using namespace std;

    int main()
    {
        pair&lt;string, int&gt;
            pa[] =
            {
                pair&lt;string,int&gt;("one", 10),
                pair&lt;string,int&gt;("two", 20),
                pair&lt;string,int&gt;("three", 30),
            };
        map&lt;string, int&gt;
            object(&amp;pa[0], &amp;pa[3]);

        for
        (
            map&lt;string, int&gt;::iterator it = object.begin();
                it != object.end();
                    ++it
        )
            cout &lt;&lt; setw(5) &lt;&lt; it-&gt;first.c_str() &lt;&lt;
                    setw(5) &lt;&lt; it-&gt;second &lt;&lt; '\n';
    }
    /*
        Generated output:
      one   10
    three   30
      two   20
    */
</pre>
<p>
<a name="MULTIMAP"></a><a name="l237"></a>
<h3>12.4.8: The `multimap' container</h3>
    Like the <code>map</code>, the <a name="an1512"></a><code>multimap</code> class implements a (sorted)
    <a name="an1513"></a>associative array. Before using a <code>multimap</code> container the header
file <a name="an1514"></a><code>&lt;map&gt;</code> must be included.
<p>
The main difference between the <code>map</code> and the <code>multimap</code> is that the
multimap supports multiple values associated with the same key, whereas the
map contains single-valued keys. Note that the multimap also accepts multiple
identical values associated with identical keys.
<p>
The <code>map</code> and the <code>multimap</code> have the same set of constructors and member
functions, with the exception of the <a name="an1515"></a>index operator which is not supported
 <a name="an1516"></a> with the multimap. This is understandable: if
multiple entries of the same key are allowed, which of the possible values
should be returned for <code>object[key]</code>?
<p>
Refer to section <a href="cplusplus12.html#MAP">12.4.7</a> for an overview of
the <code>multimap</code> member functions. Some member functions, however, deserve
additional attention when used in the context of the <code>multimap</code>
container. These members are discussed below.
    <ul>
        <li><a name="an1517"></a><code>size_t map::count(key)</code>:<blockquote>returns the
number of entries in the multimap associated with the given <code>key</code>.</blockquote>
        <li><a name="an1518"></a><code>... erase()</code>:<blockquote>erases elements from the map:</blockquote>
            <ul>
            <li><code>size_t erase(key)</code> erases all elements having the
given <code>key</code>. The number of erased elements is returned.
            <li><code>void erase(pos)</code> erases the single element pointed to by
<code>pos</code>. Other elements possibly having the same keys are not erased.
            <li><code>void erase(first, beyond)</code> erases all elements indicated by
the iterator range <code>[first, beyond)</code>.
            </ul>
<p>
<li><a name="an1519"></a><code>pair&lt;multimap::iterator, multimap::iterator&gt; equal_range(key)</code>:<blockquote>returns a pair of iterators, being respectively the return values of
<code>lower_bound</code> and <code>upper_bound</code>, introduced below.  The function provides
a simple means to determine all elements in the <code>multimap</code> that have the
same <code>keys</code>. An example illustrating the use of these member functions is
given at the end of this section.</blockquote>
        <li><a name="an1520"></a><code>multimap::iterator find(key)</code>:<blockquote>this
member returns an iterator pointing to the first value whose key is
<code>key</code>. If the element isn't available, <code>end</code> is returned. The
iterator could be incremented to visit all elements having the same <code>key</code>
until it is either <code>end</code>, or the iterator's <code>first</code> member is
not equal to <code>key</code> anymore.</blockquote>
        <li><a name="an1521"></a><code>multimap::iterator insert()</code>:<blockquote>this
member function normally succeeds, and so a <em>multimap::iterator</em> is
returned, instead of a <code>pair&lt;multimap::iterator, bool&gt;</code> as returned with the
<code>map</code> container. The returned iterator points to the newly added element.</blockquote>
    </ul>
    Although the functions <code>lower_bound</code> and <code>upper_bound</code> act
identically in the <code>map</code> and <code>multimap</code> containers, their operation in a
<code>multimap</code> deserves some additional attention. The next example illustrates
<code>lower_bound</code>, <code>upper_bound</code> and
<code>equal_range</code> applied to a <code>multimap</code>:
        <pre>
    #include &lt;iostream&gt;
    #include &lt;map&gt;
    using namespace std;

    int main()
    {
        pair&lt;string, int&gt; pa[] =
        {
            pair&lt;string,int&gt;("alpha", 1),
            pair&lt;string,int&gt;("bravo", 2),
            pair&lt;string,int&gt;("charley", 3),
            pair&lt;string,int&gt;("bravo", 6),   // unordered `bravo' values
            pair&lt;string,int&gt;("delta", 5),
            pair&lt;string,int&gt;("bravo", 4),
        };
        multimap&lt;string, int&gt; object(&amp;pa[0], &amp;pa[6]);

        typedef multimap&lt;string, int&gt;::iterator msiIterator;

        msiIterator it = object.lower_bound("brava");

        cout &lt;&lt; "Lower bound for `brava': " &lt;&lt;
                it-&gt;first &lt;&lt; ", " &lt;&lt; it-&gt;second &lt;&lt; '\n';

        it = object.upper_bound("bravu");

        cout &lt;&lt; "Upper bound for `bravu': " &lt;&lt;
                it-&gt;first &lt;&lt; ", " &lt;&lt; it-&gt;second &lt;&lt; '\n';

        pair&lt;msiIterator, msiIterator&gt;
            itPair = object.equal_range("bravo");

        cout &lt;&lt; "Equal range for `bravo':\n";
        for (it = itPair.first; it != itPair.second; ++it)
            cout &lt;&lt; it-&gt;first &lt;&lt; ", " &lt;&lt; it-&gt;second &lt;&lt; '\n';
        cout &lt;&lt; "Upper bound: " &lt;&lt; it-&gt;first &lt;&lt; ", " &lt;&lt; it-&gt;second &lt;&lt; '\n';

        cout &lt;&lt; "Equal range for `brav':\n";
        itPair = object.equal_range("brav");
        for (it = itPair.first; it != itPair.second; ++it)
            cout &lt;&lt; it-&gt;first &lt;&lt; ", " &lt;&lt; it-&gt;second &lt;&lt; '\n';
        cout &lt;&lt; "Upper bound: " &lt;&lt; it-&gt;first &lt;&lt; ", " &lt;&lt; it-&gt;second &lt;&lt; '\n';
    }
    /*
        Generated output:

        Lower bound for `brava': bravo, 2
        Upper bound for `bravu': charley, 3
        Equal range for `bravo':
        bravo, 2
        bravo, 6
        bravo, 4
        Upper bound: charley, 3
        Equal range for `brav':
        Upper bound: bravo, 2
    */
</pre>
<p>
In particular note the following characteristics:
    <ul>
    <li><code>lower_bound</code> and <code>upper_bound</code> produce the same result for
non-existing keys: they both return the first element having a key that
exceeds the provided key.
    <li> Although the keys are ordered in the <code>multimap</code>, the values for
equal keys are not ordered: they are retrieved in the order in which they were
enterd.
    </ul>
<p>
<a name="SET"></a><a name="l238"></a>
<h3>12.4.9: The `set' container</h3>
    The <a name="an1522"></a><code>set</code> class implements a <a name="an1523"></a>sorted collection of values. Before using
<code>set</code> containers the <a name="an1524"></a><code>&lt;set&gt;</code> header file must be included.
<p>
A set contains unique values (of a container-acceptable type). Each value
is stored only once.
<p>
A specific value can be explicitly created: Every <code>set</code> defines a
<a name="an1525"></a><code>value_type</code> which may be used to create values that can be stored in the
<code>set</code>. For example, a value for a <code>set&lt;string&gt;</code> can be constructed as
follows:
        <pre>
    set&lt;string&gt;::value_type setValue("Hello");
</pre>
    The <code>value_type</code> is associated with the <code>set&lt;string&gt;</code>. Anonymous
<code>value_type</code> objects are also often used. E.g.,
        <pre>
    set&lt;string&gt;::value_type("Hello");
</pre>
    Instead of using the line <code>set&lt;string&gt;::value_type(...)</code> over
and over again, a <code>typedef</code> is often used to reduce typing and to improve
readability:
        <pre>
    typedef set&lt;string&gt;::value_type StringSetValue
</pre>
    Using this typedef, values for the <code>set&lt;string&gt;</code> may be constructed
as follows:
        <pre>
    StringSetValue("Hello");
</pre>
    Alternatively, values of the set's type may be used
immediately. In that case the value of type <code>Type</code> is implicitly
converted  to a <code>set&lt;Type&gt;::value_type</code>.
<p>
The following constructors, operators, and member functions are available
for the <code>set</code> container:
    <ul>
    <li> Constructors:
        <ul>
        <li> The copy and move constructors are available;
        <li> A <code>set</code> may be constructed empty:
        <pre>
    set&lt;int&gt; object;
</pre>
        <li> A set may be initialized using two iterators. For example:
            <pre>
    int intarr[] = {1, 2, 3, 4, 5};

    set&lt;int&gt; object(&amp;intarr[0], &amp;intarr[5]);
</pre>
        </ul>
<p>
Note that all values in the set must be different: it is not possible to
store the same value repeatedly when the set is constructed. If the same value
occurs repeatedly, only the first instance of the value is entered into the
set; the remaining values are silently ignored.
<p>
Like the <a href="cplusplus12.html#MAP">map</a>, the <code>set</code> receives its own copy of the data it
contains.
    <li> The <code>set</code> container only supports the standard set of operators
that are available for containers.
    <li> The <code>set</code> class has the following member functions:
        <ul>
        <li><a name="an1526"></a><code>set::iterator begin()</code>:<blockquote>returns an <a name="an1527"></a>iterator pointing to
the first element of the set. If the set is empty <code>end</code> is returned.</blockquote>
        <li><a name="an1528"></a><code>void clear()</code>:<blockquote>erases all elements from the set.</blockquote>
        <li><a name="an1529"></a><code>size_t count(key)</code>:<blockquote>returns 1 if
the provided key is available in the <code>set</code>, otherwise 0 is returned.</blockquote>
        <li><a name="an1530"></a><code>bool empty()</code>:<blockquote>returns <code>true</code> if
the set contains no elements.</blockquote>
        <li><a name="an1531"></a><code>set::iterator end()</code>:<blockquote>returns an iterator pointing beyond
the last element of the set.</blockquote>
        <li><a name="an1532"></a><code>pair&lt;set::iterator, set::iterator&gt; equal_range(key)</code>:<blockquote>this
member returns a pair of iterators, being respectively the return values of
the member functions <code>lower_bound</code> and <code>upper_bound</code>, introduced
below.</blockquote>
        <li><a name="an1533"></a><code>... erase()</code>:<blockquote>erases a specific element or range of
elements from the set:</blockquote>
            <ul>
            <li><code>bool erase(value)</code> erases the element having the given
<code>value</code> from the <code>set</code>. <code>True</code> is returned if the value was removed,
<code>false</code> if the set did not contain an element `<code>value</code>'.
            <li><code>void erase(pos)</code> erases the element pointed to by the iterator
<code>pos</code>.
            <li><code>void erase(first, beyond)</code> erases all elements
indicated by the iterator range <code>[first, beyond)</code>.
            </ul>
<p>
<li><a name="an1534"></a><code>set::iterator find(value)</code>:<blockquote>returns
an iterator to the element having the given value. If the element isn't
available, <code>end</code> is returned.</blockquote>
        <li><a name="an1535"></a><code>allocator_type get_allocator() const</code>:<blockquote>returns a
copy of the allocator object used by the <code>set</code> object.</blockquote>
        <li><a name="an1536"></a><code>... insert()</code>:<blockquote>inserts elements into the <code>set</code>. If the
element already exists, the existing element is left untouched and the element
to be inserted is ignored.  The return value depends on the version of
<code>insert</code> that is called:</blockquote>
            <ul>
            <li><code>pair&lt;set::iterator, bool&gt; insert(keyvalue)</code> inserts
a new <code>set::value_type</code> into the set. The return value is a
<a name="an1537"></a><code>pair&lt;set::iterator, bool&gt;</code>.  If the returned <a name="an1538"></a><code>bool</code> field is <code>true</code>,
<code>value</code> was inserted into the set. The value <code>false</code> indicates that the
value that was specified was already available in the set, and
so the provided <code>value</code> was not inserted into the set.  In both cases the
<code>set::iterator</code> field points to the data element in the <code>set</code> having the
specified <code>value</code>.
            <li><code>set::iterator insert(pos, keyvalue)</code>. This way a
<code>set::value_type</code> may also be inserted into the set. <code>pos</code> is ignored, and
an iterator to the inserted element is returned.
            <li><code>void insert(first, beyond)</code> inserts the (<code>set::value_type</code>)
elements pointed to by the <a name="an1539"></a>iterator range <a name="an1540"></a><code>[first, beyond)</code> into the
set.
            </ul>
<p>
<li><a name="an1541"></a><code>key_compare key_comp()</code>:<blockquote>returns a copy of the object used by the <code>set</code> to compare keys. The
        type <br/>
        <code>set&lt;ValueType&gt;::key_compare</code> is defined by the set container
        and <code>key_compare</code>'s parameters have types <code>ValueType const &amp;</code>. The
        comparison function returns <code>true</code> if its first argument should
        be ordered before its second argument.</blockquote>
    <li><a name="an1542"></a><code>set::iterator lower_bound(key)</code>:<blockquote>returns an iterator pointing to the first <code>keyvalue</code> element of
        which the <code>key</code> is at least equal to the specified <code>key</code>.  If no
        such element exists, the function returns <code>end</code>.</blockquote>
    <li><a name="an1543"></a><code>size_t max_size()</code>:<blockquote>returns the maximum number of
        elements this <code>set</code> may contain.</blockquote>
    <li><a name="an1544"></a><code>set::reverse_iterator rbegin()</code>:<blockquote>
    <a name="an1545"></a> returns an iterator pointing to the last element of
the set.</blockquote>
    <li><a name="an1546"></a><code>set::reverse_iterator rend</code>:<blockquote>returns an iterator pointing
        before the first element of the set.</blockquote>
    <li><a name="an1547"></a><code>size_t size()</code>:<blockquote>returns the
number of elements in the set.</blockquote>
    <li><a name="an1548"></a><code>void swap(argument)</code>:<blockquote>swaps two sets (<code>argument</code> being
the second set) that use identical data types.</blockquote>
    <li><a name="an1549"></a><code>set::iterator upper_bound(key)</code>:<blockquote>returns an iterator pointing to the first
<code>keyvalue</code> element having a <code>key</code> exceeding the specified <code>key</code>.  If no
such element exists, the function returns <code>end</code>.</blockquote>
        </ul>
    <li><a name="an1550"></a><code>value_compare value_comp()</code>:<blockquote>returns a copy of the object used by the <code>set</code> to compare keys. The
        type <br/>
       <code>set&lt;ValueType&gt;::value_compare</code> is defined by the set container and
        <code>value_compare</code>'s parameters have types <code>ValueType const &amp;</code>. The
        comparison function returns <code>true</code> if its first argument should be
        ordered before its second argument. Its operation is identical to that
        of a <code>key_compare</code> object, returned by <code>key_comp</code>.</blockquote>
    </ul>
<p>
<a name="MULTISET"></a><a name="l239"></a>
<h3>12.4.10: The `multiset' container</h3>
    Like the <code>set</code>, the <a name="an1551"></a><code>multiset</code> class implements a
    <a name="an1552"></a> sorted collection of values. Before
using <code>multiset</code> containers the header file <a name="an1553"></a><code>&lt;set&gt;</code> must be included.
<p>
The main difference between the <code>set</code> and the <code>multiset</code> is that the
multiset supports multiple entries of the same value, whereas the set contains
unique values.
<p>
The <code>set</code> and the <code>multiset</code> have the same set of constructors and member
functions.  Refer to section <a href="cplusplus12.html#SET">12.4.9</a> for an overview of the <code>multiset</code>
member functions.  Some member functions, however, behave slightly different
than their counterparts of the <code>set</code> container. Those members are mentioned
here.
    <ul>
        <li><a name="an1554"></a><code>size_t count(value)</code>:<blockquote>returns the number of
entries in the multiset associated with the given <code>value</code>.</blockquote>
        <li><a name="an1555"></a><code>... erase()</code>:<blockquote>erases elements from the set:</blockquote>
            <ul>
            <li><code>size_t erase(value)</code> erases all elements having the given
<code>value</code>. The number of erased elements is returned.
            <li><code>void erase(pos)</code> erases the element pointed to by the iterator
<code>pos</code>. Other elements possibly having the same values are not erased.
            <li><code>void erase(first, beyond)</code> erases all elements indicated by
the iterator range <code>[first, beyond)</code>.
            </ul>
<p>
<li><a name="an1556"></a><code>pair&lt;multiset::iterator, multiset::iterator&gt; equal_range(value)</code>:<blockquote>returns a pair of iterators, being respectively the return values of
<code>lower_bound</code> and <code>upper_bound</code>, introduced below.  The function provides
a simple means to determine all elements in the <code>multiset</code> that have the
same <code>values</code>.</blockquote>
        <li><a name="an1557"></a><code>multiset::iterator find(value)</code>:<blockquote>returns an
iterator pointing to the first element having the specified value. If the
element isn't available, <code>end</code> is returned. The iterator could be
incremented to visit all elements having the given <code>value</code> until it is
either <code>end</code>, or the iterator doesn't point to `<code>value</code>' anymore.</blockquote>
        <li><a name="an1558"></a><code>... insert()</code>:<blockquote>this member function normally succeeds and
returns a <a name="an1559"></a><em>multiset::iterator</em> rather than a <code>pair&lt;multiset::iterator,
bool&gt;</code> as returned with the <code>set</code> container. The returned iterator points to
the newly added element.</blockquote>
    </ul>
    Although the functions <code>lower_bound</code> and <code>upper_bound</code> act identically
in the <code>set</code> and <code>multiset</code> containers, their operation in a <code>multiset</code>
deserves some additional attention. With a <code>multiset</code> container
<code>lower_bound</code> and <code>upper_bound</code> produce the same result for non-existing
keys: they both return the first element having a key exceeding the provided
key.
<p>
Here is an example showing the use of various member functions of a
multiset:
    <pre>
    #include &lt;iostream&gt;
    #include &lt;set&gt;

    using namespace std;

    int main()
    {
        string
            sa[] =
            {
                "alpha",
                "echo",
                "hotel",
                "mike",
                "romeo"
            };

        multiset&lt;string&gt;
            object(&amp;sa[0], &amp;sa[5]);

        object.insert("echo");
        object.insert("echo");

        multiset&lt;string&gt;::iterator
            it = object.find("echo");

        for (; it != object.end(); ++it)
            cout &lt;&lt; *it &lt;&lt; " ";
        cout &lt;&lt; '\n';

        cout &lt;&lt; "Multiset::equal_range(+NOTRANS(&amp;euml;)ch\")\n";
        pair
        &lt;
            multiset&lt;string&gt;::iterator,
            multiset&lt;string&gt;::iterator
        &gt;
            itpair = object.equal_range("ech");

        if (itpair.first != object.end())
            cout &lt;&lt; "lower_bound() points at " &lt;&lt; *itpair.first &lt;&lt; '\n';
        for (; itpair.first != itpair.second; ++itpair.first)
            cout &lt;&lt; *itpair.first &lt;&lt; " ";

        cout &lt;&lt; '\n' &lt;&lt;
                object.count("ech") &lt;&lt; " occurrences of 'ech'" &lt;&lt; '\n';

        cout &lt;&lt; "Multiset::equal_range(+NOTRANS(&amp;euml;)cho\")\n";
        itpair = object.equal_range("echo");

        for (; itpair.first != itpair.second; ++itpair.first)
            cout &lt;&lt; *itpair.first &lt;&lt; " ";

        cout &lt;&lt; '\n' &lt;&lt;
                object.count("echo") &lt;&lt; " occurrences of 'echo'" &lt;&lt; '\n';

        cout &lt;&lt; "Multiset::equal_range(+NOTRANS(&amp;euml;)choo\")\n";
        itpair = object.equal_range("echoo");

        for (; itpair.first != itpair.second; ++itpair.first)
            cout &lt;&lt; *itpair.first &lt;&lt; " ";

        cout &lt;&lt; '\n' &lt;&lt;
                object.count("echoo") &lt;&lt; " occurrences of 'echoo'" &lt;&lt; '\n';
    }
    /*
        Generated output:

        echo echo echo hotel mike romeo
        Multiset::equal_range("ech")
        lower_bound() points at echo

        0 occurrences of 'ech'
        Multiset::equal_range("echo")
        echo echo echo
        3 occurrences of 'echo'
        Multiset::equal_range("echoo")

        0 occurrences of 'echoo'
    */
</pre>
<p>
<a name="STACK"></a><a name="l240"></a>
<h3>12.4.11: The `stack' container</h3>
    The <a name="an1560"></a><code>stack</code> class implements a <a name="an1561"></a>stack data structure.  Before using
<code>stack</code> containers the header file <a name="an1562"></a><code>&lt;stack&gt;</code> must be included.
<p>
A stack is also called a <a name="an1563"></a>first in, last out (<a name="an1564"></a>FILO or <a name="an1565"></a>LIFO) data
structure as the first item to enter the stack is the last item to leave.  A
stack is an extremely useful data structure in situations where data must
temporarily remain available. For example, programs maintain a stack to store
local variables of functions: the lifetime of these variables is determined by
the time these functions are active, contrary to global (or static local)
variables, which live for as long as the program itself lives. Another example
is found in calculators using the
 <a name="an1566"></a><em>Reverse Polish Notation</em> (<a name="an1567"></a>RPN), in which the operands of operators are
kept  in a stack, whereas operators pop their operands off the stack and
push the results of their work back onto the stack.
<p>
As an example of the use of a stack, consider figure <a href="cplusplus12.html#StackFig">12</a>, in which
the contents of the stack is shown while the expression <code>(3 + 4) * 2</code> is
evaluated. In the RPN this expression becomes <code>3 4 + 2 *</code>, and figure
<a href="cplusplus12.html#StackFig">12</a> shows the stack contents after each <a name="an1568"></a><em>token</em> (i.e., the
operands and the operators) is read from the input. Notice that each operand
is indeed pushed on the stack, while each operator changes the contents of the
stack.
    <a name="StackFig"></a><p><figure><img src="containers/stack/stack.gif" alt="Figure 12 is shown here."/><br/>
<figcaption>Figure 12: The contents of a stack while evaluating <code>3 4 + 2 *</code></figcaption>
</figure></p>

    The expression is evaluated in five steps. The caret between the tokens
in the expressions shown on the first line of figure <a href="cplusplus12.html#StackFig">12</a> shows what
token has just been read. The next line shows the actual stack-contents, and
the final line shows the steps for referential purposes. Note that at step 2,
two numbers have been pushed on the stack. The first number (<code>3</code>) is now at
the bottom of the stack. Next, in step 3, the <code>+</code> operator is read. The
operator pops two operands (so that the stack is empty at that moment),
calculates their sum, and pushes the resulting value (<code>7</code>) on the
stack. Then, in step 4, the number <code>2</code> is read, which is dutifully pushed on
the stack again. Finally, in step 5 the final operator <code>*</code> is read, which
pops the values <code>2</code> and <code>7</code> from the stack, computes their product, and
pushes the result back on the stack. This result (<code>14</code>) could then be popped
to be displayed on some medium.
<p>
From figure <a href="cplusplus12.html#StackFig">12</a> we see that a stack has one location (the <a name="an1569"></a><em>top</em>)
where items can be pushed onto and popped off the stack. This top element is
the stack's only immediately visible element. It may be accessed and modified
directly.
<p>
Bearing this model of the stack in mind, let's see what we formally can do
with the <code>stack</code> container. For the <code>stack</code>, the following constructors,
operators, and member functions are available:
    <ul>
    <li> <a name="an1570"></a> Constructors:
        <ul>
        <li> The copy and move constructors are available;
        <li> A <code>stack</code> may be constructed empty:
    <pre>
stack&lt;string&gt; object;
</pre>
    </ul>
    <li> Only the basic set of container operators are supported by the
<code>stack</code>
    <li> The following member functions are available for stacks:
        <ul>
        <li><a name="an1571"></a><code>bool empty()</code>:<blockquote>this
member returns <code>true</code> if the stack contains no elements.</blockquote>
        <li><a name="an1572"></a><code>void pop()</code>:<blockquote>removes the element at the top of
the stack. Note that the popped element is <em>not</em> returned by this member,
and refer to section <a href="cplusplus12.html#QUEUE">12.4.4</a> for a discussion about the reason why <code>pop</code>
has return type <code>void</code>.</blockquote>  Furthermore, it is the responsibility of the
stack's user to assure that <code>pop</code> is not called when the stack is empty. If
<code>pop</code> <em>is</em> called for an empty stack, its internal administration breaks,
resulting, e.g., in a negative size (showing itself as a very large stacksize
due to its <code>size</code> member returning a <code>size_t</code>, and other operations (like
<code>push</code>) fail and may crash your program. Of course, with a well designed
algorithm requests to pop from empty stacks do not occur (which is probably
why this implementation was used for the stack container).
        <li><a name="an1573"></a><code>void push(value)</code>:<blockquote>places
<code>value</code> at the top of the stack, hiding the other elements from view.</blockquote>
        <li><a name="an1574"></a><code>size_t size()</code>:<blockquote>this
member returns the number of elements in the stack.</blockquote>
        <li><a name="an1575"></a><code>Type &amp;top()</code>:<blockquote>this member
returns a reference to the stack's top (and only visible) element. It is the
    <a name="an1576"></a>responsibility of the programmer to use this member only if the stack
is not empty.</blockquote>
        )
    </ul>
    The stack does not support iterators or a subscript
operator. The only elements that can be accessed is its top element.
  To empty a stack:
    <ul>
    <li> repeatedly remove its front element;
    <li> assign an empty stack to it;
    <li> have its destructor called (e.g., by ending its lifetime).
    </ul>
  </ul>
<p>
<a name="l241"></a>
<h3>12.4.12: The `unordered_map' container (`hash table')</h3>
    In <strong>C++</strong> hash tables are available as objects of the class <a name="an1577"></a><code>unordered_map</code>.
<p>
Before using <code>unordered_map</code> or <code>unordered_multimap</code> containers the header
file <a name="an1578"></a><code>&lt;unordered_map&gt;</code> must be included.
<p>
The <code>unordered_map</code> class implements an <a name="an1579"></a>associative array in which the
elements are stored according to some <em>hashing</em> scheme.  As discussed, the
map is a sorted data structure. The keys in maps are sorted using the
<a name="an1580"></a><code>operator&lt;</code> of the key's data type. Generally, this is not the fastest way
to either store or retrieve data.  The main benefit of sorting is that a
listing of sorted keys appeals more to humans than an unsorted list.  However,
a by far faster way to store and retrieve data is to use <a name="an1581"></a><em>hashing</em>.
<p>
Hashing uses a function (called the <a name="an1582"></a><em>hash function</em>) to compute an
(unsigned) number from the key, which number is thereupon used as an index in
the table storing the keys and their values. This number is called the
 <a name="an1583"></a><em>bucket number</em>. Retrieval of a key is as simple as computing the
 <a name="an1584"></a>hash value of the provided key, and looking in the table at the computed
index location: if the key is present, it is stored in the table, at the
computed bucket location and its value can be returned. If it's not present,
the key is not currently stored in the container.
<p>
<em>Collisions</em> <a name="an1585"></a> occur when a computed index position is already
occupied by another element. For these situations the abstract containers have
solutions available. A simple solution, used by <code>unordered_maps</code>, consists
of using <a name="an1586"></a><em>linear chaining</em>, which uses linked list to store colliding table
elements.
<p>
The term <em>unordered_map</em> is used rather than <em>hash</em> to avoid name
collisions with hash tables developed before they were added to the language.
<p>
Because of the hashing method, the <a name="an1587"></a><em>efficiency</em> of a <code>unordered_map</code> in
terms of speed should greatly exceed the efficiency of the <code>map</code>. Comparable
conclusions may be drawn for the <code>unordered_set</code>, the <code>unordered_multimap</code>
and the <code>unordered_multiset</code>.
<p>
<a name="l242"></a>
<h4>12.4.12.1: The `unordered_map' constructors</h4>
        When defining an <a name="an1588"></a><code>unordered_map</code> type five template arguments must be
specified :
    <ul>
    <li> a <a name="an1589"></a>KeyType (becoming <a name="an1590"></a><code>unordered_map::key_type</code>),
    <li> a <a name="an1591"></a>ValueType (becoming <a name="an1592"></a><code>unordered_map::mapped_type</code>),
    <li> the type of an object computing a hash value from a key value
        (becoming <a name="an1593"></a><code>unordered_map::hasher</code>), and
    <li> the type of an object that can compare two keys for equality (becoming
        <a name="an1594"></a><code>unordered_map::key_equal</code>).
    <li> the type of its allocator. This is usually left unspecified, using
        the allocator provided by default by the implementor.
    </ul>
<p>
The generic definition of an <code>unordered_map</code> container looks like this:
        <pre>
    std::unordered_map &lt;KeyType, ValueType, hash type, predicate type,
                        allocator type&gt;
</pre>
    When <code>KeyType</code> is <code>std::string</code> or a built-in type then default types
are available for the hash type and the predicate type. In practice the
allocator type is not specified, as the default allocator suffices.  In these
cases an <code>unordered_map</code> object can be defined by merely specifying the key-
and value types, like this:
        <pre>
    std::unordered_map&lt;std::string, ValueType&gt; hash(size_t size = implSize);
</pre>
    Here, <code>implSize</code> is the container's default initial size, which is
specified by the implementor. The map's size is automatically enlarged by the
<code>unordered_map</code> when necessary, in which case the container <em>rehashes</em> all
its elements. In practice the default <code>size</code> argument provided by the
implementor is completely satisfactory.
<p>
The <code>KeyType</code> frequently consists of text. So, a <code>unordered_map</code> using a
<code>std::string KeyType</code> is frequently used. Be careful not to use a plain
<code>char const * key_type</code> as two <code>char const *</code> values pointing to equal
<strong>C</strong>-strings stored at different locations are considered to be different
keys, as their pointer values rather than their textual contents are
compared. Here is an example showing how a <code>char const * KeyType</code> can be
used. Note that in the example no arguments are specified when constructing
<code>months</code>, since default values and constructors are available:
        <pre>
    #include &lt;unordered_map&gt;
    #include &lt;iostream&gt;
    #include &lt;string&gt;
    #include &lt;cstring&gt;

    using namespace std;

    struct EqualCp
    {
        bool operator()(char const *l, char const *r) const
        {
            return strcmp(l, r) == 0;
        }
    };
    struct HashCp
    {
        size_t operator()(char const *str) const
        {
            return std::hash&lt;std::string&gt;()(str);
        }
    };
    int main()
    {
        unordered_map&lt;char const *, int, HashCp, EqualCp&gt; months;
        // or explicitly:
            unordered_map&lt;char const *, int, HashCp, EqualCp&gt;
                                      monthsTwo(61, HashCp(), EqualCp());

        months["april"] = 30;
        months["november"] = 31;

        string apr("april");    // different pointers, same string

        cout &lt;&lt; "april     -&gt; " &lt;&lt; months["april"] &lt;&lt; '\n' &lt;&lt;
                "april     -&gt; " &lt;&lt; months[apr.c_str()] &lt;&lt; '\n';
    }
</pre>
<p>
If other <code>KeyTypes</code> must be used, then the <code>unordered_map</code>'s constructor
requires (constant references to) a hash function object, computing a hash
value from a key value, and a predicate function object, returning <code>true</code> if
two <code>unordered_map::key_type</code> objects are identical.  A <em>generic
algorithm</em> (see chapter <a href="cplusplus19.html#GENERIC">19</a>) exists performing tests of equality
(i.e., <code>equal_to</code>). These tests can be used if the key's data type supports
the equality operator. Alternatively, an overloaded <a name="an1595"></a><code>operator==</code> or
specialized <a name="an1596"></a>function object could be constructed returning <code>true</code> if two
keys are equal and <code>false</code> otherwise.
<p>
<strong>Constructors</strong>
<p>
The <code>unordered_map</code> supports the following constructors:
    <ul>
    <li> The copy and move constructors are available;
    <li><code>explicit unordered_map(size_type n = implSize,
             hasher const &amp;hf = hasher(),</code><br/>
             <code>key_equal const &amp;eql = key_equal(),</code><br/>
             <code>allocator_type const &amp;alloc = allocator_type())</code>:
        this constructor can also be used as default constructor;
    <li><code>unordered_map(const_iterator begin,
                    const_iterator end,
                    size_type n = implSize, hasher const &amp;hf = hasher(),
                    key_equal const &amp;eql = key_equal(),
                    allocator_type const &amp;alloc = allocator_type())</code>:
        this constructor expects two iterators specifying
a range of <code>unordered_map::value_type const</code> objects, and
    <li><code>unordered_map(initializer_list&lt;value_type&gt; initList,
                    size_type n = implSize, hasher const &amp;hf = hasher(),
                    key_equal const &amp;eql = key_equal(),
                    allocator_type const &amp;alloc = allocator_type())</code>:
            a constructor expecting an <code>initializer_list</code> of
            <code>unordered_map::value_type</code> values.
    </ul>
<p>
The following example shows a program using an unordered_map containing
the names of the months of the year and the number of days these months
(usually) have. Then, using the subscript operator the days in several months
are displayed (the predicate used here is the generic algorithm
<code>equal_to&lt;string&gt;</code>, which is provided by the compiler as the default fourth
argument of the <code>unordered_map</code> constructor):
        <pre>
    #include &lt;unordered_map&gt;
    #include &lt;iostream&gt;
    #include &lt;string&gt;
    using namespace std;

    int main()
    {
        unordered_map&lt;string, int&gt; months;

        months["january"] = 31;
        months["february"] = 28;
        months["march"] = 31;
        months["april"] = 30;
        months["may"] = 31;
        months["june"] = 30;
        months["july"] = 31;
        months["august"] = 31;
        months["september"] = 30;
        months["october"] = 31;
        months["november"] = 30;
        months["december"] = 31;

        cout &lt;&lt; "september -&gt; " &lt;&lt; months["september"] &lt;&lt; '\n' &lt;&lt;
                "april     -&gt; " &lt;&lt; months["april"] &lt;&lt; '\n' &lt;&lt;
                "june      -&gt; " &lt;&lt; months["june"] &lt;&lt; '\n' &lt;&lt;
                "november  -&gt; " &lt;&lt; months["november"] &lt;&lt; '\n';
    }
    /*
        Generated output:
    september -&gt; 30
    april     -&gt; 30
    june      -&gt; 30
    november  -&gt; 30
    */
</pre>
<p>
<a name="UMAPMEMBERS"></a><a name="l243"></a>
<h4>12.4.12.2: The `unordered_map' public members</h4>
        The <code>unordered_map</code> supports the index operator operating identically to the
<code>map</code>'s index operator: a (const) reference to the <code>ValueType</code> associated
with the provided <code>KeyType</code>'s value is returned. If not yet available, the
key is added to the <code>unordered_map</code>, and a default <code>ValueType</code> value is
returned. In addition, it supports <code>operator==</code>.
<p>
The <code>unordered_map</code> provides the following
 <a name="an1597"></a> member functions (<code>key_type,
value_type</code> etc. refer to the types defined by the <code>unordered_map</code>):
<p>
<ul>
        <li><a name="an1598"></a><code>mapped_type &amp;at(key_type const &amp;key)</code>:<blockquote>returns a reference to the unordered_map's <code>mapped_type</code>
associated with <code>key</code>. If the key is not stored in the <code>unordered_map</code> an
<code>std::out_of_range</code> exception is thrown.</blockquote>
        <li><a name="an1599"></a><code>unordered_map::iterator begin()</code>:<blockquote>returns an <a name="an1600"></a>iterator pointing to the first
element in the unordered_map, returning <code>end</code> if the unordered_map is empty.</blockquote>
        <li><a name="an1601"></a><code>size_t bucket(key_type const &amp;key)</code>:<blockquote>returns the index location where <code>key</code> is stored. If
<code>key</code> wasn't stored yet <code>bucket</code> adds <code>value_type(key, Value())</code> before
returning its index position.</blockquote>
        <li><a name="an1602"></a><code>size_t bucket_count()</code>:<blockquote>returns the number of slots used by the containers. Each slot may
contain one (or more, in case of collisions) <code>value_type</code> objects.</blockquote>
        <li><a name="an1603"></a><code>size_t bucket_size(size_t index)</code>:<blockquote>returns the number of <code>value_type</code> objects stored at bucket
position <code>index</code>.</blockquote>
        <li><a name="an1604"></a><code>unordered_map::const_iterator cbegin()</code>:<blockquote>returns a <a name="an1605"></a>const_iterator pointing to the first
element in the unordered_map, returning <code>cend</code> if the unordered_map is empty.</blockquote>
        <li><a name="an1606"></a><code>unordered_map::const_iterator cend()</code>:<blockquote>returns a <a name="an1607"></a>const_iterator pointing just beyond the
unordered_map's last element.</blockquote>
        <li><a name="an1608"></a><code>void clear()</code>:<blockquote>erases all the unordered_map's elements.</blockquote>
        <li><a name="an1609"></a><code>size_t count(key_type const &amp;key)</code>:<blockquote>returns the number of times a <code>value_type</code> object using
<code>key_type</code> <code>key</code> is stored in the <code>unordered_map</code> (which is either one
or zero).</blockquote>
        <li><a name="an1610"></a><code>pair&lt;iterator, bool&gt; emplace(Args &amp;&amp;...args)</code>:<blockquote>a <code>value_type</code> object is constructed from <code>emplace</code>'s
arguments. If the <code>unordered_map</code> already contained an object using the same
<code>key_type</code> value, then a <code>std::pair</code> is returned containing an iterator
pointing to the object using the same <code>key_type</code> value and the value
<code>false</code>. If no such <code>key_type</code> value was found, the newly constructed
object is inserted into the <code>unordered_map</code>, and the returned <code>std::pair</code>
contains an iterator pointing to the newly inserted inserted <code>value_type</code>
as well as the value <code>true</code>.</blockquote>
        <li><a name="an1611"></a><code>iterator emplace_hint(const_iterator position,
                            Args &amp;&amp;...args)</code>:<blockquote>a <code>value_type</code> object is constructed from the member's
arguments, and the newly created element is inserted into the
<code>unordered_map</code>, unless the (at <code>args</code>) provided key already exists. The
implementation may or may not use <code>position</code> as a <em>hint</em> to start looking
for an insertion point. The returned <code>iterator</code> points to the <code>value_type</code>
using the provided key. It may refer to an already existing <code>value_type</code> or
to a newly added <code>value_type</code>; an existing <code>value_type</code> is not
replaced. If a new value <em>was</em> added, then the container's size has been
incremented when <code>emplace_hint</code> returns.</blockquote>
    <li><a name="an1612"></a><code>bool empty()</code>:<blockquote>returns <code>true</code> if the unordered_map contains no elements.</blockquote>
    <li><a name="an1613"></a><code>unordered_map::iterator end()</code>:<blockquote>returns an iterator pointing beyond the last element in the
unordered_map.</blockquote>
    <li><a name="an1614"></a><code>pair&lt;iterator, iterator&gt; equal_range(key)</code>:<blockquote>this
member returns a pair of iterators  defining the range of elements having a
key that is equal to <code>key</code>. With the <code>unordered_map</code> this range includes
at most one element.</blockquote>
        <li><a name="an1615"></a><code>unordered_map::iterator erase()</code>:<blockquote>erases a specific range of elements in the unordered_map:</blockquote>
            <ul>
            <li><code>erase(pos)</code> erases the element pointed to by the iterator
<code>pos</code>. The iterator <code>++pos</code> is returned.
            <li><code>erase(first, beyond)</code> erases elements indicated by the iterator
range <code>[first, beyond)</code>, returning <code>beyond</code>.
            </ul>
<p>
<li><a name="an1616"></a><code>iterator find(key)</code>:<blockquote>returns an iterator to the element having the given key. If the
element isn't available, <code>end</code> is returned.</blockquote>
        <li><a name="an1617"></a><code>allocator_type get_allocator() const</code>:<blockquote>returns a
copy of the allocator object used by the <code>unordered_map</code> object.</blockquote>
        <li><a name="an1618"></a><code>hasher hash_function() const</code>:<blockquote>returns a copy of
the hash function object used by the <code>unordered_map</code> object.</blockquote>
        <li><a name="an1619"></a><code>... insert()</code>:
            <blockquote>elements may be inserted starting at a certain position. No
insertion is performed if the provided key is already in use. The return value
depends on the version of <code>insert()</code> that is called. When a
<code>pair&lt;iterator, bool&gt;</code> is returned, then the <code>pair's first</code> member is an
iterator pointing to the element having a key that is equal to the key of the
provided <code>value_type</code>, the <code>pair's second</code> member is <code>true</code> if <code>value</code>
was actually inserted into the container, and <code>false</code> if not.</blockquote>
            <ul>
            <li><code>pair&lt;iterator, bool&gt; insert(value_type const &amp;value)</code>
                attempts to insert <code>value</code>.
            <li><code>pair&lt;iterator, bool&gt; insert(value_type &amp;&amp;tmp)</code>
                attempts to insert <code>value</code> using <code>value_type</code>'s move
                constructor.
            <li><code>pair&lt;iterator, bool&gt; insert(const_iterator hint, value_type
const &amp;value)</code>
                attempts to insert <code>value</code>, possibly using <code>hint</code> as a
starting point when trying to insert <code>value</code>.
            <li><code>pair&lt;iterator, bool&gt; insert(const_iterator hint, value_type
&amp;&amp;tmp)</code>
                attempts to insert a <code>value</code> using <code>value_type</code>'s move
constructor, and possibly using <code>hint</code> as a starting point when trying to
insert <code>value</code>.
            <li><code>void insert(first, beyond)</code> tries to insert the elements in
the iterator range <code>[first, beyond)</code>.
            <li><code>void insert(initializer_list &lt;value_type&gt; iniList)</code>
                attempts to insert the elements in <code>iniList</code> into the
container.
            </ul>
<p>
<li><a name="an1620"></a><code>hasher key_eq() const</code>:<blockquote>returns a copy of
the <code>key_equal</code> function object used by the <code>unordered_map</code> object.</blockquote>
        <li><a name="an1621"></a><code>float load_factor() const</code>:<blockquote>returns the container's
current load factor, i.e. <code>size / bucket_count</code>.</blockquote>
        <li><a name="an1622"></a><code>size_t max_bucket_count()</code>:<blockquote>returns the maximum
number of buckets  this <code>unordered_map</code> may contain.</blockquote>
        <li><a name="an1623"></a><code>float max_load_factor() const</code>:<blockquote>identical to
<code>load_factor</code>.</blockquote>
        <li><a name="an1624"></a><code>void max_load_factor(float max)</code>:<blockquote>changes the
current maximum load factor to <code>max</code>. When a load factor of <code>max</code> is
reached, the container will enlarge its <code>bucket_count</code>, followed by a rehash
of its elements. Note that the container's default maximum load factor equals
1.0</blockquote>
        <li><a name="an1625"></a><code>size_t max_size()</code>:<blockquote>returns the maximum number of
elements this <code>unordered_map</code> may contain.</blockquote>
        <li><a name="an1626"></a><code>void rehash(size_t size)</code>:<blockquote>if <code>size</code> exceeds the current bucket count, then the bucket
count is increased to <code>size</code>, followed by a rehash of its elements.</blockquote>
        <li><a name="an1627"></a><code>void reserve(size_t request)</code>:<blockquote>if <code>request</code> is less than or equal to the current bucket count,
this call has no effect. Otherwise, the bucket count is increased to a value
of at least <code>request</code>, followed by a rehash of the container's elements.</blockquote>
        <li><a name="an1628"></a><code>size_t size()</code>:<blockquote>returns the number of elements in the unordered_map.</blockquote>
        <li><a name="an1629"></a><code>void swap(unordered_map &amp;other)</code>:<blockquote>swaps the contents of the current and the other
            <code>unordered_map</code>.</blockquote>
        </ul>
<p>
<a name="l244"></a>
<h4>12.4.12.3: The `unordered_multimap' container</h4>
        The <a name="an1630"></a><code>unordered_multimap</code> allows multiple objects using the same keys to be
stored in an unordered map. The <code>unordered_multimap</code> container offers the
same set of members and constructors as the <code>unordered_map</code>, but without the
unique-key restriction imposed upon the <code>unordered_map</code>.
<p>
The <code>unordered_multimap</code> does not offer <code>operator[]</code> and does not offer
the <code>at</code> members.
<p>
Below all members are described whose behavior differs from the behavior of
the corresponding <code>unordered_map</code> members:
<p>
<ul>
        <li><code>at</code>
            <blockquote>not supported by the <code>unordered_multimap</code> container</blockquote>
        <li><a name="an1631"></a><code>size_t count(key_type const &amp;key)</code>:<blockquote>returns the number of times a <code>value_type</code> object using
<code>key_type</code> <code>key</code> is stored in the <code>unordered_map</code>. This member is
commonly used to verify whether <code>key</code> is available in the
<code>unordered_multimap</code>.</blockquote>
        <li><a name="an1632"></a><code>iterator emplace(Args &amp;&amp;...args)</code>:<blockquote>a <code>value_type</code> object is constructed from <code>emplace</code>'s
arguments. The returned <code>iterator</code> points to the newly inserted inserted
<code>value_type</code>.</blockquote>
        <li><a name="an1633"></a><code>iterator emplace_hint(const_iterator position,
                            Args &amp;&amp;...args)</code>:<blockquote>a <code>value_type</code> object is constructed from the member's
arguments, and the newly created element is inserted into the
<code>unordered_multimap</code>. The
implementation may or may not use <code>position</code> as a <em>hint</em> to start looking
for an insertion point. The returned <code>iterator</code> points to the <code>value_type</code>
using the provided key.</blockquote>
    <li><a name="an1634"></a><code>pair&lt;iterator, iterator&gt; equal_range(key)</code>:<blockquote>this
member returns a pair of iterators  defining the range of elements having a
key that is equal to <code>key</code>.</blockquote>
    <li><a name="an1635"></a><code>terator find(key)</code>:<blockquote>returns an iterator to an element having the given key. If no
such element is available, <code>end</code> is returned.</blockquote>
        <li><a name="an1636"></a><code>... insert()</code>:
            <blockquote>elements may be inserted starting at a certain position. The
return value depends on the version of <code>insert()</code> that is called. When an
<code>iterator</code> is returned, then it points to the element that was inserted.</blockquote>
            <ul>
            <li><code>iterator insert(value_type const &amp;value)</code>
                inserts <code>value</code>.
            <li><code>iterator insert(value_type &amp;&amp;tmp)</code>
                inserts <code>value</code> using <code>value_type</code>'s move
                constructor.
            <li><code>iterator insert(const_iterator hint, value_type const &amp;value)</code>
                inserts <code>value</code>, possibly using <code>hint</code> as a
starting point when trying to insert <code>value</code>.
            <li><code>iterator insert(const_iterator hint, value_type &amp;&amp;tmp)</code>
                inserts <code>value</code> using <code>value_type</code>'s move
constructor, and possibly using <code>hint</code> as a starting point when trying to
insert <code>value</code>.
            <li><code>void insert(first, beyond)</code> inserts the elements in
the iterator range <code>[first, beyond)</code>.
            <li><code>void insert(initializer_list &lt;value_type&gt; iniList)</code>
                inserts the elements in <code>iniList</code> into the container.
            </ul>
        </ul>
<p>
<a name="l245"></a>
<h3>12.4.13: The `unordered_set' container</h3>
    The <em>set</em> container, like the <code>map</code> container, orders its elements. If
ordering is not an issue, but fast lookups are, then a hash-based set and/or
multi-set may be preferred. <strong>C++</strong> provides such hash-based sets and
multi-sets: the <a name="an1637"></a><code>unordered_set</code> and <code>unordered_multiset</code>.
<p>
Before using these hash-based set containers the header file
<a name="an1638"></a><code>&lt;unordered_set&gt;</code> must be included.
<p>
Elements stored in the <code>unordered_set</code> are immutable, but they can be
inserted and removed from the container. Different from the <code>unordered_map</code>,
the <code>unordered_set</code> does not use a <code>ValueType</code>. The set merely stores
elements, and the stored element itself is its own key.
<p>
The <code>unordered_set</code> has the same constructors as the <code>unordered_map</code>, but
the set's <code>value_type</code> is equal to its <code>key_type</code>.
<p>
When defining an <a name="an1639"></a><code>unordered_set</code> type four template arguments must be
specified :
    <ul>
    <li> a <a name="an1640"></a>KeyType (becoming <a name="an1641"></a><code>unordered_set::key_type</code>),
    <li> the type of an object computing a hash value from a key value
        (becoming <a name="an1642"></a><code>unordered_set::hasher</code>), and
    <li> the type of an object that can compare two keys for equality (becoming
        <a name="an1643"></a><code>unordered_set::key_equal</code>).
    <li> the type of its allocator. This is usually left unspecified, using
        the allocator provided by default by the implementor.
    </ul>
<p>
The generic definition of an <code>unordered_set</code> container looks like this:
        <pre>
    std::unordered_set &lt;KeyType, hash type, predicate type, allocator type&gt;
</pre>
    When <code>KeyType</code> is <code>std::string</code> or a built-in type then default types
are available for the hash type and the predicate type. In practice the
allocator type is not specified, as the default allocator suffices.  In these
cases an <code>unordered_set</code> object can be defined by merely specifying the key-
and value types, like this:
        <pre>
    std::unordered_set&lt;std::string&gt; rawSet(size_t size = implSize);
</pre>
    Here, <code>implSize</code> is the container's default initial size, which is
specified by the implementor. The set's size is automatically enlarged when
necessary, in which case the container <em>rehashes</em> all its elements. In
practice the default <code>size</code> argument provided by the implementor is
completely satisfactory.
<p>
The <code>unordered_set</code> supports the following constructors:
    <ul>
    <li> The copy and move constructors are available;
    <li><code>explicit unordered_set(size_type n = implSize,
             hasher const &amp;hf = hasher(),</code><br/>
             <code>key_equal const &amp;eql = key_equal(),</code><br/>
             <code>allocator_type const &amp;alloc = allocator_type())</code>:
        this constructor can also be used as default constructor;
    <li><code>unordered_set(const_iterator begin,
                    const_iterator end,
                    size_type n = implSize, hasher const &amp;hf = hasher(),
                    key_equal const &amp;eql = key_equal(),
                    allocator_type const &amp;alloc = allocator_type())</code>:
        this constructor expects two iterators specifying
a range of <code>unordered_set::value_type const</code> objects, and
    <li><code>unordered_set(initializer_list&lt;value_type&gt; initList,
                    size_type n = implSize, hasher const &amp;hf = hasher(),
                    key_equal const &amp;eql = key_equal(),
                    allocator_type const &amp;alloc = allocator_type())</code>:
            a constructor expecting an <code>initializer_list</code> of
            <code>unordered_set::value_type</code> values.
    </ul>
<p>
The <code>unordered_set</code> does not offer an index operator, and it does not offer
an <code>at</code> member. Other than those, it offers the same members as the
<code>unordered_map</code>. Below the members whose behavior differs from the behavior
of the <code>unordered_map</code> are discussed. For a description of the remaining
members, please refer to section <a href="cplusplus12.html#UMAPMEMBERS">12.4.12.2</a>.
<p>
<ul>
        <li><a name="an1644"></a><code>iterator emplace(Args &amp;&amp;...args)</code>:<blockquote>a <code>value_type</code> object is constructed from <code>emplace</code>'s
arguments. It is added to the set if it is unique, and an iterator to the
<code>value_type</code> is returned.</blockquote>
        <li><a name="an1645"></a><code>iterator emplace_hint(const_iterator position,
                            Args &amp;&amp;...args)</code>:<blockquote>a <code>value_type</code> object is constructed from the member's
arguments, and if the newly created element is unique it is inserted into the
<code>unordered_set</code>. The
implementation may or may not use <code>position</code> as a <em>hint</em> to start looking
for an insertion point. The returned <code>iterator</code> points to the
<code>value_type</code>.</blockquote>
        <li><a name="an1646"></a><code>unordered_set::iterator erase()</code>:<blockquote>erases a specific range of elements in the unordered_set:</blockquote>
            <ul>
            <li><code>erase(key_type const &amp;key)</code> erases <code>key</code> from the set. An
iterator pointing to the next element is returned.
            <li><code>erase(pos)</code> erases the element pointed to by the iterator
<code>pos</code>. The iterator <code>++pos</code> is returned.
            <li><code>erase(first, beyond)</code> erases elements indicated by the iterator
range <code>[first, beyond)</code>, returning <code>beyond</code>.
            </ul>
        </ul>
<p>
<a name="l246"></a>
<h4>12.4.13.1: The `unordered_multiset' container</h4>
        The <a name="an1647"></a><code>unordered_multiset</code> allows multiple objects using the same keys to be
stored in an unordered set. The <code>unordered_multiset</code> container offers the
same set of members and constructors as the <code>unordered_set</code>, but without the
unique-key restriction imposed upon the <code>unordered_set</code>.
<p>
Below all members are described whose behavior differs from the behavior of
the corresponding <code>unordered_set</code> members:
<p>
<ul>
        <li><a name="an1648"></a><code>size_t count(key_type const &amp;key)</code>:<blockquote>returns the number of times a <code>value_type</code> object using
<code>key_type</code> <code>key</code> is stored in the <code>unordered_set</code>. This member is
commonly used to verify whether <code>key</code> is available in the
<code>unordered_multiset</code>.</blockquote>
        <li><a name="an1649"></a><code>iterator emplace(Args &amp;&amp;...args)</code>:<blockquote>a <code>value_type</code> object is constructed from <code>emplace</code>'s
arguments. The returned <code>iterator</code> points to the newly inserted inserted
<code>value_type</code>.</blockquote>
        <li><a name="an1650"></a><code>iterator emplace_hint(const_iterator position,
                            Args &amp;&amp;...args)</code>:<blockquote>a <code>value_type</code> object is constructed from the member's
arguments, and the newly created element is inserted into the
<code>unordered_multiset</code>. The
implementation may or may not use <code>position</code> as a <em>hint</em> to start looking
for an insertion point. The returned <code>iterator</code> points to the <code>value_type</code>
using the provided key.</blockquote>
    <li><a name="an1651"></a><code>pair&lt;iterator, iterator&gt; equal_range(key)</code>:<blockquote>this
member returns a pair of iterators  defining the range of elements having a
key that is equal to <code>key</code>.</blockquote>
    <li><a name="an1652"></a><code>terator find(key)</code>:<blockquote>returns an iterator to an element having the given key. If no
such element is available, <code>end</code> is returned.</blockquote>
        <li><a name="an1653"></a><code>... insert()</code>:
            <blockquote>elements may be inserted starting at a certain position. The
return value depends on the version of <code>insert()</code> that is called. When an
<code>iterator</code> is returned, then it points to the element that was inserted.</blockquote>
            <ul>
            <li><code>iterator insert(value_type const &amp;value)</code>
                inserts <code>value</code>.
            <li><code>iterator insert(value_type &amp;&amp;tmp)</code>
                inserts <code>value</code> using <code>value_type</code>'s move
                constructor.
            <li><code>iterator insert(const_iterator hint, value_type const &amp;value)</code>
                inserts <code>value</code>, possibly using <code>hint</code> as a
starting point when trying to insert <code>value</code>.
            <li><code>iterator insert(const_iterator hint, value_type &amp;&amp;tmp)</code>
                inserts <code>value</code> using <code>value_type</code>'s move
constructor, and possibly using <code>hint</code> as a starting point when trying to
insert <code>value</code>.
            <li><code>void insert(first, beyond)</code> inserts the elements in
the iterator range <code>[first, beyond)</code>.
            <li><code>void insert(initializer_list &lt;value_type&gt; iniList)</code>
                inserts the elements in <code>iniList</code> into the container.
            </ul>
        </ul>
<p>
<a name="l247"></a>
<h3>12.4.14: C14: heterogeneous lookup</h3>
    The associative containers offered by <strong>C++</strong> allow us to find a value (or
values) matching a given key. Traditionally, the type of the key used for the
lookup must match the container's key type. 
<p>
The <a name="an1654"></a>C++14 standard allows an arbitrary lookup key type to be used, as long as
the comparison operator can compare that type with the container's key type.
Thus, a <code>char const *</code> key (or any other type for which an <code>operator&lt;</code>
overload for <code>std::string</code> is available) can be used to lookup values in a
<code>map&lt;std::string, ValueType&gt;</code>. This is called <a name="an1655"></a><em>heterogeneous lookup</em>.
<p>
Heterogeneous lookup is allowed when the comparator given to the associative
container does allow this. The standard library classes <code>std::less</code> and
<code>std::greater</code> were augmented to allow heterogeneous lookup.
<p>
<a name="COMPLEX"></a><a name="l248"></a>
<h2>12.5: The `complex' container</h2>
The <a name="an1656"></a><code>complex</code> container defines the standard operations that can be
performed on <a name="an1657"></a>complex numbers. Before using <code>complex</code> containers the
header file <a name="an1658"></a><code>&lt;complex&gt;</code> must be included.
<p>
The complex number's real and imaginary types are specified as the container's
data type. Examples:
        <pre>
    complex&lt;double&gt;
    complex&lt;int&gt;
    complex&lt;float&gt;
</pre>
    Note that the real and imaginary parts of complex numbers have the same
datatypes.
<p>
When initializing (or assigning) a complex object, the <a name="an1659"></a>imaginary part
may be omitted from the initialization or assignment resulting in its value
being 0 (zero). By default, both parts are zero.
<p>
Below it is silently assumed that the used <code>complex</code> type is
<code>complex&lt;double&gt;</code>. Given this assumption, complex numbers may be initialized
as follows:
    <ul>
    <li><code>target</code>:   A default initialization: real and imaginary parts are 0.
    <li><code>target(1)</code>: The <a name="an1660"></a>real part is 1, imaginary part is 0
    <li><code>target(0, 3.5)</code>: The real part is 0, imaginary part is 3.5
    <li><code>target(source)</code>: <code>target</code> is initialized with the values of
<code>source</code>.
    </ul>
    Anonymous complex values may also be used. In the next example two
anonymous complex values are pushed on a stack of complex numbers, to be
popped again thereafter:
        <pre>
    #include &lt;iostream&gt;
    #include &lt;complex&gt;
    #include &lt;stack&gt;

    using namespace std;

    int main()
    {
        stack&lt;complex&lt;double&gt;&gt;
            cstack;

        cstack.push(complex&lt;double&gt;(3.14, 2.71));
        cstack.push(complex&lt;double&gt;(-3.14, -2.71));

        while (cstack.size())
        {
            cout &lt;&lt; cstack.top().real() &lt;&lt; ", " &lt;&lt;
                    cstack.top().imag() &lt;&lt; "i" &lt;&lt; '\n';
            cstack.pop();
        }
    }
    /*
        Generated output:
    -3.14, -2.71i
    3.14, 2.71i
    */
</pre>
<p>
The following member functions and operators are defined for complex
numbers (below, <code>value</code> may be either a primitve <a name="an1661"></a>scalar type or a
<code>complex</code> object):
    <ul>
        <li> Apart from the standard container operators, the following
operators are supported from the <code>complex</code> container.
        <ul>
        <li><a name="an1662"></a><code>complex operator+(value)</code>:<blockquote> this
member returns the sum of the current <code>complex</code> container and <code>value</code>.</blockquote>
        <li><a name="an1663"></a><code>complex operator-(value)</code>:<blockquote> this
member returns the difference between the current <code>complex</code> container and
<code>value</code>.</blockquote>
        <li><a name="an1664"></a><code>complex operator*(value)</code>:<blockquote> this
member returns the product of the current <code>complex</code> container and
<code>value</code>.</blockquote>
        <li><a name="an1665"></a><code>complex operator/(value)</code>:<blockquote> this
member returns the quotient of the current <code>complex</code> container and
<code>value</code>.</blockquote>
        <li><a name="an1666"></a><code>complex operator+=(value)</code>:<blockquote> this
member adds <code>value</code> to the current <code>complex</code> container, returning the
new value.</blockquote>
        <li><a name="an1667"></a><code>complex operator-=(value)</code>:<blockquote>
this member subtracts <code>value</code> from the current <code>complex</code> container,
returning the new value.</blockquote>
        <li><a name="an1668"></a><code>complex operator*=(value)</code>:<blockquote> this
member multiplies the current <code>complex</code> container by <code>value</code>, returning
the new value</blockquote>
        <li><a name="an1669"></a><code>complex operator/=(value)</code>:<blockquote> this
member divides the current <code>complex</code> container by <code>value</code>, returning the
new value.</blockquote>
        </ul>
        <li><a name="an1670"></a><code>Type real()</code>:<blockquote>returns the <a name="an1671"></a>real part of a
complex number.</blockquote>
        <li><a name="an1672"></a><code>Type imag()</code>:<blockquote>returns the <a name="an1673"></a>imaginary part
of a complex number.</blockquote>
        <li> Several <a name="an1674"></a>mathematical functions are available for the
<code>complex</code> container, such as <a name="an1675"></a><code>abs</code>, <a name="an1676"></a><code>arg</code>, <a name="an1677"></a><code>conj</code>, <a name="an1678"></a><code>cos</code>,
<a name="an1679"></a><code>cosh</code>, <a name="an1680"></a><code>exp</code>, <a name="an1681"></a><code>log</code>, <a name="an1682"></a><code>norm</code>, <a name="an1683"></a><code>polar</code>, <a name="an1684"></a><code>pow</code>,
<a name="an1685"></a><code>sin</code>, <a name="an1686"></a><code>sinh</code> and <a name="an1687"></a><code>sqrt</code>. All these functions are free functions,
not member functions, accepting complex numbers as their arguments. For
example,
    <pre>
abs(complex&lt;double&gt;(3, -5));
pow(target, complex&lt;int&gt;(2, 3));
</pre>
        <li> Complex numbers may be <a name="an1688"></a> extracted from <code>istream</code>
objects and inserted <a name="an1689"></a> into <code>ostream</code> objects. The insertion
results in an <a name="an1690"></a>ordered pair <code>(x, y)</code>, in which <code>x</code> represents the real
part and <code>y</code> the imaginary part of the complex number. The same form may
also be used when extracting a complex number from an <code>istream</code>
object. However, simpler forms are also allowed. E.g., when extracting
<code>1.2345</code> the imaginary part is set to 0.
    </ul>
<p>
<a name="UNIONS"></a><a name="l249"></a>
<h2>12.6: Unrestricted Unions</h2>
We end this chapter about abstract containers with a small detour, introducing
extensions to the <code>union</code> concept. Although unions themselves aren't
`abstract containers', having covered containers puts us in a good position
to introduce and illustrate
    <a name="an1691"></a><em>unrestricted unions</em>.
<p>
Whereas traditional unions can only contain primitive data, unrestricted
unions allow addition of data fields of types for which non-trivial
constructors have been defined. Such data fields commonly are of
class-types. Here is an example of such an unrestricted union:
        <pre>
    union Union
    {
        int u_int;
        std::string u_string;
    };
</pre>
    One of its fields defines a constructor, turning this union into an
<em>unrestricted</em> union.  As an unrestricted union defines at least one field
of a type having a constructor the question becomes how these unions can be
constructed and destroyed.
<p>
The destructor of a union consisting of, e.g. a <code>std::string</code> and an
<code>int</code> should of course not call the <code>string</code>'s destructor if the
union's last (or only) use referred to its <code>int</code> field. Likewise, when
the <code>std::string</code> field is used, and a switch is made next from the
<code>std::string</code> to the <code>int</code> field, <code>std::string</code>'s destructor
should be called before any assignment to the <code>double</code> field takes place.
<p>
The compiler does not solve the issue for us, and in fact does <em>not</em>
implement default constructors or destructors for unrestricted unions at
all. If we try to define an unrestricted union like the one shown above, an
error message like the following is issued:
        <pre>
    error: use of deleted function 'Union::Union()'
    error: 'Union::Union()' is implicitly deleted because the default
            definition would be ill-formed:
    error: union member 'Union::u_string' with non-trivial
            'std::basic_string&lt;...&gt;::basic_string() ...'
</pre>
<p>
<a name="l250"></a>
<h3>12.6.1: Implementing the destructor</h3>
    Although the compiler won't provide (default) implementations for constructors
and destructors of unrestricted unions, <em>we</em> can. The task isn't difficult,
but there are some caveats.
<p>
Consider our unrestricted union's destructor. It clearly should destroy
<code>u_string</code>'s data if that is its currently active field; but it should do
nothing if <code>u_int</code> is its currently active field. But how does the
destructor know what field to destroy? It doesn't as the unrestricted union
holds no information about what field is currently active.
<p>
Here is one way to tackle this problem:
<p>
If we embed the unrestricted union in a larger aggregate, like a class or a
struct, then the class or struct can be provided with a <a name="an1692"></a><em>tag</em> data member
storing the currently active union-field. The tag can be an enumeration type,
defined by the aggregate. The unrestricted union may then be controlled by the
aggregate. Under this approach we start out with an explicit empty
implementations of the destructor, as there's no way to tell the destructor
itself what field to destroy:
        <pre>
    Data::Union::~Union()
    {};
</pre>
<p>
<a name="l251"></a>
<h3>12.6.2: Embedding an unrestricted union in a surrounding class</h3>
    Next, we embed the unrestricted union in a surrounding aggregate: <code>class
Data</code>. The aggregate is provided with an <code>enum Tag</code>, declared in its public
section, so <code>Data</code>'s users may request tags. <code>Union</code> itself is for
<code>Data</code>'s internal use only, so <code>Union</code> is declared in <code>Data</code>'s private
section. Using a <code>struct Data</code> rather than <code>class Data</code> we start out
in a public section, saving us from having to specify the initial <code>public:</code>
section for <code>enum Tag</code>:
        <pre>
    struct Data
    {
        enum Tag
        {
            INT,
            STRING
        };

        private:
            union Union
            {
                int         u_int;
                std::string u_string;

                ~Union();           // no actions
                // ... to do: declarations of members
            };

            Tag d_tag;
            Union d_union;
    };
</pre>
<p>
<code>Data</code>'s constructors receive <code>int</code> or <code>string</code> values. To pass these
values on to <code>d_union</code>, we need <code>Union</code> constructors for the various union
fields; matching <code>Data</code> constructors also initialize <code>d_tag</code> to proper
values:
        <pre>
    Data::Union::Union(int value)
    :
        u_int(value)
    {}
    Data::Union::Union(std::string const &amp;str)
    :
        u_string(str)
    {}

    Data::Data(std::string const &amp;str)
    :
        d_tag(STRING),
        d_union(str)
    {}
    Data::Data(int value)
    :
        d_tag(INT),
        d_union(value)
    {}
</pre>
<p>
<a name="l252"></a>
<h3>12.6.3: Destroying an embedded unrestricted union</h3>
    <code>Data</code>'s destructor has a data member which is an unrestricted union. As the
union's destructor can't perform any actions, the union's proper destruction
is delegated to a member, <code>Union::destroy</code> destroying the fields for which
destructors are defined. As <code>d_tag</code> stores the currently used <code>Union</code>
field, <code>Data</code>'s destructor can pass <code>d_tag</code> to <code>Union::destroy</code> to
inform it about which field should be destroyed.
<p>
<code>Union::destroy</code> does not need to perform any action for <code>INT</code> tags, but
for <code>STRING</code> tags the memory allocated by <code>u_string</code> must be returned. For
this an explicit destructor call is used. <code>Union::destroy</code> and
<code>Data</code>'s destructor are therefore implemented like this:
        <pre>
    void Data::Union::destroy(Tag myTag)
    {
        if (myTag == Tag::STRING)
            u_string.~string();
    }

    Data::~Data()
    {
        d_union.destroy(d_tag);
    }
</pre>
<p>
<a name="l253"></a>
<h3>12.6.4: Copy and move constructors</h3>
    <code>Union</code>'s copy and move constructors suffer from the same problem as
<code>Union</code>'s destructor does: the union does not know which is its currently
active field. But again: <code>Data</code> does, and by defining `extended' copy and
move constructors, also receiving a <code>Tag</code> argument, these extended
constructors can perform their proper initializations. The <code>Union</code>'s copy-
and move-constructors are deleted, and extended copy- and move constructors
are declared:
        <pre>
    Union(Union const &amp;other) = delete;
    Union &amp;operator=(Union const &amp;other) = delete;

    Union(Union const &amp;other, Tag tag);
    Union(Union &amp;&amp;tmp, Tag tag);
</pre>
<p>
Shortly we'll encounter a situation where we must be able to initialize a
block of memory using an existing <code>Union</code> object. This task can be performed
by <code>copy</code> members, whose implementations are trivial, and which may be used
by the above constructors. They can be declared in <code>Union</code>'s private
section, and have identical parameter lists as the above constructors:
        <pre>
    void copy(Union const &amp;other, Tag tag);
    void copy(Union &amp;&amp;other, Tag tag);
</pre>
<p>
The constructors merely have to call these <code>copy</code> members:
        <pre>
    inline Data::Union::Union(Union const &amp;other, Tag tag)
    {
        copy(other, tag);
    }

    inline Data::Union::Union(Union &amp;&amp;tmp, Tag tag)
    {
        copy(std::move(tmp), tag);
    }
</pre>
<p>
Interestingly, no `initialization followed by assignment' happens here:
<code>d_union</code> has not been initialized in any way by the the time we reach the
statement blocks of the above constructors. But upon reaching the statement
blocks, <code>d_union</code> memory is merely raw memory. This is no problem, as the
<code>copy</code> members use placement new to initialize the <code>Union</code>'s memory:
        <pre>
    void Data::Union::copy(Union const &amp;other, Tag otag)
    {
        if (tag == INT)
            u_int = other.u_int;
        else
            new (this) string(other.u_string);
    }

    void Data::Union::copy(Union &amp;&amp;tmp, Tag tag)
    {
        if (tag == INT)
            u_int = tmp.u_int;
        else
            new (this) string(std::move(tmp.u_string));
    }
</pre>
<p>
<a name="l254"></a>
<h3>12.6.5: Assignment</h3>
    To assign a <code>Data</code> object to another data object, we need an assignment
operator. The standard mold for the assignment operator looks like this:
        <pre>
    Class &amp;Class::operator=(Class const &amp;other)
    {
        Class tmp(other);
        swap(*this, tmp);
        return *this;
    }
</pre>
    This implementation is exception safe: it offers the `commit or roll-back'
guarantee (cf. section <a href="cplusplus09.html#CopyDestroy">9.6</a>). But can it be applied to <code>Data</code>?
<p>
It depends. It depends on whether <code>Data</code> objects can be <em>fast swapped</em>
(cf. section <a href="cplusplus09.html#FSWAP">9.6.1.1</a>) or not. If <code>Union</code>'s fields can be fast swapped
then we can simply swap bytes and we're done. In that case <code>Union</code> does not
require any additional members (to be specific: it won't need an assignment
operator).
<p>
But now assume that <code>Union</code>'s fields cannot be fast swapped. How to
implement an exception-safe assignment (i.e., an assignment offering the
`commit or roll-back' guarantee) in that case? The <code>d_tag</code> field clearly
isn't a problem, so we delegate the responsibility for proper assignment to
<code>Union</code>, implementing <code>Data</code>'s assignment operators as follows:
        <pre>
    Data &amp;Data::operator=(Data const &amp;rhs)
    {
        if (d_union.assign(d_tag, rhs.d_union, rhs.d_tag))
            d_tag = rhs.d_tag;
        return *this;
    }

    Data &amp;Data::operator=(Data &amp;&amp;tmp)
    {
        if (d_union.assign(d_tag, std::move(tmp.d_union), tmp.d_tag))
            d_tag = tmp.d_tag;
        return *this;
    }
</pre>
<p>
But now for <code>Union::assign</code>. Assuming that both <code>Unions</code> use different
fields, but swapping objects of the separate types is allowed.  Now things
may go wrong. Assume the left-side union uses type X, the right-side
union uses type Y and both types use allocation. First, briefly look at
standard swapping. It involves three steps:
    <ul>
    <li> <code>tmp(lhs)</code>: initialize a temporary objecct;
    <li> <code>lhs = rhs</code>: assign the rhs object to the lhs object;
    <li> <code>rhs = tmp</code>: assign the tmp object to the rhs
    </ul>
    Usually we assume that these steps do not throw exceptions, as <code>swap</code>
itself shouldn't throw exceptions. How could we implement
swapping for our union? Assume the fields are known (easily done by passing
<code>Tag</code> values to <code>Union::swap</code>):
    <ul>
    <li> <code>X tmp(lhs.x)</code>: initialize a temporary X;
    <li> in-place destroy lhs.x; placement new initialize lhs.y from rhs.y
        (alternatively: placement new default initialize lhs.y, then do the
        standard lhs.y = rhs.y)
    <li> in-place destroy rhs.y; placement new initialize rhs.x from tmp
(alternatively: placement new default initialize rhs.x, then do the standard
rhs.x = tmp)
    </ul>
<p>
By <strong>C++</strong>-standard requirement, the in-place destruction won't throw. Since
the standard swap also performs an assignment that part should work fine as
well. And since the standard swap also does a copy construction the placement
new operations should perform fine as well, and if so, <code>Union</code> may be
provided with the following <code>swap</code> member:
        <pre>
    void Data::Union::swap(Tag myTag, Union &amp;other, Tag oTag)
    {
        Union tmp(*this, myTag);    // save lhs

        destroy(myTag);             // destroy lhs
        copy(other, oTag);          // assign rhs

        other.destroy(oTag);        // destroy rhs
        other.copy(tmp, myTag);     // save lhs via tmp
    }
</pre>
<p>
Now that <code>swap</code> is available <code>Data</code>'s assignment operators are easily
realized:
        <pre>
    Data &amp;Data::operator=(Data const &amp;rhs)
    {
        Data tmp(rhs);  // tmp(std::move(rhs)) for the move assignment

        d_union.swap(d_tag, tmp.d_union, tmp.d_tag);
        swap(d_tag, tmp.d_tag);

        return *this;
    }
</pre>
<p>
What if the <code>Union</code> constructors <em>could</em> throw? In that case we can
provide <code>Data</code> with an 'commit or roll-back' assignment operator like this:
        <pre>
    Data &amp;Data::operator=(Data const &amp;rhs)
    {
        Data tmp(rhs);
                            // rolls back before throwing an exception
        d_union.assign(d_tag, rhs.d_union, rhs.d_tag);
        d_tag = rhs.d_tag;

        return *this;
    }
</pre>
<p>
How to implement <code>Union::assign</code>? Here are the steps <code>assign</code> must take:
    <ul>
    <li> First save the current union in a block of memory. This merely
involves a non-throwing <code>memcpy</code> operation;
    <li> Then use placement new to copy the other object's union field into
the current object. If this throws:
        <ul>
        <li> catch the exception, restore the original <code>Union</code> from the
saved block and rethrow the exception: we have rolled-back to our previous
(valid) state.
        </ul>
    <li> We still have to delete the original field's allocated data. To do
so, we perform the following steps:
        <ul>
        <li> (Fast) swap the current union's new contents with the contents in
the previously saved block;
        <li> Call <code>destroy</code> for the now restored original union;
        <li> Re-install the new union from the memory block.
        </ul>
        As none of the above steps will throw, we have committed the new
situation.
    </ul>
    Here is the implementation of the `commit or roll-back' <code>Union::assign</code>:
        <pre>
    void Data::Union::assign(Tag myTag, Union const &amp;other, Tag otag)
    {
        char saved[sizeof(Union)];
        memcpy(saved, this, sizeof(Union));     // raw copy: saved &lt;- *this
        try
        {
            copy(other, otag);                  // *this = other: may throw
            fswap(*this,                        // *this &lt;-&gt; saved
                    *reinterpret_cast&lt;Union *&gt;(saved));
            destroy(myTag);                     // destroy original *this
            memcpy(this, saved, sizeof(Union)); // install new *this
        }
        catch (...)                             // copy threw
        {
            memcpy(this, saved, sizeof(Union)); // roll back: restore *this
            throw;
        }
    }
</pre>
    The source distribution contains
<code>yo/containers/examples/unrestricted2.cc</code> offering a small demo-program in
which the here developed <code>Data</code> class is used.
<p>

<hr>
<ul>
    <li> <a href="cplusplus.html">Table of Contents</a>
    <li> <a href="cplusplus11.html">Previous Chapter</a>
    <li> <a href="cplusplus13.html">Next Chapter</a>
</ul>
<hr>
</body>
</html>
