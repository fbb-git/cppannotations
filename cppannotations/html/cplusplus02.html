<!DOCTYPE html><html><head>
<meta charset="UTF-8">
<title> C++ Annotations Version 10.8.0 </title>
<link rel="stylesheet" type="text/css" href="cplusplus.css"><style type="text/css">
    figure {text-align: center;}
    img {vertical-align: center;}
</style>
<link rel="stylesheet" type="text/css" href="cplusplus.css"></head>
<body >
<hr>
<ul>
    <li> <a href="cplusplus.html">Table of Contents</a>
    <li> <a href="cplusplus01.html">Previous Chapter</a>
    <li> <a href="cplusplus03.html">Next Chapter</a>
</ul>
<hr>
<a name="IntroC"></a><a name="l2"></a>
<h1 >Chapter 2: Introduction</h1>
This document offers an introduction to the <strong >C++</strong> programming language. It
is a guide for <strong >C/C++</strong> programming courses, yearly presented by Frank at the
University of Groningen. This document is not a complete <strong >C/C++</strong> handbook,
as much of the <strong >C</strong>-background of <strong >C++</strong> is not covered. Other sources
should be referred to for that (e.g., the Dutch book <em >De programmeertaal C</em>,
Brokken and Kubat, University of Groningen, 1996) or the
<a name="an3"></a>
 <a target=_top href="http://publications.gbdirect.co.uk/c_book/">on-line book</a> suggested to
me by George Danchev (danchev at spnet dot net).
<p>
The reader should be forewarned that extensive knowledge of the <strong >C</strong>
programming language is actually assumed. The <strong >C++</strong> Annotations continue where
topics of the <strong >C</strong> programming language end, such as pointers, basic flow
control and the construction of functions.
<p>
Some elements of the language, like specific lexical tokens (like
<a name="an4"></a><em >digraphs</em> (e.g., <code >&lt;:</code> for <code >[</code>, and <code >&gt;:</code> for <code >]</code>)) are not covered
by the <strong >C++</strong> Annotations, as these tokens occur extremely seldom in <strong >C++</strong> source
code. In addition, <a name="an5"></a><em >trigraphs</em> (using <code >??&lt;</code> for <code >{</code>, and <code >??&gt;</code> for
<code >}</code>) were removed from <strong >C++</strong> in the <a name="an6"></a>C++17 standard.
<p>
The version number of the <strong >C++</strong> Annotations (currently 10.8.0) is updated when
the contents of the document change. The first number is the major number, and
is probably not going to change for some time: it indicates a major
rewriting. The middle number is increased when new information is added to the
document. The last number only indicates small changes; it is increased when,
e.g., series of typos are corrected.
<p>
This document is published by the Center of Information Technology,
University of Groningen,
the Netherlands under the <a name="an7"></a>
 <a target=_top href="http://www.gnu.org/licenses/">GNU General Public License</a>.
<p>
The <strong >C++ Annotations</strong> were typeset using the <a name="an8"></a>
    <a name="an9"></a>
    <a target=_top href="https://fbb-git.github.io/yodl/">yodl</a>
formatting system.
<p>
<blockquote >
    <strong >
        All correspondence concerning suggestions, additions, improvements or
        changes to this document should be directed to the author:
    </strong>
<p>
<strong >
        <div style="text-align: center">Frank B. Brokken <br/>
        Center of Information Technology,<br/>
        University of Groningen <br/>Nettelbosje 1,<br/>P.O. Box 11044,<br/>9700 CA Groningen <br/>The Netherlands <br/>
        (email: f.b.brokken@rug.nl)
        </div>
   </strong>
</blockquote>
<p>
In this chapter an overview of <strong >C++</strong>'s defining features is presented. A few
extensions to <strong >C</strong> are reviewed and the concepts of object based and object
oriented programming (OOP) are briefly introduced.
<p>
<a name="WHATSNEW"></a><a name="l3"></a>
<h2 >2.1: What's new in the C++ Annotations</h2>
    This section is modified when the first or second part of the version number
changes (and occasionally also for the third field of the version number). At
a major version upgrade the entries of the previous major version are kept,
and entries referring to older releases are removed.
    <ul>

    <li> Version 10.8.0 contains a new section (<a href="cplusplus02.html#CXVII">2.5.14</a>) providing an
        overview of new language features introduced by the C++17 standard,
        and many typos and suboptimally formulated statements were fixed.
        Also, coverage of (obsolete) binders, negators and <code >random_shuffle</code>,
        removed by the C++17 standard, was discontinued. 
    <li> Version 10.7.2 contains a complete rewrite and re-implementation of
        section <a href="cplusplus11.html#OVERLOADBINARY">11.6</a> covering overloading/adding binary
        operators in classes.
    <li> Version 10.7.0 adds various sections about the upcoming new C++17
        standard (cf. section <a href="cplusplus02.html#CXVII">2.5.14</a>). In addition, the sections about
        overloading binary operators and adding binary operators to existing
        classes were rewritten.
    <li> Version 10.6.0 adds a section (Lvalues, rvalues and more) introducing
        some new terms in addition to the familiar terms `lvalue and rvalue';
        adds a new section (Standard Exceptions: to use or not to use?) about
        the distinction between standard and non-standard exceptions;
        describes how to initialize an array of allocated values/POD objects
        using <code >new Type[size]()</code>; the section about explicit conversion
        operators received an overhaul.
    <li> Version 10.5.0 contains a partial rewrite of facilities for
        specifying time. It includes functions <code >std::localtime,
        std::gmtime,</code> and <code >std::put_time</code> (section <a href="cplusplus20.html#TIME">20.1.5</a>), as well as
        the full table of format specifiers that are recognized by
        <code >put_time</code>.
    <li> Version 10.4.0 adds the previously missing section about reference
        bindings (section <a href="cplusplus11.html#REFBIND">11.6.1</a>). This section is a subsection of
        section <a href="cplusplus11.html#OVERLOADBINARY">11.6</a>, covering overloading binary operators,
        and this latter section, as well as the section covering static
        polymorphism (section <a href="cplusplus22.html#STATICPOLY">22.12</a>) was completely 
        rewritten. In addition, the appearance of the html-version of the
        <strong >C++</strong> Annotations can now to some extent be fine-tuned by adding CSS
        elements in the top-level file <code >cplusplus.css</code>.
    <li> Version 10.3.0 contains new sections about expression templates,
        about at tributes, about shared mutexes, about shared locks, about
        heterogeneous lookups, about sized deallocation functions, and about
        moving and swapping streams; reorganizes the section about lambda
        expressions; and adds additional references to the C++14 standard.
    <li> Version 10.2.0 contains a rewrite of the stl's regular expression
        classes, introduces the <code >std::placeholders</code> namespace and 
        covers the generic <code >bind</code>-binder. Since C++11 by now is <em >de facto</em>
        the current <strong >C++</strong> standard explicit references to it have been
        removed. References to C++14 were kept, and some notes about the
        upcoming C++17 standard were added.
    <li> Version 10.1.0 adds several sections about C++11 regular expression
        handling, supported since the C++11 standard, but which was overlooked
        when 10.0.0 was published. Coverage of regular expression handling was
        moved from the Containers chapter to the chapter covering the Standard
        Template Library.
    <li> Version 10.0.0 adds a new chapter about multi threading, which is
        formally supported since the C++11 standard. In addition some minor
        topics (e.g., <code >std::distance</code>, some new syntax elements) were added
        to the <strong >C++</strong> Annotations.
    </ul>
<p>
<a name="l4"></a>
<h2 >2.2: C++'s history</h2>
    The first implementation of <strong >C++</strong> was developed in the 1980s at
the AT&amp;T Bell Labs, where the Unix operating system was created.
<p>
<strong >C++</strong> was originally a `pre-compiler', similar to the preprocessor of <strong >C</strong>,
converting special constructions in its source code to plain <strong >C</strong>. Back then
this code was compiled by a standard <strong >C</strong> compiler. The `pre-code', which was
read by the <strong >C++</strong> pre-compiler, was usually located in a file with the
extension <code >.cc</code>, <code >.C</code> or <code >.cpp</code>. This file would then be converted to a
<strong >C</strong> source file with the extension <code >.c</code>, which was thereupon compiled and
linked.
<p>
The nomenclature of <strong >C++</strong> source files remains: the extensions <code >.cc</code> and
<code >.cpp</code> are still used. However, the preliminary work of a <strong >C++</strong>
pre-compiler is nowadays usually performed during the actual compilation
process. Often compilers determine the language used in a source file from its
extension. This holds true for Borland's and Microsoft's <strong >C++</strong> compilers,
which assume a <strong >C++</strong> source for an extension <code >.cpp</code>. The <a name="an10"></a>Gnu
<a name="an11"></a>compiler <a name="an12"></a><code >g++</code>, which is available on many Unix platforms, assumes for
<strong >C++</strong> the extension <code >.cc</code>.
<p>
The fact that <strong >C++</strong> used to be compiled into <strong >C</strong> code is also visible
from the fact that <strong >C++</strong> is a superset of <strong >C</strong>: <strong >C++</strong> offers the full
<strong >C</strong> grammar and supports all <strong >C</strong>-library functions, and adds to this
features of its own. This makes the transition from <strong >C</strong> to
<strong >C++</strong> quite easy. Programmers familiar with <strong >C</strong> may start
`programming in <strong >C++</strong>' by using source files having extensions <code >.cc</code> or
<code >.cpp</code> instead of <code >.c</code>, and may then comfortably slip into all the
possibilities offered by <strong >C++</strong>. No abrupt change of habits is required.
<p>
<a name="l5"></a>
<h3 >2.2.1: History of the C++ Annotations</h3>
        The original version of the <strong >C++</strong> Annotations was written by Frank Brokken
and Karel Kubat in Dutch using <code >LaTeX</code>. After some time, Karel rewrote the
text and converted the guide to a more suitable format and (of course) to
English in september 1994.
<p>
The first version of the guide appeared on the net in october 1994. By then it
was converted to <code >SGML</code>.
<p>
Gradually new chapters were added, and the contents were modified and further
improved (thanks to countless readers who sent us their comment).
<p>
In major version four Frank added new chapters and converted the document from
SGML to <a target=_top href="https://fbb-git.github.io/yodl/">yodl</a>.
    <blockquote >
    The <strong >C++</strong> Annotations are freely distributable. Be sure to read
    the <a href="legal.shtml">legal notes</a>.
<p>
<strong >Reading the annotations beyond this point implies that you are aware of
    these notes and that you agree with them.</strong>
    </blockquote>
    If you like this document, tell your friends about it. Even better, let us
know by sending email to <a href="f.b.brokken@rug.nl)">Frank</a>.
<p>
<a name="CppComp"></a><a name="l6"></a>
<h3 >2.2.2: Compiling a C program using a C++ compiler</h3>
        Prospective <strong >C++</strong> programmers should realize that <strong >C++</strong> is not a perfect
superset of <strong >C</strong>. There are some differences you might encounter when you
simply rename a file to a file having the extension <code >.cc</code> and run it through
a <strong >C++</strong> compiler:
    <ul>
    <li> In <strong >C</strong>, <a name="an13"></a><code >sizeof</code><code >('c')</code> equals <code >sizeof(int)</code>, <code >'c'</code> being
any ASCII character.  The underlying philosophy is probably that <code >char</code>s,
when passed as arguments to functions, are passed as integers
anyway. Furthermore, the <strong >C</strong> compiler handles a character constant like
<code >'c'</code> as an integer constant. Hence, in <strong >C</strong>, the function calls
        <pre>
    putchar(10);
</pre>
    and
        <pre>
    putchar('\n');
</pre>
    are synonymous.
<p>
By contrast, in <strong >C++</strong>, <code >sizeof('c')</code> is always 1 (but see also section
<a href="cplusplus03.html#WCHAR">3.4.2</a>). An <code >int</code> is still an <code >int</code>, though. As we shall see later
(section <a href="cplusplus02.html#FunctionOverloading">2.5.4</a>), the two function calls
        <pre>
    somefunc(10);
</pre>
    and
        <pre>
    somefunc('\n');
</pre>
    may be handled by different functions: <strong >C++</strong> distinguishes functions not
only by their names, but also by their argument types, which are different in
these two calls. The former using an <code >int</code> argument, the latter a <code >char</code>.
    <li> <strong >C++</strong> requires very strict <a name="an14"></a>prototyping of external
functions. E.g., in <strong >C</strong> a prototype like
        <pre>
    void func();
</pre>
    means that a function <code >func()</code> exists, returning no value. The
declaration doesn't specify which arguments (if any) are accepted by the
function.
<p>
However, in <strong >C++</strong> the above declaration means that the function <code >func()</code>
does <em >not</em> accept any arguments at all. Any arguments passed to it
result in a compile-time error.
<p>
Note that the keyword <a name="an15"></a><code >extern</code> is not required when declaring functions. A
function definition becomes a function declaration simply by replacing a
function's body by a semicolon. The keyword <code >extern</code> <em >is</em> required,
though, when declaring variables.
    </ul>
<p>
<a name="COMPILATION"></a><a name="l7"></a>
<h3 >2.2.3: Compiling a C++ program</h3>
        To compile a <strong >C++</strong> program, a <strong >C++</strong> <a name="an16"></a>compiler is required. Considering
the free nature of this document, it won't come as a surprise that a
 <a name="an17"></a><em >free compiler</em> is suggested here. The
 <a name="an18"></a>Free Software Foundation (<a name="an19"></a>FSF) provides at <a name="an20"></a>
 <a target=_top href="http://www.gnu.org">http://www.gnu.org</a> a free <strong >C++</strong>
compiler which is, among other places, also part of the <a name="an21"></a>Debian
 <a name="an22"></a>
 (<a target=_top href="http://www.debian.org">http://www.debian.org</a>) distribution of <a name="an23"></a>Linux
 (<a name="an24"></a> <a target=_top href="http://www.linux.org">http://www.linux.org</a>).
<p>
To use the features of the C++14 standard the <a name="an25"></a>compiler flag <a name="an26"></a><code >--std=c++14</code>
must currently be provided. In the <strong >C++</strong> Annotations it is assumed that this flag
is used when compiling the examples. To use the <a name="an27"></a>C++17 standard Gnu's
<a name="an28"></a><code >g++-6</code> compiler can be used. To activate the C++17 standard specify the
flag <a name="an29"></a><code >--std=c++1z</code>.
<p>
<a name="l8"></a>
<h4>2.2.3.1: C++ under MS-Windows</h4>
            For <a name="an30"></a>MS-Windows <a name="an31"></a>Cygnus <a name="an32"></a>
(<a target=_top href="http://sources.redhat.com/cygwin">http://sources.redhat.com/cygwin</a>) provides the foundation
for installing the <em >Windows port</em> of the <a name="an33"></a>Gnu <a name="an34"></a><code >g++</code> <a name="an35"></a>compiler.
<p>
When visiting the above URL to obtain a <a name="an36"></a> free <code >g++</code>
compiler, click on <code >install now</code>. This will download the file <a name="an37"></a><code >setup.exe</code>,
which can be run to install <code >cygwin</code>. The software to be installed can be
downloaded by <code >setup.exe</code> from the internet. There are alternatives (e.g.,
using a CD-ROM), which are described on the <a name="an38"></a>Cygwin page. Installation
proceeds interactively. The offered defaults are sensible and should be
accepted unless you have reasons to divert.
<p>
The most recent Gnu <code >g++</code> compiler can be obtained from
    <a name="an39"></a> <a target=_top href="http://gcc.gnu.org">http://gcc.gnu.org</a>. If the compiler that is
made available in the Cygnus distribution lags behind the latest version, the
sources of the latest version can be downloaded after which the compiler can
be built using an already available compiler. The compiler's webpage
(mentioned above) contains detailed instructions on how to proceed. In our
experience building a new compiler within the Cygnus environment works
flawlessly.
<p>
<a name="COMPSRC"></a><a name="l9"></a>
<h4>2.2.3.2: Compiling a C++ source text</h4>
            Generally the following command can be used to compile a <strong >C++</strong> source file
`<code >source.cc</code>':
        <pre>
        g++ source.cc
</pre>
    This produces a binary program (<code >a.out</code> or <code >a.exe</code>). If the default
name is inappropriate, the name of the executable can be specified using the
<code >-o</code> flag (here producing the program <code >source</code>):
        <pre>
        g++ -o source source.cc
</pre>
<p>
If a mere compilation is required, the compiled module can be produced using
the <code >-c</code> flag:
        <pre>
        g++ -c source.cc
</pre>
    This generates the file <code >source.o</code>, which can later on be linked to
other modules. As pointed out, provide the <a name="an40"></a>compiler option <a name="an41"></a>--std=c++14
to activate the features of the C++14 standard.
<p>
<strong >C++</strong> programs quickly become too complex to maintain `by hand'. With all
serious programming projects program maintenance tools are used. Usually the
standard <a name="an42"></a><code >make</code> program is used to maintain <strong >C++</strong> programs, but good
alternatives exist, like  the <a name="an43"></a>
        <a target=_top href="https://fbb-git.github.io/icmake/">icmake</a>
    or <a name="an44"></a> <a target=_top href="https://github.com/bneijt/ccbuild/">ccbuild</a> program
maintenance utilities.
<p>
It is strongly advised to start using maintenance utilities early in the study
of <strong >C++</strong>.
<p>
<a name="Pretensions"></a><a name="l10"></a>
<h2 >2.3: C++: advantages and claims</h2>
    Often it is said that programming in <strong >C++</strong> leads to `better' programs. Some
of the claimed advantages of <strong >C++</strong> are:
    <ul>
    <li> New programs would be developed in less time because old code can be
reused.
    <li> Creating and using new data types would be easier than in <strong >C</strong>.
    <li> The memory management under <strong >C++</strong> would be easier and more
transparent.
    <li> Programs would be less bug-prone, as <strong >C++</strong> uses a stricter syntax
and type checking.
    <li> <a name="an45"></a>`Data hiding', the usage of data by one program part
while other program parts cannot access the data, would be easier to implement
with <strong >C++</strong>.
    </ul>
    Which of these allegations are true? Originally, our impression was that
the <strong >C++</strong> language was somewhat overrated; the same holding true for the
entire object-oriented programming (OOP) approach. The enthusiasm for the
<strong >C++</strong> language resembles the once uttered allegations about
Artificial-Intelligence (AI) languages like <a name="an46"></a>Lisp and <a name="an47"></a>Prolog: these
languages were supposed to solve the most difficult AI-problems `almost
without effort'. New languages are often oversold: in the end, each problem
can be coded in any programming language (say <a name="an48"></a>BASIC or
    <a name="an49"></a>assembly language).  The advantages and disadvantages of a given
programming language aren't in `what you can do with them', but rather in
`which tools the language offers to implement an efficient and understandable
solution to a programming problem'. Often these tools take the form of
syntactic <a name="an50"></a><em >restrictions</em>, enforcing or promoting certain constructions or
which simply suggest intentions by applying or `embracing' such syntactic
forms. Rather than a long list of plain assembly instructions we now use flow
control statements, functions, objects or even (with <strong >C++</strong>) so-called
<em >templates</em> to structure and organize code and to express
oneself `eloquently' in the language of one's choice.
<p>
Concerning the above allegations of <strong >C++</strong>, we support the following, however.
    <ul>
    <li> The development of new programs while existing code is reused can
also be implemented in <strong >C</strong> by, e.g., using function libraries.  Functions
can be collected in a library and need not be re-invented with each new
program. <strong >C++</strong>, however, offers specific syntax possibilities for code
reuse, apart from function libraries (see chapters <a href="cplusplus13.html#INHERITANCE">13</a> and
<a href="cplusplus21.html#TEMPLATES">21</a>).
    <li> Creating and using new data types is certainly possible in <strong >C</strong>;
e.g., by using <code >struct</code>s, <code >typedef</code>s etc.. From these types other types
can be derived, thus leading to <code >struct</code>s containing <code >struct</code>s and so
on. In <strong >C++</strong> these facilities are augmented by defining data types which are
completely `self supporting', taking care of, e.g., their memory management
automatically (without having to resort to an independently operating memory
management system as used in, e.g., <strong >Java</strong>).
    <li> In <strong >C++</strong> memory management can in principle be either as easy or as
difficult as it is in C.  Especially when dedicated <strong >C</strong> functions such as
<code >xmalloc</code> and <code >xrealloc</code> are used (allocating the memory or aborting
the program when the memory pool is exhausted). However, with functions like
<code >malloc</code> it is easy to err. Frequently errors in <strong >C</strong> programs can be
traced back to  miscalculations when using <code >malloc</code>. Instead, <strong >C++</strong>
offers facilities to allocate memory in a somewhat safer way, using its
<code >operator new</code>.
    <li> Concerning `bug proneness' we can say that <strong >C++</strong> indeed uses
stricter type checking than <strong >C</strong>. However, most modern <strong >C</strong> compilers
implement `warning levels'; it is then the programmer's choice to disregard or
get rid of the warnings. In <strong >C++</strong> many of such warnings become fatal errors
(the compilation stops).
    <li> As far as `data hiding' is concerned, <strong >C</strong> does offer some tools.
E.g., where possible, local or <a name="an51"></a><code >static</code> variables can be used and special
data types such as <code >struct</code>s can be manipulated by dedicated functions.
Using such techniques, data hiding can be implemented even in <strong >C</strong>; though it
must be admitted that <strong >C++</strong> offers special syntactic constructions, making
it far easier to implement `data hiding' (and more in general:
`encapsulation') in <strong >C++</strong> than in <strong >C</strong>.
    </ul>
    <strong >C++</strong> in particular (and OOP in general) is of course not <em >the</em>
solution to all programming problems. However, the language <em >does</em> offer
various new and elegant facilities which are worth investigating. At the
downside, the level of grammatical complexity of <strong >C++</strong> has increased
significantly as compared to <strong >C</strong>. This may be considered a serious drawback
of the language. Although we got used to this increased level of complexity
over time, the transition was neither fast nor painless.
<p>
With the <strong >C++</strong> Annotations we hope to help the reader when transiting from <strong >C</strong>
to <strong >C++</strong> by focusing on the additions of <strong >C++</strong> as compared to <strong >C</strong> and by
leaving out plain <strong >C</strong>. It is our hope that you like this document and
may benefit from it.
<p>
Enjoy and good luck on your journey into <strong >C++</strong>!
<p>
<a name="OOP"></a><a name="l11"></a>
<h2 >2.4: What is Object-Oriented Programming?</h2>
    Object-oriented (and object-based) programming propagates a slightly different
approach to programming problems than the strategy usually used in <strong >C</strong>
programs. In <strong >C</strong> programming problems are usually solved using a
`<a name="an52"></a>procedural approach': a problem is decomposed into subproblems and this
process is repeated until the subtasks can be coded. Thus a conglomerate of
functions is created, communicating through arguments and variables, global or
local (or <code >static</code>).
<p>
In contrast (or maybe better: in addition) to this, an object-based approach
identifies the <strong >keywords</strong> used in a problem statement. These keywords are
then depicted in a diagram where arrows are drawn between those keywords to
depict an internal hierarchy. The keywords become the objects in the
implementation and the hierarchy defines the relationship between these
objects. The term object is used here to describe a limited, well-defined
structure, containing all information about an entity: data types and
functions to manipulate the data. As an example of an
  <a name="an53"></a>object oriented approach, an illustration follows:
    <blockquote >
    The employees and owner of a car dealer and auto garage company are paid
    as follows. First, mechanics who work in the garage are paid a certain sum
    each month. Second, the owner of the company receives a fixed amount each
    month. Third, there are car salesmen who work in the showroom and receive
    their salary each month plus a bonus per sold car. Finally, the company
    employs second-hand car purchasers who travel around; these employees
    receive their monthly salary, a bonus per bought car, and a restitution of
    their travel expenses.
    </blockquote>
    When representing the above salary administration, the keywords could be
mechanics, owner, salesmen and purchasers. The properties of such units are: a
monthly salary, sometimes a bonus per purchase or sale, and sometimes
restitution of travel expenses. When analyzing the problem in this manner we
arrive at the following representation:
    <ul>
    <li> The owner and the mechanics can be represented by identical types,
receiving a given salary per month. The relevant information for such a type
would be the monthly amount. In addition this object could contain data as the
name, address and social security number.
    <li> Car salesmen who work in the showroom can be represented as the same
type as above but with some <em >extra</em> functionality: the number of
transactions (sales) and the bonus per transaction.
<p>
In the hierarchy of objects we would define the dependency between the
first two objects by letting the car salesmen be `derived' from
the owner and mechanics.
    <li> Finally, there are the second-hand car purchasers. These share the
functionality of the salesmen except for travel expenses. The additional
functionality would therefore consist of the expenses made and this type would
be derived from the salesmen.
    </ul>
    The hierarchy of the identified objects are further illustrated in
Figure <a href="cplusplus02.html#objects">1</a>.
    <p><a name="objects"></a><figure >
<img src="intro/objects.gif" >
<figcaption >Figure 1: Hierarchy of objects in the salary administration.</figcaption>
</figure></p>

<p>
The overall process in the definition of a hierarchy such as the above starts
with the description of the most simple type. Traditionally (and still in
vogue with some popular object oriented languages) more complex types are then
derived from the basic set, with each derivation adding a little extra
functionality. From these derived types, more complex types can be derived
<em >ad infinitum</em>, until a representation of the entire problem can be
made. Over the years, however, this approach has become less popular in
<strong >C++</strong> as it typically results in overly tight <a name="an54"></a><em >coupling</em>, which in turns
<em >reduces</em> rather than enhances the understanding, maintainability and
testability of complex programs. In <strong >C++</strong> object oriented program more and
more favors small, easy to understand hierarchies, limited coupling and a
developmental process where <a name="an55"></a><em >design patterns</em>
(cf. <em >Gamma et al.</em>  (1995)) play a central role.
<p>
Nonetheless, in <strong >C++</strong> <a name="an56"></a> <em >classes</em> are frequently used to define
the characteristics of <em >objects</em>. Classes contain the necessary
functionality to do useful things. Classes generally do not offer all their
functionality (and typically <em >none</em> of their data)
to objects of other classes. As we will see, classes tend to <em >hide</em> their
properties in such a way that they are not directly modifiable by the outside
world. Instead, dedicated functions are used to reach or modify the properties
of objects. Thus class-type objects are able to uphold their own
integrity. The core concept here is <a name="an57"></a><em >encapsulation</em> of which
  <a name="an58"></a><em >data hiding</em> is just an example. These concepts are further
explained in chapter <a href="cplusplus07.html#Classes">7</a>.
<p>
<a name="l12"></a>
<h2 >2.5: Differences between C and C++</h2>
    In this section some examples of <strong >C++</strong> code are shown. Some differences
between <strong >C</strong> and <strong >C++</strong> are highlighted.
<p>
<a name="l13"></a>
<h3 >2.5.1: The function `main'</h3>
        In <strong >C++</strong> there are only two variants of the function <a name="an59"></a><code >main</code>:
<code >int main()</code> and <code >int main(int argc, char **argv)</code>. 
<p>
Notes:
    <ul>
    <li> The return type of <code >main</code> is <code >int</code>, and <em >not</em> <code >void</code>;
    <li> The function <code >main</code> cannot be overloaded (for other than the
abovementioned signatures);
    <li> It is <em >not</em> required to use an explicit <code >return</code> statement at the
end of  <code >main</code>. If omitted <code >main</code> returns 0;
    <li> The value of <code >argv[argc]</code> equals 0;
    <li> The `third <code >char **envp</code> parameter' is not defined by the <strong >C++</strong>
standard and should be avoided.  Instead, the global variable <a name="an60"></a>
<code >extern char **environ</code> should be declared providing access to the program's
environment variables. Its final element has the value 0;
    <li> A <strong >C++</strong> program ends normally when the <code >main</code> function
returns. Using a <em >function try block</em> (cf. section <a href="cplusplus10.html#FUNTRY">10.11</a>) for <code >main</code>
is also considered a normal end of a <strong >C++</strong> program. When a <strong >C++</strong> ends
normally, destructors (cf. section <a href="cplusplus09.html#DESTRUCTOR">9.2</a>) of globally defined
objects are activated. A function like <strong >exit</strong>(3) does not normally end
a <strong >C++</strong> program and using such functions is therefore deprecated.
    </ul>
<p>
<a name="l14"></a>
<h3 >2.5.2: End-of-line comment</h3>
        According to the <a name="an61"></a>ANSI/ISO definition, `<a name="an62"></a>end of line comment' is
implemented in the syntax of <strong >C++</strong>. This comment starts with <a name="an63"></a><code >//</code> and ends
at the end-of-line marker. The standard <strong >C</strong> comment, delimited by <code >/*</code> and
<code >*/</code> can still be used in <strong >C++</strong>:
        <pre>
    int main()
    {
        // this is end-of-line comment
        // one comment per line

        /*
            this is standard-C comment, covering
            multiple lines
        */
    }
</pre>
    Despite the example, it is advised <em >not</em> to use <strong >C</strong> type comment
inside the body of <strong >C++</strong> functions. Sometimes existing code must temporarily
be suppressed, e.g., for testing purposes. In those cases it's very practical
to be able to use standard <strong >C</strong> comment. If such suppressed code itself
contains such comment, it would result in nested comment-lines, resulting in
compiler errors. Therefore, the <a name="an64"></a>rule of thumb is not to use <strong >C</strong> type
comment inside the body of <strong >C++</strong> functions (alternatively, <code >#if 0</code> until
<code >#endif</code> pair of preprocessor directives could of course also be used).
<p>
<a name="l15"></a>
<h3 >2.5.3: Strict type checking</h3>
        <strong >C++</strong> uses very strict <a name="an65"></a>type checking. A prototype must be known for each
function before it is called, and the call must match the prototype.
The program
        <pre>
    int main()
    {
        printf("Hello World\n");
    }
</pre>
 often compiles under <strong >C</strong>, albeit with a warning that <a name="an66"></a><code >printf()</code>
is an unknown function. But <strong >C++</strong> compilers (should) fail to produce code in
such cases. The error is of course caused by the missing <a name="an67"></a>
 <code >#include &lt;stdio.h&gt;</code> (which in <strong >C++</strong> is more commonly included as
 <a name="an68"></a> <code >#include &lt;cstdio&gt;</code> directive).
<p>
And while we're at it: as we've seen in <strong >C++</strong> <a name="an69"></a><code >main</code> <em >always</em> uses
the <code >int</code> <a name="an70"></a>return value. Although it is possible to define <a name="an71"></a><code >int
main()</code> without explicitly defining a return statement, within <code >main</code> it is
not possible to use a <code >return</code> statement without an explicit
<code >int</code>-expression.  For example:
        <pre>
    int main()
    {
        return;     // won't compile: expects int expression, e.g.
                    // return 1;
    }
</pre>
<p>
<a name="FunctionOverloading"></a><a name="l16"></a>
<h3 >2.5.4: Function Overloading</h3>
        In <strong >C++</strong> it is possible to define
    <a name="an72"></a>functions having identical names but performing different actions. The
functions must differ in their <a name="an73"></a> parameter lists (and/or in
their <a name="an74"></a> <code >const</code> attribute). An example is given
below:
        <pre>
    #include &lt;stdio.h&gt;

    void show(int val)
    {
        printf("Integer: %d\n", val);
    }

    void show(double val)
    {
        printf("Double: %lf\n", val);
    }

    void show(char const *val)
    {
        printf("String: %s\n", val);
    }

    int main()
    {
        show(12);
        show(3.1415);
        show("Hello World!\n");
    }
</pre>
    In the above program three functions <code >show</code> are defined, only differing
in their parameter lists, expecting an <code >int</code>, <code >double</code> and <code >char *</code>,
respectively. The functions have identical names. Functions having identical
names but different parameter lists are called <em >overloaded</em>. The act of
defining such functions is called `<a name="an75"></a>function overloading'.
<p>
The <strong >C++</strong> compiler implements function overloading in a rather simple
way. Although the functions share their names (in this example <code >show</code>), the
compiler (and hence the linker) use quite different names. The conversion of a
name in the source file to an internally used name is called
 `<a name="an76"></a>name mangling'. E.g., the <strong >C++</strong> compiler might convert the prototype
<code >void</code> <code >show</code> <code >(int)</code> to the internal name <code >VshowI</code>, while an
analogous function having a <code >char *</code> argument might be called
<code >VshowCP</code>. The actual names that are used internally depend on the compiler
and are not relevant for the programmer, except where these names show up in
e.g., a listing of the contents of a library.
<p>
Some additional remarks with respect to  function overloading:
    <ul>
    <li> Do not use function overloading for functions doing conceptually
different tasks.  In the example above, the functions <code >show</code> are still
somewhat related (they print information to the screen).
<p>
However, it is also quite possible to define two functions <code >lookup</code>,
one of which would find a name in a list while the other would determine the
video mode. In this case the behavior of those two functions have nothing in
common. It would therefore be more practical to use names which suggest their
actions; say, <code >findname</code> and <code >videoMode</code>.
    <li> <strong >C++</strong> does not allow identically named functions to differ only in
their return values, as it is always the programmer's choice to either use or
ignore a function's  return value. E.g., the fragment
    <pre>
printf("Hello World!\n");
</pre>
    provides no information about the return value of the function
<code >printf</code>. Two functions <code >printf</code> which only differ in their
return types would therefore not be distinguishable to the compiler.
    <li> In chapter <a href="cplusplus07.html#Classes">7</a> the notion of <code >const</code> member functions is
introduced (cf. section <a href="cplusplus07.html#ConstFunctions">7.7</a>). Here it is merely mentioned
that classes normally have so-called member functions associated with them
(see, e.g., chapter <a href="cplusplus05.html#String">5</a> for an informal introduction to the
concept). Apart from
    <a name="an77"></a>
    overloading member functions using different parameter lists, it
is then also possible to
    <a name="an78"></a>
    overload member functions by their <code >const</code> attributes. In those cases,
classes may have pairs of identically named member functions, having identical
parameter lists. Then, these functions are overloaded by their <code >const</code>
attribute. In such cases only one of these functions must have the <code >const</code>
attribute.
    </ul>
<p>
<a name="l17"></a>
<h3 >2.5.5: Default function arguments</h3>
        In <strong >C++</strong> it is possible to provide `<a name="an79"></a>default arguments' when defining a
function. These arguments are supplied by the compiler when they are not
specified by the programmer. For example:
        <pre>
    #include &lt;stdio.h&gt;

    void showstring(char *str = "Hello World!\n");

    int main()
    {
        showstring("Here's an explicit argument.\n");

        showstring();           // in fact this says:
                                // showstring("Hello World!\n");
    }
</pre>
    The possibility to omit arguments in situations where default arguments
are defined is just a nice touch: it is the compiler who supplies the lacking
argument unless it is explicitly specified at the call. The code of the
program will neither be shorter nor more efficient when default arguments are
used.
<p>
Functions may be defined with more than one default argument:
        <pre>
    void two_ints(int a = 1, int b = 4);

    int main()
    {
        two_ints();            // arguments:  1, 4
        two_ints(20);          // arguments: 20, 4
        two_ints(20, 5);       // arguments: 20, 5
    }
</pre>
    When the function <code >two_ints</code> is called, the compiler supplies one or two
arguments whenever necessary. A statement like <code >two_ints(,6)</code> is, however,
not allowed: when arguments are omitted they must be on the right-hand side.
<p>
Default arguments must be known at <a name="an80"></a>compile-time since at that moment
arguments are supplied to functions. Therefore, the default arguments must be
mentioned at the function's <em >declaration</em>, rather than at its
<em >implementation</em>:
        <pre>
    // sample header file
    extern void two_ints(int a = 1, int b = 4);

    // code of function in, say, two.cc
    void two_ints(int a, int b)
    {
        ...
    }
</pre>
    It is an error to supply default arguments in function definitions. When
the function is used by other sources the compiler reads the header file
rather than the function definition. Consequently the compiler has no way to
determine the values of default function arguments. Current compilers generate
compile-time errors when detecting default arguments in function definitions.
<p>
<a name="l18"></a>
<h3 >2.5.6: NULL-pointers vs. 0-pointers and nullptr</h3>
        In <strong >C++</strong> all zero values are coded as <code >0</code>. In <strong >C</strong> <a name="an81"></a><code >NULL</code> is often used
in the context of pointers. This difference is purely stylistic, though one
that is widely adopted. In <strong >C++</strong> <code >NULL</code> should be avoided (as it is a
<a name="an82"></a>macro, and macros can --and therefore should-- easily be avoided in
<strong >C++</strong>, see also section <a href="cplusplus08.html#GENCONST">8.1.4</a>). Instead <code >0</code> can almost always be
used.
<p>
Almost always, but not always. As <strong >C++</strong> allows function overloading
(cf. section <a href="cplusplus02.html#FunctionOverloading">2.5.4</a>) the programmer might be confronted with
an unexpected function selection in the situation shown in section
<a href="cplusplus02.html#FunctionOverloading">2.5.4</a>:
        <pre>
    #include &lt;stdio.h&gt;

    void show(int val)
    {
        printf("Integer: %d\n", val);
    }

    void show(double val)
    {
        printf("Double: %lf\n", val);
    }

    void show(char const *val)
    {
        printf("String: %s\n", val);
    }

    int main()
    {
        show(12);
        show(3.1415);
        show("Hello World!\n");
    }
</pre>
<p>
In this situation a programmer intending to call <code >show(char const *)</code> might
call <code >show(0)</code>. But this doesn't work, as 0 is interpreted as <code >int</code> and so
<code >show(int)</code> is called. But calling <code >show(NULL)</code> doesn't work either, as
<strong >C++</strong> usually defines <a name="an83"></a><code >NULL</code> as 0, rather than <code >((void *)0)</code>. So,
<code >show(int)</code> is called once again. To solve these kinds of problems the new
<strong >C++</strong> standard introduces the keyword <a name="an84"></a><code >nullptr</code> representing the 0
pointer. In the current example the programmer should call <code >show(nullptr)</code>
to avoid the selection of the wrong function. The <code >nullptr</code> value can also
be used to initialize pointer variables. E.g.,
        <pre>
    int *ip = nullptr;      // OK
    int value = nullptr;    // error: value is no pointer
</pre>
<p>
<a name="l19"></a>
<h3 >2.5.7: The `void' parameter list</h3>
        In <strong >C</strong>, a function prototype with an <a name="an85"></a>empty parameter list, such as
        <pre>
    void func();
</pre>
 means that the argument list of the declared function is not prototyped: for
functions using this prototype the compiler does not warn against calling
<code >func</code> with any set of arguments. In <strong >C</strong> the keyword <a name="an86"></a><code >void</code> is used when
it is the explicit intent to declare a function with no arguments at all, as
in:
        <pre>
    void func(void);
</pre>
    As <strong >C++</strong> enforces strict type checking, in <strong >C++</strong> an empty parameter
list indicates the <em >total absence</em> of parameters. The keyword <code >void</code> is
thus omitted.
<p>
<a name="l20"></a>
<h3 >2.5.8: The `#define __cplusplus'</h3>
        Each <strong >C++</strong> compiler which conforms to the <a name="an87"></a>ANSI/ISO standard defines the
symbol <a name="an88"></a><code >__cplusplus</code>: it is as if each source file were prefixed with the
<a name="an89"></a>preprocessor directive <a name="an90"></a><code >#define __cplusplus</code>.
<p>
We shall see examples of the usage of this symbol in the following sections.
<p>
<a name="l21"></a>
<h3 >2.5.9: Using standard C functions</h3>
        Normal <strong >C</strong> functions, e.g., which are compiled and collected in a run-time
library, can also be used in <strong >C++</strong> programs. Such functions, however, must be
declared as <strong >C</strong> functions.
<p>
As an example, the following code fragment declares a function <code >xmalloc</code>
as a <strong >C</strong> function:
        <pre>
    extern "C" void *xmalloc(int size);
</pre>
    This declaration is analogous to a declaration in <strong >C</strong>, except that the
prototype is prefixed with <a name="an91"></a><code >extern "C"</code>.
<p>
A slightly different way to declare <strong >C</strong> functions is the following:
        <pre>
    extern "C"
    {
        // C-declarations go in here
    }
</pre>
    It is also possible to place preprocessor directives at the location of
the declarations. E.g., a <strong >C</strong> header file <code >myheader.h</code> which declares
<strong >C</strong> functions can be included in a <strong >C++</strong> source file as follows:
        <pre>
    extern "C"
    {
        #include &lt;myheader.h&gt;
    }
</pre>
    Although these two approaches may be used, they are actually seldom
encountered in <strong >C++</strong> sources. A more frequently used method to declare
external <strong >C</strong> functions is encountered in the next section.
<p>
<a name="CHeaders"></a><a name="l22"></a>
<h3 >2.5.10: Header files for both C and C++</h3>
        The combination of the predefined symbol <a name="an92"></a><code >__cplusplus</code> and the
possibility to define <a name="an93"></a><code >extern "C"</code> functions offers the ability to
create header files for both <strong >C</strong> and <strong >C++</strong>. Such a header file might,
e.g., declare a group of functions which are to be used in both <strong >C</strong> and
<strong >C++</strong> programs.
<p>
The setup of such a header file is as follows:
        <pre>
    #ifdef __cplusplus
    extern "C"
    {
    #endif

        /* declaration of C-data and functions are inserted here. E.g., */
        void *xmalloc(int size);

    #ifdef __cplusplus
    }
    #endif
</pre>
 Using this setup, a normal <strong >C</strong> header file is enclosed by <code >extern "C"</code>
<code >{</code> which occurs near the top of the file and by <code >}</code>, which occurs near
the bottom of the file. The <a name="an94"></a><code >#ifdef</code> directives test for the type of the
compilation: <strong >C</strong> or <strong >C++</strong>. The `standard' <strong >C</strong> header files, such as
<a name="an95"></a><code >stdio.h</code>, are built in this manner and are therefore usable for both <strong >C</strong>
and <strong >C++</strong>.
<p>
In addition <strong >C++</strong> headers should support <a name="an96"></a><em >include guard</em><em >s</em>.
In <strong >C++</strong> it is usually undesirable to include the same header file twice in
the same source file. Such multiple inclusions can easily be avoided by
including an <a name="an97"></a><code >#ifndef</code> directive in the header file.  For example:
        <pre>
    #ifndef MYHEADER_H_
    #define MYHEADER_H_
        // declarations of the header file is inserted here,
        // using #ifdef __cplusplus etc. directives
    #endif
</pre>
 When this file is initially scanned by the preprocessor, the symbol
<code >MYHEADER_H_</code> is not yet defined. The <code >#ifndef</code> condition succeeds and all
declarations are scanned. In addition, the symbol <code >MYHEADER_H_</code> is defined.
<p>
When this file is scanned next while compiling the same source file,
the symbol <code >MYHEADER_H_</code> has been defined and consequently all information
between the <code >#ifndef</code> and <code >#endif</code> directives is skipped by the compiler.
<p>
In this context the symbol name <code >MYHEADER_H_</code> serves only for
recognition purposes. E.g., the name of the header file can be used for this
purpose, in capitals, with an underscore character instead of a dot.
<p>
Apart from all this, the custom has evolved to give <strong >C</strong> header files the
extension <a name="an98"></a><code >.h</code>, and to give <code >C++</code> header files <em >no</em> extension. For
example, the standard <em >iostreams</em> <code >cin, cout</code> and <code >cerr</code> are available
after including the header file <a name="an99"></a><code >iostream</code>, rather
than <a name="an100"></a><code >iostream.h</code>. In the Annotations this convention is used
with the standard <strong >C++</strong> header files, but not necessarily everywhere else.
<p>
There is more to be said about header files. Section <a href="cplusplus07.html#CLASSHEADER">7.11</a> provides
an in-depth discussion of the preferred organization of <strong >C++</strong> header files.
<p>
<a name="LOCALVARS"></a><a name="l23"></a>
<h3 >2.5.11: Defining local variables</h3>
        Although already available in the <strong >C</strong> programming language,
    <a name="an101"></a>local variables should only be defined once they're needed.  Although
doing so requires a little getting used to, eventually it tends to produce
more readable, maintainable and often more efficient code than defining
variables at the beginning of compound statements. We suggest to apply the
following rules <a name="an102"></a> of thumb when defining local variables:
    <ul>
    <li> Local variables should be created at `intuitively right' places, such
as in the example above. This does not only entail the <code >for</code>-statement, but
also all situations where a variable is only needed, say, half-way through the
function.
    <li> More in general, variables should be defined in such a way that their
scope is as <em >limited</em> and <em >localized</em> as possible.  When avoidable local
variables are not defined at the beginning of functions but rather where
they're first used.
    <li> It is considered good practice to <a name="an103"></a>
    <a name="an104"></a><em >avoid global variables</em>. It is fairly easy to lose track of which
global variable is used for what purpose. In <strong >C++</strong> global variables are
seldom required, and by localizing variables the well known phenomenon of
using the same variable for multiple purposes, thereby invalidating each
individual purpose of the variable, can easily be prevented.
    </ul>
<p>
If considered appropriate, <a name="an105"></a><em >nested blocks</em> can be used to localize
auxiliary variables. However, situations exist where local variables are
considered appropriate inside nested statements. The just mentioned <code >for</code>
statement is of course a case in point, but local variables can also be
defined within the condition clauses of <code >if-else</code> statements, within
selection clauses of <code >switch</code> statements and condition clauses of <code >while</code>
statements. Variables thus defined are available to the full
statement, including its nested statements. For example, consider the
following <code >switch</code> statement:
        <pre>
    #include &lt;stdio.h&gt;

    int main()
    {
        switch (int c = getchar())
        {
            case 'a':
            case 'e':
            case 'i':
            case 'o':
            case 'u':
                printf("Saw vowel %c\n", c);
            break;

            case EOF:
                printf("Saw EOF\n");
            break;

            case '0' ... '9':
                printf("Saw number character %c\n", c);
            break;

            default:
                printf("Saw other character, hex value 0x%2x\n", c);
        }
    }
</pre>
    Note the location of the definition of the character `<code >c</code>': it is
defined in the expression part of the <code >switch</code> statement. This implies
that `<code >c</code>' is available <em >only</em> to the <code >switch</code> statement itself,
including its nested (sub)statements, but not outside the scope of the
<code >switch</code>.
<p>
The same approach can be used with <code >if</code> and <code >while</code> statements: a
variable that is defined in the condition part of an <code >if</code> and <code >while</code>
statement is available in their nested statements. There are some caveats,
though:
    <ul>
    <li> The variable definition must result in a variable which is
initialized to a numeric or logical value;
    <li> The variable definition cannot be nested (e.g., using parentheses)
within a more complex expression.
    </ul>
    The latter point of attention should come as no big surprise: in order to
be able to evaluate the logical condition of an <code >if</code> or <code >while</code> statement,
the value of the variable must be interpretable as either zero (false) or
non-zero (true). Usually this is no problem, but in <strong >C++</strong> <em >objects</em> (like
objects of the type <code >std::string</code> (cf. chapter <a href="cplusplus05.html#String">5</a>)) are often
returned by functions. Such objects may or may not be interpretable as numeric
values. If not (as is the case with <code >std::string</code> objects), then such
variables can <em >not</em> be defined at the condition or expression clauses of
condition- or repetition statements. The following example will therefore
<em >not</em> compile:
        <pre>
    if (std::string myString = getString())     // assume getString returns
    {                                           // a std::string value
        // process myString
    }
</pre>
<p>
The above example requires additional clarification. Often a variable can
profitably be given local scope, but an extra check is required immediately
following its initialization. The initialization <em >and</em> the test cannot
<em >both</em> be combined in one expression. Instead <em >two</em> nested statements are
required. Consequently, the following example won't compile either:
        <pre>
    if ((int c = getchar()) &amp;&amp; strchr("aeiou", c))
        printf("Saw a vowel\n");
</pre>
    If such a situation occurs, either use two nested <code >if</code> statements, or
localize the definition of <code >int c</code> using a nested compound statement:
        <pre>
    if (int c = getchar())             // nested if-statements
        if (strchr("aeiou", c))
            printf("Saw a vowel\n");

    {                                  // nested compound statement
        int c = getchar();
        if (c &amp;&amp; strchr("aeiou", c))
           printf("Saw a vowel\n");
    }
</pre>
<p>
<a name="l24"></a>
<h3 >2.5.12: The keyword `typedef'</h3>
        The keyword <a name="an106"></a><code >typedef</code> is still used in <strong >C++</strong>, but is not required
anymore when defining  <a name="an107"></a><code >union</code>, <a name="an108"></a><code >struct</code> or <a name="an109"></a><code >enum</code> definitions.
This is illustrated in the following example:
        <pre>
    struct SomeStruct
    {
        int     a;
        double  d;
        char    string[80];
    };
</pre>
    When a <code >struct, union</code> or other compound type is defined, the tag of
this type can be used as type name (this is <code >SomeStruct</code> in the above
example):
        <pre>
    SomeStruct what;

    what.d = 3.1415;
</pre>
<p>
<a name="FunctionInStruct"></a><a name="l25"></a>
<h3 >2.5.13: Functions as part of a struct</h3>
        In <strong >C++</strong> we may define <a name="an110"></a>functions as members of structs. Here we
encounter the first concrete example of an object: as previously described
(see section <a href="cplusplus02.html#OOP">2.4</a>), an <a name="an111"></a>object is a structure containing data while
specialized functions exist to manipulate those data.
<p>
A definition of a <code >struct Point</code> is provided by the code fragment below.
In this structure, two <code >int</code> data fields and one function <code >draw</code> are
declared.
        <pre>
    struct Point            // definition of a screen-dot
    {
        int x;              // coordinates
        int y;              // x/y
        void draw();        // drawing function
    };
</pre>
    A similar structure could be part of a painting program and could, e.g.,
represent a pixel. With respect to this <code >struct</code> it should be noted that:
    <ul>
    <li> The function <code >draw</code> mentioned in the <code >struct</code> definition is a
mere <em >declaration</em>. The actual code of the function defining the actions
performed by the function is found elsewhere (the concept of functions inside
<code >struct</code>s is further discussed in section <a href="cplusplus03.html#FunctionsInStructs">3.2</a>).
    <li> The size of the <code >struct</code> <code >Point</code> is equal to the size of its
two <code >int</code>s.  A function declared inside the structure does not affect its
size. The compiler implements this behavior by allowing the function
<code >draw</code> to be available only in the context of a <code >Point</code>.
    </ul>
    The <code >Point</code> structure could be used as follows:
        <pre>
    Point a;                // two points on
    Point b;                // the screen

    a.x = 0;                // define first dot
    a.y = 10;               // and draw it
    a.draw();

    b = a;                  // copy a to b
    b.y = 20;               // redefine y-coord
    b.draw();               // and draw it
</pre>
    As shown in the above example a function that is part of the structure may
be selected using the dot (.) (the arrow (<code >-&gt;</code>) operator is used when
pointers to objects are available). This is therefore identical to the way
data fields of structures are selected.
<p>
The idea behind this syntactic construction is that several types may
contain <a name="an112"></a>functions having identical names. E.g., a structure representing a
circle might contain three <code >int</code> values: two values for the coordinates of
the center of the circle and one value for the radius. Analogously to the
<code >Point</code> structure, a <code >Circle</code> may now have a function <code >draw</code> to draw the
circle.
<p>
<a name="CXVII"></a><a name="l26"></a>
<h3 >2.5.14: Features introduced at the C++17 standard</h3>
        The <a name="an113"></a>C++17 (also referred to as <a name="an114"></a>C++1z) standard will be implemented in
the next major version upgrade of the Gnu <code >g++</code> compiler (version
7.0.0 or beyond).
<p>
The working draft of the standard is freely available, and can be cloned from
the git-repository at <a href="https://github.com/cplusplus/draft.git">https://github.com/cplusplus/draft.git</a>
<p>
In time the <strong >C++</strong> Annotations will reflect the changes related to the C++17
standard. Several sections in the <strong >C++</strong> Annotations directly relate to the C++17
standard. These sections can easily be located by looking for he C++17 entry
in the table of contents or in the index.
<p>
In addition to the topics mentioned in separate sections the C++17 standard
introduces the following features:
<p>
<dl>    
<p>
<dt ><strong>Evaluation order of operands of operators</strong></dt><br/>
<p>
Up to C++17, the evaluation order of expressions of operands of binary
operators is, except for the boolean operators <code >and</code> and <code >or</code>, not
defined. C++17 changes this for postfix expressions, assignment expressions
(including compound assignments), and shift operators:
    <ul>
    <li> Postfix expressions (like index operators and member selectors) 
        are evaluated from left to right;
    <li> Assignment expressions are evaluated from right to left;
    <li> Operands of shift operators are evaluated from left to right.
    </ul>
    In the following examples <code >first</code> is evaluated before <code >second</code>, before
<code >third</code>, before <code >fourth</code>, whether they are single variables, parenthesized
expressions, or function calls:
        <pre>
    first.second
    fourth += third = second += first
    first &lt;&lt; second &lt;&lt; third &lt;&lt; fourth
    first &gt;&gt; second &gt;&gt; third &gt;&gt; fourth
</pre>
    In addition, when overloading an operator, the function implementing the
overloaded operator is evaluated like the built-in operator it overloads, and
not in the way function calls are generally ordered.
<p>
<dt ><strong>[[fallthrough]]</strong></dt><a name="an115"></a><br/>
<p>
When statements that are nested under <code >case</code> entries in <code >switch</code>
statements continue into subsequent <code >case</code> or <code >default</code> entries the
compiler will issue a `falling through' warning. If falling through is
intentional the attribute <code >[[fallthrough]]</code> should be used. Here is an
annotated example:
        <pre>
void function(int selector)
{
    switch (selector)
    {
        case 1:
        case 2:             // no falling through, but merged entry points
            cout &lt;&lt; "cases 1 and 2\n";
        [[fallthrough]];
        case 3:
            cout &lt;&lt; "case 3\n";

        case 4:             // a warning is issued
            cout &lt;&lt; "case 4\n";
        [[fallthrough]];    // error: nothing beyond
    }
}
</pre>
<p>
<dt ><strong>[[maybe_unused]]</strong></dt><a name="an116"></a><br/>
<p>
This attribute can be applied to a class, typedef-name, variable,
non-static data member, a function, an enumeration or an enumerator. When it
is applied to an entity no warning is generated when the
entity is not used. Example:
        <pre>
void fun([[maybe_unused]] size_t argument)
{
    // argument isn't used, but no warning 
    // telling you so is issued
}
</pre>
<p>
<dt ><strong>[[nodiscard]]</strong></dt><a name="an117"></a><br/>
<p>
The attribute <code >[[nodiscard]]</code> may be specified when declaring a
function, class or enumeration. If a function is declared <code >[[nodiscard]]</code> or
if a function returns an entity previously declared using <code >[[nodiscard]]</code>
then the return value of such a function may only be ignored when explicitly
cast to void. Otherwise, when the return value is not used a warning is
issued. Example:
        <pre>
int [[nodiscard]] importantInt();
struct [[nodiscard]] ImportantStruct { ... };

ImportantStruct factory();
    
int main()
{
    importantInt();         // warning issued
    factory();              // warning issued
}
</pre>
<p>
</dl>
<p>

<hr>
<ul>
    <li> <a href="cplusplus.html">Table of Contents</a>
    <li> <a href="cplusplus01.html">Previous Chapter</a>
    <li> <a href="cplusplus03.html">Next Chapter</a>
</ul>
<hr>
</body>
</html>
