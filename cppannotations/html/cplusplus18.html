<!DOCTYPE html><html><head>
<meta charset="UTF-8">
<title> C++ Annotations Version 10.9.2 </title>
<link rel="stylesheet" type="text/css" href="cplusplus.css"><style type="text/css">
    figure {text-align: center;}
    img {vertical-align: center;}
    .XXfc {margin-left:auto;margin-right:auto;}
    .XXtc {text-align: center;}
    .XXtl {text-align: left;}
    .XXtr {text-align: right;}
    .XXvt {vertical-align: top;}
    .XXvb {vertical-align: bottom;}
</style>
<link rel="stylesheet" type="text/css" href="cplusplus.css"></head>
<body >
<hr>
<ul>
    <li> <a href="cplusplus.html">Table of Contents</a>
    <li> <a href="cplusplus17.html">Previous Chapter</a>
    <li> <a href="cplusplus19.html">Next Chapter</a>
</ul>
<hr>
<a name="STL"></a><a name="l325"></a>
<h1 >Chapter 18: The Standard Template Library</h1>
The <a name="an2002"></a><code >Standard Template Library</code> (<a name="an2003"></a>STL) is a general purpose library
consisting of containers, generic algorithms, iterators, function objects,
allocators, adaptors and data structures. The data structures used by the
algorithms are <em >abstract</em> in the sense that the algorithms can be used with
(practically) any data type.
<p>
The algorithms can process these abstract data types because they are
<a name="an2004"></a><em >template</em> based. This chapter does not cover template <em >construction</em>
(see chapter <a href="cplusplus21.html#TEMPLATES">21</a> for that). Rather, it focuses on the <em >use</em>
of the algorithms.
<p>
Several elements also used by the standard template library have already been
discussed in the <strong >C++</strong> Annotations. In chapter <a href="cplusplus12.html#CONTAINERS">12</a> abstract containers
were discussed, and in section <a href="cplusplus11.html#FUNOBJ">11.10</a> function objects were introduced.
Also, <em >iterators</em> were mentioned at several places in this document.
<p>
The main components of the STL are covered in this and the next
chapter. Iterators, adaptors, smart pointers, multi threading and other
features of the STL are discussed in coming sections. Generic
algorithms are covered in the next chapter (<a href="cplusplus19.html#GENERIC">19</a>).
<p>
<em >Allocators</em> take care of the memory allocation within the
STL. The default <a name="an2005"></a>allocator class suffices for most applications, and is
not further discussed in the <strong >C++</strong> Annotations.
<p>
All elements of the STL <a name="an2006"></a> are defined in the
standard namespace. Therefore, a <code >using namespace std</code> or a comparable
directive is required unless it is preferred to specify the required namespace
explicitly. In header files  the <code >std</code> namespace should explicitly
be used (cf. section <a href="cplusplus07.html#NAMESPACEHDR">7.11.1</a>).
<p>
In this chapter the empty <a name="an2007"></a>angle bracket notation is frequently used. In
code a typename must be supplied between the angle brackets. E.g., <code >plus&lt;&gt;</code>
is used in the <strong >C++</strong> Annotations, but in code <code >plus&lt;string&gt;</code> may be encountered.
<p>
<a name="PREDEFINED"></a><a name="l326"></a>
<h2 >18.1: Predefined function objects</h2>
Before using the predefined function objects presented in this section the
<a name="an2008"></a><code >&lt;functional&gt;</code> header file must be included.
<p>
Function objects play important roles in generic
algorithms. For example, there exists a generic algorithm <code >sort</code>
expecting two iterators defining the range of objects that should be sorted,
as well as a function object calling the appropriate comparison operator for
two objects. Let's take a quick look at this situation. Assume strings are
stored in a vector, and we want to sort the vector in descending order. In
that case, sorting the vector <code >stringVec</code> is as simple as:
            <pre>
        sort(stringVec.begin(), stringVec.end(), greater&lt;string&gt;());
</pre>
    The last argument is recognized as a <a name="an2009"></a><em >constructor</em>: it is an
<em >instantiation</em> of the <code >greater&lt;&gt;</code> class template, applied to
<code >strings</code>. This object is called as a function object by the <code >sort</code>
generic algorithm. The generic algorithm calls the function object's
<code >operator()</code> member to compare two <code >string</code> objects. The function object's
<code >operator()</code> will, in turn, call <code >operator&gt;</code> of the <code >string</code> data
type. Eventually, when <code >sort</code> returns, the first element of the vector will
contain the string having the greatest <code >string</code> value of all.
<p>
The function object's <code >operator()</code> itself is <em >not</em> visible at this
point. Don't confuse the parentheses in the `<code >greater&lt;string&gt;()</code>' argument
with calling <code >operator()</code>. When <code >operator()</code> is actually used inside
<code >sort</code>, it receives two arguments: two strings to compare for
`greaterness'. Since <code >greater&lt;string&gt;::operator()</code> is defined <a name="an2010"></a>inline, the
call itself is not actually present in the above <code >sort</code> call.  Instead
<code >sort</code> calls <code >string::operator&gt;</code> through <code >greater&lt;string&gt;::operator()</code>.
<p>
Now that we know that a constructor is passed as argument to (many) generic
algorithms, we can design our own function objects. Assume we want to sort our
vector case-insensitively. How do we proceed? First we note that the default
<code >string::operator&lt;</code> (for an incremental sort) is not appropriate, as it does
case sensitive comparisons. So, we provide our own <code >CaseInsensitive</code> class,
which compares two strings case insensitively. Using the <code >POSIX</code> function
<a name="an2011"></a><code >strcasecmp</code>, the following program performs the trick. It
case-insensitively sorts its command-line arguments in ascending alphabetic
order:
        <pre>
    #include &lt;iostream&gt;
    #include &lt;string&gt;
    #include &lt;cstring&gt;
    #include &lt;algorithm&gt;
    using namespace std;

    class CaseInsensitive
    {
        public:
            bool operator()(string const &amp;left, string const &amp;right) const
            {
                return strcasecmp(left.c_str(), right.c_str()) &lt; 0;
            }
    };
    int main(int argc, char **argv)
    {
        sort(argv, argv + argc, CaseInsensitive{});
        for (int idx = 0; idx &lt; argc; ++idx)
            cout &lt;&lt; argv[idx] &lt;&lt; " ";
        cout &lt;&lt; '\n';
    }
</pre>
    The default constructor of the <code >class CaseInsensitive</code> is used to
provide <code >sort</code> with its final argument. So the only member function that
must be defined is <code >CaseInsensitive::operator()</code>. Since we know it's called
with <code >string</code> arguments, we define it to expect two <code >string</code> arguments,
which are used when calling <code >strcasecmp</code>. Furthermore, the function call
operator <code >operator()</code> is defined <a name="an2012"></a>inline, so that it does not produce
overhead when called by the <code >sort</code> function. The <code >sort</code> function calls the
function object with various combinations of <code >strings</code>. If the compiler
grants our inline requests, it will in fact call <code >strcasecmp</code>, skipping two
extra function calls.
<p>
The comparison function object is often a <a name="an2013"></a><em >predefined function object</em>.
Predefined function object classes are available for many commonly used
operations.  In the following sections the available predefined function
objects are presented, together with some examples showing their use. Near the
end of the section about function objects <a name="an2014"></a><em >function adaptors</em> are
introduced.
<p>
Predefined function objects are used predominantly with generic
algorithms. Predefined function objects exists for arithmetic, relational, and
logical operations. 
<p>
<a name="l327"></a>
<h3 >18.1.1: Arithmetic function objects</h3>
    The <a name="an2015"></a><a name="an2016"></a> arithmetic
function objects support the standard <a name="an2017"></a>arithmetic operations: addition,
subtraction, multiplication, division, modulo and negation. These function
objects invoke the corresponding operators of the data types for which they
are instantiated. For example, for addition the function object <code >plus&lt;Type&gt;</code>
<a name="an2018"></a> is available. If we replace <code >Type</code> by <code >size_t</code> then the addition
operator for <code >size_t</code> values is used, if we replace <code >Type</code> by <code >string</code>,
the addition operator for strings is used. For example:
        <pre>
    #include &lt;iostream&gt;
    #include &lt;string&gt;
    #include &lt;functional&gt;
    using namespace std;

    int main(int argc, char **argv)
    {
        plus&lt;size_t&gt; uAdd;              // function object to add size_ts

        cout &lt;&lt; "3 + 5 = " &lt;&lt; uAdd(3, 5) &lt;&lt; '\n';

        plus&lt;string&gt; sAdd;              // function object to add strings

        cout &lt;&lt; "argv[0] + argv[1] = " &lt;&lt; sAdd(argv[0], argv[1]) &lt;&lt; '\n';
    }
    /*
        Output when called as: a.out going

        3 + 5 = 8
        argv[0] + argv[1] = a.outgoing
    */
</pre>
    Why is this useful? Note that the function object can be used with all
kinds of data types (not only with the predefined datatypes) supporting the
operator called by the function object.
<p>
Suppose we want to perform an operation on a left hand side operand which is
always the same variable and a right hand side argument for which, in turn,
all elements of an array should be used. E.g., we want to compute the sum of
all elements in an array; or we want to concatenate all the strings in a
text-array. In situations like these function objects come in handy.
<p>
As stated, function objects are heavily used in the context of the generic
algorithms, so let's take a quick look ahead at yet another one.
<p>
The generic algorithm <code >accumulate</code> visits all elements specified by an
iterator-range, and performs a requested binary operation on a common element
and each of the elements in the range, returning the accumulated result after
visiting all elements specified by the iterator range. It's easy to use this
algorithm. The next program accumulates all command line arguments and prints
the final string:
        <pre>
    #include &lt;iostream&gt;
    #include &lt;string&gt;
    #include &lt;functional&gt;
    #include &lt;numeric&gt;
    using namespace std;

    int main(int argc, char **argv)
    {
        string result =
                accumulate(argv, argv + argc, string(), plus&lt;string&gt;());

        cout &lt;&lt; "All concatenated arguments: " &lt;&lt; result &lt;&lt; '\n';
    }
</pre>
    The first two arguments define the (iterator) range of elements to visit,
the third argument is <code >string</code>. This anonymous string object provides an
initial value. We could also have used
        <pre>
    string("All concatenated arguments: ")
</pre>
    in which case the <code >cout</code> statement could simply have been
<code >cout &lt;&lt; result &lt;&lt; '\n'</code>.
    The string-addition operation is used, called from <code >plus&lt;string&gt;</code>. The
final concatenated string is returned.
<p>
Now we define a class <code >Time</code>, overloading <a name="an2019"></a><code >operator+</code>. Again, we can
apply the predefined function object <code >plus</code>, now tailored to our newly
defined datatype, to add times:
        <pre>
    #include &lt;iostream&gt;
    #include &lt;string&gt;
    #include &lt;vector&gt;
    #include &lt;functional&gt;
    #include &lt;numeric&gt;
    using namespace std;

    class Time
    {
        friend ostream &amp;operator&lt;&lt;(ostream &amp;str, Time const &amp;time);
        size_t d_days;
        size_t d_hours;
        size_t d_minutes;
        size_t d_seconds;
        public:
            Time(size_t hours, size_t minutes, size_t seconds);
            Time &amp;operator+=(Time const &amp;rhs);
    };
    Time &amp;&amp;operator+(Time const &amp;lhs, Time const &amp;rhs)
    {
        Time ret(lhs);
        return std::move(ret += rhs);
    }
    Time::Time(size_t hours, size_t minutes, size_t seconds)
    :
        d_days(0),
        d_hours(hours),
        d_minutes(minutes),
        d_seconds(seconds)
    {}
    Time &amp;Time::operator+=(Time const &amp;rhs)
    {
        d_seconds   += rhs.d_seconds;
        d_minutes   += rhs.d_minutes   + d_seconds / 60;
        d_hours     += rhs.d_hours     + d_minutes / 60;
        d_days      += rhs.d_days      + d_hours   / 24;
        d_seconds   %= 60;
        d_minutes   %= 60;
        d_hours     %= 24;
        return *this;
    }
    ostream &amp;operator&lt;&lt;(ostream &amp;str, Time const &amp;time)
    {
        return cout &lt;&lt; time.d_days &lt;&lt; " days, " &lt;&lt; time.d_hours &lt;&lt;
                                                    " hours, " &lt;&lt;
                        time.d_minutes &lt;&lt; " minutes and " &lt;&lt;
                        time.d_seconds &lt;&lt; " seconds.";
    }
    int main(int argc, char **argv)
    {
        vector&lt;Time&gt; tvector;

        tvector.push_back(Time( 1, 10, 20));
        tvector.push_back(Time(10, 30, 40));
        tvector.push_back(Time(20, 50,  0));
        tvector.push_back(Time(30, 20, 30));

        cout &lt;&lt;
            accumulate
            (
                tvector.begin(), tvector.end(), Time(0, 0, 0), plus&lt;Time&gt;()
            ) &lt;&lt;
            '\n';
    }
    //  Displays: 2 days, 14 hours, 51 minutes and 30 seconds.
</pre>
    The design of the above program is fairly straightforward.  <code >Time</code>
defines a constructor, it defines an insertion operator and it defines its own
<code >operator+</code>, adding two time objects. In <code >main</code> four <code >Time</code> objects are
stored in a <code >vector&lt;Time&gt;</code> object. Then, <code >accumulate</code> is used to compute
the accumulated time. It returns a <code >Time</code> object, which is inserted into
<code >cout</code>.
<p>
While this section's first example illustrated using a <em >named</em> function
object, the last two examples illustrate how <a name="an2020"></a><em >anonymous</em> objects can be
passed to the (<code >accumulate</code>) function.
<p>
The STL supports the following set of arithmetic function objects.  The
function call operator (<code >operator()</code>) of these function objects calls the
matching arithmetic operator for the objects that are passed to the function
call operator, returning that arithmetic operator's return value. The
arithmetic operator that is actually called is mentioned below:
    <ul>
    <li><a name="an2021"></a><code >plus&lt;&gt;</code>: calls the binary <a name="an2022"></a><code >operator+</code>;
    <li><a name="an2023"></a><code >minus&lt;&gt;</code>: calls the binary <a name="an2024"></a><code >operator-</code>;
    <li><a name="an2025"></a><code >multiplies&lt;&gt;</code>: calls the binary <a name="an2026"></a><code >operator*</code>;
    <li><a name="an2027"></a><code >divides&lt;&gt;</code>: calls <a name="an2028"></a><code >operator/</code>;
    <li><a name="an2029"></a><code >modulus&lt;&gt;</code>:  calls <a name="an2030"></a><code >operator%</code>;
    <li><a name="an2031"></a><code >negate&lt;&gt;</code>: calls the unary <code >operator-</code>. This arithmetic
function object is a unary function object as it expects one argument.
    </ul>
    In the next example the <a name="an2032"></a><code >transform</code> generic algorithm is used to toggle
the signs of all elements of an array. <code >Transform</code>
expects two iterators, defining the range of objects to be transformed; an
iterator defining the begin of the destination range (which may be the same
iterator as the first argument); and a function object defining a unary
operation for the indicated data type.
        <pre>
    #include &lt;iostream&gt;
    #include &lt;string&gt;
    #include &lt;functional&gt;
    #include &lt;algorithm&gt;
    using namespace std;

    int main(int argc, char **argv)
    {
        int iArr[] = { 1, -2, 3, -4, 5, -6 };

        transform(iArr, iArr + 6, iArr, negate&lt;int&gt;());

        for (int idx = 0; idx &lt; 6; ++idx)
            cout &lt;&lt; iArr[idx] &lt;&lt; ", ";
        cout &lt;&lt; '\n';
    }
    // Displays:  -1, 2, -3, 4, -5, 6,
</pre>
<p>
<a name="RELATIONAL"></a><a name="l328"></a>
<h3 >18.1.2: Relational function objects</h3>
    The relational operators are called by the
 <a name="an2033"></a><a name="an2034"></a> relational
function objects. All standard relational operators are supported: <code >==, !=,
&gt;, &gt;=, &lt;</code> and <code >&lt;=</code>.
<p>
The STL supports the following set of relational function objects.  The
function call operator (<code >operator()</code>) of these function objects calls the
matching relational operator for the objects that are passed to the function
call operator, returning that relational operator's return value. The
relational operator that is actually called is mentioned below:
    <ul>
    <li><a name="an2035"></a><code >equal_to&lt;&gt;</code>: calls <a name="an2036"></a><code >operator==</code>;
    <li><a name="an2037"></a><code >not_equal_to&lt;&gt;</code>: calls <a name="an2038"></a><code >operator!=</code>;
    <li><a name="an2039"></a><code >greater&lt;&gt;</code>: calls <a name="an2040"></a><code >operator&gt;</code>;
    <li><a name="an2041"></a><code >greater_equal&lt;&gt;</code>: calls <a name="an2042"></a><code >operator&gt;=</code>;
    <li><a name="an2043"></a><code >less&lt;&gt;</code>: this object's member <code >operator()</code> calls
        <a name="an2044"></a><code >operator&lt;</code>;
    <li><a name="an2045"></a><code >less_equal&lt;&gt;</code>: calls <a name="an2046"></a><code >operator&lt;=</code>.
    </ul>
    An example using the relational function objects in combination with
<a name="an2047"></a><code >sort</code> is:
        <pre>
    #include &lt;iostream&gt;
    #include &lt;string&gt;
    #include &lt;functional&gt;
    #include &lt;algorithm&gt;
    using namespace std;

    int main(int argc, char **argv)
    {
        sort(argv, argv + argc, greater_equal&lt;string&gt;());

        for (int idx = 0; idx &lt; argc; ++idx)
            cout &lt;&lt; argv[idx] &lt;&lt; " ";
        cout &lt;&lt; '\n';

        sort(argv, argv + argc, less&lt;string&gt;());

        for (int idx = 0; idx &lt; argc; ++idx)
            cout &lt;&lt; argv[idx] &lt;&lt; " ";
        cout &lt;&lt; '\n';
    }
</pre>
    The example illustrates how strings may be sorted alphabetically and
reversed alphabetically. By passing <code >greater_equal&lt;string&gt;</code> the strings are
sorted in <em >decreasing</em> order (the first word will be the 'greatest'), by
passing <code >less&lt;string&gt;</code> the strings are sorted in <em >increasing</em> order (the
first word will be the 'smallest').
<p>
Note that <code >argv</code> contains <code >char *</code> values, and that the relational
function object expects a <code >string</code>.  The promotion from <code >char const *</code> to
<code >string</code> is silently performed.
<p>
<a name="l329"></a>
<h3 >18.1.3: Logical function objects</h3>
    The <a name="an2048"></a>logical operators are called by the
 <a name="an2049"></a><a name="an2050"></a> logical function
objects. The standard logical operators are supported: <code >and, or,</code> and
<code >not</code>.
<p>
The STL supports the following set of logical function objects. The
function call operator (<code >operator()</code>) of these function objects calls the
matching logical operator for the objects that are passed to the function
call operator, returning that logical operator's return value. The
logical operator that is actually called is mentioned below:
    <ul>
    <li><a name="an2051"></a><code >logical_and&lt;&gt;</code>: calls <a name="an2052"></a><code >operator&amp;&amp;</code>;
    <li><a name="an2053"></a><code >logical_or&lt;&gt;</code>: calls <a name="an2054"></a><code >operator||</code>;
    <li><a name="an2055"></a><code >logical_not&lt;&gt;</code>: calls <code >operator!</code>.
    </ul>
    An example using <code >operator!</code> is provided in the following trivial
program, using <a name="an2056"></a><code >transform</code>  to transform
the logical values stored in an array:
        <pre>
    #include &lt;iostream&gt;
    #include &lt;string&gt;
    #include &lt;functional&gt;
    #include &lt;algorithm&gt;
    using namespace std;

    int main(int argc, char **argv)
    {
        bool bArr[] = {true, true, true, false, false, false};
        size_t const bArrSize = sizeof(bArr) / sizeof(bool);

        for (size_t idx = 0; idx &lt; bArrSize; ++idx)
            cout &lt;&lt; bArr[idx] &lt;&lt; " ";
        cout &lt;&lt; '\n';

        transform(bArr, bArr + bArrSize, bArr, logical_not&lt;bool&gt;());

        for (size_t idx = 0; idx &lt; bArrSize; ++idx)
            cout &lt;&lt; bArr[idx] &lt;&lt; " ";
        cout &lt;&lt; '\n';
    }
    /*
      Displays:

        1 1 1 0 0 0
        0 0 0 1 1 1
    */
</pre>
<p>
<a name="l330"></a>
<h3 >18.1.4: The `std::not_fn' negator</h3>
    A <a name="an2057"></a><em >negator</em> is a function object toggling the truth value of
a function that's called from the negator: if the function returns <code >true</code>
the negator returns <code >false</code> and vv.
<p>
The standard negator is <code >std::not_fn</code><a name="an2058"></a>, declared in the
<a name="an2059"></a><code >&lt;functional&gt;</code> header file.
<p>
The function <code >not_fn</code> expects a (movable) object as its argument, returning
the negated value of the return value of its argument's function call
operator. 
<p>
As an example consider a <code >main</code> function defining an array of <code >int</code>
values:
        <pre>
    int main()
    {
        int arr[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};
    }
</pre>
<p>
To count the number of even values <code >count_if</code>, using a lambda function can
be used:
        <pre>
        cout &lt;&lt; 
            count_if(arr, arr + size(arr),
                [&amp;](int value)
                {
                    return (value &amp; 1 == 0);
                }
            ) &lt;&lt; '\n';
</pre>
<p>
To count the number of odd values, <code >not_fn</code> can be used in the above code
like so:
        <pre>
        cout &lt;&lt; 
            count_if(arr, arr + size(arr),
                not_fn(
                    [&amp;](int value)
                    {
                        return (value &amp; 1 == 0);
                    }
                )
            ) &lt;&lt; '\n';
</pre>
<p>
Of course, in this simple example the lambda function could also easily have
been modified. But if instead of a lambda function an existing class
implementing a function object had been used it would have been difficult or
impossible to change the behavior of that class. If the class offers moving
operations then <code >not_fn</code> can be used to negate the values returned by that
class's function call operator.
<p>
<a name="ITERATORS"></a><a name="l331"></a>
<h2 >18.2: Iterators</h2>
In addition to the conceptual iterator types presented in this section the STL
defines several adaptors <a name="an2060"></a> allowing objects to
be passed as iterators. These adaptors are presented in the upcoming
sections. Before those adaptors can be used the <a name="an2061"></a><code >&lt;iterator&gt;</code> header file
must be included. 
<p>
Although standard iterators are candidates for 
deprecation&nbsp;(http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0174r1.html#2.1),
    this does not mean that they will (soon) be removed from the <code >std</code>
library. It's probably a suboptimal strategy to `reinvent' your own. Instead,
it is advised to continue using the <code >std::iterator</code> classes until they have
officially been replaced by alternatives.
<p>
Iterators are objects acting like pointers. Iterators have the following
general  <a name="an2062"></a> characteristics:
    <ul>
    <li> Two iterators may be compared for (in)equality using the <code >==</code> and
<code >!=</code> operators. The <em >ordering</em> operators (e.g., <code >&gt;</code>, <code >&lt;</code>)
can usually not be used.
    <li> Given an iterator <code >iter</code>, <code >*iter</code> represents the object the
iterator points to (alternatively, <code >iter-&gt;</code> can be used to reach the members
of the object the iterator points to).
    <li> <code >++iter</code> or <code >iter++</code> advances the iterator to the next
element. The notion of advancing an iterator to the next element is
consequently applied: several containers support <a name="an2063"></a><em >reversed_iterator</em> types,
in which the <code >++iter</code> operation actually reaches a previous element in a
sequence.
    <li> <em >Pointer arithmetic</em> may be used with iterators of containers
storing their elements consecutively in memory like <a name="an2064"></a><code >vector</code> and
<a name="an2065"></a><code >deque</code>. For such containers <code >iter + 2</code> points to the second element
beyond the one to which <code >iter</code> points. See also section <a href="cplusplus18.html#DISTANCE">18.2.1</a>,
covering <a name="an2066"></a><code >std::distance</code>.
    <li> Merely defining an iterator is comparable to having a
        0-pointer. Example:
        <pre>
#include &lt;vector&gt;
#include &lt;iostream&gt;
using namespace std;

int main()
{
    vector&lt;int&gt;::iterator vi;

    cout &lt;&lt; &amp;*vi;       // prints 0
}
</pre>
    </ul>
    STL containers usually define members offering iterators (i.e., they
define their own type <a name="an2067"></a><code >iterator</code>). These members are commonly called
<a name="an2068"></a><code >begin</code> and <a name="an2069"></a><code >end</code> and (for reversed iterators (type <code >reverse_iterator</code>))
<a name="an2070"></a><code >rbegin</code> and <a name="an2071"></a><code >rend</code>.
<p>
Standard practice requires <a name="an2072"></a> iterator ranges to be
<em >left inclusive</em>.  The notation <a name="an2073"></a><code >[left, right)</code> indicates that <code >left</code>
is an iterator pointing to the first element, while <code >right</code> is an iterator
pointing just <em >beyond</em> the last element. The iterator range is <em >empty</em>
when <code >left == right</code>.
<p>
The following example shows how all elements of a vector of strings can be
inserted into <code >cout</code> using its iterator ranges <code >[begin(), end())</code>, and
<code >[rbegin(), rend())</code>. Note that the <code >for-loops</code> for both ranges are
identical. Furthermore it nicely illustrates how the <code >auto</code> keyword can be
used to define the type of the loop control variable instead of using a much
more verbose variable definition like <code >vector&lt;string&gt;::iterator</code> (see also
section <a href="cplusplus03.html#AUTO">3.3.6</a>):
    <pre>
    #include &lt;iostream&gt;
    #include &lt;vector&gt;
    #include &lt;string&gt;
    using namespace std;

    int main(int argc, char **argv)
    {
        vector&lt;string&gt; args(argv, argv + argc);

        for (auto iter = args.begin(); iter != args.end(); ++iter)
            cout &lt;&lt; *iter &lt;&lt; " ";
        cout &lt;&lt; '\n';

        for (auto iter = args.rbegin(); iter != args.rend(); ++iter)
            cout &lt;&lt; *iter &lt;&lt; " ";
        cout &lt;&lt; '\n';
    }
</pre>
<p>
Furthermore, the STL defines
 <a name="an2074"></a><a name="an2075"></a><em >const_iterator</em> types that must be used
when visiting a series of elements in a constant container. Whereas the
elements of the vector in the previous example could have been altered, the
elements of the vector in the next example are immutable, and
<code >const_iterator</code>s are required:
        <pre>
    #include &lt;iostream&gt;
    #include &lt;vector&gt;
    #include &lt;string&gt;
    using namespace std;

    int main(int argc, char **argv)
    {
        vector&lt;string&gt; const args(argv, argv + argc);

        for
        (
            vector&lt;string&gt;::const_iterator iter = args.begin();
                iter != args.end();
                    ++iter
        )
            cout &lt;&lt; *iter &lt;&lt; " ";
        cout &lt;&lt; '\n';

        for
        (
            vector&lt;string&gt;::const_reverse_iterator iter = args.rbegin();
                iter != args.rend();
                    ++iter
        )
            cout &lt;&lt; *iter &lt;&lt; " ";
        cout &lt;&lt; '\n';
    }
</pre>
    The examples also illustrate that plain
 <a name="an2076"></a> pointers can be used as iterators. The
initialization <code >vector&lt;string&gt; args(argv, argv + argc)</code> provides the
<code >args</code> vector with a pair of pointer-based iterators: <code >argv</code> points to the
first element to initialize <code >args</code> with, <code >argv + argc</code> points just beyond
the last element to be used, <code >++argv</code> reaches the next command line
argument. This is a general pointer characteristic, which is why they too can
be used in situations where <code >iterators</code> are expected.
<p>
The STL defines five types <a name="an2077"></a> of iterators. These
iterator types are expected by generic algorithms, and in order to create a
particular type of iterator yourself it is important to know their
characteristics. In general, iterators <a name="an2078"></a> (see also
section <a href="cplusplus22.html#ITERATORCONS">22.14</a>) must define:
    <ul>
    <li><a name="an2079"></a><code >operator==</code>, testing two iterators for equality,
    <li><a name="an2080"></a><code >operator!=</code>, testing two iterators for inequality,
    <li><a name="an2081"></a><code >operator++</code>, incrementing the iterator, as prefix operator,
    <li><a name="an2082"></a><code >operator*</code>, to access the element the iterator refers to,
    </ul>
    The following types of iterators are used when describing generic
algorithms  in chapter <a href="cplusplus19.html#GENERIC">19</a>:
    <ul>
    <li> <a name="an2083"></a><strong >InputIterator</strong><strong >s</strong>:
        <blockquote >InputIterators are used to read from a container.  The
dereference operator is guaranteed to work as <a name="an2084"></a><code >rvalue</code> in
expressions. Instead of an InputIterator it is also possible to use (see
below) Forward-, Bidirectional- or RandomAccessIterators.  Notations like
<a name="an2085"></a><code >InputIterator1</code> and <a name="an2086"></a><code >InputIterator2</code> may be used as well. In these cases,
numbers are used to indicate which iterators `belong together'. E.g., the
generic algorithm <a href="cplusplus19.html#INNERPROD"><code >inner_product</code></a> has the following
prototype:
        <pre>
Type inner_product(InputIterator1 first1, InputIterator1 last1,
               InputIterator2 first2, Type init);
</pre>
    <code >InputIterator1 first1</code> and <code >InputIterator1 last1</code> define a pair of
input iterators on one range, while <code >InputIterator2 first2</code> defines the
beginning of another range. Analogous notations may be used with other
iterator types.</blockquote>
    <li> <a name="an2087"></a><strong >OutputIterator</strong><strong >s</strong>:
        <blockquote >OutputIterators can be used to write to a container. The
dereference operator is guaranteed to work as an <a name="an2088"></a><code >lvalue</code> in expressions,
but not necessarily as <code >rvalue</code>. Instead of an OutputIterator it is also
possible to use (see below) Forward-, Bidirectional- or
RandomAccessIterators.</blockquote>
    <li> <a name="an2089"></a><strong >ForwardIterator</strong><strong >s</strong>:
        <blockquote >ForwardIterators combine InputIterators and
OutputIterators. They can be used to traverse containers in one direction,
for reading and/or writing. Instead of a ForwardIterator it is also possible
to use (see below) Bidirectional- or RandomAccessIterators.</blockquote>
    <li> <a name="an2090"></a><strong >BidirectionalIterator</strong><strong >s</strong>:
        <blockquote >BidirectionalIterators can be used to traverse containers in
both directions, for reading and writing. Instead of a BidirectionalIterator
it is also possible to use (see below) a RandomAccessIterator.</blockquote>
    <li> <a name="an2091"></a><strong >RandomAccessIterator</strong><strong >s</strong>:
        <blockquote >RandomAccessIterators provide <a name="an2092"></a>random access to container
elements. An algorithm like <a href="cplusplus19.html#SORT"><code >sort</code></a> requires a
RandomAccessIterator, and can therefore <em >not</em> be used to sort the elements
of lists or maps, which only provide BidirectionalIterators.</blockquote>
    </ul>
    The example given with the RandomAccessIterator illustrates how to relate
iterators and generic algorithms: look for the iterator that's required by the
(generic) algorithm, and then see whether the datastructure supports the
required type of iterator. If not, the algorithm cannot be used with the
particular datastructure.
<p>
<a name="DISTANCE"></a><a name="l332"></a>
<h3 >18.2.1: std::distance and std::size</h3>
    Earlier, in section <a href="cplusplus18.html#ITERATORS">18.2</a> it was stated that iterators support
pointer arithmetic for containers storing their elements consecutively in
memory. This is not completely true: to determine the number of elements
between the elements to which two iterators refer the iterator must 
support the subtraction operator.  
<p>
Using pointer arithmetic to compute the number of elements between two
iterators in, e.g., a <code >std::list</code> or <code >std::unordered_map</code> is not possible,
as these containers do not store their elements consecutively in memory.
<p>
The function <code >std::distance</code><a name="an2093"></a> fills in that little gap:
<code >std::distance</code> expects two InputIterators and returns the number of
elements between them.
<p>
Before using <code >distance</code> the <a name="an2094"></a><code >&lt;iterator&gt;</code> header file must be included.
<p>
If the iterator specified as first argument exceeds the iterator specified as
its second argument then the number of elements is non-positive, otherwise it
is non-negative. If the number of elements cannot be determined (e.g., the
iterators do not refer to elements in the same container), then <code >distance's</code>
return value is undefined.
<p>
Example:
        <pre>
    #include &lt;iostream&gt;
    #include &lt;unordered_map&gt;
        
    using namespace std;
    
    int main()
    {
        unordered_map&lt;int, int&gt; myMap = {{1, 2}, {3, 5}, {-8, 12}};
    
        cout &lt;&lt; distance(++myMap.begin(), myMap.end()) &lt;&lt; '\n'; // shows: 2
    }
</pre>
<p>
The <code >iterator</code> header file also defines the function <code >std::size</code><a name="an2095"></a>,
returning the number of elements in a containers (as returned by the
container's <code >size</code> member) or of an array whose dimension is known to the
compiler at the point of <code >std::size's</code> call. E.g., if the size of an array
<code >data</code> is known to the compiler, then to call a function <code >handler</code>
(expecting the address of the first element of an array and the address of the
location just beyond that array) the following statement can be used:
        <pre>
    handler(data, data + std::size(data));
</pre>
    As noted, the <code >std::size</code> function is defined in the <code >iterator</code>
header. However, it's also guaranteed available when including the header file
of a container supporting iterators (including the <code >string</code> header file).
<p>
<a name="INSERTER"></a><a name="l333"></a>
<h3 >18.2.2: Insert iterators</h3>
    Generic algorithms often require a target container into which the results of
the algorithm are deposited. For example, the <a href="cplusplus19.html#COPY"><code >copy</code></a> generic
algorithm has three parameters. The first two define the range of visited
elements, the third defines the first position where the results
of the copy operation should be stored.
<p>
With the <code >copy</code> algorithm the number of elements to copy is usually
available beforehand, since that number can usually be provided by pointer
arithmetic. However, situations exist where pointer arithmetic cannot be
used. Analogously, the number of resulting elements sometimes differs from the
number of elements in the initial range. The generic algorithm
<a href="cplusplus19.html#UNIQUECP"><code >unique_copy</code></a> is a case in point. Here the number of
elements that are copied to the destination container is normally not known
beforehand.
<p>
In situations like these an <a name="an2096"></a><em >inserter</em> <a name="an2097"></a> adaptor
function can often be used to create elements in the destination container.
There are three types of inserter adaptors:
    <ul>
    <li><a name="an2098"></a><code >back_inserter</code>: calls the container's <a name="an2099"></a><code >push_back</code> member to add
new elements at the end of the container. E.g., to copy all elements of
<code >source</code> in reversed order to the back of <code >destination</code>, using the
<a href="cplusplus19.html#COPY"><code >copy</code></a> generic algorithm:
        <pre>
copy(source.rbegin(), source.rend(), back_inserter(destination));
</pre>
    <li><a name="an2100"></a><code >front_inserter</code> calls the container's <a name="an2101"></a><code >push_front</code> member, adding
new elements at the beginning of the container. E.g., to copy all elements of
<code >source</code> to the front of the destination container (thereby also reversing
the order of the elements):
        <pre>
copy(source.begin(), source.end(), front_inserter(destination));
</pre>
    <li><a name="an2102"></a><code >inserter</code> calls the container's <a name="an2103"></a><code >insert</code> member adding new elements
starting at a specified starting point. E.g., to copy all elements of
<code >source</code> to the destination container, starting at the beginning of
<code >destination</code>, shifting up existing elements to beyond the newly inserted
elements:
        <pre>
copy(source.begin(), source.end(), inserter(destination,
    destination.begin()));
</pre>
    </ul>
    The inserter adaptors
 <a name="an2104"></a> <a name="an2105"></a>
 require the existence of two <code >typedef</code>s:
    <ul>
    <li><code >typedef Data value_type</code>, where <code >Data</code> is the data type stored in
the class offering <code >push_back, push_front</code> or <code >insert</code> members (Example:
<code >typedef std::string value_type</code>);
    <li><code >typedef value_type const &amp;const_reference</code>
    </ul>
    Concentrating on <code >back_inserter</code>, this iterator expects the name of a
container supporting a member <code >push_back</code>. The inserter's <code >operator()</code>
member calls the container's <code >push_back</code> member. Objects
 <a name="an2106"></a> of any class supporting a <code >push_back</code>
member can be passed as arguments to <code >back_inserter</code> provided the class adds
        <pre>
    typedef DataType const &amp;const_reference;
</pre>
    to its interface (where <code >DataType const &amp;</code> is the type of the parameter
of the class's member <code >push_back</code>). Example:
        <pre>
    #include &lt;iostream&gt;
    #include &lt;algorithm&gt;
    #include &lt;iterator&gt;
    using namespace std;

    class Insertable
    {
        public:
            typedef int value_type;
            typedef int const &amp;const_reference;

            void push_back(int const &amp;)
            {}
    };

    int main()
    {
        int arr[] = {1};
        Insertable insertable;

        copy(arr, arr + 1, back_inserter(insertable));
    }
</pre>
<p>
<a name="ISTREAMITERATORS"></a><a name="l334"></a>
<h3 >18.2.3: Iterators for `istream' objects</h3>
    The <a name="an2107"></a><code >istream_iterator&lt;Type&gt;</code> can be used to define a set
of iterators for
 <a name="an2108"></a> <code >istream</code> objects. The general form of the
<code >istream_iterator</code> iterator is:
        <pre>
    istream_iterator&lt;Type&gt; identifier(istream &amp;in)
</pre>
    Here, <code >Type</code> is the type of the data elements read from the <code >istream</code>
stream. It is used as the `begin' iterator in an iterator range. <code >Type</code> may
be any type for which <code >operator</code>&gt;&gt; is defined in combination with <code >istream</code>
objects.
<p>
The default constructor is used as the end-iterator and corresponds to the
 <a name="an2109"></a>end-of-stream. For example,
        <pre>
    istream_iterator&lt;string&gt; endOfStream;
</pre>
    The <em >stream</em> object that was specified when defining the
begin-iterator is <em >not</em> mentioned with the default constructor.
<p>
Using <code >back_inserter</code> and <code >istream_iterator</code> adaptors, all strings
from a stream can easily be stored in a container. Example (using <a name="an2110"></a>anonymous
<code >istream_iterator</code> adaptors):
        <pre>
    #include &lt;iostream&gt;
    #include &lt;iterator&gt;
    #include &lt;string&gt;
    #include &lt;vector&gt;
    #include &lt;algorithm&gt;
    using namespace std;

    int main()
    {
        vector&lt;string&gt; vs;

        copy(istream_iterator&lt;string&gt;(cin), istream_iterator&lt;string&gt;(),
             back_inserter(vs));

        for
        (
            vector&lt;string&gt;::const_iterator begin = vs.begin(), end = vs.end();
                begin != end; ++begin
        )
            cout &lt;&lt; *begin &lt;&lt; ' ';
        cout &lt;&lt; '\n';
    }
</pre>
<p>
<a name="l335"></a>
<h4>18.2.3.1: Iterators for `istreambuf' objects</h4>
        Input iterators are also available for <a name="an2111"></a><code >streambuf</code> objects.
<p>
To read from <code >streambuf</code> objects supporting input operations
 <a name="an2112"></a><code >istreambuf_iterators</code> can be used, supporting the
operations that are also available for <code >istream_iterator</code>. Different from
the latter iterator type <code >istreambuf_iterators</code> support three constructors:
    <ul>
    <li><code >istreambuf_iterator&lt;Type&gt;</code>:<blockquote >The end iterator of an iterator range is created using the default
<code >istreambuf_iterator</code> constructor. It represents the <a name="an2113"></a>end-of-stream
condition when extracting values of type <code >Type</code> from the <code >streambuf</code>.
        </blockquote>
    <li><code >istreambuf_iterator&lt;Type&gt;(streambuf *)</code>:<blockquote >A pointer to a <code >streambuf</code> may be used when defining an
<code >istreambuf_iterator</code>. It represents the begin iterator of an iterator
range.</blockquote>
    <li><code >istreambuf_iterator&lt;Type&gt;(istream)</code>:<blockquote >An <em >istream</em> may be also used when defining an
<code >istreambuf_iterator</code>. It accesses the <code >istream</code>'s <code >streambuf</code> and it
also represents the begin iterator of an iterator range.</blockquote>
    </ul>
    In section <a href="cplusplus18.html#OSTREAMBUFITER">18.2.4.1</a> an example is given using both
<code >istreambuf_iterators</code> and <code >ostreambuf_iterators</code>.
<p>
<a name="l336"></a>
<h3 >18.2.4: Iterators for `ostream' objects</h3>
    An <a name="an2114"></a><code >ostream_iterator&lt;Type&gt;</code> adaptor can be used to pass
an <code >ostream</code> to algorithms expecting an OutputIterator. Two constructors are
available for defining <code >ostream_iterators</code>:
        <pre>
    ostream_iterator&lt;Type&gt; identifier(ostream &amp;outStream);
    ostream_iterator&lt;Type&gt; identifier(ostream &amp;outStream, char const *delim);
</pre>
    <code >Type</code> is the type of the data elements that should be inserted into an
<code >ostream</code>. It may be any type for which <code >operator</code>&lt;&lt; is defined in
combination with <code >ostream</code> objects.  The latter constructor can be used to
separate the individual <code >Type</code> data elements by <a name="an2115"></a><code >delimiter</code> strings. The
former constructor does not use any delimiters.
<p>
The example shows how <a href="cplusplus18.html#ISTREAMITERATORS"><code >istream_iterators</code></a> and an
<code >ostream_iterator</code> may be used to copy information of a file to another
file. A subtlety here is that you probably want to use
<code >in.unsetf(ios::skipws)</code>. It is used to clear the
 <a name="an2116"></a><code >ios::skipws</code> flag. As a consequence whitespace characters are
simply returned by the operator, and the file is copied character by
character. Here is the program:
        <pre>
    #include &lt;iostream&gt;
    #include &lt;algorithm&gt;
    #include &lt;iterator&gt;
    using namespace std;

    int main()
    {
        cin.unsetf(ios::skipws);
        copy(istream_iterator&lt;char&gt;(cin), istream_iterator&lt;char&gt;(),
             ostream_iterator&lt;char&gt;(cout));
    }
</pre>
<p>
<a name="OSTREAMBUFITER"></a><a name="l337"></a>
<h4>18.2.4.1: Iterators for `ostreambuf' objects</h4>
        Output iterators are also available for <a name="an2117"></a><code >streambuf</code> objects.
<p>
To write to  <code >streambuf</code> objects supporting output operations
 <a name="an2118"></a><code >ostreambuf_iterators</code> can be used, supporting the
operations that are also available for
<code >ostream_iterator</code>. <code >Ostreambuf_iterators</code> support two constructors:
    <ul>
    <li><code >ostreambuf_iterator&lt;Type&gt;(streambuf *)</code>:<blockquote >A pointer to a <code >streambuf</code> may be used when defining an
<code >ostreambuf_iterator</code>. It can be used as an OutputIterator.</blockquote>
    <li><code >ostreambuf_iterator&lt;Type&gt;(ostream)</code>:<blockquote >An <em >ostream</em> may be also used when defining an
<code >ostreambuf_iterator</code>. It accesses the <code >ostream</code>'s <code >streambuf</code> and it
can also be used as an OutputIterator.</blockquote>
    </ul>
    The next example illustrates the use of both
 <a name="an2119"></a><code >istreambuf_iterators</code> and <code >ostreambuf_iterators</code>
when copying a stream in yet another way. Since the stream's <code >streambuf</code>s
are directly accessed the streams and stream flags are bypassed. Consequently
there is no need to clear <code >ios::skipws</code> as in the previous section, while
the next program's efficiency probably also exceeds the efficiency of the
program shown in the previous section.
        <pre>
    #include &lt;iostream&gt;
    #include &lt;algorithm&gt;
    #include &lt;iterator&gt;
    using namespace std;

    int main()
    {
        istreambuf_iterator&lt;char&gt; in(cin.rdbuf());
        istreambuf_iterator&lt;char&gt; eof;
        ostreambuf_iterator&lt;char&gt; out(cout.rdbuf());

        copy(in, eof, out);
    }
</pre>
<p>
<a name="UNIQUEPTR"></a><a name="l338"></a>
<h2 >18.3: The class 'unique_ptr'</h2>
Before using the <code >unique_ptr</code> class presented in this section the
<a name="an2120"></a><code >&lt;memory&gt;</code> header file must be included.
<p>
When pointers are used to access dynamically allocated memory strict
bookkeeping is required to prevent memory leaks. When a pointer variable
referring to dynamically allocated memory goes out of scope, the dynamically
allocated memory becomes inaccessible and the program suffers from a 
    <a name="an2121"></a>memory leak.
    Consequently, the programmer has to make sure that the dynamically
allocated memory is returned to the common pool just before the pointer
variable goes out of scope.
<p>
When a pointer variable points to a dynamically allocated single value or
object, bookkeeping requirements are greatly simplified when the pointer
variable is defined as a <code >std::unique_ptr</code><a name="an2122"></a> object.
<p>
Unique_ptrs are <em >objects</em> masquerading as pointers. Since they are objects,
their destructors are called when they go out of scope.  Their destructors
automatically delete the dynamically allocated memory to which they
point. Unique_ptrs (and their cousins shared_ptrs (cf. section <a href="cplusplus18.html#SHAREDPTR">18.4</a>)
are also called
    <a name="an2123"></a><em >smart pointers</em>).
<p>
<code >Unique_ptrs</code> have several special characteristics:
    <ul>
    <li> when assigning a <code >unique_ptr</code> to another <em >move semantics</em> is
used. If move semantics is not available compilation fails. On the other
hand, if compilation succeeds then the used containers or generic algorithms
support the use of <code >unique_ptr</code>s. Here is an example:
        <pre>
std::unique_ptr&lt;int&gt; up1(new int);
std::unique_ptr&lt;int&gt; up2(up1);      // compilation error
</pre>
    The second definition fails to compile as <code >unique_ptr</code>'s copy
constructor is private (the same holds true for the assignment operator). But
the <code >unique_ptr</code> class <em >does</em> offer facilities to initialize and assign
from <em >rvalue references</em>:
        <pre>
class unique_ptr                        // interface partially shown
{
    public:
        unique_ptr(unique_ptr &amp;&amp;tmp);   // rvalues bind here
    private:
        unique_ptr(const unique_ptr &amp;other);
};
</pre>
    In the next example move semantics is used and so it compiles correctly:
        <pre>
unique_ptr&lt;int&gt; cp(unique_ptr&lt;int&gt;(new int));
</pre>
<p>
<li> a <code >unique_ptr</code> object should only point to memory that was made
available dynamically, as only dynamically allocated memory can be deleted.
<p>
<li> multiple <code >unique_ptr</code> objects should not be allowed to point to the
same block of dynamically allocated memory. The <code >unique_ptr</code>'s interface was
designed to prevent this from happening. Once a <code >unique_ptr</code> object goes out
of scope, it deletes the memory it points to, immediately changing any other
object also pointing to the allocated memory into a <a name="an2124"></a> wild
pointer.
<p>
<li> When a class <code >Derived</code> is derived from <code >Base</code>, then a newly
allocated <code >Derived</code> class object can be assigned to a <code >unique_ptr&lt;Base&gt;</code>,
without having to define a virtual destructor for <code >Base</code>. The <code >Base *</code>
pointer that is returned by the <code >unique_ptr</code> object can simply be cast
statically to <code >Derived</code>, and <code >Derived's</code> destructor is automatically
called as well, if the <code >unique_ptr</code> definition is provided with a
<em >deleter</em> function address. This is illustrated in the next example:
        <pre>
    class Base
    { ... };
    class Derived: public Base
    {
        ...
        public:
            // assume Derived has a member void process()
   
            static void deleter(Base *bp);
    };
    void Derived::deleter(Base *bp)
    {
        delete static_cast&lt;Derived *&gt;(bp);
    }
    int main()
    {
        unique_ptr&lt;Base, void (*)(Base *)&gt; bp(new Derived, &amp;Derived::deleter);
        static_cast&lt;Derived *&gt;(bp.get())-&gt;process(); // OK!

    } // here ~Derived is called: no polymorphism required.
</pre>
    </ul>
    The class <code >unique_ptr</code> offers several member functions to access the
pointer itself or to have a <code >unique_ptr</code> point to another block of
memory. These member functions (and <code >unique_ptr</code> constructors) are
introduced in the next few sections.
<p>
<code >Unique_ptr</code> can also be used with containers and (generic) algorithms. They
can properly destruct any type of object, as their constructors accept
customizable deleters. In addition, arrays can be handled by <code >unique_ptrs</code>.
<p>
<a name="l339"></a>
<h3 >18.3.1: Defining `unique_ptr' objects</h3>
    There are three ways to <a name="an2125"></a> define <code >unique_ptr</code>
objects. Each definition contains the usual <code >&lt;type&gt;</code> specifier between
angle brackets:
    <ul>
    <li> The default constructor simply creates a <code >unique_ptr</code> object that
does not point to a particular block of memory. Its pointer is initialized to
0 (zero):
        <pre>
unique_ptr&lt;type&gt; identifier;
</pre>
    This form is discussed in section <a href="cplusplus18.html#UNIQUEPLAIN">18.3.2</a>.
    <li> The <em >move constructor</em>  initializes an <code >unique_ptr</code> object.
Following the use of the move constructor its <code >unique_ptr</code> argument no
longer points to the dynamically allocated memory and its pointer data member
is turned into a zero-pointer:
        <pre>
unique_ptr&lt;type&gt; identifier(another unique_ptr for type);
</pre>
    This form is discussed in section <a href="cplusplus18.html#UNIQUEMOVE">18.3.3</a>.
    <li> The form that is used most often initializes a <code >unique_ptr</code> object
to the block of dynamically allocated memory that is passed to the object's
constructor. Optionally <a name="an2126"></a><code >deleter</code> can be provided. A (free) function (or
function object) receiving the <code >unique_ptr</code>'s pointer as its argument can be
passed as deleter. It is supposed to return the dynamically allocated
memory to the common pool (doing nothing if the pointer equals zero).
        <pre>
unique_ptr&lt;type&gt; identifier (new-expression [, deleter]);
</pre>
    This form is discussed in section <a href="cplusplus18.html#UNIQUENEW">18.3.4</a>.
    </ul>
<p>
<a name="UNIQUEPLAIN"></a><a name="l340"></a>
<h3 >18.3.2: Creating a plain `unique_ptr'</h3>
    <code >Unique_ptr</code>'s default constructor defines a <a name="an2127"></a>
<code >unique_ptr</code> not pointing to a particular block of memory:
        <pre>
    unique_ptr&lt;type&gt; identifier;
</pre>
    The <a name="an2128"></a> pointer controlled by the <code >unique_ptr</code>
object is initialized to <code >0</code> (zero). Although the <code >unique_ptr</code> object
itself is not the pointer, its value <em >can</em> be compared to <code >0</code>. Example:
        <pre>
    unique_ptr&lt;int&gt; ip;

    if (!ip)
        cout &lt;&lt; "0-pointer with a unique_ptr object\n";
</pre>
    Alternatively, the member <a name="an2129"></a><code >get</code> can be used (cf. section <a href="cplusplus18.html#UNIQUEMEM">18.3.5</a>).
<p>
<a name="UNIQUEMOVE"></a><a name="l341"></a>
<h3 >18.3.3: Moving  another `unique_ptr'</h3>
        A <code >unique_ptr</code> <a name="an2130"></a> may be initialized
using an rvalue reference to a <code >unique_ptr</code> object for the same type:
        <pre>
    unique_ptr&lt;type&gt; identifier(other unique_ptr object);
</pre>
    The move constructor is used, e.g., in the following example:
        <pre>
    void mover(unique_ptr&lt;string&gt; &amp;&amp;param)
    {
        unique_ptr&lt;string&gt; tmp(move(param));
    }
</pre>
    Analogously, the assignment operator can <a name="an2131"></a> be
used. A <code >unique_ptr</code> object may be assigned to a temporary  <code >unique_ptr</code>
object of the same type (again move-semantics is used). For example:
        <pre>
    #include &lt;iostream&gt;
    #include &lt;memory&gt;
    #include &lt;string&gt;

    using namespace std;

    int main()
    {
        unique_ptr&lt;string&gt; hello1(new string("Hello world"));
        unique_ptr&lt;string&gt; hello2(move(hello1));
        unique_ptr&lt;string&gt; hello3;

        hello3 = move(hello2);
        cout &lt;&lt; // *hello1 &lt;&lt; '\n' &lt;&lt;   // would have segfaulted
                // *hello2 &lt;&lt; '\n' &lt;&lt;   // same
                *hello3 &lt;&lt; '\n';
    }
    // Displays:    Hello world
</pre>
    The example illustrates that
    <ul>
    <li> <code >hello1</code> is initialized by a pointer to a dynamically allocated
<code >string</code> (see the next section).
    <li> The <code >unique_ptr hello2</code> grabs the pointer controlled by <code >hello1</code>
using a move constructor. This effectively changes <code >hello1</code> into a
0-pointer.
    <li> Then <code >hello3</code> is defined as a default <code >unique_ptr&lt;string&gt;</code>. But
then it grabs its value using move-assignment from <code >hello2</code> (which, as a
consequence, is changed into a 0-pointer).
    </ul>
    If <code >hello1</code> or <code >hello2</code> had been inserted into <code >cout</code> a
<a name="an2132"></a><em >segmentation fault</em> would have resulted. The reason for this should now be
clear: it is caused by dereferencing 0-pointers. In the end, only <code >hello3</code>
actually points to the originally allocated <code >string</code>.
<p>
<a name="UNIQUENEW"></a><a name="l342"></a>
<h3 >18.3.4: Pointing to a newly allocated object</h3>
    A <code >unique_ptr</code> <a name="an2133"></a> is most often initialized
using a pointer to dynamically allocated memory. The generic form is:
        <pre>
    unique_ptr&lt;type [, deleter_type]&gt; identifier(new-expression
            [, deleter = deleter_type{}]);
</pre>
    The second (template) argument (<code >deleter(_type)</code>) is optional and may
 <a name="an2134"></a> refer to a free function or function object handling the
destruction of the allocated memory. A deleter is used, e.g., in situations
where a double pointer is allocated and the destruction must visit each nested
pointer to destroy the allocated memory (see below for an illustration).
<p>
Here is an example initializing a <code >unique_ptr</code> pointing to a <code >string</code>
object:
        <pre>
    unique_ptr&lt;string&gt; strPtr(new string("Hello world"));
</pre>
    The argument that is passed to the constructor is the pointer returned by
<code >operator new</code>. Note that <code >type</code> does <em >not</em> mention the pointer.  The
<a name="an2135"></a> type that is used in the <code >unique_ptr</code> construction
is the same as the type that is used in <code >new</code> expressions.
<p>
Here is an example showing how an explicitly defined deleter may be used to
delete a dynamically allocated array of pointers to strings:
        <pre>
    #include &lt;iostream&gt;
    #include &lt;string&gt;
    #include &lt;memory&gt;
    using namespace std;

    struct Deleter
    {
        size_t d_size;
        Deleter(size_t size = 0)
        :
            d_size(size)
        {}
        void operator()(string **ptr) const
        {
            for (size_t idx = 0; idx &lt; d_size; ++idx)
                delete ptr[idx];
            delete[] ptr;
        }
    };
    int main()
    {
        unique_ptr&lt;string *, Deleter&gt; sp2{ new string *[10], Deleter{ 10 } };

        Deleter &amp;obj = sp2.get_deleter();
    }
</pre>
<p>
A <code >unique_ptr</code> can be used to reach the
 <a name="an2136"></a> member functions that are available for
objects allocated by the <code >new</code> expression.  These members can be reached as
if the <code >unique_ptr</code> was a plain pointer to the dynamically allocated
object. For example, in the following program the text `<code >C++</code>' is inserted
behind the word `<code >hello</code>':
        <pre>
    #include &lt;iostream&gt;
    #include &lt;memory&gt;
    #include &lt;cstring&gt;
    using namespace std;

    int main()
    {
        unique_ptr&lt;string&gt; sp(new string("Hello world"));

        cout &lt;&lt; *sp &lt;&lt; '\n';
        sp-&gt;insert(strlen("Hello "), "C++ ");
        cout &lt;&lt; *sp &lt;&lt; '\n';
    }
    /*
        Displays:
            Hello world
            Hello C++ world
    */
</pre>
<p>
<a name="UNIQUEMEM"></a><a name="l343"></a>
<h3 >18.3.5: Operators and members</h3>
    The class <code >unique_ptr</code> offers the  following
 <a name="an2137"></a> operators:
    <ul>
    <li><a name="an2138"></a><code >unique_ptr&lt;Type&gt; &amp;operator=(unique_ptr&lt;Type&gt; &amp;&amp;tmp)</code>:<blockquote >This operator transfers the memory pointed to by the <a name="an2139"></a>rvalue
        <code >unique_ptr</code> object to the <a name="an2140"></a>lvalue <code >unique_ptr</code> object using
        <em >move semantics</em>. So, the rvalue object <em >loses</em> the memory it
        pointed at and turns into a 0-pointer. An existing <code >unique_ptr</code> may
        be assigned to another <code >unique_ptr</code> by converting it to an rvalue
        reference first using <code >std::move</code>. Example:
   <pre>
unique_ptr&lt;int&gt; ip1(new int);
unique_ptr&lt;int&gt; ip2;

ip2 = std::move(ip1);
</pre>
    </blockquote>
    <li><a name="an2141"></a><code >operator bool() const</code>:<blockquote >This operator returns <code >false</code> if the <code >unique_ptr</code> does not point
        to memory (i.e., its <code >get</code> member, see below, returns 0). Otherwise,
        <code >true</code> is returned.</blockquote>
    <li><a name="an2142"></a><code >Type &amp;operator*()</code>:<blockquote >This operator returns a reference to the information accessible via
        a <code >unique_ptr</code> object . It acts like a normal pointer dereference
        operator.</blockquote>
    <li><a name="an2143"></a><code >Type *operator-&gt;()</code>:<blockquote >This operator returns a pointer to the information accessible via a
        <code >unique_ptr</code> object. This operator allows you to select
        members of an object accessible via a <code >unique_ptr</code> object. Example:
   <pre>
unique_ptr&lt;string&gt; sp(new string("hello"));
cout &lt;&lt; sp-&gt;c_str();
</pre>
        </blockquote>
    </ul>
<p>
The class <code >unique_ptr</code> supports the following <a name="an2144"></a>
member functions:
    <ul>
    <li><a name="an2145"></a><code >Type *get()</code>:<blockquote >A pointer to the information controlled by the <code >unique_ptr</code> object
        is returned. It acts like <code >operator-&gt;</code>. The returned pointer can be
        inspected. If it is zero the <code >unique_ptr</code> object does not point to
        any memory.</blockquote>
    <li><a name="an2146"></a><code >Deleter &amp;unique_ptr&lt;Type&gt;::get_deleter()</code>:<blockquote >A reference to the deleter object used by the <code >unique_ptr</code> is
        returned.</blockquote>
    <li><a name="an2147"></a><code >Type *release()</code>:<blockquote >A pointer to the information accessible via a <code >unique_ptr</code> object is
        returned. At the same time the object itself becomes a 0-pointer
        (i.e., its pointer data member is turned into a 0-pointer). This
        member can be used to transfer the information accessible via a
        <code >unique_ptr</code> object to a plain <code >Type</code> pointer. After calling this
        member the proper destruction of the dynamically allocated memory
        is the <a name="an2148"></a>responsibility of the programmer.</blockquote>
    <li><a name="an2149"></a><code >void reset(Type *)</code>:<blockquote >The dynamically allocated memory controlled by the <code >unique_ptr</code>
        object is returned to the common pool; the object thereupon controls
        the memory  to which the argument that is passed to the function
        points. It can also be called without argument, turning the object
        into a 0-pointer. This member function can be used to assign a new
        block of dynamically allocated memory to a <code >unique_ptr</code> object.</blockquote>
    <li><a name="an2150"></a><code >void swap(unique_ptr&lt;Type&gt; &amp;)</code>:<blockquote >Two identically typed <code >unique_ptrs</code> are swapped.</blockquote>
    </ul>
<p>
<a name="l344"></a>
<h3 >18.3.6: Using `unique_ptr' objects for arrays</h3>
    When a <code >unique_ptr</code> is used to store arrays the dereferencing operator makes
little sense but with arrays <code >unique_ptr</code> objects benefit from index
operators. The distinction between a single object <code >unique_ptr</code> and a
<code >unique_ptr</code> referring to a dynamically allocated array of objects is
realized through a template specialization.
<p>
With dynamically allocated arrays the following syntax is available:
    <ul>
    <li> the index (<code >[]</code>) notation is used to specify that the smart
        pointer controls a dynamically allocated <em >array</em>. Example:
            <pre>
unique_ptr&lt;int[]&gt; intArr(new int[3]);
</pre>
    <li> the index operator can be used to access the array's
        elements. Example:
            <pre>
intArr[2] = intArr[0];
</pre>
    </ul>
    In these cases the smart pointer's destructors call
<code >delete[]</code> rather than <code >delete</code>.
<p>
<a name="SHAREDPTR"></a><a name="l345"></a>
<h2 >18.4: The class `shared_ptr'</h2>
In addition to the class <code >unique_ptr</code> the class
<a name="an2151"></a><code >std::shared_ptr&lt;Type&gt;</code> is available, which is a reference
counting smart pointer.
<p>
Before using <code >shared_ptrs</code> the <a name="an2152"></a><code >&lt;memory&gt;</code> header file must be included.
<p>
The shared pointer automatically destroys its contents once its reference
count has decayed to zero. As with <code >unique_ptr</code>, when defining a
<code >shared_ptr&lt;Base&gt;</code> to store a newly allocated <code >Derived</code> class object, the
returned <code >Base *</code> may be cast to a <code >Derived *</code> using a <code >static_cast</code>:
polymorphism isn't required, and when resetting the <code >shared_ptr</code> or when the
<code >shared_ptr</code> goes out of scope, no slicing occurs, and <code >Derived</code>'s
destructor (or, if configured: deleter) is called (cf. section
<a href="cplusplus18.html#UNIQUEPTR">18.3</a>).
<p>
<code >Shared_ptrs</code> support copy and move constructors as well as standard and
move overloaded assignment operators.
<p>
Like <code >unique_ptrs, shared_ptrs</code> may refer to dynamically allocated arrays.
<p>
<a name="l346"></a>
<h3 >18.4.1: Defining `shared_ptr' objects</h3>
    There are four ways to <a name="an2153"></a> define <code >shared_ptr</code>
objects. Each definition contains the usual <code >&lt;type&gt;</code> specifier between
angle brackets:
    <ul>
    <li> The default constructor simply creates a <code >shared_ptr</code> object that
does not point to a particular block of memory. Its pointer is initialized to
0 (zero):
        <pre>
shared_ptr&lt;type&gt; identifier;
</pre>
    This form is discussed in section <a href="cplusplus18.html#SHAREDPLAIN">18.4.2</a>.
<p>
<li> The copy constructor initializes a <code >shared_ptr</code> so that both
objects share the memory pointed at by the existing object. The copy
constructor also increments the <code >shared_ptr</code>'s reference count. Example:
        <pre>
shared_ptr&lt;string&gt; org(new string("hi there"));
shared_ptr&lt;string&gt; copy(org);   // reference count now 2
</pre>
<p>
<li> The move constructor initializes a <code >shared_ptr</code> with the pointer
and reference count of a temporary <code >shared_ptr</code>. The temporary
<code >shared_ptr</code> is changed into a 0-pointer. An existing <code >shared_ptr</code> may
have its data moved to a newly defined <code >shared_ptr</code> (turning the existing
<code >shared_ptr</code> into a 0-pointer as well). In the next example a temporary,
anonymous <code >shared_ptr</code> object is constructed, which is then used to
construct <code >grabber</code>. Since <code >grabber</code>'s constructor receives an anonymous
temporary object, the compiler uses <code >shared_ptr</code>'s move constructor:
        <pre>
shared_ptr&lt;string&gt; grabber(shared_ptr&lt;string&gt;(new string("hi there")));
</pre>
<p>
<li> The form that is used most often initializes a <code >shared_ptr</code> object
to the block of dynamically allocated memory that is passed to the object's
constructor. Optionally <a name="an2154"></a><code >deleter</code> can be provided. A (free) function (or
function object) receiving the <code >shared_ptr</code>'s pointer as its argument can be
passed as deleter. It is supposed to return the dynamically allocated
memory to the common pool (doing nothing if the pointer equals zero).
        <pre>
shared_ptr&lt;type&gt; identifier (new-expression [, deleter]);
</pre>
    This form is discussed in section <a href="cplusplus18.html#SHAREDNEW">18.4.3</a>.
    </ul>
<p>
<a name="SHAREDPLAIN"></a><a name="l347"></a>
<h3 >18.4.2: Creating a plain `shared_ptr'</h3>
    <code >Shared_ptr</code>'s default constructor defines a <a name="an2155"></a>
<code >shared_ptr</code> not pointing to a particular block of memory:
        <pre>
    shared_ptr&lt;type&gt; identifier;
</pre>
    The <a name="an2156"></a> pointer controlled by the <code >shared_ptr</code>
object is initialized to <code >0</code> (zero). Although the <code >shared_ptr</code> object
itself is not the pointer, its value <em >can</em> be compared to <code >0</code>. Example:
        <pre>
    shared_ptr&lt;int&gt; ip;

    if (!ip)
        cout &lt;&lt; "0-pointer with a shared_ptr object\n";
</pre>
    Alternatively, the member <a name="an2157"></a><code >get</code> can be used (cf. section <a href="cplusplus18.html#SHAREDMEM">18.4.4</a>).
<p>
<a name="SHAREDNEW"></a><a name="l348"></a>
<h3 >18.4.3: Pointing to a newly allocated object</h3>
    Most often a <code >shared_ptr</code> <a name="an2158"></a> is initialized by a
dynamically allocated block of memory. The generic form is:
        <pre>
    shared_ptr&lt;type&gt; identifier(new-expression [, deleter]);
</pre>
    The second argument (<code >deleter</code>) is optional and
 <a name="an2159"></a> refers to a function object or free function handling the
destruction of the allocated memory. A deleter is used, e.g., in situations
where a double pointer is allocated and the destruction must visit each nested
pointer to destroy the allocated memory (see below for an illustration).  It
is used in situations comparable to those encountered with <code >unique_ptr</code>
(cf. section <a href="cplusplus18.html#UNIQUENEW">18.3.4</a>).
<p>
Here is an example initializing a <code >shared_ptr</code> pointing to a <code >string</code>
object:
        <pre>
    shared_ptr&lt;string&gt; strPtr(new string("Hello world"));
</pre>
    The argument that is passed to the constructor is the pointer returned by
<code >operator new</code>. Note that <code >type</code> does <em >not</em> mention the pointer.  The
<a name="an2160"></a> type that is used in the <code >shared_ptr</code> construction
is the same as the type that is used in <code >new</code> expressions.
<p>
The next example illustrates that two <code >shared_ptrs</code> indeed share their
information. After modifying the information controlled by one of the
objects the information controlled by the other object is modified as well:
        <pre>
    #include &lt;iostream&gt;
    #include &lt;memory&gt;
    #include &lt;cstring&gt;
    using namespace std;

    int main()
    {
        shared_ptr&lt;string&gt; sp(new string("Hello world"));
        shared_ptr&lt;string&gt; sp2(sp);

        sp-&gt;insert(strlen("Hello "), "C++ ");
        cout &lt;&lt; *sp &lt;&lt; '\n' &lt;&lt;
                *sp2 &lt;&lt; '\n';
    }
    /*
        Displays:
            Hello C++ world
            Hello C++ world
    */
</pre>
<p>
<a name="SHAREDMEM"></a><a name="l349"></a>
<h3 >18.4.4: Operators and members</h3>
    The class <code >shared_ptr</code> offers the following <a name="an2161"></a>
operators:
    <ul>
    <li><a name="an2162"></a><code >shared_ptr &amp;operator=(shared_ptr&lt;Type&gt; const &amp;other)</code>:<blockquote >Copy assignment: the reference count of the operator's left hand side
        operand is reduced. If the reference count decays to zero the
        dynamically allocated memory controlled by the left hand side operand
        is deleted. Then it shares the information with the operator's
        right hand side operand, incrementing the information's reference
        count.</blockquote>
    <li><a name="an2163"></a><code >shared_ptr &amp;operator=(shared_ptr&lt;Type&gt; &amp;&amp;tmp)</code>:<blockquote >Move assignment: the reference count of the operator's left hand side
        operand is reduced. If the reference count decays to zero the
        dynamically allocated memory controlled by the left hand side operand
        is deleted. Then it grabs the information controlled by the
        operator's right hand side operand which is turned into a 0-pointer.</blockquote>
    <li><a name="an2164"></a><code >operator bool() const</code>:<blockquote >If the <code >shared_ptr</code> actually points to memory <code >true</code> is returned,
        otherwise, <code >false</code> is returned.</blockquote>
    <li><a name="an2165"></a><code >Type &amp;operator*()</code>:<blockquote >A reference to the information stored in the
        <code >shared_ptr</code> object is returned. It acts like a normal pointer.</blockquote>
    <li><a name="an2166"></a><code >Type *operator-&gt;()</code>:<blockquote >A pointer to the information controlled by the <code >shared_ptr</code> object
        is returned. Example:
   <pre>
shared_ptr&lt;string&gt; sp(new string("hello"));
cout &lt;&lt; sp-&gt;c_str() &lt;&lt; '\n';
</pre>
        </blockquote>
    </ul>
<p>
The following <a name="an2167"></a>member function member functions are supported:
    <ul>
    <li><a name="an2168"></a><code >Type *get()</code>:<blockquote >A pointer to the information controlled by the <code >shared_ptr</code> object
        is returned. It acts like <code >operator-&gt;</code>. The returned pointer can be
        inspected. If it is zero the <code >shared_ptr</code> object does not point to
        any memory.</blockquote>
    <li><a name="an2169"></a><code >Deleter &amp;get_deleter()</code>:<blockquote >A reference to the <code >shared_ptr</code>'s deleter (function or function
        object) is returned.</blockquote>
    <li><a name="an2170"></a><code >void reset(Type *)</code>:<blockquote >The reference count of the information controlled by the <code >shared_ptr</code>
        object is reduced and if it decays to zero the memory it points to
        is deleted. Thereafter the
        object's information will refer to the argument that is passed to the
        function, setting its shared count to 1. It can also be called without
        argument, turning the object into a 0-pointer. This member function
        can be used to assign a new block of dynamically allocated memory to a
        <code >shared_ptr</code> object.</blockquote>
    <li><a name="an2171"></a><code >void reset(Type *, DeleterType &amp;&amp;)</code>:<blockquote >This variant of the previous member accepts a specific <code >Deleter</code>
        type: if <code >Type</code> is a base-class and derived class objects are used,
        these derived class objects may require specific actions at
        destruction time. When the previous member is used, then eventually the
        newly assigned object's destructor is called without using an
        explicit deleter function. The current member ensures that by the time
        the shared counter has decayed to zero the provided deleter is used.</blockquote>
      <li><a name="an2172"></a><code >void shared_ptr&lt;Type&gt;::swap(shared_ptr&lt;Type&gt; &amp;&amp;)</code>:<blockquote >Two identically typed <code >shared_ptrs</code> are swapped.</blockquote>
    <li><a name="an2173"></a><code >bool unique() const</code>:<blockquote >If the current object is the only object referring to the memory
        controlled by the object <code >true</code> is returned otherwise (including the
        situation where the object is a 0-pointer) <code >false</code> is returned.</blockquote>
    <li><a name="an2174"></a><code >size_t use_count() const</code>:<blockquote >The number of objects sharing the memory controlled by the object is
        returned.</blockquote>
    </ul>
<p>
<a name="SHAREDCAST"></a><a name="l350"></a>
<h3 >18.4.5: Casting shared pointers</h3>
    Be cautious when using standard <strong >C++</strong> style casts in combination with
<code >shared_ptr</code> objects. Consider the following two classes:
        <pre>
    struct Base
    {};
    struct Derived: public Base
    {};
</pre>
<p>
As with <code >unique_ptr</code>, when defining a <code >shared_ptr&lt;Base&gt;</code> to store a
newly allocated <code >Derived</code> class object, the returned <code >Base *</code> may be cast
to a <code >Derived *</code> using a <code >static_cast</code>: polymorphism isn't required, and
when resetting the <code >shared_ptr</code> or when the <code >shared_ptr</code> goes out of
scope, no slicing occurs, and <code >Derived</code>'s destructor is called (cf. section
<a href="cplusplus18.html#UNIQUEPTR">18.3</a>).
<p>
Of course, a <code >shared_ptr&lt;Derived&gt;</code> can easily be defined. Since a
<code >Derived</code> object is also a <code >Base</code> object, a pointer to <code >Derived</code> can
be considered a pointer to <code >Base</code> without using casts, but a <code >static_cast</code>
could be used to force the interpretation of a <code >Derived *</code> to a <code >Base *</code>:
        <pre>
    Derived d;
    static_cast&lt;Base *&gt;(&amp;d);
</pre>
<p>
However, a plain <code >static_cast</code> cannot be used when initializing a shared
pointer to a <code >Base</code> using the <code >get</code> member of a shared pointer to a
<code >Derived</code> object. The following code snipped eventually results in an
attempt to delete the dynamically allocated <code >Base</code> object twice:
        <pre>
    shared_ptr&lt;Derived&gt; sd{ new Derived };
    shared_ptr&lt;Base&gt; sb{ static_cast&lt;Base *&gt;(sd.get()) };
</pre>
    Since <code >sd</code> and <code >sb</code> point at the same object <code >~Base</code> will be called
for the same object when <code >sb</code> goes out of scope and when <code >sd</code> goes out of
scope, resulting in premature termination of the program due to a
 <a name="an2175"></a><em >double free</em> error.
<p>
These errors can be prevented using casts that were specifically designed
for being used with <code >shared_ptrs</code>. These casts use specialized constructors
that create a <code >shared_ptr</code> pointing to memory but shares ownership (i.e.,
a reference count) with an existing <code >shared_ptr</code>. These special casts are:
    <ul>
    <li><a name="an2176"></a><code >std::static_pointer_cast&lt;Base&gt;(std::shared_ptr&lt;Derived&gt; ptr)</code>:<blockquote >A <code >shared_ptr</code> to a <code >Base</code> class object is returned. The returned
<code >shared_ptr</code> refers to the base class portion of the <code >Derived</code> class to
which the <code >shared_ptr&lt;Derived&gt; ptr</code> refers. Example:
        <pre>
shared_ptr&lt;Derived&gt; dp{ new Derived };
shared_ptr&lt;Base&gt; bp = static_pointer_cast&lt;Base&gt;(dp);
</pre>
        </blockquote>
<p>
<li><a name="an2177"></a><code >std::const_pointer_cast&lt;Class&gt;(std::shared_ptr&lt;Class const&gt; ptr)</code>:<blockquote >A <code >shared_ptr</code> to a <code >Class</code> class object is returned. The
returned <code >shared_ptr</code> refers to a non-const <code >Class</code> object whereas the
<code >ptr</code> argument refers to a <code >Class const</code> object. Example:
        <pre>
shared_ptr&lt;Derived const&gt; cp{ new Derived };
shared_ptr&lt;Derived&gt; ncp = const_pointer_cast&lt;Derived&gt;(cp);
</pre>
        </blockquote>
<p>
<li><a name="an2178"></a><code >std::dynamic_pointer_cast&lt;Derived&gt;(std::shared_ptr&lt;Base&gt; ptr)</code>:<blockquote >A <code >shared_ptr</code> to a <code >Derived</code> class object is returned. The
<code >Base</code> class must have at least one virtual member function, and the class
<code >Derived</code>, inheriting from <code >Base</code> may have overridden <code >Base</code>'s virtual
member(s). The returned <code >shared_ptr</code> refers to a <code >Derived</code> class object if
the dynamic cast from <code >Base *</code> to <code >Derived *</code> succeeded. If the dynamic
cast did not succeed the <code >shared_ptr</code>'s <code >get</code> member returns 0.  Example
(assume <code >Derived</code> and <code >Derived2</code> were derived from <code >Base</code>):
        <pre>
shared_ptr&lt;Base&gt; bp(new Derived());
cout &lt;&lt; dynamic_pointer_cast&lt;Derived&gt;(bp).get() &lt;&lt; ' ' &lt;&lt;
        dynamic_pointer_cast&lt;Derived2&gt;(bp).get() &lt;&lt; '\n';
</pre>
    The first <code >get</code> returns a non-0 pointer value, the second <code >get</code>
returns 0.
        </blockquote>
    </ul>
<p>
<a name="SHAREDARRAY"></a><a name="l351"></a>
<h3 >18.4.6: Using `shared_ptr' objects for arrays</h3>
    Different from the <code >unique_ptr</code> class no specialization exists for the
<code >shared_ptr</code> class to handle dynamically allocated arrays of objects.
<p>
But like <code >unique_ptrs</code>, with <code >shared_ptrs</code> referring to arrays the
dereferencing operator makes little sense while in these circumstances
<code >shared_ptr</code> objects would benefit from index operators.
<p>
It is not difficult to create a class <code >shared_array</code> offering such
facilities. The class template <code >shared_array</code>, derived from <code >shared_ptr</code>
merely should provide an appropriate <em >deleter</em> to make sure that the array
and its elements are properly destroyed. In addition it should define the
index operator and, when applicable should declare the derefencing operators
using <code >delete</code>.
<p>
Here is an example showing how <code >shared_array</code> can be defined and used:
    <pre>
    struct X
    {
        ~X()
        {
            cout &lt;&lt; "destr\n";  // show the object's destruction
        }
    };
    template &lt;typename Type&gt;
    class shared_array: public shared_ptr&lt;Type&gt;
    {
        struct Deleter          // Deleter receives the pointer
        {                       // and calls delete[]
           void operator()(Type* ptr)
           {
              delete[] ptr;
           }
        };
        public:
            shared_array(Type *p)           // other constructors
            :                               // not shown here
                shared_ptr&lt;Type&gt;(p, Deleter())
            {}
            Type &amp;operator[](size_t idx)    // index operators
            {
                return shared_ptr&lt;Type&gt;::get()[idx];
            }
            Type const &amp;operator[](size_t idx) const
            {
                return shared_ptr&lt;Type&gt;::get()[idx];
            }
            Type &amp;operator*() = delete;     // delete pointless members
            Type const &amp;operator*() const = delete;
            Type *operator-&gt;() = delete;
            Type const *operator-&gt;() const = delete;
    };
    int main()
    {
        shared_array&lt;X&gt; sp{ new X[3] };
        sp[0] = sp[1];
    }
</pre>
<p>
<a name="l352"></a>
<h2 >18.5: Smart smart pointer construction: `make_shared' and `make_unique'</h2>
Usually a <code >shared_ptr</code> is initialized at definition time
with a pointer to a newly allocated object. Here is an example:
        <pre>
    std::shared_ptr&lt;string&gt; sptr(new std::string("hello world"))
</pre>
    In such statements <em >two</em> memory allocation calls are used: one for the
allocation of the <code >std::string</code> and one used interally by
<code >std::shared_ptr</code>'s constructor itself.
<p>
The two allocations can be combined into one single allocation (which is
also slightly more efficient than explicitly calling <code >shared_ptr</code>'s
constructor) using the <a name="an2179"></a><code >make_shared</code> template. The function template
<code >std::make_shared</code> has the following prototype:
        <pre>
    template&lt;typename Type, typename ...Args&gt;
    std::shared_ptr&lt;Type&gt; std::make_shared(Args ...args);
</pre>
<p>
Before using <code >make_shared</code> the <a name="an2180"></a><code >&lt;memory&gt;</code> header file must be included.
<p>
This function template allocates an object of type <code >Type</code>, passing
<code >args</code> to its constructor (using <em >perfect forwarding</em>, see section
<a href="cplusplus22.html#PERFECT">22.5.2</a>), and returns a <code >shared_ptr</code> initialized with the address of
the newly allocated <code >Type</code> object.
<p>
Here is how the above <code >sptr</code> object can be initialized
using <code >std::make_shared</code>. Notice the use of <code >auto</code> which frees us from
having to specify <code >sptr</code>'s type explicitly:
        <pre>
    auto sptr(std::make_shared&lt;std::string&gt;("hello world"));
</pre>
    After this initialization <code >std::shared_ptr&lt;std::string&gt; sptr</code> has been
defined and initialized. It could be used as follows:
        <pre>
    std::cout &lt;&lt; *sptr &lt;&lt; '\n';
</pre>
<p>
In addition to <code >make_shared</code> the function
    <a name="an2181"></a><code >std::make_unique</code> can be used. It can be used
<code >make_shared</code> but returns a <code >std::unique_ptr</code> rather than a
<code >shared_ptr</code>.
<p>
<a name="l353"></a>
<h2 >18.6: Classes having pointer data members</h2>
Classes having <a name="an2182"></a> pointer data members require special
attention. In particular at construction time one must be careful to prevent
 <a name="an2183"></a> wild pointers and/or <a name="an2184"></a> memory leaks. Consider
the following class defining two pointer data members:
        <pre>
    class Filter
    {
        istream *d_in;
        ostream *d_out;
        public:
            Filter(char const *in, char const *out);
    };
</pre>
    Assume that <code >Filter</code> objects filter information read from <code >*d_in</code> and
write the filtered information to <code >*d_out</code>.  Using pointers to streams
allows us to have them point at any kind of stream like <code >istreams,
ifstreams, fstreams</code> or <code >istringstreams</code>.  The shown constructor could be
implemented like this:
        <pre>
    Filter::Filter(char const *in, char const *out)
    :
        d_in(new ifstream{ in }),
        d_out(new ofstream{ out })
    {
        if (!*d_in || !*d_out)
            throw string("Input and/or output stream not available");
    }
</pre>
    Of course, the construction could fail. <code >new</code> could throw an exception;
the stream constructors could throw exceptions; or the streams could not be
opened in which case an exception is thrown from the constructor's body. Using
a function try block helps. Note that if <code >d_in</code>'s initialization throws,
there's nothing to be worried about. The <code >Filter</code> object hasn't been
constructed, its destructor is not called and processing continues at the
point where the thrown exception is caught. But <code >Filter</code>'s destructor is
also not called when <code >d_out</code>'s initialization or the constructor's <code >if</code>
statement throws: no object, and hence no destructor is called. This may
result in memory leaks, as <code >delete</code> isn't called for <code >d_in</code> and/or
<code >d_out</code>. To prevent this, <code >d_in</code> and <code >d_out</code> must first be initialized
to 0 and only then the initialization can be performed:
        <pre>
    Filter::Filter(char const *in, char const *out)
    try
    :
        d_in(0),
        d_out(0)
    {
        d_in = new ifstream{ in };
        d_out = new ofstream{ out };

        if (!*d_in || !*d_out)
            throw string("Input and/or output stream not available");
    }
    catch (...)
    {
        delete d_out;
        delete d_in;
    }
</pre>
    This quickly gets complicated, though. If <code >Filter</code> harbors yet another
data member of a class whose constructor needs two streams then that data
cannot be constructed or it must itself be converted into a pointer:
        <pre>
    Filter::Filter(char const *in, char const *out)
    try
    :
        d_in(0),
        d_out(0)
        d_filterImp(*d_in, *d_out)    // won't work
    { ... }

    // instead:

    Filter::Filter(char const *in, char const *out)
    try
    :
        d_in(0),
        d_out(0),
        d_filterImp(0)
    {
        d_in = new ifstream(in);
        d_out = new ofstream(out);
        d_filterImp = new FilterImp(*d_in, *d_out);
        ...
    }
    catch (...)
    {
        delete d_filterImp;
        delete d_out;
        delete d_in;
    }
</pre>
    Although the latter alternative works, it quickly gets hairy. In
situations like these smart pointers should be used to prevent the
hairiness. By defining the stream pointers as (smart pointer) objects they
will, once constructed, properly be destroyed even if the rest of the
constructor's code throws exceptions. Using a <code >FilterImp</code> and two
<code >unique_ptr</code> data members <code >Filter</code>'s setup and its constructor becomes:
        <pre>
    class Filter
    {
        std::unique_ptr&lt;std::ifstream&gt; d_in;
        std::unique_ptr&lt;std::ofstream&gt; d_out;
        FilterImp d_filterImp;
        ...
    };

    Filter::Filter(char const *in, char const *out)
    try
    :
        d_in(new ifstream(in)),
        d_out(new ofstream(out)),
        d_filterImp(*d_in, *d_out)
    {
        if (!*d_in || !*d_out)
            throw string("Input and/or output stream not available");
    }
</pre>
    We're back at the original implementation but this time without having to
worry about wild pointers and memory leaks. If one of the member initializers
throws the destructors of previously constructed data members (which are now
objects) are always called.
<p>
As a <a name="an2185"></a>rule of thumb: when classes need to define pointer data members
they should define those pointer data members as smart pointers if there's any
chance that their constructors throw exceptions.
<p>
<a name="l354"></a>
<h2 >18.7: Regular Expressions</h2>
<strong >C++</strong> itself provides facilities for handling regular expressions. Regular
expressions were already available in <strong >C++</strong> via its <strong >C</strong> heritage (as <strong >C</strong>
has always offered functions like <a name="an2186"></a><code >regcomp</code> and <a name="an2187"></a><code >regexec</code>), but the
dedicated regular expression facilities have a richer interface than the
traditional <strong >C</strong> facilities, and can be used in code using templates.
<p>
Before using the specific <strong >C++</strong> implementations of regular expressions the
header file <a name="an2188"></a><code >&lt;regex&gt;</code> must be included.
<p>
Regular expressions are extensively documented elsewhere (e.g., <strong >regex</strong>(7),
<a name="an2189"></a>Friedl, J.E.F
  <a href="http://oreilly.com/catalog/">Mastering Regular Expressions</a>, O'Reilly).
    The reader is referred to these sources for a refresher on the topic of
regular expressions. In essence, regular expressions define a small
meta-language recognizing textual units (like `numbers', `identifiers', etc.).
They are extensively used in the context of <em >lexical scanners</em> (cf. section
<a href="cplusplus24.html#Flexcpp">24.6.1</a>) when defining the sequence of input characters associated with
<em >tokens</em>. But they are also intensively used in other situations.  Programs
like <strong >sed</strong>(1) and <strong >grep</strong>(1) use regular expressions to find pieces of text
in files having certain characteristics, and a program like <strong >perl</strong>(1) adds
some `sugar' to the regular expression language, simplifying the construction
of regular expressions. However, though extremely useful, it is also well
known that regular expressions tend to be very hard to read. Some even call
the regular expression language a <em >write-only language</em>: while specifying a
regular expression it's often clear why it's written in a particular way. But
the opposite, understanding what a regular expression is supposed to represent
if you lack the proper context, can be extremely difficult. That's why, from
the onset and as a <a name="an2190"></a><em >rule of thumb</em>, it is stressed that an appropriate
comment should be provided, with <em >each</em> regular expression, as to what it is
supposed to match.
<p>
In the upcoming sections first a short overview of the regular expression
language is provided, which is then followed by the facilities <strong >C++</strong> is
currently offering for using regular expressions. These facilities mainly
consist of classes helping you to specify regular expression, matching them to
text, and determining which parts of the text (if any) match (parts of) the
text being analyzed.
<p>
<a name="l355"></a>
<h3 >18.7.1: The regular expression mini language</h3>
    Regular expressions are expressions consisting of elements resembling those of
numeric expressions. Regular expressions consist of basic elements and
operators, having various priorities and associations. Like numeric
expressions, parentheses can be used to group elements together to form a
unit on which operators operate. For an extensive discussion the reader is
referred to, e.g., section 15.10 of the <a href="http://ecma-international.org/ecma-262/5.1/#sec-15.10">ecma-international.org</a> page, which
describes the characteristics of the regular expressions used by default by
<strong >C++</strong>'s <code >regex</code> classes.
<p>
<strong >C++</strong>'s default definition of regular expressions distinguishes the
following <em >atoms</em>:
    <ul>
    <li><code >x</code>: the character `x';
<p>
<li><code >.</code>: any character except for the newline character;
<p>
<li><code >[xyz]</code>: a character class; in this case, either an `x', a `y', or a `z'
        matches the regular expression.  See also the paragraph about
        character classes below;
<p>
<li><code >[abj-oZ]</code>: a character class containing a range of characters; this
        regular expression matches an `a', a `b', any letter from `j' through
        `o', or a `Z'.  See also the paragraph about character classes below;
<p>
<li><code >[^A-Z]</code>: a negated character class: this regular expression matches
        any character but those in the class beyond <code >^</code>.  In this case, any
        character <em >except for</em> an uppercase letter.  See also the paragraph
        about character classes below;
<p>
<li><code >[:predef:]</code>: a <em >predefined</em> set of characters. See below for an
        overview. When used, it is interpreted as an element in a character
        class. It is therefore always embedded in a set of square brackets
        defining the character class (e.g., <code >[[:alnum:]]</code>);
<p>
<li><code >\X</code>: if X is `a', `b', `f', `n', `r', `t', or `v', then the ANSI-C
        interpretation of `\x'. Otherwise, a literal `X' (used to escape
        operators such as <code >*</code>);
<p>
<li><code >(r)</code>: the regular expression <code >r</code>. It is used to override precedence
        (see below), but also to define <code >r</code> as a
       <a name="an2191"></a><em >marked sub-expression</em> whose matching characters may directly be
        retrieved from, e.g., a <code >std::smatch</code> object (cf. section
        <a href="cplusplus18.html#SMATCH">18.7.3</a>);
<p>
<li><code >(?:r)</code>: the regular expression <code >r</code>. It is used to override
        precedence (see below), but it is <em >not</em> regarded as a <em >marked
        sub-expression</em>;
    </ul>
<p>
In addition to these basic atoms, the following special atoms are available
(which can also be used in character classes):
    <ul>
    <li><code >\s</code>: a whitespace character;
<p>
<li><code >\S</code>: any character but a whitespace character;
<p>
<li><code >\d</code>: a decimal digit character;
<p>
<li><code >\D</code>: any character but a decimal digit character;
<p>
<li><code >\w</code>: an alphanumeric character or an underscore (<code >_</code>) character;
<p>
<li><code >\W</code>: any character but an alphanumeric character or an underscore
        (<code >_</code>) character.
    </ul>
<p>
Atoms may be concatenated. If <code >r</code> and <code >s</code> are atoms then the regular
expression <code >rs</code> matches a target text if the target text matches <code >r</code>
<em >and</em> <code >s</code>, in that order (without any intermediate characters 
inside the target text). E.g., the regular expression <code >[ab][cd]</code> matches the
target text <code >ac</code>, but not the target text <code >a:c</code>. 
<p>
Atoms may be combined using operators. Operators bind to the preceding
atom. If an operator should operate on multiple atoms the atoms must be
surrounded by parentheses (see the last element in the previous itemization). 
To use an operator character as an atom it can be escaped. Eg., <code >*</code>
represents an operator, <code >\*</code> the atom character star. Note that 
character classes do not recognize escape sequences: <code >[\*]</code> represents a
character class consisting of two characters: a backslash and a star.
<p>
The following operators are supported (<code >r</code> and <code >s</code> represent regular
expression atoms):
    <ul>
    <li><code >r*</code>: zero or more <code >r</code>s;
<p>
<li><code >r+</code>: one or more <code >r</code>s;
<p>
<li><code >r?</code>: zero or one <code >r</code>s (that is, an optional r);
<p>
<li><code >r{m, n}</code>: where <code >1 &lt;= m &lt;= n</code>: matches `r' at least m, but at most n
        times;
<p>
<li><code >r{m,}</code>: where <code >1 &lt;= m</code>: matches `r' at least m times;
<p>
<li><code >r{m}</code>: where <code >1 &lt;= m</code>: matches `r' exactly m times;
<p>
<li><code >r|s</code>: matches either an `r' or an `s'. This operator has a lower
        priority than any of the multiplication operators;
<p>
<li><code >^r</code> : <code >^</code> is a pseudo operator. This expression matches `r', if
        appearing at the beginning of the target text. If the <code >^</code>-character
        is not the first character of a regular expression it is interpreted
        as a literal <code >^</code>-character;
<p>
<li><code >r$</code>: <code >$</code> is a pseudo operator. This expression matches `r', if
        appearing at the end of the target text. If the <code >$</code>-character is not
        the last character of a regular expression it is interpreted as a
        literal <code >$</code>-character;
    </ul>
<p>
When a regular expression contains marked sub-expressions and multipliers, and
the marked sub-expressions are multiply matched, then the target's final
sub-string matching the marked sub-expression is reported as the text matching
the marked sub-expression. E.g, when using <code >regex_search</code> (cf. section
<a href="cplusplus18.html#REGSRCH">18.7.4.3</a>), marked sub-expression (<code >((a|b)+\s?)</code>), and target text <code >a a
b</code>, then <code >a a b</code> is the fully matched text, while <code >b</code> is reported as the
sub-string matching the first and second marked sub-expressions.
<p>
<a name="l356"></a>
<h4>18.7.1.1: Character classes</h4>
        Inside a character class all regular expression operators lose their special
meanings, except for the special atoms <code >\s, \S, \d, \D, \w,</code> and <code >\W</code>; the
character range operator <code >-</code>; the end of character class operator <code >]</code>;
and, at the beginning of the character class, <code >^</code>. Except in combination
with the special atoms the escape character is interpreted as a literal
backslash character (to define a character class containing a backslash and a
<code >d</code> simply use <code >[d\]</code>).
<p>
To add a closing bracket to a character class use <code >[]</code> immediately following
the initial open-bracket, or start with <code >[^]</code> for a negated character class
not containing the closing bracket.  Minus characters are used to define
character ranges (e.g., <code >[a-d]</code>, defining <code >[abcd]</code>) (be advised that the
actual range may depend on the locale being used). To add a literal minus
character to a character class put it at the very beginning (<code >[-</code>, or
<code >[^-</code>) or at the very end (<code >-]</code>) of a character class.
<p>
Once a character class has started, all subsequent characters are added to the
class's set of characters, until the final closing bracket (<code >]</code>) has been
reached.
<p>
In addition to characters and ranges of characters, character classes may also
contain <em >predefined sets of character</em>. They are:
    <pre>
         [:alnum:] [:alpha:] [:blank:]
         [:cntrl:] [:digit:] [:graph:]
         [:lower:] [:print:] [:punct:]
         [:space:] [:upper:] [:xdigit:]
</pre>
    These predefined sets designate sets of characters equivalent to the
corresponding standard <strong >C</strong> <code >isXXX</code> function. For example, <code >[:alnum:]</code>
defines all  characters for which <strong >isalnum</strong>(3) returns true.
<p>
<a name="l357"></a>
<h3 >18.7.2: Defining regular expressions: std::regex</h3>
    Before using the <code >(w)regex</code> class presented in this section the
<a name="an2192"></a><code >&lt;regex&gt;</code> header file must be included.
<p>
The types <code >std::regex</code><a name="an2193"></a> and <code >std::wregex</code><a name="an2194"></a> define regular
expression patterns. They define, respectively the types
<code >basic_regex&lt;char&gt;</code><a name="an2195"></a> and <code >basic_regex&lt;wchar_t&gt;</code>
types. Below, the class <code >regex</code> is used, but in the examples <code >wregex</code>
could also have been used.
<p>
Regular expression facilities were, to a large extent, implemented through
templates, using, e.g., the <code >basic_string&lt;char&gt;</code> type (which is equal to
<code >std::string</code>). Likewise, generic types like <em >OutputIter</em> (output
iterator) and <em >BidirConstIter</em> (bidirectional const iterator) are used with
several functions. Such functions are function templates. Function templates
determine the actual types from the arguments that are provided at
<em >call-time</em>.
<p>
These are the steps that are commonly taken when using regular expressions:
    <ul>
    <li> First, a regular expression is defined. This involves
        defining or modifying a <code >regex</code> object.
    <li> Then the regular expression is provided with a <em >target text</em>, which
        may result in sections of the target text matching the regular
        expression. 
    <li> The sections of the target text matching (or not matching) the
        regular expression are retrieved to be processed elsewhere, or:
    <li> The sections of the target text matching (or not matching) the
        regular expression are directly modified by existing regular
        expression facilities, after which the modified target text may be
        processed elsewhere.
    </ul>
<p>
The way <code >regex</code> objects handle regular expressions can be configured using a
<code >bit_or</code> combined set of <code >std::regex_constants</code><a name="an2196"></a> values,
defining a <code >regex::flag_type</code><a name="an2197"></a> value. These
<code >regex_constants</code> are:
    <ul>
    <li><code >std::regex_constants::awk</code>:<blockquote ><strong >awk</strong>(1)'s (POSIX) regular expression grammar is used to specify
        regular exressions (e.g., regular expressions are delimited by
        <code >/</code>-characters, like <code >/\w+/</code>; for further details and for details
        of other regular expression grammars the reader should consult the
        man-pages of the respective programs);</blockquote>
<p>
<li><code >std::regex_constants::basic</code>:<blockquote >the basic POSIX regular expression grammar is used to specify regular
        expressions;</blockquote> 
<p>
<li><code >std::regex_constants::collate</code>:<blockquote >the character range operator (<code >-</code>) used in character classes defines
        a locale sensitive range (e.g., <code >[a-k]</code>);</blockquote>
<p>
<li><a name="an2198"></a><code >std::regex_constants::ECMAScript</code>:<blockquote >this <code >flag_type</code> is used by default by <code >regex</code>
        constructors. The regular expression uses the Modified <a name="an2199"></a>ECMAScript
        regular expression grammar;</blockquote>
<p>
<li><code >std::regex_constants::egrep</code>:<blockquote ><strong >egrep</strong>(1)'s (POSIX) regular expression grammar is used to specify
        regular expressions. This is the same grammar as used by
        <code >regex_constants::extended</code>, with the addition of the newline
        character (<code >'\n'</code>) as an alternative for the <code >'|'</code>-operator;</blockquote>
<p>
<li><code >std::regex_constants::extended</code>:<blockquote >the extended POSIX regular expression grammar is used to specify
        regular expressions;</blockquote>
<p>
<li><code >std::regex_constants::grep</code>:<blockquote ><strong >grep</strong>(1)'s (POSIX) regular expression grammar is used to specify
        regular expressions. This is the same grammar as used by
        <code >regex_constants::basic</code>, with the addition of the newline character
        (<code >'\n'</code>) as an alternative for the <code >'|'</code>-operator;</blockquote>
<p>
<li><a name="an2200"></a><code >std::regex_constants::icase</code>:<blockquote >letter casing in the target string is ignored. E.g., the regular
        expression <code >A</code> matches <code >a</code> and <code >A</code>;</blockquote>  
<p>
<li><code >std::regex_constants::nosubs</code>:<blockquote >When performing matches, all sub-expressions (<code >(expr)</code>) are
        treated as non-marked (<code >?:expr</code>);</blockquote>
<p>
<li><code >std::regex_constants::optimize</code>:<blockquote >optimizes the speed of matching regular expressions, at the cost of
        slowing down the construction of the regular expression somewhat. If
        the same regular expression object is frequently used then this flag
        may substantially improve the speed of matching target texts;</blockquote>
    </ul>
<p>
<strong >Constructors</strong>
<p>
The default, move and copy constructors are available. Actually, the
default constructor defines one parameter of type <code >regex::flag_type</code>, for
which the value <code >regex_constants::ECMAScript</code> is used by default.
    <ul>
    <li><code >regex()</code>:<blockquote >the default constructor defines a <code >regex</code> object not containing a
        regular expression;</blockquote>
<p>
<li><code >explicit regex(char const *pattern)</code>:<blockquote >defines a <code >regex</code> object containing the regular expression found at
        <code >pattern</code>;</blockquote>
<p>
<li><code >regex(char const *pattern, std::size_t count)</code>:<blockquote >defines a <code >regex</code> object containing the regular expression found at
        the first <code >count</code> characters of <code >pattern</code>;</blockquote>
<p>
<li><code >explicit regex(std::string const &amp;pattern)</code>:<blockquote >defines a <code >regex</code> object containing the regular expression found at
        <code >pattern</code>. This constructor is defined as a member template,
        accepting a <code >basic_string</code>-type argument which may also use
        non-standard character traits and allocators;</blockquote>
<p>
<li><code >regex(ForwardIterator first, ForwardIterator last)</code>:<blockquote >defines a <code >regex</code> object containing the regular expression found at
        the (forward) iterator range <code >[first, last)</code>. This constructor is
        defined as a member template, accepting any forward iterator type
        (e.g., plain <code >char</code> pointers) which can be used to define the
        regular expression's pattern;</blockquote>
<p>
<li><code >regex(std::initializer_list&lt;Char&gt; init)</code>:<blockquote >defines a <code >regex</code> object containing the regular expression from the
        characters in the initializer list <code >init</code>.</blockquote>
<p>
Here are some examples:
        <pre>
    std::regex re("\\w+");      // matches a sequence of alpha-numeric
                                // and/or underscore characters 

    std::regex re{'\\', 'w', '+'} ;     // idem

    std::regex re(R"(\w+xxx")", 3);     // idem
</pre>
    </ul>
<p>
<strong >Member functions</strong>
<p>
<ul>
    <li><code >regex &amp;operator=(RHS)</code>:<blockquote >The copy and move assignment operators are available. Otherwise, RHS
        may be:
        <ul>
        <li> an NTBS (of type <code >char const *</code>);
        <li> a <code >std::string const &amp;</code> (or any compatible
            <code >std::basic_string</code>); 
        <li> a <code >std::initializer_list&lt;char&gt;</code>;
        </ul></blockquote>
<p>
<li><code >regex &amp;assign(RHS)</code>:<blockquote >This member accepts the same arguments as <code >regex's</code> constructors,
        including the (optional) <code >regex_constants</code> values;</blockquote>
<p>
<li><code >regex::flag_type flag() const</code>:<blockquote >Returns the <code >regex_constants</code> flags that are active for the current
        <code >regex</code> object. E.g.,
            <pre>
    int main()
    {
        regex re;

        regex::flag_type flags = re.flags();
    
        cout &lt;&lt;                                 // displays: 16 0 0
            (re.flags() &amp; regex_constants::ECMAScript) &lt;&lt; ' '  &lt;&lt;
            (re.flags() &amp; regex_constants::icase) &lt;&lt; ' '  &lt;&lt;
            (re.flags() &amp; regex_constants::awk) &lt;&lt; ' '  &lt;&lt; '\n';
    }
</pre>
        </blockquote>
    Note that when a combination of <code >flag_type</code> values is specified at
        construction-time that only those flags that were specified are
        set. E.g., when <code >re(regex_constants::icase)</code> would have been
        specified the <code >cout</code> statement would have shown <code >0 1
        0</code>. It's also possible to specify conflicting combinations of
        flag-values like <code >regex_constants::awk | regex_constants::grep</code>. The
        construction of such <code >regex</code> objects succeeds, but should be
        avoided.
<p>
<li><code >locale_type get_loc() const</code>:<blockquote >Returns the locale that is associated with the current <code >regex</code>
        object;</blockquote>
<p>
<li><code >locale_type imbue(locale_type locale)</code>:<blockquote >Replaces the <code >regex</code> object's current locale setting with
        <code >locale</code>, returning the replaced locale;</blockquote>
<p>
<li><code >unsigned mark_count() const</code>:<blockquote >The number of <em >marked sub-expressions</em><a name="an2201"></a> in
        the <code >regex</code> objext is returned. E.g., 
            <pre>
    int main()
    {
        regex re("(\\w+)([[:alpha:]]+)"); 
        cout &lt;&lt; re.mark_count() &lt;&lt; '\n';        // displays: 2
    }
</pre>
        </blockquote>
<p>
<li><code >void swap(regex &amp;other) noexcept</code>:<blockquote >Swaps the current <code >regex</code> object with <code >other</code>. Also available as a
        free function: <code >void swap(regex &amp;lhs, regex &amp;rhs)</code>, swapping <code >lhs</code>
        and <code >rhs</code>.</blockquote>
    </ul>
<p>
<a name="SMATCH"></a><a name="l358"></a>
<h3 >18.7.3: Retrieving matches: std::match_results</h3>
    Once a <code >regex</code> object is available, it can be used to match some target text
against the regular expression. To match a target text against a regular
expression the following functions, described in the next section
(<a href="cplusplus18.html#REGALG">18.7.4</a>), are available:
    <ul>
    <li><code >regex_match</code> merely matches a target text against a regular
expression, informing the caller whether a match was found or not;
    <li><code >regex_search</code> also  matches a target text against a regular
expression, but allows retrieval of matches of marked sub-expressions (i.e.,
parenthesized regular expressions);
    <li><code >regex_replace</code> matches a target text against a regular
expression, and replaces pieces of matched sections of the target text by
another text.
    </ul>
<p>
These functions must be provided with a target text and a <code >regex</code> object
(which is not modified by these functions). Usually another argument, a
<code >std::match_results</code><a name="an2202"></a> object is also passed to these
functions, to contain the results of the regular expression matching
procedure.
<p>
Before using the <code >match_results</code> class the <a name="an2203"></a><code >&lt;regex&gt;</code> header file must be
included.
<p>
Examples of using <code >match_results</code> objects are provided in section
<a href="cplusplus18.html#REGALG">18.7.4</a>. This and the next section are primarily for referential
purposes. 
<p>
Various specializations of the class <code >match_results</code> exist. The
specialization that is used should match the specializations of the used
<code >regex</code> class. E.g., if the regular expression was specified as a <code >char
const *</code> the <code >match_results</code> specialization should also operate on <code >char
const *</code> values. The various specializations of <code >match_results</code> have been
given names that can easily be remembered, so selecting the appropriate
specialization is simple.
<p>
The class <code >match_results</code> has the following specializations:
    <ul>
    <li><code >cmatch</code>:<blockquote >defines <code >match_results&lt;char const *&gt;</code>, using a <code >char const *</code> type
        of iterator. It should be used with a <code >regex(char const *)</code> regular
        expression specification;</blockquote>
    <li><code >wcmatch</code>:<blockquote >defines <code >match_results&lt;wchar_ const *&gt;</code>, using a <code >wchar_t const *</code>
        type of iterator. It should be used with a <code >regex(wchar_t const *)</code>
        regular expression specification;</blockquote>
    <li><code >smatch</code>:<blockquote >defines <code >match_results&lt;std::string::const_iterator&gt;</code>, using a
        <code >std::string::const_iterator</code> type of iterator. It should be used
        with a <code >regex(std::string const &amp;)</code> regular expression
        specification;</blockquote>
    <li><code >wsmatch</code>:<blockquote >defines <code >match_results&lt;std::wstring::const_iterator&gt;</code>, using a
        <code >std::wstring::const_iterator</code> type of iterator. It should be used
        with a <code >regex(wstring const &amp;)</code> regular expression specification.</blockquote>
    </ul>
<p>
<strong >Constructors</strong>
<p>
The default, copy, and move constructors are available. The default
constructor defines an <code >Allocator const &amp;</code> parameter, which by default is
initialized to the default allocator. Normally, objects of the class
<code >match_results</code> receive their match-related information by passing them to
the above-mentioned functions, like <code >regex_match</code>. When returning from these
functions members of the class <code >match_results</code> can be used to retrieve
specific results of the matching process.
<p>
<strong >Member functions</strong>
<p>
<ul>
    <li><code >match_results &amp;operator=</code>:<blockquote >The copy and move assignment operators are available;</blockquote>
<p>
<li><code >std::string const &amp;operator[](size_t idx) const</code>:<blockquote >Returns a (const) reference to sub-match <code >idx</code>. With <code >idx</code> value 0
        a reference to the full match is returned. If <code >idx &gt;= size()</code> (see
        below) a reference to an empty sub-range of the target string is
        returned. The behavior of this member is undefined if the member
        <code >ready()</code> (see below) returns <code >false</code>;</blockquote>
<p>
<li><code >Iterator begin() const</code>:<blockquote >Returns an iterator to the first sub-match. <code >Iterator</code> is a
        const-iterator for <code >const match_results</code> objects;</blockquote>
<p>
<li><code >Iterator cegin() const</code>:<blockquote >Returns an iterator to the first sub-match. <code >Iterator</code> is a
        const-iterator;</blockquote>
<p>
<li><code >Iterator cend() const</code>:<blockquote >Returns an iterator pointing beyond the last sub-match. <code >Iterator</code>
        is a const-iterator;</blockquote>
<p>
<li><code >Iterator end() const</code>:<blockquote >Returns an iterator pointing beyond the last sub-match. <code >Iterator</code>
        is a const-iterator for <code >const match_results</code> objects;</blockquote>
<p>
<li><code >ReturnType format(Parameters) const</code>:<blockquote >As this member requires a fairly extensive description, it would break
        the flow of the current overview. This member is used in combination
        with the <code >regex_replace</code> function, and it is therefore covered in
        detail in that function's section (<a href="cplusplus18.html#REGREP">18.7.4.5</a>);</blockquote>
<p>
<li><code >allocator_type get_allocator() const</code>:<blockquote >Returns the object's allocator;</blockquote>
<p>
<li><code >bool empty() const</code>:<blockquote >Returns <code >true</code> if the <code >match_results</code> object contains
        no matches (which is also returned after merely using the default
        constructor). Otherwise it returns <code >false</code>;</blockquote>
<p>
<li><code >int length(size_t idx = 0) const</code>:<blockquote >Returns the length of sub-match <code >idx</code>. By default the length of
        the full match is returned. If <code >idx &gt;= size()</code> (see below) 0 is
        returned;</blockquote>
<p>
<li><code >size_type max_size() const</code>:<blockquote >Returns the maximum number of sub-matches that can be contained in a
        <code >match_results</code> object. This is an implementation dependent constant
        value;</blockquote>
<p>
<li><code >int position(size_t idx = 0) const</code>:<blockquote >Returns the offset in the target text of the first character of
        sub-match <code >idx</code>. By default the position of the first character of
        the full match is returned. If <code >idx &gt;= size()</code> (see below) -1 is
        returned;</blockquote>
<p>
<li><code >std::string const &amp;prefix() const</code>:<blockquote >Returns a (const) reference to a sub-string of the target text that
        ends at the first character of the full match;</blockquote>
<p>
<li><code >bool ready() const</code>:<blockquote >No match results are available from a default constructed
        <code >match_results</code> object. It receives its match results from one of
        the mentioned matching functions. Returns <code >true</code> once match results
        are available, and <code >false</code> otherwise.</blockquote>
<p>
<li><code >size_type size() const</code>:<blockquote >Returns the number of sub-matches. E.g., with a regular expression
        <code >(abc)|(def)</code> and target <code >defcon</code> three submatches are reported:
        the total match (def); the empty text for <code >(abc)</code>; and <code >def</code> for
        the <code >(def)</code> marked sub-expression. 
<p>
Note: when multipliers are used only the last match is counted and
        reported. E.g., for the pattern <code >(a|b)+</code> and target <code >aaab</code> <em >two</em>
        sub-matches are reported: the total match <code >aaab</code>, and the last match
        (<code >b</code>);</blockquote>
<p>
<li><code >std::string str(size_t idx = 0) const</code>:<blockquote >Returns the characters defining sub-match <code >idx</code>. By default this is
        the full match. If <code >idx &gt;= size()</code> (see below) an empty string
        returned;</blockquote>
<p>
<li><code >std::string const &amp;suffix() const</code>:<blockquote >Returns a (const) reference to a sub-string of the target text that
        starts beyond the last character of the full match;</blockquote>
<p>
<li><code >void swap(match_results &amp;other) noexcept</code>:<blockquote >Swaps the current <code >match_results</code> object with <code >other</code>. Also
        available as a free function: <code >void swap(match_results &amp;lhs,
        match_results &amp;rhs)</code>, swapping <code >lhs</code> and <code >rhs</code>.</blockquote>
    </ul>
<p>
<a name="REGALG"></a><a name="l359"></a>
<h3 >18.7.4: Regular expression matching functions</h3>
    Before using the functions presented in this section the <a name="an2204"></a><code >&lt;regex&gt;</code> header
file must be included.
<p>
There are three major families of functions that can be used to match a target
text against a regular expression. Each of these functions, as well as the
<code >match_results::format</code> member, has a final
<code >std::regex_constants::match_flag_type</code> parameter (see the next section),
which is given the default value <code >regex_constants::match_default</code> which can
be used to fine-tune the way the regular expression and the matching process
is being used. This
final parameter is not explicitly mentioned with the regular expression
matching functions or with the <code >format</code> member. The three families of
functions are:
    <ul>
    <li><a name="an2205"></a><code >bool std::regex_match(Parameters)</code>:<blockquote >This family of functions is used to match a regular expression against
        a target text. Only if the regular expression matches the full target
        text <code >true</code> is returned; otherwise <code >false</code> is returned. Refer to
        section <a href="cplusplus18.html#REGMATCH">18.7.4.2</a> for an overview of the available overloaded
        <code >regex_match</code> functions;</blockquote>
<p>
<li><a name="an2206"></a><code >bool std::regex_search(Parameters)</code>:<blockquote >This family of functions is also used to match a regular expression
        against a target text. This function returns true once the regular
        expression matches a sub-string of the target text; otherwise
        <code >false</code> is returned. See below for an overview of the available
        overloaded <code >regex_search</code> functions;</blockquote>
<p>
<li><a name="an2207"></a><code >ReturnType std::regex_replace(Parameters)</code>:<blockquote >This family of functions is used to produce modified texts, using the
        characters of a target string, a <code >regex</code> object and a format
        string. This member closely resembles the functionality of the 
        <code >match_results::format</code> member discussed in section <a href="cplusplus18.html#FORMAT">18.7.4.4</a>.</blockquote>
    </ul>
    The <code >match_results::format</code> member can be used after <code >regex_replace</code>
and is discussed after covering <code >regex_replace</code> (section <a href="cplusplus18.html#FORMAT">18.7.4.4</a>).
<p>
<a name="l360"></a>
<h4>18.7.4.1: The std::regex_constants::match_flag_type flags</h4>
        All overloaded <code >format</code> members and all regular expression matching
functions accept a final
<code >regex_constants::match_flag_type</code><a name="an2208"></a> argument, which is a
bit-masked type, for which the <code >bit_or</code> operator can be used. All <code >format</code>
members by default specify the argument <code >match_default</code>.
<p>
The <code >match_flag_type</code> enumeration defines the following values (below,
`<code >[first, last)</code>' refers to the character sequence being matched).
<p>
<ul>
<li><a name="an2209"></a><code >format_default</code> (not a bit-mask value, but a default value which is
	equal to 0). With just this specification ECMAScript rules are used to
	construct strings in <code >std::regex_replace</code>;
<p>
<li><a name="an2210"></a><code >format_first_only</code>: <code >std::regex_replace</code> only replaces the first
	match;
<p>
<li><a name="an2211"></a><code >format_no_copy</code>: non-matching strings are not passed to the output
	by <code >std::regex_replace</code>;
<p>
<li><a name="an2212"></a><code >format_sed</code>:  POSIX <strong >sed</strong>(1) rules are used to construct strings in
	<code >std::regex_replace</code>;
<p>
<li><a name="an2213"></a><code >match_any</code>: if multiple matches are possible, then any match is an
	acceptable result;
<p>
<li><a name="an2214"></a><code >match_continuous</code>: sub-sequences are only matching if they start at
	<code >first</code>; 
<p>
<li><a name="an2215"></a><code >match_not_bol</code>: the first character in <code >[first, last)</code> is treated
	as an ordinary character:  <code >^</code> does not match <code >[first, first)</code>;
<p>
<li><a name="an2216"></a><code >match_not_bow</code>: <code >\b</code> does not match <code >[first, first)</code>;
<p>
<li><a name="an2217"></a><code >match_default</code> (not a bit-mask value, but equal to 0): the default
    value of the final argument that's passed to the regular expression
    matching functions and <code >match_results::format</code> member. ECMAScript
	rules are used to construct strings in <code >std::regex_replace</code>;
<p>
<li><a name="an2218"></a><code >match_not_eol</code>: the last character in <code >[first, last)</code> is treated
	as an ordinary character: <code >$</code> does not match <code >[last,last)</code>;
<p>
<li><a name="an2219"></a><code >match_not_eow</code>: <code >\b</code> does  not match <code >[last, last)</code>;
<p>
<li><a name="an2220"></a><code >match_not_null</code>: empty sequences are not considered matches;
<p>
<li><a name="an2221"></a><code >match_prev_avail</code>: <code >--first</code> refers to a valid character
	position. When specified <code >match_not_bol</code> and <code >match_not_bow</code> are
	ignored;
</ul>
<p>
<a name="REGMATCH"></a><a name="l361"></a>
<h4>18.7.4.2: Matching full texts: std::regex_match</h4>
        The regular expression matching function <code >std::regex_match</code><a name="an2222"></a>
returns <code >true</code> if the regular expression defined in its provided
<code >regex</code> argument <em >fully</em> matches the provided target text. This means that
<code >match_results::prefix</code> and <code >match_results::suffix</code> must return empty
strings. But defining sub-expressions is OK.
<p>
The following overloaded variants of this function are available:
    <ul>
    <li><code >bool regex_match(BidirConstIter first, BidirConstIter last,
                  std::match_results &amp;results,
                  std::regex const &amp;re)</code>:<blockquote ><code >BidirConstIter</code> is a bidirectional const iterator. The range
        <code >[first, last)</code> defines the target text. The match results are
        returned in <code >results</code>. The types of the iterators must match the
        type of the <code >match_results</code> that's used. E.g., a <code >cmatch</code> should
        be used if the iterators are of <code >char const *</code> types, and a
        <code >smatch</code> should be used if the iterators are of
        <code >string::const_iterator</code> types. Similar correspondence requirements
        hold true for the other overloaded versions of this function;</blockquote>
<p>
<li><code >bool regex_match(BidirConstIter first, BidirConstIter last,
        std::regex const &amp;re)</code>:<blockquote >this function behaves like the previous function, but does not
        return the results of the matching process in a <code >match_results</code>
        object;</blockquote>
<p>
<li><code >bool regex_match(char const *target,
                  std::match_results &amp;results, std::regex const &amp;re)</code>:<blockquote >this function behaves like the first overloaded variant, using
        the characters in <code >target</code> as its target text;</blockquote>
<p>
<li><code >bool regex_match(char const *str, std::regex const &amp;re)</code>:<blockquote >this function behaves like the previous function but does not return
        the match results;</blockquote>
<p>
<li><code >bool regex_match(std::string const &amp;target,
                  std::match_results &amp;results, std::regex const &amp;re)</code>:<blockquote >this function behaves like the first overloaded variant, using
        the characters in <code >target</code> as its target text;</blockquote>
<p>
<li><code >bool regex_match(std::string const &amp;str, std::regex const &amp;re)</code>:<blockquote >this function behaves like the previous function but does not return
        the match results;</blockquote>
<p>
<li><code >bool regex_match(std::string const &amp;&amp;, std::match_results &amp;, 
                         std::regex &amp;) = delete</code>
       (the <code >regex_match</code> function does not accept temporary <code >string</code>
        objects as target strings, as this would result in invalid string
        iterators in the <code >match_result</code> argument.)
    </ul>
    Here is a small example: the regular expression matches the matched text
(provided by <code >argv[1]</code>) if it starts with 5 digits and then 
merely contains  letters (<code >[[:alpha:]]</code>). The digits can be retrieved as
sub-expression 1:
        <pre>
    #include &lt;iostream&gt;
    #include &lt;regex&gt;
    
    using namespace std;
    
    int main(int argc, char const **argv)
    {
        regex re("(\\d{5})[[:alpha:]]+"); 

        cmatch results;

        if (not regex_match(argv[1], results, re))
            cout &lt;&lt; "No match\n";
        else
            cout &lt;&lt; "size: " &lt;&lt; results.size() &lt;&lt; ": " &lt;&lt; 
                    results.str(1) &lt;&lt; " -- " &lt;&lt; results.str() &lt;&lt; '\n';
    }
</pre>
<p>
<a name="REGSRCH"></a><a name="l362"></a>
<h4>18.7.4.3: Partially matching text: std::regex_search</h4>
        Different from <code >regex_match</code> the regular expression matching function
<code >std::regex_search</code><a name="an2223"></a> returns <code >true</code> if the regular
expression defined in its <code >regex</code> argument partially matches the target
text.
<p>
The following overloaded variants of this function are available:
    <ul>
    <li><code >bool regex_search(BidirConstIter first, BidirConstIter last,
                  std::match_results &amp;results,
                  std::regex const &amp;re)</code>:<blockquote ><code >BidirConstIter</code> is a bidirectional const iterator. The range 
        <code >[first, last)</code> defines the target text. The match results are
        returned in <code >results</code>. The types of the iterators must match the
        type of the <code >match_results</code> that's used. E.g., a <code >cmatch</code> should
        be used if the iterators are of <code >char const *</code> types, and a
        <code >smatch</code> should be used if the iterators are of
        <code >string::const_iterator</code> types. Similar correspondence requirements
        hold true for the other overloaded versions of this function;</blockquote>
<p>
<li><code >bool regex_search(BidirConstIter first, BidirConstIter last,
        std::regex const &amp;re)</code>:<blockquote >this function behaves like the previous function, but does not
        return the results of the matching process in a <code >match_results</code>
        object;</blockquote>
<p>
<li><code >bool regex_search(char const *target,
                  std::match_results &amp;results, std::regex const &amp;re)</code>:<blockquote >this function behaves like the first overloaded variant, using
        the characters in <code >target</code> as its target text;</blockquote>
<p>
<li><code >bool regex_search(char const *str, std::regex const &amp;re)</code>:<blockquote >this function behaves like the previous function but does not return
        the match results;</blockquote>
<p>
<li><code >bool regex_search(std::string const &amp;target,
                  std::match_results &amp;results, std::regex const &amp;re)</code>:<blockquote >this function behaves like the first overloaded variant, using
        the characters in <code >target</code> as its target text;</blockquote>
<p>
<li><code >bool regex_search(std::string const &amp;str, std::regex const &amp;re)</code>:<blockquote >this function behaves like the previous function but does not return
        the match results;</blockquote>
<p>
<li><code >bool regex_search(std::string const &amp;&amp;, std::match_results &amp;, 
                         std::regex &amp;) = delete</code>:<blockquote >the <code >regex_search</code> function does not accept temporary <code >string</code>
        objects as target strings, as this would result in invalid string
        iterators in the <code >match_result</code> argument.</blockquote>
    </ul>
    The following example illustrates how <code >regex_search</code> could be used:
    <pre>
     1: #include &lt;iostream&gt;
     2: #include &lt;string&gt;
     3: #include &lt;regex&gt;
     4: 
     5: using namespace std;
     6: 
     7: int main()
     8: {
     9:     while (true)
    10:     {
    11:         cout &lt;&lt; "Enter a pattern or plain Enter to stop: ";
    12: 
    13:         string pattern;
    14:         if (not getline(cin, pattern) or pattern.empty())
    15:             break;
    16: 
    17:         regex re(pattern);
    18:         while (true)
    19:         {
    20:             cout &lt;&lt; "Enter a target text for `" &lt;&lt; pattern &lt;&lt; "'\n"
    21:                     "(plain Enter for the next pattern): ";
    22: 
    23:             string text;
    24:             if (not getline(cin, text) or text.empty())
    25:                 break;
    26: 
    27:             smatch results;
    28:             if (not regex_search(text, results, re))
    29:                 cout &lt;&lt; "No match\n";
    30:             else
    31:             {
    32:                 cout &lt;&lt; "Prefix: "  &lt;&lt; results.prefix() &lt;&lt; "\n"
    33:                         "Match:  "  &lt;&lt; results.str()    &lt;&lt; "\n"
    34:                         "Suffix: "  &lt;&lt; results.suffix() &lt;&lt; "\n";
    35:                 for (size_t idx = 1; idx != results.size(); ++idx)
    36:                     cout &lt;&lt; "Match " &lt;&lt; idx &lt;&lt; " at offset " &lt;&lt;
    37:                                 results.position(idx) &lt;&lt; ": " &lt;&lt;
    38:                                 results.str(idx) &lt;&lt; '\n';
    39:             }
    40:         }
    41:     }
    42: }
</pre>
<p>
<a name="FORMAT"></a><a name="l363"></a>
<h4>18.7.4.4: The member std::match:_results::format</h4>
        The <code >match_results::format</code><a name="an2224"></a><code >format</code> member is a rather complex member
function of the class <code >match_results</code>, which can be used to modify text
which was previously matched against a regular expression, e.g., using the
function <code >regex_search</code>. Because of its complexity and because the
functionality of another regular expression processing function
(<code >regex_replace</code>) offers similar functionality it is discussed at this point
in the <strong >C++</strong> Annotations, just before discussing the <code >regex_replace</code> function.
<p>
The <code >format</code> member operates on (sub-)matches contained in a
<code >match_results</code> object, using a <a name="an2225"></a><em >format string</em>, and producing text in
which <a name="an2226"></a> format specifiers (like <code >$&amp;</code>) are replaced by
matching sections of the originally provided target text. In addition, the
<code >format</code> member recognizes all standard <strong >C</strong> escape sequences (like
<code >\n</code>). The <code >format</code> member is used to create text that is modified with
respect to the original target text.
<p>
As a preliminary illustration: if <code >results</code> is a <code >match_results</code> object
and <code >match[0]</code> (the fully matched text) equals `<code >hello world</code>', then
calling <code >format</code> with the format string <code >this is [$&amp;]</code> produces the text
<code >this is [hello world]</code>. Note the specification <code >$&amp;</code> in this format
string: this is an example of a format specifier. Here is an overview of all
supported format specifiers:
    <ul>
    <li><code >$`</code>: corresponds to the text returned by the <code >prefix</code> member: all
        characters in the original target text up to the first character
        of the fully matched text;
    <li><code >$&amp;</code>: corresponds to the fully matched text (i.e., the text returned by
        the <code >match_results::str</code> member);
    <li><code >$n</code>: (where <code >n</code> is an integral natural number): corresponds to the
        text returned bu <code >operator[](n)</code>;
    <li><code >$'</code>: corresponds to the text returned by the <code >suffix</code> member: all
        characters in the original target string beyond the last character
        of the fully matched text;
    <li><code >$$</code>: corresponds to the single <code >$</code> character.
    </ul>
<p>
Four overloaded versions of the <code >format</code> members are available. All
overloaded versions define a final <code >regex_constants::match_flag_type</code>
parameter, which is by default initialized to <code >match_default</code>. This final
parameter is not explicitly mentioned in the following coverage of the
<code >format</code> members.
<p>
To further illustrate the way the <code >format</code> members can be used it is assumed
that the following code has been executed:
    <pre>
     1:     regex re("([[:alpha:]]+)\\s+(\\d+)");  // letters blanks digits
     2: 
     3:     smatch results;
     4:     string target("this value 1024 is interesting");
     5: 
     6:     if (not regex_search(target, results, re))
     7:         return 1;
</pre>
  After calling <code >regex_search</code> (line 6) the results of the regular
expression matching process are available in the <code >match_results results</code>
object that is defined in line 3.
<p>
The first two overloaded <code >format</code> functions expect an output-iterator to
where the formatted text is written. These overloaded members return the 
final output iterator, pointing just beyond the character that was last
written.
    <ul>
    <li><code >OutputIter format(OutputIter out, char const *first, char const
        *last)  const</code>:<blockquote >the characters in the range <code >[first, last)</code> are applied to the 
        sub-expressions stored in the <code >match_results</code> object, and the
        resulting string is inserted at <code >out</code>. An illustration is provided
        with the next overloaded version;</blockquote>
<p>
<li><code >OutputIter format(OutputIter out, std::string const &amp;fmt)  const</code>:<blockquote >the contents of <code >fmt</code> are applied to the sub-expressions stored in
        the <code >match_results</code> object, and the resulting string is inserted at
        <code >out</code>. The next line of code inserts the value 1024 into <code >cout</code>
        (note that <code >fmt</code> <em >must</em> be a <code >std::string</code>, hence the explicit
        use of the <code >string</code> constructor):
         <pre>
results.format(ostream_iterator&lt;char&gt;(cout, ""), string("$2"));
</pre>
        </blockquote>
    </ul>
<p>
The remaining two overloaded <code >format</code> members expect a <code >std::string</code> or
an NTBS defining the format string. Both members return a <code >std::string</code>
containing the formatted text:
    <ul>
    <li><code >std::string format(std::string const &amp;fmt) const</code>
    <li><code >std::string format(char const *fmt) const</code>
    </ul>
    The next example shows how a <code >string</code> can be obtained
in which the order of the first and second marked sub-expressions contained in
the previously obtained <code >match_results</code> object have been
swapped: 
    <pre>
    string reverse(results.format("$2 and $1"));
</pre>
<p>
<a name="REGREP"></a><a name="l364"></a>
<h4>18.7.4.5: Modifying target strings: std::regex_replace</h4>
        The family of <code >std::regex_replace</code><a name="an2227"></a> functions uses regular
expressions to perform substitution on sequences of characters. Their
functionality closely resembles the functionality of the
<code >match_results::format</code> member discussed in the previous section. The
following overloaded variants are available:
    <ul>
    <li><code >OutputIt regex_replace(OutputIter out, 
                        BidirConstIter first, BidirConstIter last,
                        std::regex const &amp;re, std::string const &amp;fmt)</code>:<blockquote ><code >OutputIter</code> is an output iterator; <code >BidirConstIter</code> a
        bidirectional const iterator.
<p>
The function returns the possibly modified text in an iterator range
            <code >[out, retvalue)</code>, where <code >out</code> is the output iterator
            passed as the first argument to <code >regex_replace</code>, and
            <code >retvalue</code> is the output iterator returned by
            <code >regex_replace</code>. 
<p>
The function matches the text at the range <code >[first, last)</code>
            against the regular expression stored in <code >re</code>. If the regular
            expression does <em >not</em> match the target text in the range
            <code >[first, last)</code> then the target text is literally copied to
            <code >out</code>. If the regular expression <em >does</em> match the target text
            then 
       <ul>
        <li> first, the match result's prefix is copied to <code >out</code>. The prefix
            equals the initial characters of the target text up to the very
            first character of the fully matched text.
        <li> next, the matched text is replaced by the contents of the <code >fmt</code>
            format string, in which the format specifiers can be used that
            were described in the previous section (section <a href="cplusplus18.html#FORMAT">18.7.4.4</a>), and
            the replaced text is copied to <code >out</code>;
        <li> finally, the match result's suffix is copied to <code >out</code>. The
            suffix equals all characters of the target text beyond the last
            character of the matched text.
        </ul>
        The workings of <code >regex_replace</code> is illustrated in the next example:
    <pre>
 1:     regex re("([[:alpha:]]+)\\s+(\\d+)");  // letters blanks digits
 2: 
 3:     string target("this value 1024 is interesting");
 4: 
 5:     regex_replace(ostream_iterator&lt;char&gt;(cout, ""), target.begin(),
 6:                     target.end(), re, string("$2"));
</pre>
       In line 5 <code >regex_replace</code> is called. Its format string merely
        contains <code >$2</code>, matching 1024 in the target text. The prefix ends at
        the word <code >value</code>, the suffix starts beyond 1024, so the statement in
        line 5 inserts the text <pre>
this 1024 is interesting
</pre>
 into the
        standard output stream.  </blockquote>
<p>
<li><code >OutputIt regex_replace( OutputIter out, BidirConstIter first,
        BidirConstIter last, std::regex const &amp;re, char const *fmt)</code>:<blockquote >This variant behaves like the first variant. When using, in the above
        example, <code >"$2"</code> instead of <code >string("$2")</code>, then this variant would
        have been used;</blockquote>
<p>
<li><code >std::string regex_replace(std::string const &amp;str,
                   std::regex const &amp;re, std::string const &amp;fmt)</code>:<blockquote >This variant returns a <code >std::string</code> containing the modified text,
        and expects a <code >std::string</code> containing the target text. Other than
        that, it behaves like the first variant. To use this overloaded
        variant in the above example the statement in line 5 could have been
        replaced by the following statement, initializing the <code >string
        result</code>:
       <pre>
string result(regex_replace(target, re, string("$2")));
</pre>
       </blockquote> 
<p>
<li><code >std::string regex_replace(std::string const &amp;str,
                   std::regex const &amp;re, char const *fmt)</code>:<blockquote >After changing, in the above statement, <code >string("$2")</code> into
        <code >"$2"</code>, this variant is used, behaving exactly like the previous
        variant;</blockquote>
<p>
<li><code >std::string regex_replace(char const *str,
                   std::regex const &amp;re, std::string const &amp;fmt)</code>:<blockquote >This variant uses a <code >char const *</code> to point to the target text, and
        behaves exactly like the previous but one variant;</blockquote>
<p>
<li><code >std::string regex_replace(char const *str,
                   std::regex const &amp;re, char const *fmt)</code>:<blockquote >This variant also uses a <code >char const *</code> to point to the target text,
        and also behaves exactly like the previous but one variant;</blockquote>
    </ul>
<p>
<a name="l365"></a>
<h2 >18.8: Randomization and Statistical Distributions</h2>
    Before the statistical distributions and accompanying random number
generators can be used the <a name="an2228"></a><code >&lt;random&gt;</code> header file must be included.
<p>
The STL offers several standard mathematical (statistical)
distributions. These distributions allow programmers to obtain randomly
selected values from a selected distribution.
<p>
These statistical distributions need to be provided with a random number
generating object. Several of such random number generating objects are
provided, extending the traditional <a name="an2229"></a><code >rand</code> function that is part of the
<strong >C</strong> standard library.
<p>
These random number generating objects produce pseudo-random numbers, which
are then processed by the statistical distribution to obtain values that are
randomly selected from the specified distribution.
<p>
Although the STL offers various statistical distributions their functionality
is fairly limited. The distributions allow us to obtain a random number from
these distributions, but
    <a name="an2230"></a>probability density functions
 or
    <a name="an2231"></a>cumulative distribution functions
 are currently not provided by the STL. These functions (distributions as well
as the density and the cumulative distribution functions) are, however,
available in other libraries, like the
    <a target=_top href="http://www.boost.org/">boost math library</a> (specifically:<br/>
     <a href="http://www.boost.org/doc/libs/1_44_0/libs/math/doc/sf_and_dist/html/index.html">http://www.boost.org/doc/libs/1_44_0/libs/math/doc/sf_and_dist/html/index.html</a>).
<p>
It is beyond the scope of the <strong >C++</strong> Annotations to discuss the mathematical
characteristics of the various statistical distributions. The interested
reader is referred to the pertinent mathematical textbooks (like Stuart and
Ord's (2009)
    <a name="an2232"></a>
    <a name="an2233"></a><em >Kendall's Advanced Theory of Statistics</em>, Wiley) or to web-locations
like <a href="http://en.wikipedia.org/wiki/Bernoulli_distribution">http://en.wikipedia.org/wiki/Bernoulli_distribution</a>.
<p>
<a name="l366"></a>
<h3 >18.8.1: Random Number Generators</h3>
    The following <a name="an2234"></a>generators are available:
<div style="text-align: center">
<table>

<tr><td colspan=5><hr/></td></tr>


<tr >
<td > Class template</td><td > Integral/Floating point</td><td > Quality</td><td > Speed</td><td > Size of state</td>
 
</tr>

<tr><td colspan=5><hr/></td></tr>


<tr >
<td > <a name="an2235"></a><code >linear_congruential_engine</code></td><td > Integral</td><td > Medium</td><td > Medium</td><td > 1</td>
 
</tr>


<tr >
<td > <a name="an2236"></a><code >subtract_with_carry_engine</code></td><td > Both</td><td > Medium</td><td > Fast</td><td > 25</td>
 
</tr>


<tr >
<td > mersenne_twister_engine</td><td > Integral</td><td > Good</td><td > Fast</td><td > 624</td>
 
</tr>

<tr><td colspan=5><hr/></td></tr>


</table></div>
<p>
The <a name="an2237"></a><code >linear_congruential_engine</code> random number generator computes
    <div style="text-align: center"><code >value</code><sub >i+1</sub><code > = OPENPAa * value</code><sub >i</sub><code > +
                                                              c+) % m</code></div>
    It expects template arguments for, respectively, the data type to contain
the generated random values; the multiplier <code >a</code>; the additive constant
<code >c</code>; and the modulo value <code >m</code>. Example:
        <pre>
    linear_congruential_engine&lt;int, 10, 3, 13&gt; lincon;
</pre>
    The <code >linear_congruential</code> generator may be seeded by providing its
constructor with a seeding-argument. E.g., <code >lincon(time(0))</code>.
<p>
The <a name="an2238"></a><code >subtract_with_carry_engine</code> random number generator computes
    <div style="text-align: center"><code >value</code><sub >i</sub><code > = (value</code><sub >i-s</sub><code > -
                                                            value</code><sub >i-r</sub><code > - carry</code><sub >i-1</sub><code >) % m</code></div>
    It expects template arguments for, respectively, the data type to contain
the generated random values; the modulo value <code >m</code>; and the subtractive
constants <code >s</code> and <code >r</code>. Example:
        <pre>
    subtract_with_carry_engine&lt;int, 13, 3, 13&gt; subcar;
</pre>
    The <code >subtract_with_carry_engine</code> generator may be seeded by providing
its constructor with a seeding-argument. E.g., <code >subcar(time(0))</code>.
<p>
The predefined <code >mersenne_twister_engine mt19937</code> (predefined using a
<code >typedef</code> defined by the <a name="an2239"></a><code >&lt;random&gt;</code> header file) is used in the examples
below. It can be constructed using
    <a name="an2240"></a>`<code >mt19937 mt</code>' or it can be seeded by providing its
constructor with an argument (e.g., <code >mt19937 mt(time(0))</code>).
    Other ways to initialize the <code >mersenne_twister_engine</code> are beyond the
scope of the <strong >C++</strong> Annotations (but see Lewis<a name="an2241"></a> <em >et
al.</em>&nbsp;(
    Lewis, P.A.W., Goodman, A.S., and Miller, J.M. (1969), A pseudorandom
number generator for the System/360, IBM Systems Journal, 8, 136-146.) (1969)).
<p>
The random number generators may also be seeded by calling their members
<code >seed</code>  accepting <code >unsigned long</code> values or generator functions (as in
<code >lc.seed(time(0)), lc.seed(mt)</code>).
<p>
The random number generators offer members <a name="an2242"></a><code >min</code> and <a name="an2243"></a><code >max</code>
returning, respectively, their minimum and maximum values (inclusive). If a
reduced range is required the generators can be nested in a function or class
adapting the range.
<p>
<a name="l367"></a>
<h3 >18.8.2: Statistical distributions</h3>
    In the following sections the various statistical distributions that are
supported by <strong >C++</strong> are covered. The notation <a name="an2244"></a><code >RNG</code> is used to
indicate a <em >Random Number Generator</em> and <a name="an2245"></a><code >URNG</code> is used to indicate a
<em >Uniform Random Number Generator</em>. With each distribution a
<code >struct param_type</code> is defined containing the distribution's parameters. The
organization of these <code >param_type</code> structs depends on (and is described
at) the actual distribution.
<p>
All distributions offer the following members (<em >result_type</em> refers to
the type name of the values returned by the distribution):
    <ul>
    <li><code >result_type max() const</code><br/>
        returns the distribution's least upper bound;
    <li><code >result_type min() const</code><br/>
        returns the distribution's greatest lower bound;
    <li><code >param_type param() const</code><br/>
        returns the object's <code >param_type</code> struct;
    <li><code >void param(const param_type &amp;param)</code>
        redefines the parameters of the distribution;
    <li><code >void reset():</code>
       clears all of its cached values;
    </ul>
<p>
All distributions support the following operators (<em >distribution-name</em>
        should be replaced by the name of the intended distribution, e.g.,
        <code >normal_distribution</code>):
    <ul>
    <li><code >template&lt;typename URNG&gt; result_type operator()(URNG &amp;urng)</code><br/>
       returns the next random value from the statistical distribution, with
        the function object <code >urng</code> returning the next random number selected
        from a uniform random distribution;
    <li><code >template&lt;typename URNG&gt; result_type operator()</code><br/>
       <code >(URNG &amp;urng, param_type &amp;param)</code><br/> returns the next random value
        from the statistical distribution initialized with the parameters
        provided by the <code >param</code> struct.  The function object <code >urng</code>
        returns the next random number selected from a uniform random
        distribution;
    <li><code >std::istream &amp;operator&gt;&gt;(std::istream &amp;in,
            distribution-name &amp;object):</code>
       The parameters of the distribution are extracted from an
        <code >std::istream</code>;
    <li><code >std::ostream &amp;operator&lt;&lt;(std::ostream &amp;out,
            distribution-name const &amp;bd):</code>
        The parameters of the distribution are inserted into an
        <code >std::ostream</code>
    </ul>
<p>
The following example shows how the distributions can be used. Replacing
the name of the distribution (<code >normal_distribution</code>) by another
distribution's name is all that is required to switch distributions. All
distributions have parameters, like the mean and standard deviation of the
normal distribution, and all parameters have default values. The names of the
parameters vary over distributions and are mentioned below at the individual
distributions. Distributions offer members returning or setting their
parameters.
<p>
Most distributions are defined as class templates, requiring the specification
of a data type that is used for the function's return type. If so, an empty
template parameter type specification (<code >&lt;&gt;</code>) will get you the default
type. The default types are either <code >double</code> (for real valued return types)
or <code >int</code> (for integral valued return types). The template parameter type
specification must be omitted with distributions that are not defined as
template classes.
<p>
Here is an example showing the use of the statistical distributions, applied
to the normal distribution:
<p>
<pre>
#include &lt;iostream&gt;
#include &lt;ctime&gt;
#include &lt;random&gt;
using namespace std;

int main()
{
    std::mt19937 engine(time(0));
    std::normal_distribution&lt;&gt; dist;

    for (size_t idx = 0; idx &lt; 10; ++idx)
        std::cout &lt;&lt; "a random value: " &lt;&lt; dist(engine) &lt;&lt; "\n";

    cout &lt;&lt; '\n' &lt;&lt;
        dist.min() &lt;&lt; " " &lt;&lt; dist.max() &lt;&lt; '\n';
}
</pre>
<p>
<a name="BERNOULLI"></a><a name="l368"></a>
<h4>18.8.2.1: Bernoulli distribution</h4>
        The <a name="an2246"></a><code >bernoulli_distribution</code> is used to generate logical truth (boolean)
values with a certain probability <code >p</code>. It is equal to a binomial
distribution for one experiment (cf <a href="cplusplus18.html#BINOMIAL">18.8.2.2</a>).
<p>
The bernoulli distribution is <em >not</em> defined as a class template.
<p>
Defined types:
            <pre>
    typedef bool result_type;
    struct param_type
    {
      explicit param_type(double prob = 0.5);
      double p() const;                     // returns prob
    };
</pre>
<p>
Constructor and members:
    <ul>
    <li><code >bernoulli_distribution(double prob = 0.5)</code><br/>
        constructs a bernoulli distribution with probability <code >prob</code> of
        returning <code >true</code>;
    <li><code >double p() const</code><br/>
        returns <code >prob</code>;
    <li><code >result_type min() const</code><br/>
        returns <code >false</code>;
    <li><code >result_type max() const</code><br/>
        returns <code >true</code>;
    </ul>
<p>
<a name="BINOMIAL"></a><a name="l369"></a>
<h4>18.8.2.2: Binomial distribution</h4>
        The <a name="an2247"></a><code >binomial_distribution&lt;IntType = int&gt;</code> is used to determine the
probability of the number of successes in a sequence of <code >n</code> independent
success/failure experiments, each of which yields success with probability
<code >p</code>.
<p>
The template type parameter <code >IntType</code> defines the type of the generated
random value, which must be an integral type.
<p>
Defined types:
            <pre>
    typedef IntType result_type;
    struct param_type
    {
      explicit param_type(IntType trials, double prob = 0.5);
      IntType t() const;                    // returns trials
      double p() const;                     // returns prob
    };
</pre>
<p>
Constructors and members and example:
    <ul>
    <li><code >binomial_distribution&lt;&gt;(IntType trials = 1, double prob = 0.5)</code>
        constructs a binomial distribution for <code >trials</code> experiments, each
        having probability <code >prob</code> of success.
    <li><code >binomial_distribution&lt;&gt;(param_type const &amp;param)</code>
        constructs a binomial distribution according to the values stored in
        the <code >param</code> struct.
    <li><code >IntType t() const</code><br/>
        returns <code >trials</code>;
    <li><code >double p() const</code><br/>
        returns <code >prob</code>;
    <li><code >result_type min() const</code> <br/>
        returns 0;
    <li><code >result_type max() const</code><br/>
        returns <code >trials</code>;
    </ul>
<p>
<a name="l370"></a>
<h4>18.8.2.3: Cauchy distribution</h4>
        The <a name="an2248"></a><code >cauchy_distribution&lt;RealType = double&gt;</code> looks similar to a normal
distribution. But cauchy distributions have heavier tails.  When studying
hypothesis tests that assume normality, seeing how the tests perform on data
from a Cauchy distribution is a good indicator of how sensitive the tests are
to heavy-tail departures from normality.
<p>
The mean and standard deviation of the Cauchy distribution are undefined.
<p>
Defined types:
        <pre>
    typedef RealType result_type;

    struct param_type
    {
        explicit param_type(RealType a = RealType(0),
                            RealType b = RealType(1));

        double a() const;
        double b() const;
    };
</pre>
<p>
Constructors and members:
    <ul>
    <li><code >cauchy_distribution&lt;&gt;(RealType a = RealType(0),
                            RealType b = RealType(1))</code>
        constructs a cauchy distribution with specified <code >a</code> and <code >b</code>
        parameters.
    <li><code >cauchy_distribution&lt;&gt;(param_type const &amp;param)</code>
        constructs a cauchy distribution according to the values stored in
        the <code >param</code> struct.
    <li><code >RealType a() const</code><br/>
        returns the distribution's <code >a</code> parameter;
    <li><code >RealType b() const</code><br/>
        returns the distribution's <code >b</code> parameter;
    <li><code >result_type min() const</code><br/>
        returns the smallest positive <code >result_type</code> value;
    <li><code >result_type max() const</code><br/>
        returns the maximum value of <code >result_type</code>;
    </ul>
<p>
<a name="CHISQUARED"></a><a name="l371"></a>
<h4>18.8.2.4: Chi-squared distribution</h4>
        The <a name="an2249"></a><code >chi_squared_distribution&lt;RealType = double&gt;</code> with <code >n</code> degrees of
freedom is the distribution of a sum of the squares of <code >n</code> independent
standard normal random variables.
<p>
Note that even though the distribution's parameter <code >n</code> usually is an
integral value, it doesn't have to be integral, as the chi_squared
distribution is defined in terms of functions (<code >exp</code> and <code >Gamma</code>) that
take real arguments (see, e.g., the formula shown in the <code >&lt;bits/random.h&gt;</code>
header file, provided with the Gnu <code >g++</code> compiler distribution).
<p>
The chi-squared distribution is used, e.g., when testing the goodness of fit
of an observed distribution to a theoretical one.
<p>
Defined types:
        <pre>
    typedef RealType result_type;

    struct param_type
    {
        explicit param_type(RealType n = RealType(1));

        RealType n() const;
    };
</pre>
<p>
Constructors and members:
    <ul>
    <li><code >chi_squared_distribution&lt;&gt;(RealType n = 1)</code>
       constructs a chi_squared distribution with specified number of degrees
        of freedom.
    <li><code >chi_squared_distribution&lt;&gt;(param_type const &amp;param)</code>
       constructs a chi_squared distribution according to the value stored in
        the <code >param</code> struct;
    <li><code >IntType n() const</code><br/>
        returns the distribution's degrees of freedom;
    <li><code >result_type min() const</code><br/>
        returns 0;
    <li><code >result_type max() const</code><br/>
        returns the maximum value of <code >result_type</code>;
    </ul>
<p>
<a name="l372"></a>
<h4>18.8.2.5: Extreme value distribution</h4>
        The <a name="an2250"></a><code >extreme_value_distribution&lt;RealType = double&gt;</code> is related to the
Weibull distribution and is used in statistical models where the variable of
interest is the minimum of many random factors, all of which can take positive
or negative values.
<p>
It has two parameters: a location parameter <code >a</code> and scale parameter <code >b</code>.
See also <br/>
    <a target=_top href="http://www.itl.nist.gov/div898/handbook/apr/section1/apr163.htm">http://www.itl.nist.gov/div898/handbook/apr/section1/apr163.htm</a>
<p>
Defined types:
        <pre>
typedef RealType result_type;

struct param_type
{
    explicit param_type(RealType a = RealType(0),
                        RealType b = RealType(1));

    RealType a() const;     // the location parameter
    RealType b() const;     // the scale parameter
};
</pre>
<p>
Constructors and members:
    <ul>
    <li><code >extreme_value_distribution&lt;&gt;(RealType a = 0, RealType b = 1)</code>
        constructs an extreme value distribution with specified <code >a</code> and
        <code >b</code> parameters;
    <li><code >extreme_value_distribution&lt;&gt;(param_type const &amp;param)</code>
        constructs an extreme value distribution according to the values
        stored in the <code >param</code> struct.
    <li><code >RealType a() const</code><br/>
        returns the distribution's location parameter;
    <li><code >RealType stddev() const</code><br/>
        returns the distribution's scale parameter;
    <li><code >result_type min() const</code><br/>
        returns the smallest positive value of <code >result_type</code>;
    <li><code >result_type max() const</code><br/>
        returns the maximum value of <code >result_type</code>;
    </ul>
<p>
<a name="l373"></a>
<h4>18.8.2.6: Exponential distribution</h4>
        The <a name="an2251"></a><code >exponential_distribution&lt;RealType = double&gt;</code> is used to describe the
lengths between events that can be modeled with a homogeneous Poisson
process. It can be interpreted as the continuous form of the
geometric distribution.
<p>
Its parameter <code >prob</code> defines the distribution's <em >lambda</em> parameter, called
its <em >rate</em> parameter. Its expected value and standard deviation are both
<code >1 / lambda</code>.
<p>
Defined types:
        <pre>
    typedef RealType result_type;

    struct param_type
    {
        explicit param_type(RealType lambda = RealType(1));

        RealType lambda() const;
    };
</pre>
<p>
Constructors and members:
    <ul>
    <li><code >exponential_distribution&lt;&gt;(RealType lambda = 1)</code>
       constructs an exponential distribution with specified <code >lambda</code>
        parameter.
    <li><code >exponential_distribution&lt;&gt;(param_type const &amp;param)</code>
       constructs an exponential distribution according to the value stored in
        the <code >param</code> struct.
    <li><code >RealType lambda() const</code><br/>
        returns the distribution's <code >lambda</code> parameter;
    <li><code >result_type min() const</code><br/>
        returns 0;
    <li><code >result_type max() const</code><br/>
        returns the maximum value of <code >result_type</code>;
    </ul>
<p>
<a name="l374"></a>
<h4>18.8.2.7: Fisher F distribution</h4>
        The <a name="an2252"></a><code >fisher_f_distribution&lt;RealType = double&gt;</code> is intensively used in
statistical methods like the Analysis of Variance. It is the distribution
resulting from dividing two <em >Chi-squared</em> distributions.
<p>
It is characterized by two parameters, being the degrees of freedom of the two
chi-squared distributions.
<p>
Note that even though the distribution's parameter <code >n</code> usually is an
integral value, it doesn't have to be integral, as the Fisher F distribution
is constructed from Chi-squared distributions that accept a non-integral
parameter value (see also section <a href="cplusplus18.html#CHISQUARED">18.8.2.4</a>).
<p>
Defined types:
        <pre>
    typedef RealType result_type;

    struct param_type
    {
        explicit param_type(RealType m = RealType(1),
                            RealType n = RealType(1));

        RealType m() const; // The degrees of freedom of the nominator
        RealType n() const; // The degrees of freedom of the denominator
    };
</pre>
<p>
Constructors and members:
    <ul>
    <li><code >fisher_f_distribution&lt;&gt;(RealType m = RealType(1),
                                RealType n = RealType(1))</code>
        constructs a fisher_f distribution with specified degrees of freedom.
    <li><code >fisher_f_distribution&lt;&gt;(param_type const &amp;param)</code>
        constructs a fisher_f distribution according to the values stored in
        the <code >param</code> struct.
    <li><code >RealType m() const</code><br/>
        returns the degrees of freedom of the nominator;
    <li><code >RealType n() const</code><br/>
        returns the degrees of freedom of the denominator;
    <li><code >result_type min() const</code><br/>
        returns 0;
    <li><code >result_type max() const</code><br/>
        returns the maximum value of <code >result_type</code>;
    </ul>
<p>
<a name="l375"></a>
<h4>18.8.2.8: Gamma distribution</h4>
        The <a name="an2253"></a><code >gamma_distribution&lt;RealType = double&gt;</code> is used when working with data
that are not distributed according to the normal distribution. It is often
used to model waiting times.
<p>
It has two parameters, <code >alpha</code> and <code >beta</code>. Its expected value is <code >alpha
* beta</code> and its standard deviation is <code >alpha * beta</code><sup >2</sup>.
<p>
Defined types:
        <pre>
    typedef RealType result_type;

    struct param_type
    {
        explicit param_type(RealType alpha = RealType(1),
                            RealType beta = RealType(1));

        RealType alpha() const;
        RealType beta() const;
    };
</pre>
<p>
Constructors and members:
    <ul>
    <li><code >gamma_distribution&lt;&gt;(RealType alpha = 1, RealType beta = 1)</code>
        constructs a gamma distribution with specified <code >alpha</code> and <code >beta</code>
        parameters.
    <li><code >gamma_distribution&lt;&gt;(param_type const &amp;param)</code>
        constructs a gamma distribution according to the values stored in
        the <code >param</code> struct.
    <li><code >RealType alpha() const</code><br/>
        returns the distribution's <code >alpha</code> parameter;
    <li><code >RealType beta() const</code><br/>
        returns the distribution's <code >beta</code> parameter;
    <li><code >result_type min() const</code><br/>
        returns 0;
    <li><code >result_type max() const</code><br/>
        returns the maximum value of <code >result_type</code>;
    </ul>
<p>
<a name="l376"></a>
<h4>18.8.2.9: Geometric distribution</h4>
        The <a name="an2254"></a><code >geometric_distribution&lt;IntType = int&gt;</code> is used to model the number
of bernoulli trials (cf. <a href="cplusplus18.html#BERNOULLI">18.8.2.1</a>) needed until the first success.
<p>
It has one parameter, <code >prob</code>, representing the probability of success in an
individual bernoulli trial.
<p>
Defined types:
        <pre>
    typedef IntType result_type;

    struct param_type
    {
        explicit param_type(double prob = 0.5);
        double p() const;
    };
</pre>
<p>
Constructors, members and example:
    <ul>
    <li><code >geometric_distribution&lt;&gt;(double prob = 0.5)</code>
        constructs a geometric distribution for bernoulli trials each having
        probability <code >prob</code> of success.
    <li><code >geometric_distribution&lt;&gt;(param_type const &amp;param)</code>
        constructs a geometric distribution according to the values stored in
        the <code >param</code> struct.
    <li><code >double p() const</code><br/>
        returns the distribution's <code >prob</code> parameter;
    <li><code >param_type param() const</code><br/>
        returns the object's <code >param_type</code> structure;
    <li><code >void param(const param_type &amp;param)</code>
        redefines the parameters of the distribution;
    <li><code >result_type min() const</code><br/>
        returns the distribution's lower bound (= <code >0</code>);
    <li><code >result_type max() const</code><br/>
        returns the distribution's upper bound;
    <li><code >template&lt;typename URNG&gt; result_type operator()(URNG &amp;urng)</code><br/>
        returns the next random value from the geometric distribution
    <li><code >template&lt;typename URNG&gt; result_type operator()</code><br/>
        <code >(URNG &amp;urng, param_type &amp;param)</code><br/>
        returns the next random value from a geometric distribution
        initialized by the provided <code >param</code> struct.
    <li> The random number generator that is passed to the generating
       functions must return integral values. Here is an example showing how
        the geometric distribution can be used:
        <pre>
#include &lt;iostream&gt;
#include &lt;ctime&gt;
#include &lt;random&gt;

int main()
{
    std::linear_congruential_engine&lt;unsigned, 7, 3, 61&gt; engine(0);

    std::geometric_distribution&lt;&gt; dist;

    for (size_t idx = 0; idx &lt; 10; ++idx)
        std::cout &lt;&lt; "a random value: " &lt;&lt; dist(engine) &lt;&lt; "\n";

    std::cout &lt;&lt; '\n' &lt;&lt;
        dist.min() &lt;&lt; " " &lt;&lt; dist.max() &lt;&lt; '\n';

}
</pre>
    </ul>
<p>
<a name="l377"></a>
<h4>18.8.2.10: Log-normal distribution</h4>
        The <a name="an2255"></a><code >lognormal_distribution&lt;RealType = double&gt;</code> is a probability
distribution of a random variable whose logarithm is normally distributed. If
a random variable <code >X</code> has a normal distribution, then <code >Y = e</code><sup >X</sup> has a
log-normal distribution.
<p>
It has two parameters, <em >m</em> and <em >s</em> representing, respectively, the mean
and standard deviation of <code >ln(X)</code>.
<p>
Defined types:
        <pre>
    typedef RealType result_type;

    struct param_type
    {
        explicit param_type(RealType m = RealType(0),
                            RealType s = RealType(1));

        RealType m() const;
        RealType s() const;
    };
</pre>
<p>
Constructor and members:
    <ul>
    <li><code >lognormal_distribution&lt;&gt;(RealType m = 0, RealType s = 1)</code>
       constructs a log-normal distribution for a random variable whose mean
        and standard deviation is, respectively, <code >m</code> and <code >s</code>.
    <li><code >lognormal_distribution&lt;&gt;(param_type const &amp;param)</code> constructs a
        log-normal distribution according to the values stored in the
        <code >param</code> struct.
    <li><code >RealType m() const</code><br/>
        returns the distribution's <code >m</code> parameter;
    <li><code >RealType stddev() const</code><br/>
        returns the distribution's <code >s</code> parameter;
    <li><code >result_type min() const</code><br/>
        returns 0;
    <li><code >result_type max() const</code><br/>
        returns the maximum value of <code >result_type</code>;
    </ul>
<p>
<a name="l378"></a>
<h4>18.8.2.11: Normal distribution</h4>
        The <a name="an2256"></a><code >normal_distribution&lt;RealType = double&gt;</code> is commonly used in science to
describe complex phenomena. When predicting or measuring variables, errors are
commonly assumed to be normally distributed.
<p>
It has two parameters, <em >mean</em> and <em >standard deviation</em>.
<p>
Defined types:
        <pre>
    typedef RealType result_type;

    struct param_type
    {
        explicit param_type(RealType mean = RealType(0),
                            RealType stddev = RealType(1));

        RealType mean() const;
        RealType stddev() const;
    };
</pre>
<p>
Constructors and members:
    <ul>
    <li><code >normal_distribution&lt;&gt;(RealType mean = 0, RealType stddev = 1)</code>
        constructs a normal distribution with specified <code >mean</code> and <code >stddev</code>
        parameters. The default parameter values define the
        <a name="an2257"></a><em >standard normal distribution</em>;
    <li><code >normal_distribution&lt;&gt;(param_type const &amp;param)</code>
        constructs a normal distribution according to the values stored in
        the <code >param</code> struct.
    <li><code >RealType mean() const</code><br/>
        returns the distribution's <code >mean</code> parameter;
    <li><code >RealType stddev() const</code><br/>
        returns the distribution's <code >stddev</code> parameter;
    <li><code >result_type min() const</code><br/>
        returns the lowest positive value of <code >result_type</code>;
    <li><code >result_type max() const</code><br/>
        returns the maximum value of <code >result_type</code>;
    </ul>
<p>
<a name="l379"></a>
<h4>18.8.2.12: Negative binomial distribution</h4>
        The <a name="an2258"></a><code >negative_binomial_distribution&lt;IntType = int&gt;</code> probability distribution
describes the number of successes in a sequence of Bernoulli trials before a
specified number of failures occurs. For example, if one throws a die
repeatedly until the third time 1 appears, then the probability distribution
of the number of other faces that have appeared is a negative binomial
distribution.
<p>
It has two parameters: (<code >IntType</code>) k (&gt; 0), being the number of failures
until the experiment is stopped and (<code >double</code>) p the probability of success
in each individual experiment.
<p>
Defined types:
        <pre>
    typedef IntType result_type;

    struct param_type
    {
        explicit param_type(IntType k = IntType(1), double p = 0.5);

        IntType k() const;
        double p() const;
    };
</pre>
<p>
Constructors and members:
    <ul>
    <li><code >negative_binomial_distribution&lt;&gt;(IntType k = IntType(1),
                                                            double p = 0.5)</code>
       constructs a negative_binomial distribution with specified <code >k</code> and
        <code >p</code> parameters;
    <li><code >negative_binomial_distribution&lt;&gt;(param_type const &amp;param)</code>
       constructs a negative_binomial distribution according to the values
        stored in the <code >param</code> struct.
    <li><code >IntType k() const</code><br/>
        returns the distribution's <code >k</code> parameter;
    <li><code >double p() const</code><br/>
        returns the distribution's <code >p</code> parameter;
    <li><code >result_type min() const</code><br/>
        returns 0;
    <li><code >result_type max() const</code><br/>
        returns the maximum value of <code >result_type</code>;
    </ul>
<p>
<a name="l380"></a>
<h4>18.8.2.13: Poisson distribution</h4>
        The <a name="an2259"></a><code >poisson_distribution&lt;IntType = int&gt;</code> is used to model the probability
of a number of events occurring in a fixed period of time if these events
occur with a known probability and independently of the time since the last
event.
<p>
It has one parameter, <code >mean</code>, specifying the expected number of events in
the interval under consideration. E.g., if on average 2 events are observed in
a one-minute interval and the duration of the interval under study is
10 minutes then <code >mean = 20</code>.
<p>
Defined types:
        <pre>
    typedef IntType result_type;

    struct param_type
    {
        explicit param_type(double mean = 1.0);

        double mean() const;
    };
</pre>
<p>
Constructors and members:
    <ul>
    <li><code >poisson_distribution&lt;&gt;(double mean = 1)</code>
        constructs a poisson distribution with specified <code >mean</code>
        parameter.
    <li><code >poisson_distribution&lt;&gt;(param_type const &amp;param)</code>
        constructs a poisson distribution according to the values stored in
        the <code >param</code> struct.
    <li><code >double mean() const</code><br/>
        returns the distribution's <code >mean</code> parameter;
    <li><code >result_type min() const</code><br/>
        returns 0;
    <li><code >result_type max() const</code><br/>
        returns the maximum value of <code >result_type</code>;
    </ul>
<p>
<a name="l381"></a>
<h4>18.8.2.14: Student t distribution</h4>
        The <a name="an2260"></a><code >student_t_distribution&lt;RealType = double&gt;</code> is a probability
distribution that is used when estimating the mean of a normally distributed
population from small sample sizes.
<p>
It is characterized by one parameter: the degrees of freedom, which is equal
to the sample size - 1.
<p>
Defined types:
        <pre>
    typedef RealType result_type;

    struct param_type
    {
        explicit param_type(RealType n = RealType(1));

        RealType n() const;    // The degrees of freedom
    };
</pre>
<p>
Constructors and members:
    <ul>
    <li><code >student_t_distribution&lt;&gt;(RealType n = RealType(1))</code>
        constructs a student_t distribution with indicated degrees of freedom.
    <li><code >student_t_distribution&lt;&gt;(param_type const &amp;param)</code>
        constructs a student_t distribution according to the values stored in
        the <code >param</code> struct.
    <li><code >RealType n() const</code><br/>
        returns the degrees of freedom;
    <li><code >result_type min() const</code><br/>
        returns 0;
    <li><code >result_type max() const</code><br/>
        returns the maximum value of <code >result_type</code>;
    </ul>
<p>
<a name="l382"></a>
<h4>18.8.2.15: Uniform int distribution</h4>
        The <a name="an2261"></a><code >uniform_int_distribution&lt;IntType = int&gt;</code> can be used to select integral
values randomly from a range of uniformly distributed integral values.
<p>
It has two parameters, <code >a</code> and <code >b</code>, specifying, respectively, the lowest
value that can be returned and the highest value that can be returned.
<p>
Defined types:
        <pre>
    typedef IntType result_type;

    struct param_type
    {
        explicit param_type(IntType a = 0, IntType b = max(IntType));

        IntType a() const;
        IntType b() const;
    };
</pre>
<p>
Constructors and members:
    <ul>
    <li><code >uniform_int_distribution&lt;&gt;(IntType a = 0, IntType b = max(IntType))</code>
        constructs a uniform_int distribution for the specified range of
        values.
    <li><code >uniform_int_distribution&lt;&gt;(param_type const &amp;param)</code>
        constructs a uniform_int distribution according to the values stored in
        the <code >param</code> struct.
    <li><code >IntType a() const</code><br/>
        returns the distribution's <code >a</code> parameter;
    <li><code >IntType b() const</code><br/>
        returns the distribution's <code >b</code> parameter;
    <li><code >result_type min() const</code><br/>
        returns the distribution's <code >a</code> parameter;
    <li><code >result_type max() const</code><br/>
        returns the distribution's <code >b</code> parameter;
    </ul>
<p>
<a name="l383"></a>
<h4>18.8.2.16: Uniform real distribution</h4>
        The <a name="an2262"></a><code >uniform_real_distribution&lt;RealType = double&gt;</code> can be used to select
<code >RealType</code> values randomly from a range of uniformly distributed
<code >RealType</code> values.
<p>
It has two parameters, <code >a</code> and <code >b</code>, specifying, respectively, the
half-open range of values (<code >[a, b)</code>) that can be returned by the
distribution.
<p>
Defined types:
        <pre>
    typedef RealType result_type;

    struct param_type
    {
        explicit param_type(RealType a = 0, RealType b = max(RealType));

        RealType a() const;
        RealType b() const;
    };
</pre>
<p>
Constructors and members:
    <ul>
    <li><code >uniform_real_distribution&lt;&gt;(RealType a = 0, RealType b = max(RealType))</code>
        constructs a uniform_real distribution for the specified range of
        values.
    <li><code >uniform_real_distribution&lt;&gt;(param_type const &amp;param)</code>
        constructs a uniform_real distribution according to the values stored in
        the <code >param</code> struct.
    <li><code >RealType a() const</code><br/>
        returns the distribution's <code >a</code> parameter;
    <li><code >RealType b() const</code><br/>
        returns the distribution's <code >b</code> parameter;
    <li><code >result_type min() const</code><br/>
        returns the distribution's <code >a</code> parameter;
    <li><code >result_type max() const</code><br/>
        returns the distribution's <code >b</code> parameter;
    </ul>
<p>
<a name="l384"></a>
<h4>18.8.2.17: Weibull distribution</h4>
        The <a name="an2263"></a><code >weibull_distribution&lt;RealType = double&gt;</code> is commonly used in
reliability engineering and in survival (life data) analysis.
<p>
It has two or three parameters and the two-parameter variant is offered by the
STL. The three parameter variant has a shape (or slope) parameter, a scale
parameter and a location parameter. The two parameter variant implicitly uses
the location parameter value 0. In the two parameter variant the shape
parameter (a) and the scale parameter (b) are provided. See <br/>
    <a target=_top href="http://www.weibull.com/hotwire/issue14/relbasics14.htm">http://www.weibull.com/hotwire/issue14/relbasics14.htm</a> for an
interesting coverage of the meaning of the Weibull distribution's parameters.
<p>
Defined types:
        <pre>
    typedef RealType result_type;

    struct param_type
    {
        explicit param_type(RealType a = RealType{ 1 },
                            RealType b = RealType{ 1 });

        RealType a() const;     // the shape (slope) parameter
        RealType b() const;     // the scale parameter
    };
</pre>
<p>
Constructors and members:
    <ul>
    <li><code >weibull_distribution&lt;&gt;(RealType a = 1, RealType b = 1)</code>
        constructs a weibull distribution with specified <code >a</code> and <code >b</code>
        parameters;
    <li><code >weibull_distribution&lt;&gt;(param_type const &amp;param)</code>
        constructs a weibull distribution according to the values stored in
        the <code >param</code> struct.
    <li><code >RealType a() const</code><br/>
        returns the distribution's shape (or slope) parameter;
    <li><code >RealType stddev() const</code><br/>
        returns the distribution's scale parameter;
    <li><code >result_type min() const</code><br/>
        returns 0;
    <li><code >result_type max() const</code><br/>
        returns the maximum value of <code >result_type</code>;
    </ul>
<p>
<a name="l385"></a>
<h2 >18.9: The std::experimental/filesystem namespace</h2>
Several system calls are usually available in the context of the <strong >C</strong>
programming language. Such function (like <strong >rename</strong>(2), <code >truncate</code>(2),
<strong >opendir</strong>(2), and <strong >realpath</strong>(3)) are of course also available in <strong >C++</strong>,
but their signatures and use are often less attractive, as they expect <code >char
const *</code> parameters, and may use static buffers or memory allocation based on
<strong >malloc</strong>(3) and <strong >free</strong>(3).
<p>
Wrappers around these functions have been available since 2003 in the
<a href="http://www.boost.org/doc/libs/1_65_1/libs/filesystem/doc/index.htm">Boost library</a>
        <a name="an2264"></a>
    Currently, <strong >C++</strong> directly supports these facilities in the
<code >std::(experimental::)filesystem</code><a name="an2265"></a><a name="an2266"></a>
namespace. To use these facilities the
    <a name="an2267"></a> header file must be included. In addition,
programs using facilities from the <code >std::(experimental::)filesystem</code>
namespace must be linked against the <a name="an2268"></a><code >stdc++fs</code> library:
<code >-lstdc++fs</code>.
<p>
Although the <code >filesystem</code> namespace currently is nested under the
<code >experimental</code> namespace, all facilities are available, and it's likely that
in due time `experimental' in front of <code >filesystem</code> will be dropped. 
<p>
The <code >filesystem</code> namespace is extensive: it offers more
than 10 different classes, and over 30 different free functions.
<p>
In this and subsequent subsections the notation <code >fs::</code> is used to refer to
the namespace <code >std::(experimental::)filesystem</code>.
<p>
<a name="l386"></a>
<h3 >18.9.1: File system exceptions: filesystem_error</h3>
    The <code >std::(experimental::)filesystem</code> namespace offers its own exception
type <a name="an2269"></a><code >filesystem_error</code>. Its constructors have the following signatures (the
bracketed parameters are optional):
        <pre>
    filesystem_error(string const &amp;what, 
                    [path const &amp;path1, [path const &amp;path2,]] 
                    error_code ec);
</pre>
    As <code >filesystem</code> facilities are closely related to standard system
functions, <code >errc</code> error code enumeration values can be used to obtain
<code >error_codes</code> to pass to <code >filesystem_error</code>, as illustrated by the
following little demo-program:
    <pre>
    #include &lt;iostream&gt;
    #include &lt;experimental/filesystem&gt;
    
    namespace fs = std::experimental::filesystem;
    using namespace std;
    
    int main()
    try
    {
        try
        {
            throw fs::filesystem_error{ "exception encountered", "p1", "p2",
                                        make_error_code(errc::address_in_use) };
        }
        catch (fs::filesystem_error const &amp;fse)
        {
            cerr &lt;&lt; fse.what() &lt;&lt; ",\n" &lt;&lt;
                    fse.path1() &lt;&lt; ",\n" &lt;&lt;
                    fse.path2() &lt;&lt; ",\n" &lt;&lt;
                    fse.code() &lt;&lt; '\n';
    
            throw;
        }
    }
    catch (exception const &amp;ec)
    {
        cerr &lt;&lt; ec.what() &lt;&lt; '\n';
    }
</pre>
<p>
<a name="l387"></a>
<h3 >18.9.2: Names of file system entries: path</h3>
    Objects of the class <code >fs::path</code><a name="an2270"></a> contain names of file
system entries. The class <code >path</code> is a value-type class: a default
constructor (empty path) as well as standard copy/move construction/assignment
facilities are available. In addition, the following constructors can be used:
    <ul>
    <li><code >path(string &amp;&amp;tmp)</code>
    <li><code >path(Type const &amp;source)</code>
    <li><code >path(InputIter begin, InputIter end)</code>
    </ul>
<p>
These constructors expect character sequences (including NTBSs) in various
forms as their arguments. Conceptually, these sequences consist of the
following elements (all optional)
    <ul>
    <li> a root-name, e.g., a disk-name (like <code >E:</code>) or device indicator
        (like <code >//nfs</code>);
    <li> a root-directory, present if it is the first character after
        the (optional) root-name;
    <li> filename characters (not containing directory separators). In
        addition the `single dot filename' (<code >.</code>) represents the current
        directory and the `double dot filename' (<code >..</code>) represents the
        current directory's parent directory;
    <li> directory separators (by default the forward slash). Multiple
        consecutive separators are treated like one separator.
    </ul>
<p>
The constructors also define a last <code >format ftmp = auto_format</code>
parameter, which probably almost never requires a non-default specification
(for this parameter, refer to <a href="http://en.cppreference.com/w/cpp/experimental/fs/path">cppreference</a>.)
<p>
Its modifying member functions are
    <ul>
    <li><code >path &amp;append(Type const &amp;arg)</code> or 
                                <code >path &amp;operator/=(Type const &amp;arg)</code>:
       the arguments that can be passed to the constructors (including the
        iterators) can also be passed to these members. Before adding the
        argument the current and <code >arg's</code> contents are separated by a
        directory separator (unless the resulting path would be absolute if
        the source path is empty and the argument does not represent an
        absolute path);
<p>
<li><code >void clear()</code>: the <code >path's</code> contents are erased;
<p>
<li><code >int compare(Type const &amp;other)</code>: returns the result of
        lexicographically comparing the current path's contents with
        <code >other</code>. <code >Other</code> can be a <code >path</code>, a string-type or a NTBS;
<p>
<li><code >path &amp;concat(Type const &amp;arg)</code> or 
                                <code >path &amp;operator+=(Type const &amp;arg)</code>:
       similar to <code >append</code>, but no directory separator will be used when
        adding <code >arg's</code> contents to the current <code >path's</code> contents;
<p>
<li><code >path &amp;remove_filename()</code>:
       removes the last component of the stored path. If only a root-directory
        is stored, then the root directory is removed. Note that the last
        directory separator is kept, unless it is the only path element;
<p>
<li><code >path &amp;replace_extension(path const &amp;replacement = path{} )</code>:
       replaces the extension of the last component of the stored path
        (including the extension's dot) with <code >replacement</code>. The extension is
        removed if <code >replacement</code> is empty. If the <code >path</code> calling
        <code >replace_extension</code> has no extension then <code >replacement</code> is added;
<p>
<li><code >path &amp;replace_filename(path const &amp;replacement)</code>:
       replaces the last component of the stored path with <code >replacement</code>,
        which itself may contain multiple path elements.  If only a
        root-directory is stored, then it is replaced by <code >replacement</code>. The
        member's behavior is undefined If before calling <code >replace_filename
        path.empty()</code> returns <code >true</code>;
    </ul>
<p>
<a name="an2271"></a>
Accessors (no arguments, const members) return the path's contents as an NTBS
(<code >c_str</code>), as a string (<code >string, wstring, u8string, u16string, u32string</code>)
(possibly prefixed by <code >generic_</code>, like <code >generic_string</code>) or as components
of path specifications, returned as <code >path</code>. Example:
        <pre>
    fs::path path{ "/usr/local/bin" };
    cout &lt;&lt; path.string() &lt;&lt; '\n';      // shows:   /usr/local/bin
</pre>
<p>
<a name="an2272"></a>
<code >Path</code> objects may be inserted into streams using the <code >&lt;&lt;</code> (stream
insertion) operator, in which case double quotes surround the displayed path
name. The double quotes are removed when accessing the path's contents as NTBS
or string, and also when assigning (or casting) it to a string.
<p>
<a name="an2273"></a>
<code >Path</code> objects may also be extracted from streams using the <code >&gt;&gt;</code> (stream
extraction) operator. In this case a path may optionally be surrounded by
double quotes. The extracted path again contains its surrounding quotes.
<p>
<a name="an2274"></a>
<code >Begin</code> and <code >end</code> iterators can be used to iterate over all of the
<code >path's</code> components: each component is returned as a <code >path</code>, root names
and root directories are returned as initial components, followed by the
individual directory (and final filename) components. The directory separators
themselves are not returned when iterating over a <code >path's</code> components.
<p>
<a name="an2275"></a>
    <a name="an2276"></a>
Decomposers, returning objects (empty if the requested component is not
present): <code >root_name, root_directory, root_path, relative_path, parent_path</code>
(i.e., the current contents from which the last element has been removed),
<code >filename, stem</code> (i.e., the filename without its dot-extension), and
<code >extension</code>. Example:
        <pre>
    fs::path path{ "/usr/local/bin" };
    cout &lt;&lt; path.relative_path() &lt;&lt; '\n';   // shows:  "usr/local/bin"
                                            // (note the double quotes)
</pre>
<p>
When prefixed by <code >has_</code> the member returns a <code >bool</code> which is <code >true</code> if
the component is present. Also available: <code >is_absolute, is_relative</code>
<p>
In addition to the member functions various free operators are available:
<code >==, !=, &lt;, &lt;=, &gt;,</code> and <code >&gt;=</code> comparing two <code >path</code> objects; <code >/</code>
returning the concatenated <code >lhs</code> and <code >rhs</code>. Comparisons use
lexicographical comparisons (as if by comparing the return values of their
<code >string</code> members).
<p>
<a name="an2277"></a>
To convert a <code >path</code> (which must refer to an existing directory entry) to its
canonical form (i.e., a path not containing . or .. components) the free
function <code >canonical</code> (cf. section <a href="cplusplus18.html#FSFUN">18.9.7</a>) can be used:
        <pre>
    fs::path path{ "/usr/local/bin/../../share/man" };
    cout &lt;&lt; canonical(path) &lt;&lt; '\n';    // shows:   "/usr/share/man"
</pre>
<p>
<a name="l388"></a>
<h3 >18.9.3: Handling directories: directory_entry,
            (recursive_)directory_iterator</h3>
    Objects of the class <a name="an2278"></a><code >directory_entry</code> contain names and statuses of
directory entries. In addition to all standard constructors and assignment
operators it defines a constructor expecting a <code >path</code>:
        <pre>
    directory_entry(path const &amp;entry);
</pre>
    <code >Entry</code> does not have to exist.
<p>
Its member functions are:
    <ul>
    <li><a name="an2279"></a><code >void assign(path const &amp;dest)</code>:<blockquote >the current path is replaced by <code >dest</code>;</blockquote>
<p>
<li><a name="an2280"></a><code >void replace_filename(path const &amp;dest)</code>:<blockquote >the last entry of the current path name (which may be empty if the
        current name ends in a directory separator) is replaced by <code >dest</code>;</blockquote>
<p>
<li><a name="an2281"></a><code >path const &amp;path() const</code>, <a name="an2282"></a>
        <code >operator path const &amp;() const</code>:
       <blockquote >returns the current path name;</blockquote>
<p>
<li><a name="an2283"></a><code >file_status status([error_code &amp;ec])</code>:<blockquote >returns type and attributes of the current path name. If the current
        path name refers to a symlink, and the symlink's type and status is
        required, then use <a name="an2284"></a><code >symlink_status</code> (see also section
        <a href="cplusplus18.html#FSSTATUS">18.9.5</a>)</blockquote>.
    </ul>
<p>
Also, <code >directory_entry</code> objects may be compared using the <code >==, !=, &lt;, &lt;=,
&gt;,</code> and <code >&gt;=</code> operators, returning the result of applying the operator to
their <code >path</code> objects.
<p>
<a name="l389"></a>
<h3 >18.9.4: Visiting directory entries: (recursive_)directory_iterator</h3>
    The <code >filesystem</code> namespace offers two classes that simplify directory
processing: objects of the class <code >directory_iterator</code> are (input) iterators
iterating over the entries of directories; and objects of the class
<code >recursive_directory_iterator</code> are (input) iterators recursively visiting
all entries of directories.
<p>
The classes <code >(recursive_)directory_iterator</code> support default, copy, and move
constructors. Objects of both classes are constructed from a <code >path</code> and an
optional <code >error_code</code>. E.g.,
        <pre>
    directory_iterator(path const &amp;dest [, error_code &amp;ec]);
</pre>
    All members of standard input iterators (cf. section <a href="cplusplus18.html#ITERATORS">18.2</a>) are
supported by these classes. Their currently stored path is returned by their
dereference operators:
        <pre>
    cout &lt;&lt; *fs::directory_iterator{ "/home" } &lt;&lt; '\n'; // shows the first
                                                        // entry under /home
</pre>
<p>
End-iterators matching these objects are the classes' default constructed
objects. In addition, <code >filesystem::begin</code><a name="an2285"></a> and
<code >filesystem::end</code><a name="an2286"></a> are available and are automatically used by
range-based for loops. E.g., all entries of the <code >/var/log</code> directory are
displayed (surrounded by double quotes) by the following statement:
        <pre>
    for (auto &amp;entry: fs:directory_iterator("/var/log"))
        cout &lt;&lt; entry &lt;&lt; '\n';
</pre>
    Alternatively, for-statements explicitly defining iterators can also be
used. E.g.,
        <pre>
    for (
        auto iter = fs:directory_iterator("/var/log"), 
              end = fs::directory_iterator{}; 
                iter != end; 
                    ++iter
    )
        cout &lt;&lt; entry &lt;&lt; '\n';
</pre>
<p>
An <code >fs::(recursive_)directory_iterator base{"/var/log"}</code> object
represents the first element of its directory. Explicitly defined iterators
can be used, like <code >auto &amp;iter = begin(base), auto iter = begin(base), auto
&amp;iter = base</code> or <code >auto iter = base</code>: they all refer to <code >base's</code> data, and
incrementing them data also advances <code >base</code> to its next element:
        <pre>
    fs::recursive_directory_iterator base{ "/var/log/" };
    auto iter = base;
                                // final two elements show identical paths,
                                // different from the first element.
    cout &lt;&lt; *iter &lt;&lt; ' ' &lt;&lt; *++iter &lt;&lt; ' ' &lt;&lt; *base &lt;&lt; '\n';    
</pre>
<p>
The <code >recursive_directory_iterator</code> also accepts a <code >directory_options</code>
argument (see below), by default specified as <code >directory_options::none</code>:
        <pre>
    recursive_directory_iterator(path const &amp;dest,
                            directory_options options [, error_code &amp;ec]);
</pre>
<p>
The <code >enum class directory_options</code><a name="an2287"></a> defines values that
can be used to fine-tune the behavior of <code >recursive_directory_iterator</code>
objects. It supports bitwise operators (the symbols' values are shown between
parentheses). Here is an overview of all its symbols:
    <ul>
    <li><code >none</code> (0): directory symlinks are skipped, denied permission to enter
        a subdirectory generates an error;
    <li><code >follow_directory_symlink</code> (1): symlinks to subdirectories are
        followed;
    <li><code >skip_permission_denied</code> (2): directories that cannot be entered are
        silently skipped. 
    </ul>
<p>
In addition to the members of the class <code >directory_iterator</code> the class
<code >recursive_directory_iterator</code> provides these members:
    <ul>
    <li><a name="an2288"></a><code >int depth() const</code>:<blockquote >returns the current iteration depth. At the initial directory
        (specified at construction-time) <code >depth</code> returns 0;</blockquote>
<p>
<li><a name="an2289"></a><code >void disable_recursion_pending()</code>:<blockquote >when called before calling the iterator's increment operator or
        member, the next entry is not recursed into if it is a
        sub-directory. Immediately after executing the increment operator
        recursion is allowed again, so if a recursion should end at a specific
        depth then this function must repeatedly be called for as long as
        <code >depth()</code> returns that specific depth;</blockquote>
<p>
<li><a name="an2290"></a><code >recursive_directory_iterator &amp;increment(error_code &amp;ec)</code>:<blockquote > acts identically to the iterator's <code >operator++()</code>. However, when an
        error occurs <code >operator++</code> throws a <code >filesystem_error</code>, while
        <code >increment</code> assigns the appropriate error to <code >ec</code>;</blockquote>
<p>
<li><a name="an2291"></a><code >directory_options options() const</code>:<blockquote >returns the option that was specified at construction-time;</blockquote>
<p>
<li><a name="an2292"></a><code >void pop()</code>:<blockquote >ends processing of the current directory, and continues at the next
        entry in the current directory's parent or ends the directory
        processing if called at the initial directory;</blockquote>
<p>
<li><a name="an2293"></a><code >bool recursion_pending() const</code>:<blockquote ><code >true</code> is returned if the entry the iterator currently points at is
        a directory into which directory processing will continue at the
        iterator's next increment;</blockquote>
    </ul>
<p>
Finally, a little program displaying all directory elements of a directory and
all its immediate sub-directories:
        <pre>
    int main()
    {
    
        fs::recursive_directory_iterator base{ "/var/log" };

        for (auto entry = base, end = fs::end(base); entry != end; ++entry)
        {
            cout &lt;&lt; entry.depth() &lt;&lt; ": " &lt;&lt; *entry &lt;&lt; '\n';
            if (entry.depth() == 1)
                entry.disable_recursion_pending();
        }
    }
</pre>
<p>
<a name="FSSTATUS"></a><a name="l390"></a>
<h3 >18.9.5: Types (file_type) and permissions (perms) of file
            system entries: file_status</h3>
    Objects of the class <a name="an2294"></a><code >file_status</code> contain a file system entries' types and
permissions. The copy- and move- constructors and assignment operators
are available. In addition it defines the constructor
        <pre>
    explicit file_status(file_type type = file_type::none,
                         perms permissions = perms::unknown)
</pre>
    which can also be used as default constructor. In addition it defines the
members 
    <ul>
    <li><a name="an2295"></a><code >perms permissions() const</code> and <code >void permissions(perms
        newPerms)</code>:
       <blockquote >the former member returns the current set of permissions,
        the latter can be used to modify them;</blockquote>
<p>
<li><a name="an2296"></a><code >file_type type() const</code> and <code >void type(file_type type)</code>:
       <blockquote >the former member returns the current type, the latter can be
        used to change the type.</blockquote>
    </ul>
<p>
The <code >enum class file_type</code><a name="an2297"></a> defines the following symbols:
    <ul>
    <li><code >not_found = -1</code> indicates that the file was not found (this is not
        considered an error);
    <li><code >none</code> indicates that the file status has not been evaluated yet, or an
        error occurred when evaluating it;
    <li><code >regular</code> a regular file;
    <li><code >directory</code> a directory;
    <li><code >symlink</code> a symbolic link;
    <li><code >block</code> a block device;
    <li><code >character</code> a character device;
    <li><code >fifo</code>: a named pipe;
    <li><code >socket</code>: a socket file;
    <li><code >unknown</code>: unknown file type
    </ul>
<p>
The <code >enum class perms</code> defines all access permissions of file system
entries. The enumeration's symbols were selected so that their meanings should
be more descriptive than the constants defined in the <a name="an2298"></a><code >&lt;sys/stat.h&gt;</code> header
file, but other than that they have identical values. Also, all bitwise
operators can be used by values of the <code >enum class perms</code>. Here is an
overview of all its defined symbols:
        <pre>
    Symbol        Value   sys/stat.h    Meaning

    none          0000                  No permission bits were set
                                        
    owner_read    0400    S_IRUSR       File owner has read permission
    owner_write   0200    S_IWUSR       File owner has write permission
    owner_exec    0100    S_IXUSR       File owner has execute/search 
                                                permissions
    owner_all     0700    S_IRWXU       File owner has read, write, and
                                                execute/search permissions
                                            
    group_read    0040    S_IRGRP       The file's group has read permission
    group_write   0020    S_IWGRP       The file's group has write permission
    group_exec    0010    S_IXGRP       The file's group has execute/search 
                                                permissions
    group_all     0070    S_IRWXG       The file's group has read, write, and 
                                                execute/search permissions
                                            
    others_read   0004    S_IROTH       Other users have read permission
    others_write  0002    S_IWOTH       Other users have write permission
    others_exec   0001    S_IXOTH       Other users have execute/search
                                                permissions
    others_all    0007    S_IRWXO       Other users have read, write, and 
                                                execute/search permissions
                                        
    all           0777                  All users have read, write, and 
                                                execute/search permissions
                                            
    set_uid      04000    S_ISUID       Set user ID to file owner user ID on 
                                                execution
    set_gid      02000    S_ISGID       Set group ID to file's user group ID 
                                                on execution
    sticky_bit   01000    S_ISVTX       POSIX XSI specifies that when set on a
                                                directory, only file owners
                                                may delete files even if the
                                                directory is writeable to
                                                others (used with /tmp)
                                        
    mask         07777                  All valid permission bits. 
</pre>
<p>
Here is a little program showing how file statuses can be determined and
used:
    <pre>
    namespace
    {
        std::unordered_map&lt;fs::file_type, char const *&gt; map =
        {
            { fs::file_type::not_found, "an unknown file" },
            { fs::file_type::none,      "not yet or erroneously evaluated "
                                                                "file type" },
            { fs::file_type::regular,   "a regular file" },
            { fs::file_type::directory, "a directory" },
            { fs::file_type::symlink,   "a symbolic link" },
            { fs::file_type::block,     "a block device" },
            { fs::file_type::character, "a character device" },
            { fs::file_type::fifo,      "a named pipe" },
            { fs::file_type::socket,    "a socket file" },
            { fs::file_type::unknown,   "an unknown file type" }
        };
    
        void status(fs::path const &amp;path)
        {
            fs::file_status stat = fs::directory_entry{ path }.symlink_status();
    
            cout &lt;&lt; path &lt;&lt; " is " &lt;&lt; map[stat.type()] &lt;&lt; '\n';
        };
    } // anon. namespace
    
    int main()
    {
        for (auto entry: fs::directory_iterator{"/home/frank"})
            ::status(entry);
    
        cout &lt;&lt; "File status_known is " &lt;&lt;
                status_known( fs::file_status{} ) &lt;&lt; '\n';
    }
</pre>
<p>
<a name="l391"></a>
<h3 >18.9.6: Information about the space of a file system entries: space_info</h3>
    Every existing <code >path</code> lives in a particular file system. File systems can
contain certain amounts of data (numbers of bytes) of which some amount
already is in use and some amount is still available. These three pieces of
information are made available by the function
    <code >fs::space</code><a name="an2299"></a><a name="an2300"></a> expecting a <code >fs::path
const &amp;</code>, and returning the information in a POD <code >struct fs::space_info</code>.
This function throws a <code >filesystem_error</code>, receiving <code >path</code> as its first
argument and the operating system's error code as its <code >error_code</code>
argument. An overloaded function <code >space</code> expects as its second argument an
<code >error_code</code> object, which is cleared if no error occurs, and which is set
to the operating system's error code if an error occurred.
<p>
The returned <code >fs::space_info</code> has three fields:
        <pre>
    uintmax_t capacity;     // total size in bytes
    uintmax_t free;         // number of free bytes on the file system
    uintmax_t available;    // free bytes for a non-privileged process
</pre>
    If a field cannot be determined it is set to -1 (i.e., the max. value of
the type <code >uintmax_t</code>).
<p>
Here is a little program illustrating how <code >space</code> can be used:
        <pre>
    int main()
    {
        fs::path p{ "/tmp" };
    
        auto pod = fs::space(p);
    
        std::cout &lt;&lt; "The filesystem containing /tmp has a capacity of " &lt;&lt;
                                                pod.capacity &lt;&lt; " bytes,\n"
            "i.e., " &lt;&lt; pod.capacity / 1024 &lt;&lt; " KB.\n"
            "# free bytes: " &lt;&lt; pod.free &lt;&lt; "\n"
            "# available:  " &lt;&lt; pod.available &lt;&lt; '\n';
    }
</pre>
<p>
<a name="FSFUN"></a><a name="l392"></a>
<h3 >18.9.7: Free functions</h3>
    Several functions are available that directly operate on the current file
system. 
<p>
Functions defining an optional <code >path const &amp;base</code> parameter by default use
<code >current_path</code>.
<p>
Some of them define an <code >error_code &amp;ec</code> parameter. Those functions
have a <code >noexcept</code> specification. If those functions cannot complete their
task, then <code >ec</code> is set to the appropriate error code. Alternatively,
<code >ec.clear()</code> is called if no error was encountered. If no <code >ec</code> argument is
provided then those functions throw a <code >filesystem_error</code> if they cannot
complete their tasks.
<p>
The following functions are available:
    <ul>
    <li><a name="an2301"></a><code >path absolute(path const &amp;src, path const&amp; base)</code>:<blockquote >a copy of <code >src</code> to which, unless already available in <code >src</code>,
        <code >absolute(base)'s</code> root name and root directory are prepended;</blockquote>
<p>
<li><a name="an2302"></a><code >path canonical(path const &amp;src [, path const &amp;base [,
        error_code &amp;ec]])</code>:<blockquote >returns <code >src's</code> canonical path (prefixing <code >base</code> if <code >src</code> is not
        an absolute path);</blockquote>
<p>
<li><a name="an2303"></a><code >void copy(path const &amp;src, path const &amp;dest [, copy_options
        opts [, error_code &amp;ec]])</code>:<blockquote ><code >src</code> must exist. Copies <code >src</code> to <code >dest</code> if the <code >cp</code> program
        would also succeed. Copy options can be specified to fine-tune its
        behavior: see below for the values that may be specified for the
        options.<br/>
       If <code >src</code> is a directory, and <code >dest</code> does not exist, <code >dest</code> is
        created. Directories are recursively copied if copy options
        <code >recursive</code> or <code >none</code> were specified;</blockquote>
<p>
<li><a name="an2304"></a><code >bool copy_file(path const &amp;src, path const &amp;dest [,
        copy_options opts [, error_code &amp;ec]])</code>:<blockquote ><code >src</code> must exist. Copies <code >src</code> to <code >dest</code> if the <code >cp</code> program
        would also succeed. Symbolic links are followed. Copy options can be
        <code >skip_existing</code>: <code >src</code> is not copied if <code >dest</code> already exists;
        <code >overwrite_existing</code>: a copy is forced; <code >update_existing</code>: <code >src</code>
        is copied if it is more recent than <code >dest</code>; <code >True</code> is returned if
        copying succeeded;</blockquote>
<p>
<li><a name="an2305"></a><code >void copy_symlink(path const &amp;src, path const &amp;dest [,
        error_code &amp;ec])</code>:<blockquote >creates the symlink <code >dest</code> as a copy of the symlink <code >src</code>;</blockquote>
<p>
<li><a name="an2306"></a><code >bool create_directories(path const &amp;dest [,
        error_code &amp;ec])</code>:<blockquote >creates each component of <code >dest</code>, unless already existing. <code >True</code>
        is returned if no errors were encountered. See also
        <code >create_directory</code> below;</blockquote>
<p>
<li><a name="an2307"></a><code >bool create_directory(path const &amp;dest [, path
        const &amp;existing] [, error_code &amp;ec])</code>:<blockquote >creates directory <code >dest</code> if it does not yet exist. It is not an
        error if a directory <code >dest</code> already exists. <code >Dest's</code> parent
        directory must exist. If <code >existing</code> is specified, then <code >dest</code>
        receives the same attributes as <code >existing</code>. <code >True</code> is returned if
        no errors were encountered;</blockquote>
<p>
<li><a name="an2308"></a><code >bool create_directory_symlink(path const &amp;dir, path
        const &amp;link [, error_code &amp;ec])</code>:<blockquote >like <code >create_symlink</code>, but should be used to create a symbolic link
        to a directory. See also <code >create_symlink</code> below;</blockquote>
<p>
<li><a name="an2309"></a><code >bool create_hardlink(path const &amp;dest, path const
        &amp;link [, error_code &amp;ec])</code>:<blockquote >creates a hard link from <code >link</code> to <code >dest</code>. <code >Dest</code> must exist;</blockquote>
<p>
<li><a name="an2310"></a><code >bool create_symlink(path const &amp;dest, path const
        &amp;link [, error_code &amp;ec])</code>:<blockquote >creates a symbolic (soft) link from <code >link</code> to <code >dest</code>; <code >dest</code>
        does <em >not</em> have to exist;</blockquote>
<p>
<li><a name="an2311"></a><code >path current path([error_code &amp;ec])</code>, <code >void
        current_path(path const &amp;toPath [, error_code &amp;ec])</code>:
       <blockquote >the former function returns the current working directory (cwd),
        the latter changes the cwd to <code >toPath</code>;</blockquote>
<p>
<li><a name="an2312"></a><code >bool equivalent(path const &amp;path1, path const &amp;path2 [,
        error_code &amp;ec])</code>:<blockquote ><code >true</code> is returned if <code >path1</code> and <code >path2</code> refer to the same file
        or directory, and have identical statuses. Both paths must exist;</blockquote>
<p>
<li><a name="an2313"></a><code >bool exists(path const &amp;dest [, error_code &amp;ec])</code>,
        <code >exists(file_status status)</code>:
       <blockquote ><code >true</code> is returned if <code >dest</code> exists (actually: if
        <code >status(dest[, ec])</code> (see below) returns <code >true</code>). Note: when
        iterating over directories, the iterator usually provides the entries'
        statuses. In those cases calling <code >exists(iterator-&gt;status())</code> is
        more efficient than calling <code >exists(*iterator)</code>;</blockquote>
<p>
<li><a name="an2314"></a><code >std::unintmax_t file_size(path const &amp;dest [, error_code
        &amp;ec])</code>:<blockquote >returns the size in bytes of a regular file (or symlink destination);</blockquote>
<p>
<li><a name="an2315"></a><code >std::uintmax_t hard_link_count(path const &amp;dest [,
        error_code &amp;ec])</code>:<blockquote >returns the number of hard links associated with <code >dest</code>;</blockquote>
<p>
<li><a name="an2316"></a><code >file_time_type last_write_time(path const &amp;dest [,
        error_code &amp;ec])</code>, <code >void last_write_time(path const &amp;dest,
        file_time_type newTime [, error_code &amp;ec])</code>:
       <blockquote >the former function returns <code >dest's</code> last modification time;
        the latter function changes <code >dest's</code> last modification time to
        <code >newTime</code>. The return type <a name="an2317"></a><code >file_time_type</code> is defined through a
        <code >using</code> alias for <code >chrono::time_point</code> (cf. section
        <a href="cplusplus20.html#TIMEPOINT">20.1.4</a>). The returned <code >time_point</code> is guaranteed to cover
        all file time values that may be encountered in the current file
        system;</blockquote>
<p>
<li><a name="an2318"></a><code >void permissions(path const &amp;dest, perms spec [,
        error_code &amp;ec])</code>:<blockquote >sets <code >dest's</code> permissions to <code >spec</code>, unless <code >perms::add_perms</code>
        or <code >perms::remove_perms</code> was set. The permissions in <code >perms</code> are
        masked using <code >perms::mask</code>;</blockquote>
<p>
<li><a name="an2319"></a><code >path read_symlink(path const &amp;src [, error_code &amp;ec])</code>:<blockquote ><code >src</code> must refer to a symbolic link or an error is generated. The
        link's target is returned;</blockquote>
<p>
<li><a name="an2320"></a><code >bool remove(path const &amp;dest [, error_code &amp;ec])</code>,
        <a name="an2321"></a> <code >std::uintmax_t remove_all(path const &amp;dest [,
        error_code &amp;ec])</code>:
       <blockquote ><code >remove</code> removes the file, symlink, or empty directory
        <code >dest</code>, returning <code >true</code> if <code >dest</code> could be removed;
        <code >remove_all</code> removes <code >dest</code> if it's a file (or symlink); and
        recursively removes directory <code >dest</code>, returning the number of
        removed entries;</blockquote>
<p>
<li><a name="an2322"></a><code >void rename(path const &amp;src, path const &amp;dest [, error_code
        &amp;ec])</code>:<blockquote >renames <code >src</code> to <code >dest</code>, as if using the standard <strong >mv</strong>(1)
        command;</blockquote>
<p>
<li><a name="an2323"></a><code >void resize_file(path const &amp;src, std::uintmax_t size [,
        error_code &amp;ec])</code>:<blockquote ><code >src's</code> size is changed to <code >size</code> as if using the standard
        <strong >truncate</strong>(1) command;</blockquote>
<p>
<li><a name="an2324"></a><code >space_info space(path const &amp;src [, error_code &amp;ec])</code>:<blockquote >returns information about the file system in which <code >src</code> is
        located;</blockquote>
<p>
<li><a name="an2325"></a><code >file_status status(path const &amp;dest [, error_code &amp;ec])</code>:<blockquote >returns type and attributes of <code >dest</code>. Use <a name="an2326"></a><code >symlink_status</code> if
        the type and attributes of a symbolic link are required;</blockquote>
<p>
<li><a name="an2327"></a><code >bool status_known(file_status status)</code>:<blockquote >returns <code >true</code> if <code >status</code> refers to a determined status (which
        may indicate that the entity referred to by <code >status</code> does not
        exist). One way of receiving <code >false</code> is by passing it a default
        <code >file_status: status_known(file_status{})</code>;</blockquote>
<p>
<li><a name="an2328"></a><code >path system_complete(path const &amp;src[, error_code&amp;
        ec])</code>:<blockquote >returns the absolute path matching <code >src</code>, using <code >current_path</code> as
        its base;</blockquote>
<p>
<li><a name="an2329"></a><code >path temp_directory_path([error_code&amp; ec])</code>:<blockquote > returns the path to a directory that can be used for temporary
        files. The directory is not created, but its name is commonly
        available from the environment variables <a name="an2330"></a><code >TMPDIR</code>, <code >TMP, TEMP</code>, or
        <code >TEMPDIR</code>. Otherwise, <code >/tmp</code> is returned.</blockquote>
    </ul>
<p>
File types <a name="an2331"></a> can be interrogated using the following functions,
all supporting the following signatures (where <code >WHATEVER</code> is the requested 
specification):
        <pre>
    bool is_WHATEVER(file_status status)
    bool is_WHATEVER(path const path &amp;dest [, error_code &amp;ec])
</pre>
    all functions return <code >true</code> if <code >dest</code> or <code >status</code> matches the
requested type. Here are the available functions:
    <ul>
    <li><a name="an2332"></a><code >is_block_file</code>: the path refers to a block device;
    <li><a name="an2333"></a><code >is_character_file</code>: the path refers to a character device;
    <li><a name="an2334"></a><code >is_directory</code>: the path refers to a directory;
    <li><a name="an2335"></a><code >is_empty</code>: the path refers to an empty file or directory;
    <li><a name="an2336"></a><code >is_fifo</code>: the path refers to a named pipe;
    <li><a name="an2337"></a><code >is_other</code>: the path does not refer to a directory, regular file or
        symlink;
    <li><a name="an2338"></a><code >is_regular_file</code>: the path refers to a regular file;
    <li><a name="an2339"></a><code >is_socket</code>: the path refers to a named socket;
    <li><a name="an2340"></a><code >is_symlink</code>: the path refers to a symbolic link;
    </ul>
<p>
The <code >enum class copy_options</code><a name="an2341"></a> define symbolic constants that
can be used to fine-tune the behavior of the <code >copy</code> and <code >copy_file</code>
functions. The enumeration supports bitwise operators (the symbols' values are
shown between parentheses). Here is an overview of all its defined symbols:
<p>
Options when copying files:
    <ul>
    <li><code >none</code> (0): report an error (default behavior);
    <li><code >skip_existing</code> (1): keep the existing file, without reporting an
        error;
    <li><code >overwrite_existing</code> (2): replace the existing file;
    <li><code >update_existing</code> (4): replace the existing file only if it is older;
        than the file being copied;
    </ul>
<p>
Options when copying subdirectories:
    <ul>
    <li><code >none</code> (0): skip subdirectories (default behavior);
    <li><code >recursive</code> (8): recursively copy subdirectories and their content;
    </ul>
<p>
Options when copying symlinks:
    <ul>
    <li><code >none</code> (0): follow symlinks (default behavior);
    <li><code >copy_symlinks</code> (16): copy symlinks as symlinks, not as the files they
        point to;
    <li><code >skip_symlinks</code> (32): ignore symlinks;
    </ul>
<p>
Options controlling <code >copy's</code> behavior itself:
    <ul>
    <li><code >none</code> (0): copy file content (default behavior);
    <li><code >directories_only</code> (64): copy the directory structure, but do not copy
        any non-directory files;
    <li><code >create_symlinks</code> (128): instead of creating copies of files, create
        symlinks pointing to the originals (the source path must be an
        absolute path unless the destination path is in the current
        directory);
    <li><code >create_hard_links</code> (256): instead of creating copies of files, create
        hardlinks that resolve to the same files as the originals.
    </ul>
<p>

<hr>
<ul>
    <li> <a href="cplusplus.html">Table of Contents</a>
    <li> <a href="cplusplus17.html">Previous Chapter</a>
    <li> <a href="cplusplus19.html">Next Chapter</a>
</ul>
<hr>
</body>
</html>
