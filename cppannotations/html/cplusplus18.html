<!DOCTYPE html><html><head>
<meta charset="UTF-8">
<title> C++ Annotations Version 10.8.0 </title>
<link rel="stylesheet" type="text/css" href="cplusplus.css"><style type="text/css">
    figure {text-align: center;}
    img {vertical-align: center;}
</style>
<link rel="stylesheet" type="text/css" href="cplusplus.css"></head>
<body >
<hr>
<ul>
    <li> <a href="cplusplus.html">Table of Contents</a>
    <li> <a href="cplusplus17.html">Previous Chapter</a>
    <li> <a href="cplusplus19.html">Next Chapter</a>
</ul>
<hr>
<a name="STL"></a><a name="l319"></a>
<h1 >Chapter 18: The Standard Template Library</h1>
The <a name="an1981"></a><code >Standard Template Library</code> (<a name="an1982"></a>STL) is a general purpose library
consisting of containers, generic algorithms, iterators, function objects,
allocators, adaptors and data structures. The data structures used by the
algorithms are <em >abstract</em> in the sense that the algorithms can be used with
(practically) any data type.
<p>
The algorithms can process these abstract data types because they are
<a name="an1983"></a><em >template</em> based. This chapter does not cover template <em >construction</em>
(see chapter <a href="cplusplus21.html#TEMPLATES">21</a> for that). Rather, it focuses on the <em >use</em>
of the algorithms.
<p>
Several elements also used by the standard template library have already been
discussed in the <strong >C++</strong> Annotations. In chapter <a href="cplusplus12.html#CONTAINERS">12</a> abstract containers
were discussed, and in section <a href="cplusplus11.html#FUNOBJ">11.10</a> function objects were introduced.
Also, <em >iterators</em> were mentioned at several places in this document.
<p>
The main components of the STL are covered in this and the next
chapter. Iterators, adaptors, smart pointers, multi threading and other
features of the STL are discussed in coming sections. Generic
algorithms are covered in the next chapter (<a href="cplusplus19.html#GENERIC">19</a>).
<p>
<em >Allocators</em> take care of the memory allocation within the
STL. The default <a name="an1984"></a>allocator class suffices for most applications, and is
not further discussed in the <strong >C++</strong> Annotations.
<p>
All elements of the STL <a name="an1985"></a> are defined in the
standard namespace. Therefore, a <code >using namespace std</code> or a comparable
directive is required unless it is preferred to specify the required namespace
explicitly. In header files  the <code >std</code> namespace should explicitly
be used (cf. section <a href="cplusplus07.html#NAMESPACEHDR">7.11.1</a>).
<p>
In this chapter the empty <a name="an1986"></a>angle bracket notation is frequently used. In
code a typename must be supplied between the angle brackets. E.g., <code >plus&lt;&gt;</code>
is used in the <strong >C++</strong> Annotations, but in code <code >plus&lt;string&gt;</code> may be encountered.
<p>
<a name="PREDEFINED"></a><a name="l320"></a>
<h2 >18.1: Predefined function objects</h2>
Before using the predefined function objects presented in this section the
<a name="an1987"></a><code >&lt;functional&gt;</code> header file must be included.
<p>
Function objects play important roles in generic
algorithms. For example, there exists a generic algorithm <code >sort</code>
expecting two iterators defining the range of objects that should be sorted,
as well as a function object calling the appropriate comparison operator for
two objects. Let's take a quick look at this situation. Assume strings are
stored in a vector, and we want to sort the vector in descending order. In
that case, sorting the vector <code >stringVec</code> is as simple as:
            <pre>
        sort(stringVec.begin(), stringVec.end(), greater&lt;string&gt;());
</pre>
    The last argument is recognized as a <a name="an1988"></a><em >constructor</em>: it is an
<em >instantiation</em> of the <code >greater&lt;&gt;</code> class template, applied to
<code >strings</code>. This object is called as a function object by the <code >sort</code>
generic algorithm. The generic algorithm calls the function object's
<code >operator()</code> member to compare two <code >string</code> objects. The function object's
<code >operator()</code> will, in turn, call <code >operator&gt;</code> of the <code >string</code> data
type. Eventually, when <code >sort</code> returns, the first element of the vector will
contain the string having the greatest <code >string</code> value of all.
<p>
The function object's <code >operator()</code> itself is <em >not</em> visible at this
point. Don't confuse the parentheses in the `<code >greater&lt;string&gt;()</code>' argument
with calling <code >operator()</code>. When <code >operator()</code> is actually used inside
<code >sort</code>, it receives two arguments: two strings to compare for
`greaterness'. Since <code >greater&lt;string&gt;::operator()</code> is defined <a name="an1989"></a>inline, the
call itself is not actually present in the above <code >sort</code> call.  Instead
<code >sort</code> calls <code >string::operator&gt;</code> through <code >greater&lt;string&gt;::operator()</code>.
<p>
Now that we know that a constructor is passed as argument to (many) generic
algorithms, we can design our own function objects. Assume we want to sort our
vector case-insensitively. How do we proceed? First we note that the default
<code >string::operator&lt;</code> (for an incremental sort) is not appropriate, as it does
case sensitive comparisons. So, we provide our own <code >CaseInsensitive</code> class,
which compares two strings case insensitively. Using the <code >POSIX</code> function
<a name="an1990"></a><code >strcasecmp</code>, the following program performs the trick. It
case-insensitively sorts its command-line arguments in ascending alphabetic
order:
        <pre>
    #include &lt;iostream&gt;
    #include &lt;string&gt;
    #include &lt;cstring&gt;
    #include &lt;algorithm&gt;
    using namespace std;

    class CaseInsensitive
    {
        public:
            bool operator()(string const &amp;left, string const &amp;right) const
            {
                return strcasecmp(left.c_str(), right.c_str()) &lt; 0;
            }
    };
    int main(int argc, char **argv)
    {
        sort(argv, argv + argc, CaseInsensitive{});
        for (int idx = 0; idx &lt; argc; ++idx)
            cout &lt;&lt; argv[idx] &lt;&lt; " ";
        cout &lt;&lt; '\n';
    }
</pre>
    The default constructor of the <code >class CaseInsensitive</code> is used to
provide <code >sort</code> with its final argument. So the only member function that
must be defined is <code >CaseInsensitive::operator()</code>. Since we know it's called
with <code >string</code> arguments, we define it to expect two <code >string</code> arguments,
which are used when calling <code >strcasecmp</code>. Furthermore, the function call
operator <code >operator()</code> is defined <a name="an1991"></a>inline, so that it does not produce
overhead when called by the <code >sort</code> function. The <code >sort</code> function calls the
function object with various combinations of <code >strings</code>. If the compiler
grants our inline requests, it will in fact call <code >strcasecmp</code>, skipping two
extra function calls.
<p>
The comparison function object is often a <a name="an1992"></a><em >predefined function object</em>.
Predefined function object classes are available for many commonly used
operations.  In the following sections the available predefined function
objects are presented, together with some examples showing their use. Near the
end of the section about function objects <a name="an1993"></a><em >function adaptors</em> are
introduced.
<p>
Predefined function objects are used predominantly with generic
algorithms. Predefined function objects exists for arithmetic, relational, and
logical operations. 
<p>
<a name="l321"></a>
<h3 >18.1.1: Arithmetic function objects</h3>
    The <a name="an1994"></a><a name="an1995"></a> arithmetic
function objects support the standard <a name="an1996"></a>arithmetic operations: addition,
subtraction, multiplication, division, modulo and negation. These function
objects invoke the corresponding operators of the data types for which they
are instantiated. For example, for addition the function object <code >plus&lt;Type&gt;</code>
<a name="an1997"></a> is available. If we replace <code >Type</code> by <code >size_t</code> then the addition
operator for <code >size_t</code> values is used, if we replace <code >Type</code> by <code >string</code>,
the addition operator for strings is used. For example:
        <pre>
    #include &lt;iostream&gt;
    #include &lt;string&gt;
    #include &lt;functional&gt;
    using namespace std;

    int main(int argc, char **argv)
    {
        plus&lt;size_t&gt; uAdd;              // function object to add size_ts

        cout &lt;&lt; "3 + 5 = " &lt;&lt; uAdd(3, 5) &lt;&lt; '\n';

        plus&lt;string&gt; sAdd;              // function object to add strings

        cout &lt;&lt; "argv[0] + argv[1] = " &lt;&lt; sAdd(argv[0], argv[1]) &lt;&lt; '\n';
    }
    /*
        Output when called as: a.out going

        3 + 5 = 8
        argv[0] + argv[1] = a.outgoing
    */
</pre>
    Why is this useful? Note that the function object can be used with all
kinds of data types (not only with the predefined datatypes) supporting the
operator called by the function object.
<p>
Suppose we want to perform an operation on a left hand side operand which is
always the same variable and a right hand side argument for which, in turn,
all elements of an array should be used. E.g., we want to compute the sum of
all elements in an array; or we want to concatenate all the strings in a
text-array. In situations like these function objects come in handy.
<p>
As stated, function objects are heavily used in the context of the generic
algorithms, so let's take a quick look ahead at yet another one.
<p>
The generic algorithm <code >accumulate</code> visits all elements specified by an
iterator-range, and performs a requested binary operation on a common element
and each of the elements in the range, returning the accumulated result after
visiting all elements specified by the iterator range. It's easy to use this
algorithm. The next program accumulates all command line arguments and prints
the final string:
        <pre>
    #include &lt;iostream&gt;
    #include &lt;string&gt;
    #include &lt;functional&gt;
    #include &lt;numeric&gt;
    using namespace std;

    int main(int argc, char **argv)
    {
        string result =
                accumulate(argv, argv + argc, string(), plus&lt;string&gt;());

        cout &lt;&lt; "All concatenated arguments: " &lt;&lt; result &lt;&lt; '\n';
    }
</pre>
    The first two arguments define the (iterator) range of elements to visit,
the third argument is <code >string</code>. This anonymous string object provides an
initial value. We could also have used
        <pre>
    string("All concatenated arguments: ")
</pre>
    in which case the <code >cout</code> statement could simply have been
<code >cout &lt;&lt; result &lt;&lt; '\n'</code>.
    The string-addition operation is used, called from <code >plus&lt;string&gt;</code>. The
final concatenated string is returned.
<p>
Now we define a class <code >Time</code>, overloading <a name="an1998"></a><code >operator+</code>. Again, we can
apply the predefined function object <code >plus</code>, now tailored to our newly
defined datatype, to add times:
        <pre>
    #include &lt;iostream&gt;
    #include &lt;string&gt;
    #include &lt;vector&gt;
    #include &lt;functional&gt;
    #include &lt;numeric&gt;
    using namespace std;

    class Time
    {
        friend ostream &amp;operator&lt;&lt;(ostream &amp;str, Time const &amp;time);
        size_t d_days;
        size_t d_hours;
        size_t d_minutes;
        size_t d_seconds;
        public:
            Time(size_t hours, size_t minutes, size_t seconds);
            Time &amp;operator+=(Time const &amp;rhs);
    };
    Time &amp;&amp;operator+(Time const &amp;lhs, Time const &amp;rhs)
    {
        Time ret(lhs);
        return std::move(ret += rhs);
    }
    Time::Time(size_t hours, size_t minutes, size_t seconds)
    :
        d_days(0),
        d_hours(hours),
        d_minutes(minutes),
        d_seconds(seconds)
    {}
    Time &amp;Time::operator+=(Time const &amp;rhs)
    {
        d_seconds   += rhs.d_seconds;
        d_minutes   += rhs.d_minutes   + d_seconds / 60;
        d_hours     += rhs.d_hours     + d_minutes / 60;
        d_days      += rhs.d_days      + d_hours   / 24;
        d_seconds   %= 60;
        d_minutes   %= 60;
        d_hours     %= 24;
        return *this;
    }
    ostream &amp;operator&lt;&lt;(ostream &amp;str, Time const &amp;time)
    {
        return cout &lt;&lt; time.d_days &lt;&lt; " days, " &lt;&lt; time.d_hours &lt;&lt;
                                                    " hours, " &lt;&lt;
                        time.d_minutes &lt;&lt; " minutes and " &lt;&lt;
                        time.d_seconds &lt;&lt; " seconds.";
    }
    int main(int argc, char **argv)
    {
        vector&lt;Time&gt; tvector;

        tvector.push_back(Time( 1, 10, 20));
        tvector.push_back(Time(10, 30, 40));
        tvector.push_back(Time(20, 50,  0));
        tvector.push_back(Time(30, 20, 30));

        cout &lt;&lt;
            accumulate
            (
                tvector.begin(), tvector.end(), Time(0, 0, 0), plus&lt;Time&gt;()
            ) &lt;&lt;
            '\n';
    }
    //  Displays: 2 days, 14 hours, 51 minutes and 30 seconds.
</pre>
    The design of the above program is fairly straightforward.  <code >Time</code>
defines a constructor, it defines an insertion operator and it defines its own
<code >operator+</code>, adding two time objects. In <code >main</code> four <code >Time</code> objects are
stored in a <code >vector&lt;Time&gt;</code> object. Then, <code >accumulate</code> is used to compute
the accumulated time. It returns a <code >Time</code> object, which is inserted into
<code >cout</code>.
<p>
While this section's first example illustrated using a <em >named</em> function
object, the last two examples illustrate how <a name="an1999"></a><em >anonymous</em> objects can be
passed to the (<code >accumulate</code>) function .
<p>
The STL supports the following set of arithmetic function objects.  The
function call operator (<code >operator()</code>) of these function objects calls the
matching arithmetic operator for the objects that are passed to the function
call operator, returning that arithmetic operator's return value. The
arithmetic operator that is actually called is mentioned below:
    <ul>
    <li><a name="an2000"></a><code >plus&lt;&gt;</code>: calls the binary <a name="an2001"></a><code >operator+</code>;
    <li><a name="an2002"></a><code >minus&lt;&gt;</code>: calls the binary <a name="an2003"></a><code >operator-</code>;
    <li><a name="an2004"></a><code >multiplies&lt;&gt;</code>: calls the binary <a name="an2005"></a><code >operator*</code>;
    <li><a name="an2006"></a><code >divides&lt;&gt;</code>: calls <a name="an2007"></a><code >operator/</code>;
    <li><a name="an2008"></a><code >modulus&lt;&gt;</code>:  calls <a name="an2009"></a><code >operator%</code>;
    <li><a name="an2010"></a><code >negate&lt;&gt;</code>: calls the unary <code >operator-</code>. This arithmetic
function object is a unary function object as it expects one argument.
    </ul>
    In the next example the <a name="an2011"></a><code >transform</code> generic algorithm is used to toggle
the signs of all elements of an array. <code >Transform</code>
expects two iterators, defining the range of objects to be transformed; an
iterator defining the begin of the destination range (which may be the same
iterator as the first argument); and a function object defining a unary
operation for the indicated data type.
        <pre>
    #include &lt;iostream&gt;
    #include &lt;string&gt;
    #include &lt;functional&gt;
    #include &lt;algorithm&gt;
    using namespace std;

    int main(int argc, char **argv)
    {
        int iArr[] = { 1, -2, 3, -4, 5, -6 };

        transform(iArr, iArr + 6, iArr, negate&lt;int&gt;());

        for (int idx = 0; idx &lt; 6; ++idx)
            cout &lt;&lt; iArr[idx] &lt;&lt; ", ";
        cout &lt;&lt; '\n';
    }
    // Displays:  -1, 2, -3, 4, -5, 6,
</pre>
<p>
<a name="RELATIONAL"></a><a name="l322"></a>
<h3 >18.1.2: Relational function objects</h3>
    The relational operators are called by the
 <a name="an2012"></a><a name="an2013"></a> relational
function objects. All standard relational operators are supported: <code >==, !=,
&gt;, &gt;=, &lt;</code> and <code >&lt;=</code>.
<p>
The STL supports the following set of relational function objects.  The
function call operator (<code >operator()</code>) of these function objects calls the
matching relational operator for the objects that are passed to the function
call operator, returning that relational operator's return value. The
relational operator that is actually called is mentioned below:
    <ul>
    <li><a name="an2014"></a><code >equal_to&lt;&gt;</code>: calls <a name="an2015"></a><code >operator==</code>;
    <li><a name="an2016"></a><code >not_equal_to&lt;&gt;</code>: calls <a name="an2017"></a><code >operator!=</code>;
    <li><a name="an2018"></a><code >greater&lt;&gt;</code>: calls <a name="an2019"></a><code >operator&gt;</code>;
    <li><a name="an2020"></a><code >greater_equal&lt;&gt;</code>: calls <a name="an2021"></a><code >operator&gt;=</code>;
    <li><a name="an2022"></a><code >less&lt;&gt;</code>: this object's member <code >operator()</code> calls
        <a name="an2023"></a><code >operator&lt;</code>;
    <li><a name="an2024"></a><code >less_equal&lt;&gt;</code>: calls <a name="an2025"></a><code >operator&lt;=</code>.
    </ul>
    An example using the relational function objects in combination with
<a name="an2026"></a><code >sort</code> is:
        <pre>
    #include &lt;iostream&gt;
    #include &lt;string&gt;
    #include &lt;functional&gt;
    #include &lt;algorithm&gt;
    using namespace std;

    int main(int argc, char **argv)
    {
        sort(argv, argv + argc, greater_equal&lt;string&gt;());

        for (int idx = 0; idx &lt; argc; ++idx)
            cout &lt;&lt; argv[idx] &lt;&lt; " ";
        cout &lt;&lt; '\n';

        sort(argv, argv + argc, less&lt;string&gt;());

        for (int idx = 0; idx &lt; argc; ++idx)
            cout &lt;&lt; argv[idx] &lt;&lt; " ";
        cout &lt;&lt; '\n';
    }
</pre>
    The example illustrates how strings may be sorted alphabetically and
reversed alphabetically. By passing <code >greater_equal&lt;string&gt;</code> the strings are
sorted in <em >decreasing</em> order (the first word will be the 'greatest'), by
passing <code >less&lt;string&gt;</code> the strings are sorted in <em >increasing</em> order (the
first word will be the 'smallest').
<p>
Note that <code >argv</code> contains <code >char *</code> values, and that the relational
function object expects a <code >string</code>.  The promotion from <code >char const *</code> to
<code >string</code> is silently performed.
<p>
<a name="l323"></a>
<h3 >18.1.3: Logical function objects</h3>
    The <a name="an2027"></a>logical operators are called by the
 <a name="an2028"></a><a name="an2029"></a> logical function
objects. The standard logical operators are supported: <code >and, or,</code> and
<code >not</code>.
<p>
The STL supports the following set of logical function objects. The
function call operator (<code >operator()</code>) of these function objects calls the
matching logical operator for the objects that are passed to the function
call operator, returning that logical operator's return value. The
logical operator that is actually called is mentioned below:
    <ul>
    <li><a name="an2030"></a><code >logical_and&lt;&gt;</code>: calls <a name="an2031"></a><code >operator&amp;&amp;</code>;
    <li><a name="an2032"></a><code >logical_or&lt;&gt;</code>: calls <a name="an2033"></a><code >operator||</code>;
    <li><a name="an2034"></a><code >logical_not&lt;&gt;</code>: calls <code >operator!</code>.
    </ul>
    An example using <code >operator!</code> is provided in the following trivial
program, using <a name="an2035"></a><code >transform</code>  to transform
the logicalvalues stored in an array:
        <pre>
    #include &lt;iostream&gt;
    #include &lt;string&gt;
    #include &lt;functional&gt;
    #include &lt;algorithm&gt;
    using namespace std;

    int main(int argc, char **argv)
    {
        bool bArr[] = {true, true, true, false, false, false};
        size_t const bArrSize = sizeof(bArr) / sizeof(bool);

        for (size_t idx = 0; idx &lt; bArrSize; ++idx)
            cout &lt;&lt; bArr[idx] &lt;&lt; " ";
        cout &lt;&lt; '\n';

        transform(bArr, bArr + bArrSize, bArr, logical_not&lt;bool&gt;());

        for (size_t idx = 0; idx &lt; bArrSize; ++idx)
            cout &lt;&lt; bArr[idx] &lt;&lt; " ";
        cout &lt;&lt; '\n';
    }
    /*
      Displays:

        1 1 1 0 0 0
        0 0 0 1 1 1
    */
</pre>
<p>
<a name="ITERATORS"></a><a name="l324"></a>
<h2 >18.2: Iterators</h2>
In addition to the conceptual iterator types presented in this section the STL
defines several adaptors <a name="an2036"></a> allowing objects to
be passed as iterators. These adaptors are presented in the upcoming
sections. Before those adaptors can be used the <a name="an2037"></a><code >&lt;iterator&gt;</code> header file
must be included. 
<p>
Although standard iterators are candidates for 
deprecation&nbsp;(http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0174r1.html#2.1),
    this does not mean that they will (soon) be removed from the <code >std</code>
library. It's probably a suboptimal strategy to `reinvent' your own. Instead,
it is advised to continue using the <code >std::iterator</code> classes until they have
officially been replaced by alternatives.
<p>
Iterators are objects acting like pointers. Iterators have the following
general  <a name="an2038"></a> characteristics:
    <ul>
    <li> Two iterators may be compared for (in)equality using the <code >==</code> and
<code >!=</code> operators. The <em >ordering</em> operators (e.g., <code >&gt;</code>, <code >&lt;</code>)
can usually not be used.
    <li> Given an iterator <code >iter</code>, <code >*iter</code> represents the object the
iterator points to (alternatively, <code >iter-&gt;</code> can be used to reach the members
of the object the iterator points to).
    <li> <code >++iter</code> or <code >iter++</code> advances the iterator to the next
element. The notion of advancing an iterator to the next element is
consequently applied: several containers support <a name="an2039"></a><em >reversed_iterator</em> types,
in which the <code >++iter</code> operation actually reaches a previous element in a
sequence.
    <li> <em >Pointer arithmetic</em> may be used with iterators of containers
storing their elements consecutively in memory like <a name="an2040"></a><code >vector</code> and
<a name="an2041"></a><code >deque</code>. For such containers <code >iter + 2</code> points to the second element
beyond the one to which <code >iter</code> points. See also section <a href="cplusplus18.html#DISTANCE">18.2.1</a>,
covering <a name="an2042"></a><code >std::distance</code>.
    <li> Merely defining an iterator is comparable to having a
        0-pointer. Example:
        <pre>
#include &lt;vector&gt;
#include &lt;iostream&gt;
using namespace std;

int main()
{
    vector&lt;int&gt;::iterator vi;

    cout &lt;&lt; &amp;*vi;       // prints 0
}
</pre>
    </ul>
    STL containers usually define members offering iterators (i.e., they
define their own type <a name="an2043"></a><code >iterator</code>). These members are commonly called
<a name="an2044"></a><code >begin</code> and <a name="an2045"></a><code >end</code> and (for reversed iterators (type <code >reverse_iterator</code>))
<a name="an2046"></a><code >rbegin</code> and <a name="an2047"></a><code >rend</code>.
<p>
Standard practice requires <a name="an2048"></a> iterator ranges to be
<em >left inclusive</em>.  The notation <a name="an2049"></a><code >[left, right)</code> indicates that <code >left</code>
is an iterator pointing to the first element, while <code >right</code> is an iterator
pointing just <em >beyond</em> the last element. The iterator range is <em >empty</em>
when <code >left == right</code>.
<p>
The following example shows how all elements of a vector of strings can be
inserted into <code >cout</code> using its iterator ranges <code >[begin(), end())</code>, and
<code >[rbegin(), rend())</code>. Note that the <code >for-loops</code> for both ranges are
identical. Furthermore it nicely illustrates how the <code >auto</code> keyword can be
used to define the type of the loop control variable instead of using a much
more verbose variable definition like <code >vector&lt;string&gt;::iterator</code> (see also
section <a href="cplusplus03.html#AUTO">3.3.6</a>):
    <pre>
    #include &lt;iostream&gt;
    #include &lt;vector&gt;
    #include &lt;string&gt;
    using namespace std;

    int main(int argc, char **argv)
    {
        vector&lt;string&gt; args(argv, argv + argc);

        for (auto iter = args.begin(); iter != args.end(); ++iter)
            cout &lt;&lt; *iter &lt;&lt; " ";
        cout &lt;&lt; '\n';

        for (auto iter = args.rbegin(); iter != args.rend(); ++iter)
            cout &lt;&lt; *iter &lt;&lt; " ";
        cout &lt;&lt; '\n';
    }
</pre>
<p>
Furthermore, the STL defines
 <a name="an2050"></a><a name="an2051"></a><em >const_iterator</em> types that must be used
when visiting a series of elements in a constant container. Whereas the
elements of the vector in the previous example could have been altered, the
elements of the vector in the next example are immutable, and
<code >const_iterator</code>s are required:
        <pre>
    #include &lt;iostream&gt;
    #include &lt;vector&gt;
    #include &lt;string&gt;
    using namespace std;

    int main(int argc, char **argv)
    {
        vector&lt;string&gt; const args(argv, argv + argc);

        for
        (
            vector&lt;string&gt;::const_iterator iter = args.begin();
                iter != args.end();
                    ++iter
        )
            cout &lt;&lt; *iter &lt;&lt; " ";
        cout &lt;&lt; '\n';

        for
        (
            vector&lt;string&gt;::const_reverse_iterator iter = args.rbegin();
                iter != args.rend();
                    ++iter
        )
            cout &lt;&lt; *iter &lt;&lt; " ";
        cout &lt;&lt; '\n';
    }
</pre>
    The examples also illustrate that plain
 <a name="an2052"></a> pointers can be used as iterators. The
initialization <code >vector&lt;string&gt; args(argv, argv + argc)</code> provides the
<code >args</code> vector with a pair of pointer-based iterators: <code >argv</code> points to the
first element to initialize <code >args</code> with, <code >argv + argc</code> points just beyond
the last element to be used, <code >++argv</code> reaches the next command line
argument. This is a general pointer characteristic, which is why they too can
be used in situations where <code >iterators</code> are expected.
<p>
The STL defines five types <a name="an2053"></a> of iterators. These
iterator types are expected by generic algorithms, and in order to create a
particular type of iterator yourself it is important to know their
characteristics. In general, iterators <a name="an2054"></a> (see also
section <a href="cplusplus22.html#ITERATORCONS">22.14</a>) must define:
    <ul>
    <li><a name="an2055"></a><code >operator==</code>, testing two iterators for equality,
    <li><a name="an2056"></a><code >operator!=</code>, testing two iterators for inequality,
    <li><a name="an2057"></a><code >operator++</code>, incrementing the iterator, as prefix operator,
    <li><a name="an2058"></a><code >operator*</code>, to access the element the iterator refers to,
    </ul>
    The following types of iterators are used when describing generic
algorithms  in chapter <a href="cplusplus19.html#GENERIC">19</a>:
    <ul>
    <li> <a name="an2059"></a><strong >InputIterator</strong><strong >s</strong>:
        <blockquote >InputIterators are used to read from a container.  The
dereference operator is guaranteed to work as <a name="an2060"></a><code >rvalue</code> in
expressions. Instead of an InputIterator it is also possible to use (see
below) Forward-, Bidirectional- or RandomAccessIterators.  Notations like
<a name="an2061"></a><code >InputIterator1</code> and <a name="an2062"></a><code >InputIterator2</code> may be used as well. In these cases,
numbers are used to indicate which iterators `belong together'. E.g., the
generic algorithm <a href="cplusplus19.html#INNERPROD"><code >inner_product</code></a> has the following
prototype:
        <pre>
Type inner_product(InputIterator1 first1, InputIterator1 last1,
               InputIterator2 first2, Type init);
</pre>
    <code >InputIterator1 first1</code> and <code >InputIterator1 last1</code> define a pair of
input iterators on one range, while <code >InputIterator2 first2</code> defines the
beginning of another range. Analogous notations may be used with other
iterator types.</blockquote>
    <li> <a name="an2063"></a><strong >OutputIterator</strong><strong >s</strong>:
        <blockquote >OutputIterators can be used to write to a container. The
dereference operator is guaranteed to work as an <a name="an2064"></a><code >lvalue</code> in expressions,
but not necessarily as <code >rvalue</code>. Instead of an OutputIterator it is also
possible to use (see below) Forward-, Bidirectional- or
RandomAccessIterators.</blockquote>
    <li> <a name="an2065"></a><strong >ForwardIterator</strong><strong >s</strong>:
        <blockquote >ForwardIterators combine InputIterators and
OutputIterators. They can be used to traverse containers in one direction,
for reading and/or writing. Instead of a ForwardIterator it is also possible
to use (see below) Bidirectional- or RandomAccessIterators.</blockquote>
    <li> <a name="an2066"></a><strong >BidirectionalIterator</strong><strong >s</strong>:
        <blockquote >BidirectionalIterators can be used to traverse containers in
both directions, for reading and writing. Instead of a BidirectionalIterator
it is also possible to use (see below) a RandomAccessIterator.</blockquote>
    <li> <a name="an2067"></a><strong >RandomAccessIterator</strong><strong >s</strong>:
        <blockquote >RandomAccessIterators provide <a name="an2068"></a>random access to container
elements. An algorithm like <a href="cplusplus19.html#SORT"><code >sort</code></a> requires a
RandomAccessIterator, and can therefore <em >not</em> be used to sort the elements
of lists or maps, which only provide BidirectionalIterators.</blockquote>
    </ul>
    The example given with the RandomAccessIterator illustrates how to relate
iterators and generic algorithms: look for the iterator that's required by the
(generic) algorithm, and then see whether the datastructure supports the
required type of iterator. If not, the algorithm cannot be used with the
particular datastructure.
<p>
<a name="DISTANCE"></a><a name="l325"></a>
<h3 >18.2.1: std::distance</h3>
    Earlier, in section <a href="cplusplus18.html#ITERATORS">18.2</a> it was stated that iterators support
pointer arithmetic for containers storing their elements consecutively in
memory. This is not completely true: to determine the number of elements
between the elements to which two iterators refer the iterator must 
support the subtraction operator.  
<p>
Using pointer arithmetic to compute the number of elements between two
iterators in, e.g., a <code >std::list</code> or <code >std::unordered_map</code> is not possible,
as these containers do not store their elements consecutively in memory.
<p>
The function <code >std::distance</code><a name="an2069"></a> fills in that little gap:
<code >std::distance</code> expects two InputIterators and returns the number of
elements between them.
<p>
Before using <code >distance</code> the <a name="an2070"></a><code >&lt;iterator&gt;</code> header file must be included.
<p>
If the iterator specified as first argument exceeds the iterator specified as
its second argument then the number of elements is non-positive, otherwise it
is non-negative. If the number of elements cannot be determined (e.g., the
iterators do not refer to elements in the same container), then <code >distance's</code>
return value is undefined.
<p>
Example:
        <pre>
    #include &lt;iostream&gt;
    #include &lt;unordered_map&gt;
        
    using namespace std;
    
    int main()
    {
        unordered_map&lt;int, int&gt; myMap = {{1, 2}, {3, 5}, {-8, 12}};
    
        cout &lt;&lt; distance(++myMap.begin(), myMap.end()) &lt;&lt; '\n'; // shows: 2
    }
</pre>
<p>
<a name="INSERTER"></a><a name="l326"></a>
<h3 >18.2.2: Insert iterators</h3>
    Generic algorithms often require a target container into which the results of
the algorithm are deposited. For example, the <a href="cplusplus19.html#COPY"><code >copy</code></a> generic
algorithm has three parameters. The first two define the range of visited
elements, the third defines the first position where the results
of the copy operation should be stored.
<p>
With the <code >copy</code> algorithm the number of elements to copy is usually
available beforehand, since that number can usually be provided by pointer
arithmetic. However, situations exist where pointer arithmetic cannot be
used. Analogously, the number of resulting elements sometimes differs from the
number of elements in the initial range. The generic algorithm
<a href="cplusplus19.html#UNIQUECP"><code >unique_copy</code></a> is a case in point. Here the number of
elements that are copied to the destination container is normally not known
beforehand.
<p>
In situations like these an <a name="an2071"></a><em >inserter</em> <a name="an2072"></a> adaptor
function can often be used to create elements in the destination container.
There are three types of inserter adaptors:
    <ul>
    <li><a name="an2073"></a><code >back_inserter</code>: calls the container's <a name="an2074"></a><code >push_back</code> member to add
new elements at the end of the container. E.g., to copy all elements of
<code >source</code> in reversed order to the back of <code >destination</code>, using the
<a href="cplusplus19.html#COPY"><code >copy</code></a> generic algorithm:
        <pre>
copy(source.rbegin(), source.rend(), back_inserter(destination));
</pre>
    <li><a name="an2075"></a><code >front_inserter</code> calls the container's <a name="an2076"></a><code >push_front</code> member, adding
new elements at the beginning of the container. E.g., to copy all elements of
<code >source</code> to the front of the destination container (thereby also reversing
the order of the elements):
        <pre>
copy(source.begin(), source.end(), front_inserter(destination));
</pre>
    <li><a name="an2077"></a><code >inserter</code> calls the container's <a name="an2078"></a><code >insert</code> member adding new elements
starting at a specified starting point. E.g., to copy all elements of
<code >source</code> to the destination container, starting at the beginning of
<code >destination</code>, shifting up existing elements to beyond the newly inserted
elements:
        <pre>
copy(source.begin(), source.end(), inserter(destination,
    destination.begin()));
</pre>
    </ul>
    The inserter adaptors
 <a name="an2079"></a> <a name="an2080"></a>
 require the existence of two <code >typedef</code>s:
    <ul>
    <li><code >typedef Data value_type</code>, where <code >Data</code> is the data type stored in
the class offering <code >push_back, push_front</code> or <code >insert</code> members (Example:
<code >typedef std::string value_type</code>);
    <li><code >typedef value_type const &amp;const_reference</code>
    </ul>
    Concentrating on <code >back_inserter</code>, this iterator expects the name of a
container supporting a member <code >push_back</code>. The inserter's <code >operator()</code>
member calls the container's <code >push_back</code> member. Objects
 <a name="an2081"></a> of any class supporting a <code >push_back</code>
member can be passed as arguments to <code >back_inserter</code> provided the class adds
        <pre>
    typedef DataType const &amp;const_reference;
</pre>
    to its interface (where <code >DataType const &amp;</code> is the type of the parameter
of the class's member <code >push_back</code>). Example:
        <pre>
    #include &lt;iostream&gt;
    #include &lt;algorithm&gt;
    #include &lt;iterator&gt;
    using namespace std;

    class Insertable
    {
        public:
            typedef int value_type;
            typedef int const &amp;const_reference;

            void push_back(int const &amp;)
            {}
    };

    int main()
    {
        int arr[] = {1};
        Insertable insertable;

        copy(arr, arr + 1, back_inserter(insertable));
    }
</pre>
<p>
<a name="ISTREAMITERATORS"></a><a name="l327"></a>
<h3 >18.2.3: Iterators for `istream' objects</h3>
    The <a name="an2082"></a><code >istream_iterator&lt;Type&gt;</code> can be used to define a set
of iterators for
 <a name="an2083"></a> <code >istream</code> objects. The general form of the
<code >istream_iterator</code> iterator is:
        <pre>
    istream_iterator&lt;Type&gt; identifier(istream &amp;in)
</pre>
    Here, <code >Type</code> is the type of the data elements read from the <code >istream</code>
stream. It is used as the `begin' iterator in an interator range. <code >Type</code> may
be any type for which <code >operator</code>&gt;&gt; is defined in combination with <code >istream</code>
objects.
<p>
The default constructor is used as the end-iterator and corresponds to the
 <a name="an2084"></a>end-of-stream. For example,
        <pre>
    istream_iterator&lt;string&gt; endOfStream;
</pre>
    The <em >stream</em> object that was specified when defining the
begin-iterator is <em >not</em> mentioned with the default constructor.
<p>
Using <code >back_inserter</code> and <code >istream_iterator</code> adaptors, all strings
from a stream can easily be stored in a container. Example (using <a name="an2085"></a>anonymous
<code >istream_iterator</code> adaptors):
        <pre>
    #include &lt;iostream&gt;
    #include &lt;iterator&gt;
    #include &lt;string&gt;
    #include &lt;vector&gt;
    #include &lt;algorithm&gt;
    using namespace std;

    int main()
    {
        vector&lt;string&gt; vs;

        copy(istream_iterator&lt;string&gt;(cin), istream_iterator&lt;string&gt;(),
             back_inserter(vs));

        for
        (
            vector&lt;string&gt;::const_iterator begin = vs.begin(), end = vs.end();
                begin != end; ++begin
        )
            cout &lt;&lt; *begin &lt;&lt; ' ';
        cout &lt;&lt; '\n';
    }
</pre>
<p>
<a name="l328"></a>
<h4>18.2.3.1: Iterators for `istreambuf' objects</h4>
        Input iterators are also available for <a name="an2086"></a><code >streambuf</code> objects.
<p>
To read from <code >streambuf</code> objects supporting input operations
 <a name="an2087"></a><code >istreambuf_iterators</code> can be used, supporting the
operations that are also available for <code >istream_iterator</code>. Different from
the latter iterator type <code >istreambuf_iterators</code> support three constructors:
    <ul>
    <li><code >istreambuf_iterator&lt;Type&gt;</code>:<blockquote >The end iterator of an iterator range is created using the default
<code >istreambuf_iterator</code> constructor. It represents the <a name="an2088"></a>end-of-stream
condition when extracting values of type <code >Type</code> from the <code >streambuf</code>.
        </blockquote>
    <li><code >istreambuf_iterator&lt;Type&gt;(streambuf *)</code>:<blockquote >A pointer to a <code >streambuf</code> may be used when defining an
<code >istreambuf_iterator</code>. It represents the begin iterator of an iterator
range.</blockquote>
    <li><code >istreambuf_iterator&lt;Type&gt;(istream)</code>:<blockquote >An <em >istream</em> may be also used when defining an
<code >istreambuf_iterator</code>. It accesses the <code >istream</code>'s <code >streambuf</code> and it
also represents the begin iterator of an iterator range.</blockquote>
    </ul>
    In section <a href="cplusplus18.html#OSTREAMBUFITER">18.2.4.1</a> an example is given using both
<code >istreambuf_iterators</code> and <code >ostreambuf_iterators</code>.
<p>
<a name="l329"></a>
<h3 >18.2.4: Iterators for `ostream' objects</h3>
    An <a name="an2089"></a><code >ostream_iterator&lt;Type&gt;</code> adaptor can be used to pass
an <code >ostream</code> to algorithms expecting an OutputIterator. Two constructors are
available for defining <code >ostream_iterators</code>:
        <pre>
    ostream_iterator&lt;Type&gt; identifier(ostream &amp;outStream);
    ostream_iterator&lt;Type&gt; identifier(ostream &amp;outStream, char const *delim);
</pre>
    <code >Type</code> is the type of the data elements that should be inserted into an
<code >ostream</code>. It may be any type for which <code >operator</code>&lt;&lt; is defined in
combination with <code >ostream</code> objects.  The latter constructor can be used to
separate the individual <code >Type</code> data elements by <a name="an2090"></a><code >delimiter</code> strings. The
former constructor does not use any delimiters.
<p>
The example shows how <a href="cplusplus18.html#ISTREAMITERATORS"><code >istream_iterators</code></a> and an
<code >ostream_iterator</code> may be used to copy information of a file to another
file. A subtlety here is that you probably want to use
<code >in.unsetf(ios::skipws)</code>. It is used to clear the
 <a name="an2091"></a><code >ios::skipws</code> flag. As a consequence whitespace characters are
simply returned by the operator, and the file is copied character by
character. Here is the program:
        <pre>
    #include &lt;iostream&gt;
    #include &lt;algorithm&gt;
    #include &lt;iterator&gt;
    using namespace std;

    int main()
    {
        cin.unsetf(ios::skipws);
        copy(istream_iterator&lt;char&gt;(cin), istream_iterator&lt;char&gt;(),
             ostream_iterator&lt;char&gt;(cout));
    }
</pre>
<p>
<a name="OSTREAMBUFITER"></a><a name="l330"></a>
<h4>18.2.4.1: Iterators for `ostreambuf' objects</h4>
        Output iterators are also available for <a name="an2092"></a><code >streambuf</code> objects.
<p>
To write to  <code >streambuf</code> objects supporting output operations
 <a name="an2093"></a><code >ostreambuf_iterators</code> can be used, supporting the
operations that are also available for
<code >ostream_iterator</code>. <code >Ostreambuf_iterators</code> support two constructors:
    <ul>
    <li><code >ostreambuf_iterator&lt;Type&gt;(streambuf *)</code>:<blockquote >A pointer to a <code >streambuf</code> may be used when defining an
<code >ostreambuf_iterator</code>. It can be used as an OutputIterator.</blockquote>
    <li><code >ostreambuf_iterator&lt;Type&gt;(ostream)</code>:<blockquote >An <em >ostream</em> may be also used when defining an
<code >ostreambuf_iterator</code>. It accesses the <code >ostream</code>'s <code >streambuf</code> and it
can also be used as an OutputIterator.</blockquote>
    </ul>
    The next example illustrates the use of both
 <a name="an2094"></a><code >istreambuf_iterators</code> and <code >ostreambuf_iterators</code>
when copying a stream in yet another way. Since the stream's <code >streambuf</code>s
are directly accessed the streams and stream flags are bypassed. Consequently
there is no need to clear <code >ios::skipws</code> as in the previous section, while
the next program's efficiency probably also exceeds the efficiency of the
program shown in the previous section.
        <pre>
    #include &lt;iostream&gt;
    #include &lt;algorithm&gt;
    #include &lt;iterator&gt;
    using namespace std;

    int main()
    {
        istreambuf_iterator&lt;char&gt; in(cin.rdbuf());
        istreambuf_iterator&lt;char&gt; eof;
        ostreambuf_iterator&lt;char&gt; out(cout.rdbuf());

        copy(in, eof, out);
    }
</pre>
<p>
<a name="UNIQUEPTR"></a><a name="l331"></a>
<h2 >18.3: The class 'unique_ptr'</h2>
Before using the <code >unique_ptr</code> class presented in this section the
<a name="an2095"></a><code >&lt;memory&gt;</code> header file must be included.
<p>
When pointers are used to access dynamically allocated memory strict
bookkeeping is required to prevent memory leaks. When a pointer variable
referring to dynamically allocated memory goes out of scope, the dynamically
allocated memory becomes inaccessible and the program suffers from a 
    <a name="an2096"></a>memory leak.
    Consequently, the programmer has to make sure that the dynamically
allocated memory is returned to the common pool just before the pointer
variable goes out of scope.
<p>
When a pointer variable points to a dynamically allocated single value or
object, bookkeeping requirements are greatly simplified when the pointer
variable is defined as a <code >std::unique_ptr</code><a name="an2097"></a> object.
<p>
Unique_ptrs are <em >objects</em> masquerading as pointers. Since they are objects,
their destructors are called when they go out of scope.  Their destructors
automatically delete the dynamically allocated memory to which they
point. Unique_ptrs (and their cousins shared_ptrs (cf. section <a href="cplusplus18.html#SHAREDPTR">18.4</a>)
are also called
    <a name="an2098"></a><em >smart pointers</em>).
<p>
<code >Unique_ptrs</code> have several special characteristics:
    <ul>
    <li> when assigning a <code >unique_ptr</code> to another <em >move semantics</em> is
used. If move semantics is not available compilation fails. On the other
hand, if compilation succeeds then the used containers or generic algorithms
support the use of <code >unique_ptr</code>s. Here is an example:
        <pre>
std::unique_ptr&lt;int&gt; up1(new int);
std::unique_ptr&lt;int&gt; up2(up1);      // compilation error
</pre>
    The second definition fails to compile as <code >unique_ptr</code>'s copy
constructor is private (the same holds true for the assignment operator). But
the <code >unique_ptr</code> class <em >does</em> offer facilities to initialize and assign
from <em >rvalue references</em>:
        <pre>
class unique_ptr                        // interface partially shown
{
    public:
        unique_ptr(unique_ptr &amp;&amp;tmp);   // rvalues bind here
    private:
        unique_ptr(const unique_ptr &amp;other);
};
</pre>
    In the next example move semantics is used and so it compiles correctly:
        <pre>
unique_ptr&lt;int&gt; cp(unique_ptr&lt;int&gt;(new int));
</pre>
<p>
<li> a <code >unique_ptr</code> object should only point to memory that was made
available dynamically, as only dynamically allocated memory can be deleted.
<p>
<li> multiple <code >unique_ptr</code> objects should not be allowed to point to the
same block of dynamically allocated memory. The <code >unique_ptr</code>'s interface was
designed to prevent this from happening. Once a <code >unique_ptr</code> object goes out
of scope, it deletes the memory it points to, immediately changing any other
object also pointing to the allocated memory into a <a name="an2099"></a> wild
pointer.
<p>
<li> When a class <code >Derived</code> is derived from <code >Base</code>, then a newly
allocated <code >Derived</code> class object can be assigned to a <code >unique_ptr&lt;Base&gt;</code>,
without having to define a virtual destructor for <code >Base</code>. The <code >Base *</code>
pointer that is returned by the <code >unique_ptr</code> object can simply be cast
statically to <code >Derived</code>, and <code >Derived's</code> destructor is automatically
called as well, if the <code >unique_ptr</code> definition is provided with a
<em >deleter</em> function address. This is illustrated in the next example:
        <pre>
    class Base
    { ... };
    class Derived: public Base
    {
        ...
        public:
            // assume Derived has a member void process()
   
            static void deleter(Base *bp);
    };
    void Derived::deleter(Base *bp)
    {
        delete static_cast&lt;Derived *&gt;(bp);
    }
    int main()
    {
        unique_ptr&lt;Base, void (*)(Base *)&gt; bp(new Derived, &amp;Derived::deleter);
        static_cast&lt;Derived *&gt;(bp.get())-&gt;process(); // OK!

    } // here ~Derived is called: no polymorphism required.
</pre>
    </ul>
    The class <code >unique_ptr</code> offers several member functions to access the
pointer itself or to have a <code >unique_ptr</code> point to another block of
memory. These member functions (and <code >unique_ptr</code> constructors) are
introduced in the next few sections.
<p>
<code >Unique_ptr</code> can also be used with containers and (generic) algorithms. They
can properly destruct any type of object, as their constructors accept
customizable deleters. In addition, arrays can be handled by <code >unique_ptrs</code>.
<p>
<a name="l332"></a>
<h3 >18.3.1: Defining `unique_ptr' objects</h3>
    There are three ways to <a name="an2100"></a> define <code >unique_ptr</code>
objects. Each definition contains the usual <code >&lt;type&gt;</code> specifier between
angle brackets:
    <ul>
    <li> The default constructor simply creates a <code >unique_ptr</code> object that
does not point to a particular block of memory. Its pointer is initialized to
0 (zero):
        <pre>
unique_ptr&lt;type&gt; identifier;
</pre>
    This form is discussed in section <a href="cplusplus18.html#UNIQUEPLAIN">18.3.2</a>.
    <li> The <em >move constructor</em>  initializes an <code >unique_ptr</code> object.
Following the use of the move constructor its <code >unique_ptr</code> argument no
longer points to the dynamically allocated memory and its pointer data member
is turned into a zero-pointer:
        <pre>
unique_ptr&lt;type&gt; identifier(another unique_ptr for type);
</pre>
    This form is discussed in section <a href="cplusplus18.html#UNIQUEMOVE">18.3.3</a>.
    <li> The form that is used most often initializes a <code >unique_ptr</code> object
to the block of dynamically allocated memory that is passed to the object's
constructor. Optionally <a name="an2101"></a><code >deleter</code> can be provided. A (free) function (or
function object) receiving the <code >unique_ptr</code>'s pointer as its argument can be
passed as deleter. It is supposed to return the dynamically allocated
memory to the common pool (doing nothing if the pointer equals zero).
        <pre>
unique_ptr&lt;type&gt; identifier (new-expression [, deleter]);
</pre>
    This form is discussed in section <a href="cplusplus18.html#UNIQUENEW">18.3.4</a>.
    </ul>
<p>
<a name="UNIQUEPLAIN"></a><a name="l333"></a>
<h3 >18.3.2: Creating a plain `unique_ptr'</h3>
    <code >Unique_ptr</code>'s default constructor defines a <a name="an2102"></a>
<code >unique_ptr</code> not pointing to a particular block of memory:
        <pre>
    unique_ptr&lt;type&gt; identifier;
</pre>
    The <a name="an2103"></a> pointer controlled by the <code >unique_ptr</code>
object is initialized to <code >0</code> (zero). Although the <code >unique_ptr</code> object
itself is not the pointer, its value <em >can</em> be compared to <code >0</code>. Example:
        <pre>
    unique_ptr&lt;int&gt; ip;

    if (!ip)
        cout &lt;&lt; "0-pointer with a unique_ptr object\n";
</pre>
    Alternatively, the member <a name="an2104"></a><code >get</code> can be used (cf. section <a href="cplusplus18.html#UNIQUEMEM">18.3.5</a>).
<p>
<a name="UNIQUEMOVE"></a><a name="l334"></a>
<h3 >18.3.3: Moving  another `unique_ptr'</h3>
        A <code >unique_ptr</code> <a name="an2105"></a> may be initialized
using an rvalue reference to a <code >unique_ptr</code> object for the same type:
        <pre>
    unique_ptr&lt;type&gt; identifier(other unique_ptr object);
</pre>
    The move constructor is used, e.g., in the following example:
        <pre>
    void mover(unique_ptr&lt;string&gt; &amp;&amp;param)
    {
        unique_ptr&lt;string&gt; tmp(move(param));
    }
</pre>
    Analogously, the assignment operator can <a name="an2106"></a> be
used. A <code >unique_ptr</code> object may be assigned to a temporary  <code >unique_ptr</code>
object of the same type (again move-semantics is used). For example:
        <pre>
    #include &lt;iostream&gt;
    #include &lt;memory&gt;
    #include &lt;string&gt;

    using namespace std;

    int main()
    {
        unique_ptr&lt;string&gt; hello1(new string("Hello world"));
        unique_ptr&lt;string&gt; hello2(move(hello1));
        unique_ptr&lt;string&gt; hello3;

        hello3 = move(hello2);
        cout &lt;&lt; // *hello1 &lt;&lt; '\n' &lt;&lt;   // would have segfaulted
                // *hello2 &lt;&lt; '\n' &lt;&lt;   // same
                *hello3 &lt;&lt; '\n';
    }
    // Displays:    Hello world
</pre>
    The example illustrates that
    <ul>
    <li> <code >hello1</code> is initialized by a pointer to a dynamically allocated
<code >string</code> (see the next section).
    <li> The <code >unique_ptr hello2</code> grabs the pointer controlled by <code >hello1</code>
using a move constructor. This effectively changes <code >hello1</code> into a
0-pointer.
    <li> Then <code >hello3</code> is defined as a default <code >unique_ptr&lt;string&gt;</code>. But
then it grabs its value using move-assignment from <code >hello2</code> (which, as a
consequence, is changed into a 0-pointer).
    </ul>
    If <code >hello1</code> or <code >hello2</code> had been inserted into <code >cout</code> a
<a name="an2107"></a><em >segmentation fault</em> would have resulted. The reason for this should now be
clear: it is caused by dereferencing 0-pointers. In the end, only <code >hello3</code>
actually points to the originally allocated <code >string</code>.
<p>
<a name="UNIQUENEW"></a><a name="l335"></a>
<h3 >18.3.4: Pointing to a newly allocated object</h3>
    A <code >unique_ptr</code> <a name="an2108"></a> is most often initialized
using a pointer to dynamically allocated memory. The generic form is:
        <pre>
    unique_ptr&lt;type [, deleter_type]&gt; identifier(new-expression
            [, deleter = deleter_type{}]);
</pre>
    The second (template) argument (<code >deleter(_type)</code>) is optional and may
 <a name="an2109"></a> refer to a free function or function object handling the
destruction of the allocated memory. A deleter is used, e.g., in situations
where a double pointer is allocated and the destruction must visit each nested
pointer to destroy the allocated memory (see below for an illustration).
<p>
Here is an example initializing a <code >unique_ptr</code> pointing to a <code >string</code>
object:
        <pre>
    unique_ptr&lt;string&gt; strPtr(new string("Hello world"));
</pre>
    The argument that is passed to the constructor is the pointer returned by
<code >operator new</code>. Note that <code >type</code> does <em >not</em> mention the pointer.  The
<a name="an2110"></a> type that is used in the <code >unique_ptr</code> construction
is the same as the type that is used in <code >new</code> expressions.
<p>
Here is an example showing how an explicitly defined deleter may be used to
delete a dynamically allocated array of pointers to strings:
        <pre>
    #include &lt;iostream&gt;
    #include &lt;string&gt;
    #include &lt;memory&gt;
    using namespace std;

    struct Deleter
    {
        size_t d_size;
        Deleter(size_t size = 0)
        :
            d_size(size)
        {}
        void operator()(string **ptr) const
        {
            for (size_t idx = 0; idx &lt; d_size; ++idx)
                delete ptr[idx];
            delete[] ptr;
        }
    };
    int main()
    {
        unique_ptr&lt;string *, Deleter&gt; sp2{ new string *[10], Deleter{ 10 } };

        Deleter &amp;obj = sp2.get_deleter();
    }
</pre>
<p>
A <code >unique_ptr</code> can be used to reach the
 <a name="an2111"></a> member functions that are available for
objects allocated by the <code >new</code> expression.  These members can be reached as
if the <code >unique_ptr</code> was a plain pointer to the dynamically allocated
object. For example, in the following program the text `<code >C++</code>' is inserted
behind the word `<code >hello</code>':
        <pre>
    #include &lt;iostream&gt;
    #include &lt;memory&gt;
    #include &lt;cstring&gt;
    using namespace std;

    int main()
    {
        unique_ptr&lt;string&gt; sp(new string("Hello world"));

        cout &lt;&lt; *sp &lt;&lt; '\n';
        sp-&gt;insert(strlen("Hello "), "C++ ");
        cout &lt;&lt; *sp &lt;&lt; '\n';
    }
    /*
        Displays:
            Hello world
            Hello C++ world
    */
</pre>
<p>
<a name="UNIQUEMEM"></a><a name="l336"></a>
<h3 >18.3.5: Operators and members</h3>
    The class <code >unique_ptr</code> offers the  following
 <a name="an2112"></a> operators:
    <ul>
    <li><a name="an2113"></a><code >unique_ptr&lt;Type&gt; &amp;operator=(unique_ptr&lt;Type&gt; &amp;&amp;tmp)</code>:<blockquote >This operator transfers the memory pointed to by the <a name="an2114"></a>rvalue
        <code >unique_ptr</code> object to the <a name="an2115"></a>lvalue <code >unique_ptr</code> object using
        <em >move semantics</em>. So, the rvalue object <em >loses</em> the memory it
        pointed at and turns into a 0-pointer. An existing <code >unique_ptr</code> may
        be assigned to another <code >unique_ptr</code> by converting it to an rvalue
        reference first using <code >std::move</code>. Example:
   <pre>
unique_ptr&lt;int&gt; ip1(new int);
unique_ptr&lt;int&gt; ip2;

ip2 = std::move(ip1);
</pre>
    </blockquote>
    <li><a name="an2116"></a><code >operator bool() const</code>:<blockquote >This operator returns <code >false</code> if the <code >unique_ptr</code> does not point
        to memory (i.e., its <code >get</code> member, see below, returns 0). Otherwise,
        <code >true</code> is returned.</blockquote>
    <li><a name="an2117"></a><code >Type &amp;operator*()</code>:<blockquote >This operator returns a reference to the information accessible via
        a <code >unique_ptr</code> object . It acts like a normal pointer dereference
        operator.</blockquote>
    <li><a name="an2118"></a><code >Type *operator-&gt;()</code>:<blockquote >This operator returns a pointer to the information accessible via a
        <code >unique_ptr</code> object. This operator allows you to select
        members of an object accessible via a <code >unique_ptr</code> object. Example:
   <pre>
unique_ptr&lt;string&gt; sp(new string("hello"));
cout &lt;&lt; sp-&gt;c_str();
</pre>
        </blockquote>
    </ul>
<p>
The class <code >unique_ptr</code> supports the following <a name="an2119"></a>
member functions:
    <ul>
    <li><a name="an2120"></a><code >Type *get()</code>:<blockquote >A pointer to the information controlled by the <code >unique_ptr</code> object
        is returned. It acts like <code >operator-&gt;</code>. The returned pointer can be
        inspected. If it is zero the <code >unique_ptr</code> object does not point to
        any memory.</blockquote>
    <li><a name="an2121"></a><code >Deleter &amp;unique_ptr&lt;Type&gt;::get_deleter()</code>:<blockquote >A reference to the deleter object used by the <code >unique_ptr</code> is
        returned.</blockquote>
    <li><a name="an2122"></a><code >Type *release()</code>:<blockquote >A pointer to the information accessible via a <code >unique_ptr</code> object is
        returned. At the same time the object itself becomes a 0-pointer
        (i.e., its pointer data member is turned into a 0-pointer). This
        member can be used to transfer the information accessible via a
        <code >unique_ptr</code> object to a plain <code >Type</code> pointer. After calling this
        member the proper destruction of the dynamically allocated memory
        is the <a name="an2123"></a>responsibility of the programmer.</blockquote>
    <li><a name="an2124"></a><code >void reset(Type *)</code>:<blockquote >The dynamically allocated memory controlled by the <code >unique_ptr</code>
        object is returned to the common pool; the object thereupon controls
        the memory  to which the argument that is passed to the function
        points. It can also be called without argument, turning the object
        into a 0-pointer. This member function can be used to assign a new
        block of dynamically allocated memory to a <code >unique_ptr</code> object.</blockquote>
    <li><a name="an2125"></a><code >void swap(unique_ptr&lt;Type&gt; &amp;)</code>:<blockquote >Two identically typed <code >unique_ptrs</code> are swapped.</blockquote>
    </ul>
<p>
<a name="l337"></a>
<h3 >18.3.6: Using `unique_ptr' objects for arrays</h3>
    When a <code >unique_ptr</code> is used to store arrays the dereferencing operator makes
little sense but with arrays <code >unique_ptr</code> objects benefit from index
operators. The distinction between a single object <code >unique_ptr</code> and a
<code >unique_ptr</code> referring to a dynamically allocated array of objects is
realized through a template specialization.
<p>
With dynamically allocated arrays the following syntax is available:
    <ul>
    <li> the index (<code >[]</code>) notation is used to specify that the smart
        pointer controls a dynamically allocated <em >array</em>. Example:
            <pre>
unique_ptr&lt;int[]&gt; intArr(new int[3]);
</pre>
    <li> the index operator can be used to access the array's
        elements. Example:
            <pre>
intArr[2] = intArr[0];
</pre>
    </ul>
    In these cases the smart pointer's destructors call
<code >delete[]</code> rather than <code >delete</code>.
<p>
<a name="SHAREDPTR"></a><a name="l338"></a>
<h2 >18.4: The class `shared_ptr'</h2>
In addition to the class <code >unique_ptr</code> the class
<a name="an2126"></a><code >std::shared_ptr&lt;Type&gt;</code> is available, which is a reference
counting smart pointer.
<p>
Before using <code >shared_ptrs</code> the <a name="an2127"></a><code >&lt;memory&gt;</code> header file must be included.
<p>
The shared pointer automatically destroys its contents once its reference
count has decayed to zero. As with <code >unique_ptr</code>, when defining a
<code >shared_ptr&lt;Base&gt;</code> to store a newly allocated <code >Derived</code> class object, the
returned <code >Base *</code> may be cast to a <code >Derived *</code> using a <code >static_cast</code>:
polymorphism isn't required, and when resetting the <code >shared_ptr</code> or when the
<code >shared_ptr</code> goes out of scope, no slicing occurs, and <code >Derived</code>'s
destructor (or, if configured: deleter) is called (cf. section
<a href="cplusplus18.html#UNIQUEPTR">18.3</a>).
<p>
<code >Shared_ptrs</code> support copy and move constructors as well as standard and
move overloaded assignment operators.
<p>
Like <code >unique_ptrs, shared_ptrs</code> may refer to dynamically allocated arrays.
<p>
<a name="l339"></a>
<h3 >18.4.1: Defining `shared_ptr' objects</h3>
    There are four ways to <a name="an2128"></a> define <code >shared_ptr</code>
objects. Each definition contains the usual <code >&lt;type&gt;</code> specifier between
angle brackets:
    <ul>
    <li> The default constructor simply creates a <code >shared_ptr</code> object that
does not point to a particular block of memory. Its pointer is initialized to
0 (zero):
        <pre>
shared_ptr&lt;type&gt; identifier;
</pre>
    This form is discussed in section <a href="cplusplus18.html#SHAREDPLAIN">18.4.2</a>.
<p>
<li> The copy constructor initializes a <code >shared_ptr</code> so that both
objects share the memory pointed at by the existing object. The copy
constructor also increments the <code >shared_ptr</code>'s reference count. Example:
        <pre>
shared_ptr&lt;string&gt; org(new string("hi there"));
shared_ptr&lt;string&gt; copy(org);   // reference count now 2
</pre>
<p>
<li> The move constructor initializes a <code >shared_ptr</code> with the pointer
and reference count of a temporary <code >shared_ptr</code>. The temporary
<code >shared_ptr</code> is changed into a 0-pointer. An existing <code >shared_ptr</code> may
have its data moved to a newly defined <code >shared_ptr</code> (turning the existing
<code >shared_ptr</code> into a 0-pointer as well). In the next example a temporary,
anonymous <code >shared_ptr</code> object is constructed, which is then used to
construct <code >grabber</code>. Since <code >grabber</code>'s constructor receives an anonymous
temporary object, the compiler uses <code >shared_ptr</code>'s move constructor:
        <pre>
shared_ptr&lt;string&gt; grabber(shared_ptr&lt;string&gt;(new string("hi there")));
</pre>
<p>
<li> The form that is used most often initializes a <code >shared_ptr</code> object
to the block of dynamically allocated memory that is passed to the object's
constructor. Optionally <a name="an2129"></a><code >deleter</code> can be provided. A (free) function (or
function object) receiving the <code >shared_ptr</code>'s pointer as its argument can be
passed as deleter. It is supposed to return the dynamically allocated
memory to the common pool (doing nothing if the pointer equals zero).
        <pre>
shared_ptr&lt;type&gt; identifier (new-expression [, deleter]);
</pre>
    This form is discussed in section <a href="cplusplus18.html#SHAREDNEW">18.4.3</a>.
    </ul>
<p>
<a name="SHAREDPLAIN"></a><a name="l340"></a>
<h3 >18.4.2: Creating a plain `shared_ptr'</h3>
    <code >Shared_ptr</code>'s default constructor defines a <a name="an2130"></a>
<code >shared_ptr</code> not pointing to a particular block of memory:
        <pre>
    shared_ptr&lt;type&gt; identifier;
</pre>
    The <a name="an2131"></a> pointer controlled by the <code >shared_ptr</code>
object is initialized to <code >0</code> (zero). Although the <code >shared_ptr</code> object
itself is not the pointer, its value <em >can</em> be compared to <code >0</code>. Example:
        <pre>
    shared_ptr&lt;int&gt; ip;

    if (!ip)
        cout &lt;&lt; "0-pointer with a shared_ptr object\n";
</pre>
    Alternatively, the member <a name="an2132"></a><code >get</code> can be used (cf. section <a href="cplusplus18.html#SHAREDMEM">18.4.4</a>).
<p>
<a name="SHAREDNEW"></a><a name="l341"></a>
<h3 >18.4.3: Pointing to a newly allocated object</h3>
    Most often a <code >shared_ptr</code> <a name="an2133"></a> is initialized by a
dynamically allocated block of memory. The generic form is:
        <pre>
    shared_ptr&lt;type&gt; identifier(new-expression [, deleter]);
</pre>
    The second argument (<code >deleter</code>) is optional and
 <a name="an2134"></a> refers to a function object or free function handling the
destruction of the allocated memory. A deleter is used, e.g., in situations
where a double pointer is allocated and the destruction must visit each nested
pointer to destroy the allocated memory (see below for an illustration).  It
is used in situations comparable to those encountered with <code >unique_ptr</code>
(cf. section <a href="cplusplus18.html#UNIQUENEW">18.3.4</a>).
<p>
Here is an example initializing a <code >shared_ptr</code> pointing to a <code >string</code>
object:
        <pre>
    shared_ptr&lt;string&gt; strPtr(new string("Hello world"));
</pre>
    The argument that is passed to the constructor is the pointer returned by
<code >operator new</code>. Note that <code >type</code> does <em >not</em> mention the pointer.  The
<a name="an2135"></a> type that is used in the <code >shared_ptr</code> construction
is the same as the type that is used in <code >new</code> expressions.
<p>
The next example illustrates that two <code >shared_ptrs</code> indeed share their
information. After modifying the information controlled by one of the
objects the information controlled by the other object is modified as well:
        <pre>
    #include &lt;iostream&gt;
    #include &lt;memory&gt;
    #include &lt;cstring&gt;
    using namespace std;

    int main()
    {
        shared_ptr&lt;string&gt; sp(new string("Hello world"));
        shared_ptr&lt;string&gt; sp2(sp);

        sp-&gt;insert(strlen("Hello "), "C++ ");
        cout &lt;&lt; *sp &lt;&lt; '\n' &lt;&lt;
                *sp2 &lt;&lt; '\n';
    }
    /*
        Displays:
            Hello C++ world
            Hello C++ world
    */
</pre>
<p>
<a name="SHAREDMEM"></a><a name="l342"></a>
<h3 >18.4.4: Operators and members</h3>
    The class <code >shared_ptr</code> offers the following <a name="an2136"></a>
operators:
    <ul>
    <li><a name="an2137"></a><code >shared_ptr &amp;operator=(shared_ptr&lt;Type&gt; const &amp;other)</code>:<blockquote >Copy assignment: the reference count of the operator's left hand side
        operand is reduced. If the reference count decays to zero the
        dynamically allocated memory controlled by the left hand side operand
        is deleted. Then it shares the information with the operator's
        right hand side operand, incrementing the information's reference
        count.</blockquote>
    <li><a name="an2138"></a><code >shared_ptr &amp;operator=(shared_ptr&lt;Type&gt; &amp;&amp;tmp)</code>:<blockquote >Move assignment: the reference count of the operator's left hand side
        operand is reduced. If the reference count decays to zero the
        dynamically allocated memory controlled by the left hand side operand
        is deleted. Then it grabs the information controlled by the
        operator's right hand side operand which is turned into a 0-pointer.</blockquote>
    <li><a name="an2139"></a><code >operator bool() const</code>:<blockquote >If the <code >shared_ptr</code> actually points to memory <code >true</code> is returned,
        otherwise, <code >false</code> is returned.</blockquote>
    <li><a name="an2140"></a><code >Type &amp;operator*()</code>:<blockquote >A reference to the information stored in the
        <code >shared_ptr</code> object is returned. It acts like a normal pointer.</blockquote>
    <li><a name="an2141"></a><code >Type *operator-&gt;()</code>:<blockquote >A pointer to the information controlled by the <code >shared_ptr</code> object
        is returned. Example:
   <pre>
shared_ptr&lt;string&gt; sp(new string("hello"));
cout &lt;&lt; sp-&gt;c_str() &lt;&lt; '\n';
</pre>
        </blockquote>
    </ul>
<p>
The following <a name="an2142"></a>member function member functions are supported:
    <ul>
    <li><a name="an2143"></a><code >Type *get()</code>:<blockquote >A pointer to the information controlled by the <code >shared_ptr</code> object
        is returned. It acts like <code >operator-&gt;</code>. The returned pointer can be
        inspected. If it is zero the <code >shared_ptr</code> object does not point to
        any memory.</blockquote>
    <li><a name="an2144"></a><code >Deleter &amp;get_deleter()</code>:<blockquote >A reference to the <code >shared_ptr</code>'s deleter (function or function
        object) is returned.</blockquote>
    <li><a name="an2145"></a><code >void reset(Type *)</code>:<blockquote >The reference count of the information controlled by the <code >shared_ptr</code>
        object is reduced and if it decays to zero the memory it points to
        is deleted. Thereafter the
        object's information will refer to the argument that is passed to the
        function, setting its shared count to 1. It can also be called without
        argument, turning the object into a 0-pointer. This member function
        can be used to assign a new block of dynamically allocated memory to a
        <code >shared_ptr</code> object.</blockquote>
    <li><a name="an2146"></a><code >void reset(Type *, DeleterType &amp;&amp;)</code>:<blockquote >This variant of the previous member accepts a specific <code >Deleter</code>
        type: if <code >Type</code> is a base-class and derived class objects are used,
        these derived class objects may require specific actions at
        destruction time. When the previous member is used, then eventually the
        newly assigned object's destructor is called without using an
        explicit deleter function. The current member ensures that by the time
        the shared counter has decayed to zero the provided deleter is used.</blockquote>
      <li><a name="an2147"></a><code >void shared_ptr&lt;Type&gt;::swap(shared_ptr&lt;Type&gt; &amp;&amp;)</code>:<blockquote >Two identically typed <code >shared_ptrs</code> are swapped.</blockquote>
    <li><a name="an2148"></a><code >bool unique() const</code>:<blockquote >If the current object is the only object referring to the memory
        controlled by the object <code >true</code> is returned otherwise (including the
        situation where the object is a 0-pointer) <code >false</code> is returned.</blockquote>
    <li><a name="an2149"></a><code >size_t use_count() const</code>:<blockquote >The number of objects sharing the memory controlled by the object is
        returned.</blockquote>
    </ul>
<p>
<a name="SHAREDCAST"></a><a name="l343"></a>
<h3 >18.4.5: Casting shared pointers</h3>
    Be cautious when using standard <strong >C++</strong> style casts in combination with
<code >shared_ptr</code> objects. Consider the following two classes:
        <pre>
    struct Base
    {};
    struct Derived: public Base
    {};
</pre>
<p>
As with <code >unique_ptr</code>, when defining a <code >shared_ptr&lt;Base&gt;</code> to store a
newly allocated <code >Derived</code> class object, the returned <code >Base *</code> may be cast
to a <code >Derived *</code> using a <code >static_cast</code>: polymorphism isn't required, and
when resetting the <code >shared_ptr</code> or when the <code >shared_ptr</code> goes out of
scope, no slicing occurs, and <code >Derived</code>'s destructor is called (cf. section
<a href="cplusplus18.html#UNIQUEPTR">18.3</a>).
<p>
Of course, a <code >shared_ptr&lt;Derived&gt;</code> can easily be defined. Since a
<code >Derived</code> object is also a <code >Base</code> object, a pointer to <code >Derived</code> can
be considered a pointer to <code >Base</code> without using casts, but a <code >static_cast</code>
could be used to force the interpretation of a <code >Derived *</code> to a <code >Base *</code>:
        <pre>
    Derived d;
    static_cast&lt;Base *&gt;(&amp;d);
</pre>
<p>
However, a plain <code >static_cast</code> cannot be used when initializing a shared
pointer to a <code >Base</code> using the <code >get</code> member of a shared pointer to a
<code >Derived</code> object. The following code snipped eventually results in an
attempt to delete the dynamically allocated <code >Base</code> object twice:
        <pre>
    shared_ptr&lt;Derived&gt; sd{ new Derived };
    shared_ptr&lt;Base&gt; sb{ static_cast&lt;Base *&gt;(sd.get()) };
</pre>
    Since <code >sd</code> and <code >sb</code> point at the same object <code >~Base</code> will be called
for the same object when <code >sb</code> goes out of scope and when <code >sd</code> goes out of
scope, resulting in premature termination of the program due to a
 <a name="an2150"></a><em >double free</em> error.
<p>
These errors can be prevented using casts that were specifically designed
for being used with <code >shared_ptrs</code>. These casts use specialized constructors
that create a <code >shared_ptr</code> pointing to memory but shares ownership (i.e.,
a reference count) with an existing <code >shared_ptr</code>. These special casts are:
    <ul>
    <li><a name="an2151"></a><code >std::static_pointer_cast&lt;Base&gt;(std::shared_ptr&lt;Derived&gt; ptr)</code>:<blockquote >A <code >shared_ptr</code> to a <code >Base</code> class object is returned. The returned
<code >shared_ptr</code> refers to the base class portion of the <code >Derived</code> class to
which the <code >shared_ptr&lt;Derived&gt; ptr</code> refers. Example:
        <pre>
shared_ptr&lt;Derived&gt; dp{ new Derived };
shared_ptr&lt;Base&gt; bp = static_pointer_cast&lt;Base&gt;(dp);
</pre>
        </blockquote>
<p>
<li><a name="an2152"></a><code >std::const_pointer_cast&lt;Class&gt;(std::shared_ptr&lt;Class const&gt; ptr)</code>:<blockquote >A <code >shared_ptr</code> to a <code >Class</code> class object is returned. The
returned <code >shared_ptr</code> refers to a non-const <code >Class</code> object whereas the
<code >ptr</code> argument refers to a <code >Class const</code> object. Example:
        <pre>
shared_ptr&lt;Derived const&gt; cp{ new Derived };
shared_ptr&lt;Derived&gt; ncp = const_pointer_cast&lt;Derived&gt;(cp);
</pre>
        </blockquote>
<p>
<li><a name="an2153"></a><code >std::dynamic_pointer_cast&lt;Derived&gt;(std::shared_ptr&lt;Base&gt; ptr)</code>:<blockquote >A <code >shared_ptr</code> to a <code >Derived</code> class object is returned. The
<code >Base</code> class must have at least one virtual member function, and the class
<code >Derived</code>, inheriting from <code >Base</code> may have overridden <code >Base</code>'s virtual
member(s). The returned <code >shared_ptr</code> refers to a <code >Derived</code> class object if
the dynamic cast from <code >Base *</code> to <code >Derived *</code> succeeded. If the dynamic
cast did not succeed the <code >shared_ptr</code>'s <code >get</code> member returns 0.  Example
(assume <code >Derived</code> and <code >Derived2</code> were derived from <code >Base</code>):
        <pre>
shared_ptr&lt;Base&gt; bp(new Derived());
cout &lt;&lt; dynamic_pointer_cast&lt;Derived&gt;(bp).get() &lt;&lt; ' ' &lt;&lt;
        dynamic_pointer_cast&lt;Derived2&gt;(bp).get() &lt;&lt; '\n';
</pre>
    The first <code >get</code> returns a non-0 pointer value, the second <code >get</code>
returns 0.
        </blockquote>
    </ul>
<p>
<a name="SHAREDARRAY"></a><a name="l344"></a>
<h3 >18.4.6: Using `shared_ptr' objects for arrays</h3>
    Different from the <code >unique_ptr</code> class no specialization exists for the
<code >shared_ptr</code> class to handle dynamically allocated arrays of objects.
<p>
But like <code >unique_ptrs</code>, with <code >shared_ptrs</code> referring to arrays the
dereferencing operator makes little sense while in these circumstances
<code >shared_ptr</code> objects would benefit from index operators.
<p>
It is not difficult to create a class <code >shared_array</code> offering such
facilities. The class template <code >shared_array</code>, derived from <code >shared_ptr</code>
merely should provide an appropriate <em >deleter</em> to make sure that the array
and its elements are properly destroyed. In addition it should define the
index operator and, when applicable should declare the derefencing operators
using <code >delete</code>.
<p>
Here is an example showing how <code >shared_array</code> can be defined and used:
    <pre>
    struct X
    {
        ~X()
        {
            cout &lt;&lt; "destr\n";  // show the object's destruction
        }
    };
    template &lt;typename Type&gt;
    class shared_array: public shared_ptr&lt;Type&gt;
    {
        struct Deleter          // Deleter receives the pointer
        {                       // and calls delete[]
           void operator()(Type* ptr)
           {
              delete[] ptr;
           }
        };
        public:
            shared_array(Type *p)           // other constructors
            :                               // not shown here
                shared_ptr&lt;Type&gt;(p, Deleter())
            {}
            Type &amp;operator[](size_t idx)    // index operators
            {
                return shared_ptr&lt;Type&gt;::get()[idx];
            }
            Type const &amp;operator[](size_t idx) const
            {
                return shared_ptr&lt;Type&gt;::get()[idx];
            }
            Type &amp;operator*() = delete;     // delete pointless members
            Type const &amp;operator*() const = delete;
            Type *operator-&gt;() = delete;
            Type const *operator-&gt;() const = delete;
    };
    int main()
    {
        shared_array&lt;X&gt; sp{ new X[3] };
        sp[0] = sp[1];
    }
</pre>
<p>
<a name="l345"></a>
<h2 >18.5: Smart smart pointer construction: `make_shared' and `make_unique'</h2>
Usually a <code >shared_ptr</code> is initialized at definition time
with a pointer to a newly allocated object. Here is an example:
        <pre>
    std::shared_ptr&lt;string&gt; sptr(new std::string("hello world"))
</pre>
    In such statements <em >two</em> memory allocation calls are used: one for the
allocation of the <code >std::string</code> and one used interally by
<code >std::shared_ptr</code>'s constructor itself.
<p>
The two allocations can be combined into one single allocation (which is
also slightly more efficient than explicitly calling <code >shared_ptr</code>'s
constructor) using the <a name="an2154"></a><code >make_shared</code> template. The function template
<code >std::make_shared</code> has the following prototype:
        <pre>
    template&lt;typename Type, typename ...Args&gt;
    std::shared_ptr&lt;Type&gt; std::make_shared(Args ...args);
</pre>
<p>
Before using <code >make_shared</code> the <a name="an2155"></a><code >&lt;memory&gt;</code> header file must be included.
<p>
This function template allocates an object of type <code >Type</code>, passing
<code >args</code> to its constructor (using <em >perfect forwarding</em>, see section
<a href="cplusplus22.html#PERFECT">22.5.2</a>), and returns a <code >shared_ptr</code> initialized with the address of
the newly allocated <code >Type</code> object.
<p>
Here is how the above <code >sptr</code> object can be initialized
using <code >std::make_shared</code>. Notice the use of <code >auto</code> which frees us from
having to specify <code >sptr</code>'s type explicitly:
        <pre>
    auto sptr(std::make_shared&lt;std::string&gt;("hello world"));
</pre>
    After this initialization <code >std::shared_ptr&lt;std::string&gt; sptr</code> has been
defined and initialized. It could be used as follows:
        <pre>
    std::cout &lt;&lt; *sptr &lt;&lt; '\n';
</pre>
<p>
In addition to <code >make_shared</code> the function
    <a name="an2156"></a><code >std::make_unique</code> can be used. It can be used
<code >make_shared</code> but returns a <code >std::unique_ptr</code> rather than a
<code >shared_ptr</code>.
<p>
<a name="l346"></a>
<h2 >18.6: Classes having pointer data members</h2>
Classes having <a name="an2157"></a> pointer data members require special
attention. In particular at construction time one must be careful to prevent
 <a name="an2158"></a> wild pointers and/or <a name="an2159"></a> memory leaks. Consider
the following class defining two pointer data members:
        <pre>
    class Filter
    {
        istream *d_in;
        ostream *d_out;
        public:
            Filter(char const *in, char const *out);
    };
</pre>
    Assume that <code >Filter</code> objects filter information read from <code >*d_in</code> and
write the filtered information to <code >*d_out</code>.  Using pointers to streams
allows us to have them point at any kind of stream like <code >istreams,
ifstreams, fstreams</code> or <code >istringstreams</code>.  The shown constructor could be
implemented like this:
        <pre>
    Filter::Filter(char const *in, char const *out)
    :
        d_in(new ifstream{ in }),
        d_out(new ofstream{ out })
    {
        if (!*d_in || !*d_out)
            throw string("Input and/or output stream not available");
    }
</pre>
    Of course, the construction could fail. <code >new</code> could throw an exception;
the stream constructors could throw exceptions; or the streams could not be
opened in which case an exception is thrown from the constructor's body. Using
a function try block helps. Note that if <code >d_in</code>'s initialization throws,
there's nothing to be worried about. The <code >Filter</code> object hasn't been
constructed, its destructor is not called and processing continues at the
point where the thrown exception is caught. But <code >Filter</code>'s destructor is
also not called when <code >d_out</code>'s initialization or the constructor's <code >if</code>
statement throws: no object, and hence no destructor is called. This may
result in memory leaks, as <code >delete</code> isn't called for <code >d_in</code> and/or
<code >d_out</code>. To prevent this, <code >d_in</code> and <code >d_out</code> must first be initialized
to 0 and only then the initialization can be performed:
        <pre>
    Filter::Filter(char const *in, char const *out)
    try
    :
        d_in(0),
        d_out(0)
    {
        d_in = new ifstream{ in };
        d_out = new ofstream{ out };

        if (!*d_in || !*d_out)
            throw string("Input and/or output stream not available");
    }
    catch (...)
    {
        delete d_out;
        delete d_in;
    }
</pre>
    This quickly gets complicated, though. If <code >Filter</code> harbors yet another
data member of a class whose constructor needs two streams then that data
cannot be constructed or it must itself be converted into a pointer:
        <pre>
    Filter::Filter(char const *in, char const *out)
    try
    :
        d_in(0),
        d_out(0)
        d_filterImp(*d_in, *d_out)    // won't work
    { ... }

    // instead:

    Filter::Filter(char const *in, char const *out)
    try
    :
        d_in(0),
        d_out(0),
        d_filterImp(0)
    {
        d_in = new ifstream(in);
        d_out = new ofstream(out);
        d_filterImp = new FilterImp(*d_in, *d_out);
        ...
    }
    catch (...)
    {
        delete d_filterImp;
        delete d_out;
        delete d_in;
    }
</pre>
    Although the latter alternative works, it quickly gets hairy. In
situations like these smart pointers should be used to prevent the
hairiness. By defining the stream pointers as (smart pointer) objects they
will, once constructed, properly be destroyed even if the rest of the
constructor's code throws exceptions. Using a <code >FilterImp</code> and two
<code >unique_ptr</code> data members <code >Filter</code>'s setup and its constructor becomes:
        <pre>
    class Filter
    {
        std::unique_ptr&lt;std::ifstream&gt; d_in;
        std::unique_ptr&lt;std::ofstream&gt; d_out;
        FilterImp d_filterImp;
        ...
    };

    Filter::Filter(char const *in, char const *out)
    try
    :
        d_in(new ifstream(in)),
        d_out(new ofstream(out)),
        d_filterImp(*d_in, *d_out)
    {
        if (!*d_in || !*d_out)
            throw string("Input and/or output stream not available");
    }
</pre>
    We're back at the original implementation but this time without having to
worry about wild pointers and memory leaks. If one of the member initializers
throws the destructors of previously constructed data members (which are now
objects) are always called.
<p>
As a <a name="an2160"></a>rule of thumb: when classes need to define pointer data members
they should define those pointer data members as smart pointers if there's any
chance that their constructors throw exceptions.
<p>
<a name="LAMBDA"></a><a name="l347"></a>
<h2 >18.7: Lambda expressions</h2>
<strong >C++</strong> supports <a name="an2161"></a> <em >lambda expressions</em>. As we'll see in
chapter <a href="cplusplus19.html#GENERIC">19</a> <em >generic algorithms</em> often accept arguments that can
either be function objects or plain functions. Examples are the <code >sort</code>
(cf. section <a href="cplusplus19.html#SORT">19.1.58</a>) and <code >find_if</code> (cf. section <a href="cplusplus19.html#FINDIF">19.1.17</a>) generic
algorithms. As a <a name="an2162"></a>rule of thumb: when a called function must remember its
state a function object is appropriate, otherwise a plain function can be
used.
<p>
Frequently the function or function object is not readily available, and it
must be defined in or near the location where it is used.  This is commonly
realized by defining a class or function in the anonymous namespace (say:
class or function A), passing an A to the code needing A. If that code is
itself a member function of the class B, then A's implementation might benefit
from having access to the members of class B.
<p>
This scheme usually results in a significant amount of code (defining the
class), or it results in complex code (to make available software elements
that aren't automatically accessible to A's code). It may also result in code
that is irrelevant at the current level of specification. Nested classes don't
solve these problems either. Moreover, nested classes can't be used in
templates.
<p>
Lamba expressions solve these problems.  A <a name="an2163"></a>lambda expression defines an
    <a name="an2164"></a>anonymous function object which may immediately be passed to functions
expecting function object arguments, as explained in the next few sections.
<p>
According to the C++ standard, lambda expressions <em >provide a concise way to
create simple function objects.</em> The emphasis here is on <em >simple</em>: a lambda
expression's size should be comparable to the size of inline-functions: just
one or maybe two statements. If you need more code, then encapsulate that code
in a separate function which is then called from inside the lambda
expression's compound statement, or consider designing a separate function
object. 
<p>
<a name="l348"></a>
<h3 >18.7.1: Lambda expressions: syntax</h3>
    A <a name="an2165"></a>lambda expression defines an
    <a name="an2166"></a>anonymous function object<a name="an2167"></a>, also called a
    <a name="an2168"></a><em >closure object</em>. When a lambda expression is evaluated it results in a
temporary object (the closure object). The type of a closure object is called
its <a name="an2169"></a><em >closure type</em>. 
<p>
Lambda expressions are used inside blocks, classes or namespaces (i.e.,
pretty much anywhere you like). Their implied closure type is defined in the
smallest block, class or namespace scope containing the lamba
expression. The closure object's visibility starts at its point of definition
and ends where its closure type ends.
<p>
The closure type defines a (<code >const</code>) public inline function call
operator. Here is an example of a lambda expression:
    <a name="an2170"></a>
    <a name="an2171"></a>
        <pre>
    []                      // the `lambda-introducer'
    (int x, int y)          // the `lambda-declarator'
    {                       // a normal compound-statement
        return x * y;
    }
</pre>
    The function call operator of the closure object created by this lambda
expression expects two <code >int</code> arguments and returns their product. It is an
inline <code >const</code> member of the closure type. To drop the <code >const</code> attribute,
the lamba expression should specify <a name="an2172"></a> <code >mutable</code>, as
follows:
        <pre>
    [](int x, int y) mutable
    ...
</pre>
    The lambda-declarator may be omitted, if no parameters are defined, but
when specifying <code >mutable</code> (or <code >constexpr</code>, see below) the
lambda-declarator must at least start with an empty set of parenthese. The
parameters in a lamba declarator cannot be given default arguments. 
<p>
Declarator specifiers can be <code >mutable</code>, or (starting with <a name="an2173"></a>C++17)
<code >constexpr</code>, or both. A <code >constexpr</code> lambda-expression is itself a
<code >constexpr</code>, which may be compile-time evaluated if its arguments qualify as
const-expressions. Moreover, if a lambda-expression is defined inside a
<code >constexpr</code> function then the lambda-expression itself must qualify as a
<code >constexpr</code>, and explicitly specifying the <code >constexpr</code> declarator
specifier is not required. The following function definitions, therefore, are
identical:
        <pre>
    // starting with C++17:
    int constexpr change10(int n)
    {
        return [n] 
               { 
                   return n &gt; 10 ? n - 10 : n + 10; 
               }();
    }
    
    // starting with C++17:
    int constexpr change10(int n)
    {
        return [n] () constexpr 
               { 
                   return n &gt; 10 ? n - 10 : n + 10; 
               }();
    }
</pre>
<p>
A closure object as defined by the previous lamda expression could be used e.g.,
in combination with the <code >accumulate</code> (cf. section <a href="cplusplus19.html#ACCU">19.1.1</a>) generic
algorithm to compute the product of a series of <code >int</code> values stored in a
vector:
        <pre>
    cout &lt;&lt; accumulate(vi.begin(), vi.end(), 1,
                [](int x, int y) { return x * y; });
</pre>
    The above lambda function uses the implicit return
        <a name="an2174"></a>
    type <code >decltype(x * y)</code>. An implicit return type can be used in these
cases:
    <ul>
    <li> the lambda expression does not contain a <code >return</code> statement (i.e.,
a void lambda expression);
    <li> the lambda expression contains a single <code >return</code> statement; or
    <li> the lambda expression contains multiple <code >return</code> statements
        returning values of identical types (e.g., all <code >int</code> values).
    </ul>
<p>
If there are multiple <code >return</code> statements returning values of different
types then the lambda expression's return type must specified be explicitly
using a
        <a name="an2175"></a><a name="an2176"></a>late-specified return type,
(cf. section <a href="cplusplus03.html#AUTO">3.3.6</a>):
        <pre>
    [](int x, int y) -&gt; int
    {
        return y &lt; 0 ?
                    x / static_cast&lt;double&gt;(y)
                :
                    z + x;
    }
</pre>
<p>
Variables that are visible at the location of a lambda expression can be
accessed by the lambda expression. How these variables are accessed depends on
the contents of the lambda-introducer (the area between the square brackets,
called the <a name="an2177"></a><em >lambda-capture</em>). The lambda-capture allows passing a
    <a name="an2178"></a>local context to lambda expressions. 
<p>
Visible global and static variables as well as local variables defined in
the lambda expression's compound statement itself can directly be accessed
and, when applicable, be modified. Example:
        <pre>
    int global;
    
    void fun()
    {
        []()  // [] may contain any specification
        { 
            int localVariable = 0;
            localVariable = ++global; 
        };
    }
</pre>
<p>
If a lambda expression is defined inside a function then the lambda
expression may access all the function's local variables which are visible at
the lambda expression's point of definition.
<p>
An initial <code >&amp;</code> character in the lambda-capture accesses these local
variables by reference. These variables can then be modified from within the
lambda expression.
<p>
An initial <code >=</code> character in the lambda-capture creates a local copy of
the referred-to local variables. Note that in this case the values of these
local copies can only be changed by the lambda expression if the lambda
expression is defined using the <code >mutable</code> keyword. E.g.,
        <pre>
    struct Class
    {
        void fun()
        {
            int var = 0;
            [=]() mutable
            {
                ++var;  // modifies the local
            }           // copy, not fun's var
        }
    }
</pre>
<p>
In the <a name="an2179"></a>C++17 standard, when defining lambda-expressions in (non-static)
member functions, the lambda-capture may also contain <a name="an2180"></a>
    <a name="an2181"></a> <code >*this</code>. Even when not specified, lambda
expressions implicitly capture their <code >this</code> pointers, and class members are
always accessed relative to <code >this</code>. But when members are called
asynchronously a problem may arise, because the asynchronously called lambda
function may refer to members of an object whose lifetime ended shortly after
asynchronously calling the lambda function. This potentially arising problem
is solved by using `<code >, *this</code>' in the lambda-capture if it starts with
<code >=</code>, e.g., <code >[=, *this]</code> (in addition, variables may still also be
captured, as usual). When specifying `<code >, *this</code>' the object to which
<code >this</code> refers is <em >explicitly captured</em>: if the object's scope ends it is
not immediately destroyed, but it is captured by the lambda-expression for the
duration of that expression. In order to use the `<code >, *this</code>' specification,
the object must directly be available. Consider the following example:
        <pre>
    struct s2 
    {
        double ohseven = .007;
        auto f() 
        {
            return [this] 
                    {
                        return [*this] 
                                {
                                    return ohseven; // OK
                                }
                    }();
        }
        auto g() 
        {
            return [] 
                    {
                      return [*this] 
                        { 
                            // error: *this not captured by outer
                            // lambda-expression 
                        }; 
                    }();
        }
    };
</pre>
<p>
Fine-tuning lambda-captures is also possible. With an initial <code >=</code>,
comma-separated <code >&amp;var</code> specifications indicate that the mentioned local
variables should be processed by reference, rather than as copies; with an
initial <code >&amp;</code>, comma separated <code >var</code> specifications indicate that local
copies should be used of the mentioned local variables. Again, these copies
have immutable values unless the lambda expression is provided with the
<code >mutable</code> keyword.
<p>
Another fine-tuning consists of using <code >this</code> in the lambda-capture: it also
allows the lambda-expression to access the surrounding class members.
Example:
        <pre>
    class Data
    {
        std::vector&lt;std::string&gt; d_names;
        public:
            void show() const
            {
                int count = 0;
                std::for_each(d_names.begin(), d_names.end(),
                    [this, &amp;count](std::string const &amp;name)
                    {
                        std::cout &lt;&lt; ++count &lt;&lt; ' ' &lt;&lt;
                            capitalized(name) &lt;&lt; '\n';
                    }
                );
            }
        private:
            std::string capitalized(std::string name);
    };
</pre>
<p>
Although lambda expressions are anonymous function objects, they <em >can</em> be
assigned to variables. Often, the variable is defined using the keyword
<code >auto</code>. E.g.,
        <pre>
    auto sqr = [](int x)
               {
                   return x * x;
               };
</pre>
    The lifetime of such lambda expressions is equal to the lifetime of the
variable receiving the lambda expression as its value. 
<p>
<a name="l349"></a>
<h3 >18.7.2: Using lambda expressions</h3>
        Now that the syntax of lambda expressions have been covered let's see how
they can be used in various situations.
<p>
First we consider named lambda expressions. Named lambda expressions nicely
fit in the niche of <a name="an2182"></a>
        <a name="an2183"></a>
    local functions: when a function needs to perform computations which are
at a conceptually lower level than the function's task itself, then it's
attractive to encapsulate these computations in a separate support function
and call the support function where needed.  Although support functions can be
defined in anonymous namespaces, that quickly becomes awkward when the
requiring function is a class member and the support function also must access
the class's members.
<p>
In that case a named lambda expression can be used: it can be defined inside
a requiring function, and it may be given full access to the surrounding
class. The name to which the lambda expression is assigned becomes the name of
a function which can be called from the surrounding function. Here is an
example, converting a numeric IP address to a dotted decimal string, which can
also be accessed directly from an <code >Dotted</code> object (all implementations
in-class to conserve space):
        <pre>
    class Dotted
    {
        std::string d_dotted;
        
        public:
            std::string const &amp;dotted() const
            {
                return d_dotted;
            }
            std::string const &amp;dotted(size_t ip)
            {
                auto octet = 
                    [](size_t idx, size_t numeric)
                    {
                        return to_string(numeric &gt;&gt; idx * 8 &amp; 0xff);
                    };

                d_dotted = 
                        octet(3, ip) + '.' + octet(2, ip) + '.' +
                        octet(1, ip) + '.' + octet(0, ip);

                return d_dotted;
            }
    };
</pre>
<p>
Next we consider the use of generic algorithms, like 
the <code >for_each</code> (cf. section <a href="cplusplus19.html#FOREACH">19.1.18</a>):
        <pre>
    void showSum(vector&lt;int&gt; const &amp;vi)
    {
        int total = 0;
        for_each(
            vi.begin(), vi.end(),
            [&amp;](int x)
            {
                total += x;
            }
        );
        std::cout &lt;&lt; total &lt;&lt; '\n';
    }
</pre>
    Here the variable <code >int total</code> is passed to the lambda expression by
reference and is directly accessed by the function. Its parameter list merely
defines an <code >int x</code>, which is initialized in sequence by each of the values
stored in <code >vi</code>. Once the generic algorithm has completed <code >showSum</code>'s
variable <code >total</code> has received a value that is equal to the sum of all the
vector's values. It has outlived the lambda expression and its value is
displayed.
<p>
But although generic algorithms are extremely useful, there may not always be
one that fits the task at hand. Furthermore, an algorithm like <code >for_each</code>
looks a bit unwieldy, now that the language offers range-based for-loops. So
let's try this, instead of the above implementation:
        <pre>
    void showSum(vector&lt;int&gt; const &amp;vi)
    {
        int total = 0;
        for (auto el: vi)
            [&amp;](int x)
            {
                total += x;
            };

        std::cout &lt;&lt; total &lt;&lt; '\n';
    }
</pre>
    But when <code >showSum</code> is now called, its <code >cout</code> statement consistently
reports 0. What's happening here?
<p>
When a generic algorithm is given a lambda function, its implementation
instantiates a reference to a function. The referenced function is thereupon
called from within the generic algorithm. But, in the above example the
range-based for-loop's nested statement merely represents the <em >defintion</em>
of a lamba function. Nothing is actually called, and hence <code >total</code> remains
equal to 0. 
<p>
Thus, to make the above example work we not only must <em >define</em> the
lambda expression, but we must also <em >call</em> the lambda function. We can do
this by  giving the lambda function a <em >name</em>, and then call the
lamba function by its given name:
        <pre>
    void showSum(vector&lt;int&gt; const &amp;vi)
    {
        int total = 0;
        for (auto el: vi)
        {
            auto lambda = [&amp;](int x)
                            {
                                total += x;
                            };

            lambda(el);
        }
        std::cout &lt;&lt; total &lt;&lt; '\n';
    }
</pre>
<p>
In fact, there is no need to give the lambda function a name: the <code >auto
lambda</code> definition represents the lambda function, which could also
directly be called. The syntax for doing this may look a
bit weird, but there's nothing wrong with it, and it allows us to drop the
compound statment, required in the last example, completely. Here goes:
        <pre>
    void showSum(vector&lt;int&gt; const &amp;vi)
    {
        int total = 0;
        for (auto el: vi)
            [&amp;](int x)
            {
                total += x;
            }(el);          // immediately append the 
                            // argument list to the lambda
                            // function's definition
        std::cout &lt;&lt; total &lt;&lt; '\n';
    }
</pre>
<p>
Lambda expressions can also be used to prevent spurious returns from
<code >condition_variable's wait</code> calls (cf. section <a href="cplusplus20.html#CONDEX">20.5.3</a>). 
<p>
The class <code >condition_variable</code> allows us to do so by offering <code >wait</code>
members expecting a lock <em >and</em> a predicate. The predicate checks the data's
state, and returns <code >true</code> if the data's state allows the data's
processing. Here is an alternative implementation of the <code >down</code> member shown
in section <a href="cplusplus20.html#CONDEX">20.5.3</a>, checking for the data's actual availability:
        <pre>
    void down()
    {
        unique_lock&lt;mutex&gt; lock(sem_mutex);
        condition.wait(lock, 
            [&amp;]()
            {
                return semaphore != 0
            }
        );
        --semaphore;
    }
</pre>
    The lambda expression ensures that <code >wait</code> only returns once
<code >semaphore</code> has been incremented.
<p>
Lambda expression are primarily used to obtain functors that are used in a
very localized section of a program. Since they are used inside an existing
function we should realize that once we use lambda functions multiple
aggregation levels are mixed. Normally a function implements a task which can
be described at its own aggregation level using just a few sentences. E.g.,
``the function <code >std::sort</code> sorts a data structure by comparing its elements
in a way that is appropriate to the context where <code >sort</code> is called''. By
using an existing comparison method the aggregation level is kept, and the
statement is clear by itself. E.g.,
        <pre>
    sort(data.begin(), data.end(), greater&lt;DataType&gt;());
</pre>
    If an existing comparison method is not available, a tailor-made function
object must be created. This could be realized using a lambda
expression. E.g.,
        <pre>
    sort(data.begin(), data.end(), 
        [&amp;](DataType const &amp;lhs, DataType const &amp;rhs)
        {
            return lhs.greater(rhs);
        }
    );
</pre>
    Looking at the latter example, we should realize that here two different
aggregation levels are mixed: at the top level the intent is to sort the
elements in <code >data</code>, but at the nested level (inside the lambda expression)
something completely different happens. Inside the lambda expression we define
how a the decision is made about which of the two objects is the greater. Code
exhibiting such mixed aggregation levels is hard to read, and should be
avoided. 
<p>
On the other hand: lambda expressions also simplify code because the overhead
of defining a tailor-made functor is avoided. The advice, therefore, is to use
lambda expressions sparingly. <em >When</em> they are used make sure that their
sizes remain small. As a <a name="an2184"></a>rule of thumb: lambda expressions should be
treated like in-line functions, and should merely consist of one, or maybe
occasionally two expressions.
<p>
<a name="l350"></a>
<h3 >18.7.3: Generic lambda expressions</h3>
    <em >Generic lambda expressions</em> <a name="an2185"></a> use <code >auto</code> to define their
parameters. When used, an appropriate lambda expression is created by looking
at the actual types of arguments. Since they are generic, they can be used
inside one function with different types of arguments. Here is an example
(assuming all required headers and namespace declaration):
    <pre>
     1: int main()
     2: {
     3:     auto lambda = [](auto lhs, auto rhs)
     4:                 {
     5:                     return lhs + rhs;
     6:                 };
     7:
     8:     vector&lt;int&gt; values {1, 2, 3, 4, 5};
     9:     vector&lt;string&gt; text {"a", "b", "c", "d", "e"};
    10:
    11:     cout &lt;&lt;
    12:         accumulate(values.begin(), values.end(), 0, lambda) &lt;&lt; '\n' &lt;&lt;
    13:         accumulate(text.begin(), text.end(), string(), lambda) &lt;&lt; '\n';
    14: }
</pre>
    The generic lambda function is defined in lines 3 through 6, and is
assigned to the <code >lambda</code> identifier. Then, <code >lambda</code> is passed to
<code >accumulate</code> in lines 12 and 13. In line 12 it is instantiated to add
<code >int</code> values, in line 13 to add <code >std::string</code> values: the same <code >lambda</code>
is instantiated to two completely different functors, which are only locally
available in <code >main</code>.
<p>
As a prelude to our coverage of templates (in particular chapter
<a href="cplusplus21.html#TEMPLATES">21</a>), a generic lambda expression is equivalent to a class
template. To illustrate: the above example of a generalized lambda function
could also be implemented using a class template like this:
        <pre>
    struct Lambda
    {
        template &lt;typename LHS, typename RHS&gt;
        auto operator()(LHS const &amp;lhs, RHS const &amp;rhs) const 
        {
            return lhs + rhs;
        }
    };
    auto lambda = Lambda{};
</pre>
    One of the consequences of this identity is that using <code >auto</code> in the
lambda expression's parameter list obeys the rules of template argument
deduction (cf. section <a href="cplusplus21.html#TEMPFUNARGS">21.4</a>), which are somewhat different from
the way <code >auto</code> normally operates.
<p>
Another extension is how lambda expressions capture outer scope variables. In
the C++11 standard capture was used either by value or by reference. A
consequence of this is that an outer scope variable of a type that only
supports move construction cannot be passed by value to a lambda
function. This restriction was dropped, allowing variables to be initialized
from arbitrary expressions. This not only allows move-initialization of
variables in the lambda introducer, but variables may here also be initialized
if they do not have a correspondingly named variable in the lambda
expression's outer scope. In this case initializer expressions can be used as
shown in this example:
        <pre>
    auto fun = [value = 1] 
               {
                   return value;
               };
</pre>
    This lambda function (of course) returns 1: the declared capture deduces
the type from the initializer expression as if <code >auto</code> had been used.
<p>
To use move-initialization <code >std::move</code> should be used. E.g.,
        <pre>
    std::unique_ptr&lt;int&gt; ptr(new int(10));
    auto fun = [value = std::move(ptr)] 
               {
                   return *value;
               };
</pre>
<p>
In generic lambda expressions the keyword <code >auto</code> indicates that the compiler
determines which types to use when the lambda function is instantiated. A
generic lamda expression therefore <em >is</em> a class template (cf. chapter
<a href="cplusplus22.html#TEMPCLASS">22</a>), even though it doesn't look like one. As an example, the
following lambda expression defines a generic class template, which can be
used as shown:
        <pre>
    char const *target = "hello";

     auto lambda =         
        [target](auto const &amp;str)
        {
            return str == target;
        };
        
        vector&lt;string&gt; vs{stringVectorFactory()};

        find_if(vs.begin(), vs.end(), lambda);
</pre>
    This works fine, but if the programmer defines <code >lambda</code> this way then
he/she should be prepared for complex error messages if the types of the
derefenced iterators and lambda's (silently assumed) <code >str</code> type don't match.
<p>
<a name="l351"></a>
<h2 >18.8: Regular Expressions</h2>
<strong >C++</strong> itself provides facilities for handling regular expressions. Regular
expressions were already available in <strong >C++</strong> via its <strong >C</strong> heritage (as <strong >C</strong>
has always offered functions like <a name="an2186"></a><code >regcomp</code> and <a name="an2187"></a><code >regexec</code>), but the
dedicated regular expression facilities have a richer interface than the
traditional <strong >C</strong> facilities, and can be used in code using templates.
<p>
Before using the specific <strong >C++</strong> implementations of regular expressions the
header file <a name="an2188"></a><code >&lt;regex&gt;</code> must be included.
<p>
Regular expressions are extensively documented elsewhere (e.g., <strong >regex</strong>(7),
<a name="an2189"></a>Friedl, J.E.F
  <a href="http://oreilly.com/catalog/">Mastering Regular Expressions</a>, O'Reilly).
    The reader is referred to these sources for a refresher on the topic of
regular expressions. In essence, regular expressions define a small
meta-language recognizing textual units (like `numbers', `identifiers', etc.).
They are extensively used in the context of <em >lexical scanners</em> (cf. section
<a href="cplusplus24.html#Flexcpp">24.7.1</a>) when defining the sequence of input characters associated with
<em >tokens</em>. But they are also intensively used in other situations.  Programs
like <strong >sed</strong>(1) and <strong >grep</strong>(1) use regular expressions to find pieces of text
in files having certain characteristics, and a program like <strong >perl</strong>(1) adds
some `sugar' to the regular expression language, simplifying the construction
of regular expressions. However, though extremely useful, it is also well
known that regular expressions tend to be very hard to read. Some even call
the regular expression language a <em >write-only language</em>: while specifying a
regular expression it's often clear why it's written in a particular way. But
the opposite, understanding what a regular expression is supposed to represent
if you lack the proper context, can be extremely difficult. That's why, from
the onset and as a <a name="an2190"></a><em >rule of thumb</em>, it is stressed that an appropriate
comment should be provided, with <em >each</em> regular expression, as to what it is
supposed to match.
<p>
In the upcoming sections first a short overview of the regular expression
language is provided, which is then followed by the facilities <strong >C++</strong> is
currently offering for using regular expressions. These facilities mainly
consist of classes helping you to specify regular expression, matching them to
text, and determining which parts of the text (if any) match (parts of) the
text being analyzed.
<p>
<a name="l352"></a>
<h3 >18.8.1: The regular expression mini language</h3>
    Regular expressions are expressions consisting of elements resembling those of
numeric expressions. Regular expressions consist of basic elements and
operators, having various priorities and associations. Like numeric
expressions, parentheses can be used to group elements together to form a
unit on which operators operate. For an extensive discussion the reader is
referred to, e.g., section 15.10 of the <a href="http://ecma-international.org/ecma-262/5.1/#sec-15.10">ecma-international.org</a> page, which
describes the characteristics of the regular expressions used by default by
<strong >C++</strong>'s <code >regex</code> classes.
<p>
<strong >C++</strong>'s default definition of regular expressions distinguishes the
following <em >atoms</em>:
    <ul>
    <li><code >x</code>: the character `x';
<p>
<li><code >.</code>: any character except for the newline character;
<p>
<li><code >[xyz]</code>: a character class; in this case, either an `x', a `y', or a `z'
        matches the regular expression.  See also the paragraph about
        character classes below;
<p>
<li><code >[abj-oZ]</code>: a character class containing a range of characters; this
        regular expression matches an `a', a `b', any letter from `j' through
        `o', or a `Z'.  See also the paragraph about character classes below;
<p>
<li><code >[^A-Z]</code>: a negated character class: this regular expression matches
        any character but those in the class beyond <code >^</code>.  In this case, any
        character <em >except for</em> an uppercase letter.  See also the paragraph
        about character classes below;
<p>
<li><code >[:predef:]</code>: a <em >predefined</em> set of characters. See below for an
        overview. When used, it is interpreted as an element in a character
        class. It is therefore always embedded in a set of square brackets
        defining the character class (e.g., <code >[[:alnum:]]</code>);
<p>
<li><code >\X</code>: if X is `a', `b', `f', `n', `r', `t', or `v', then the ANSI-C
        interpretation of `\x'. Otherwise, a literal `X' (used to escape
        operators such as <code >*</code>);
<p>
<li><code >(r)</code>: the regular expression <code >r</code>. It is used to override precedence
        (see below), but also to define <code >r</code> as a
       <a name="an2191"></a><em >marked sub-expression</em> whose matching characters may directly be
        retrieved from, e.g., a <code >std::smatch</code> object (cf. section
        <a href="cplusplus18.html#SMATCH">18.8.3</a>);
<p>
<li><code >(?:r)</code>: the regular expression <code >r</code>. It is used to override
        precedence (see below), but it is <em >not</em> regarded as a <em >marked
        sub-expression</em>;
    </ul>
<p>
In addition to these basic atoms, the following special atoms are available
(which can also be used in character classes):
    <ul>
    <li><code >\s</code>: a whitespace character;
<p>
<li><code >\S</code>: any character but a whitespace character;
<p>
<li><code >\d</code>: a decimal digit character;
<p>
<li><code >\D</code>: any character but a decimal digit character;
<p>
<li><code >\w</code>: an alphanumeric character or an underscore (<code >_</code>) character;
<p>
<li><code >\W</code>: any character but an alphanumeric character or an underscore
        (<code >_</code>) character.
    </ul>
<p>
Atoms may be concatenated. If <code >r</code> and <code >s</code> are atoms then the regular
expression <code >rs</code> matches a target text if the target text matches <code >r</code>
<em >and</em> <code >s</code>, in that order (without any intermediate characters 
inside the target text). E.g., the regular expression <code >[ab][cd]</code> matches the
target text <code >ac</code>, but not the target text <code >a:c</code>. 
<p>
Atoms may be combined using operators. Operators bind to the preceding
atom. If an operator should operate on multiple atoms the atoms must be
surrounded by parentheses (see the last element in the previous itemization). 
To use an operator character as an atom it can be escaped. Eg., <code >*</code>
represents an operator, <code >\*</code> the atom character star. Note that 
character classes do not recognize escape sequences: <code >[\*]</code> represents a
character class consisting of two characters: a backslash and a star.
<p>
The following operators are supported (<code >r</code> and <code >s</code> represent regular
expression atoms):
    <ul>
    <li><code >r*</code>: zero or more <code >r</code>s;
<p>
<li><code >r+</code>: one or more <code >r</code>s;
<p>
<li><code >r?</code>: zero or one <code >r</code>s (that is, an optional r);
<p>
<li><code >r{m, n}</code>: where <code >1 &lt;= m &lt;= n</code>: matches `r' at least m, but at most n
        times;
<p>
<li><code >r{m,}</code>: where <code >1 &lt;= m</code>: matches `r' at least m times;
<p>
<li><code >r{m}</code>: where <code >1 &lt;= m</code>: matches `r' exactly m times;
<p>
<li><code >r|s</code>: matches either an `r' or an `s'. This operator has a lower
        priority than any of the multiplication operators;
<p>
<li><code >^r</code> : <code >^</code> is a pseudo operator. This expression matches `r', if
        appearing at the beginning of the target text. If the <code >^</code>-character
        is not the first character of a regular expression it is interpreted
        as a literal <code >^</code>-character;
<p>
<li><code >r$</code>: <code >$</code> is a pseudo operator. This expression matches `r', if
        appearing at the end of the target text. If the <code >$</code>-character is not
        the last character of a regular expression it is interpreted as a
        literal <code >$</code>-character;
    </ul>
<p>
When a regular expression contains marked sub-expressions and multipliers, and
the marked sub-expressions are multiply matched, then the target's final
sub-string matching the marked sub-expression is reported as the text matching
the marked sub-expression. E.g, when using <code >regex_search</code> (cf. section
<a href="cplusplus18.html#REGSRCH">18.8.4.3</a>), marked sub-expression (<code >((a|b)+\s?)</code>), and target text <code >a a
b</code>, then <code >a a b</code> is the fully matched text, while <code >b</code> is reported as the
sub-string matching the first and second marked sub-expressions.
<p>
<a name="l353"></a>
<h4>18.8.1.1: Character classes</h4>
        Inside a character class all regular expression operators lose their special
meanings, except for the special atoms <code >\s, \S, \d, \D, \w,</code> and <code >\W</code>; the
character range operator <code >-</code>; the end of character class operator <code >]</code>;
and, at the beginning of the character class, <code >^</code>. Except in combination
with the special atoms the escape character is interpreted as a literal
backslash character (to define a character class containing a backslash and a
<code >d</code> simply use <code >[d\]</code>).
<p>
To add a closing bracket to a character class use <code >[]</code> immediately following
the initial open-bracket, or start with <code >[^]</code> for a negated character class
not containing the closing bracket.  Minus characters are used to define
character ranges (e.g., <code >[a-d]</code>, defining <code >[abcd]</code>) (be advised that the
actual range may depend on the locale being used). To add a literal minus
character to a character class put it at the very beginning (<code >[-</code>, or
<code >[^-</code>) or at the very end (<code >-]</code>) of a character class.
<p>
Once a character class has started, all subsequent characters are added to the
class's set of characters, until the final closing bracket (<code >]</code>) has been
reached.
<p>
In addition to characters and ranges of characters, character classes may also
contain <em >predefined sets of character</em>. They are:
    <pre>
         [:alnum:] [:alpha:] [:blank:]
         [:cntrl:] [:digit:] [:graph:]
         [:lower:] [:print:] [:punct:]
         [:space:] [:upper:] [:xdigit:]
</pre>
    These predefined sets designate sets of characters equivalent to the
corresponding standard <strong >C</strong> <code >isXXX</code> function. For example, <code >[:alnum:]</code>
defines all  characters for which <strong >isalnum</strong>(3) returns true.
<p>
<a name="l354"></a>
<h3 >18.8.2: Defining regular expressions: std::regex</h3>
    Before using the <code >(w)regex</code> class presented in this section the
<a name="an2192"></a><code >&lt;regex&gt;</code> header file must be included.
<p>
The types <code >std::regex</code><a name="an2193"></a> and <code >std::wregex</code><a name="an2194"></a> define regular
expression patterns. They define, respectively the types
<code >basic_regex&lt;char&gt;</code><a name="an2195"></a> and <code >basic_regex&lt;wchar_t&gt;</code>
types. Below, the class <code >regex</code> is used, but in the examples <code >wregex</code>
could also have been used.
<p>
Regular expression facilities were, to a large extent, implemented through
templates, using, e.g., the <code >basic_string&lt;char&gt;</code> type (which is equal to
<code >std::string</code>). Likewise, generic types like <em >OutputIter</em> (output
iterator) and <em >BidirConstIter</em> (bidirectional const iterator) are used with
several functions. Such functions are function templates. Function templates
determine the actual types from the arguments that are provided at
<em >call-time</em>.
<p>
These are the steps that are commonly taken when using regular expressions:
    <ul>
    <li> First, a regular expression is defined. This involves
        defining or modifying a <code >regex</code> object.
    <li> Then the regular expression is provided with a <em >target text</em>, which
        may result in sections of the target text matching the regular
        expression. 
    <li> The sections of the target text matching (or not matching) the
        regular expression are retrieved to be processed elsewhere, or:
    <li> The sections of the target text matching (or not matching) the
        regular expression are directly modified by existing regular
        expression facilities, after which the modified target text may be
        processed elsewhere.
    </ul>
<p>
The way <code >regex</code> objects handle regular expressions can be configured using a
<code >bit_or</code> combined set of <code >std::regex_constants</code><a name="an2196"></a> values,
defining a <code >regex::flag_type</code><a name="an2197"></a> value. These
<code >regex_constants</code> are:
    <ul>
    <li><code >std::regex_constants::awk</code>:<blockquote ><strong >awk</strong>(1)'s (POSIX) regular expression grammar is used to specify
        regular exressions (e.g., regular expressions are delimited by
        <code >/</code>-characters, like <code >/\w+/</code>; for further details and for details
        of other regular expression grammars the reader should consult the
        man-pages of the respective programs);</blockquote>
<p>
<li><code >std::regex_constants::basic</code>:<blockquote >the basic POSIX regular expression grammar is used to specify regular
        expressions;</blockquote> 
<p>
<li><code >std::regex_constants::collate</code>:<blockquote >the character range operator (<code >-</code>) used in character classes defines
        a locale sensitive range (e.g., <code >[a-k]</code>);</blockquote>
<p>
<li><a name="an2198"></a><code >std::regex_constants::ECMAScript</code>:<blockquote >this <code >flag_type</code> is used by default by <code >regex</code>
        constructors. The regular expression uses the Modified <a name="an2199"></a>ECMAScript
        regular expression grammar;</blockquote>
<p>
<li><code >std::regex_constants::egrep</code>:<blockquote ><strong >egrep</strong>(1)'s (POSIX) regular expression grammar is used to specify
        regular expressions. This is the same grammar as used by
        <code >regex_constants::extended</code>, with the addition of the newline
        character (<code >'\n'</code>) as an alternative for the <code >'|'</code>-operator;</blockquote>
<p>
<li><code >std::regex_constants::extended</code>:<blockquote >the extended POSIX regular expression grammar is used to specify
        regular expressions;</blockquote>
<p>
<li><code >std::regex_constants::grep</code>:<blockquote ><strong >grep</strong>(1)'s (POSIX) regular expression grammar is used to specify
        regular expressions. This is the same grammar as used by
        <code >regex_constants::basic</code>, with the addition of the newline character
        (<code >'\n'</code>) as an alternative for the <code >'|'</code>-operator;</blockquote>
<p>
<li><a name="an2200"></a><code >std::regex_constants::icase</code>:<blockquote >letter casing in the target string is ignored. E.g., the regular
        expression <code >A</code> matches <code >a</code> and <code >A</code>;</blockquote>  
<p>
<li><code >std::regex_constants::nosubs</code>:<blockquote >When performing matches, all sub-expressions (<code >(expr)</code>) are
        treated as non-marked (<code >?:expr</code>);</blockquote>
<p>
<li><code >std::regex_constants::optimize</code>:<blockquote >optimizes the speed of matching regular expressions, at the cost of
        slowing down the construction of the regular expression somewhat. If
        the same regular expression object is frequently used then this flag
        may substantially improve the speed of matching target texts;</blockquote>
    </ul>
<p>
<strong >Constructors</strong>
<p>
The default, move and copy constructors are available. Actually, the
default constructor defines one parameter of type <code >regex::flag_type</code>, for
which the value <code >regex_constants::ECMAScript</code> is used by default.
    <ul>
    <li><code >regex()</code>:<blockquote >the default constructor defines a <code >regex</code> object not containing a
        regular expression;</blockquote>
<p>
<li><code >explicit regex(char const *pattern)</code>:<blockquote >defines a <code >regex</code> object containing the regular expression found at
        <code >pattern</code>;</blockquote>
<p>
<li><code >regex(char const *pattern, std::size_t count)</code>:<blockquote >defines a <code >regex</code> object containing the regular expression found at
        the first <code >count</code> characters of <code >pattern</code>;</blockquote>
<p>
<li><code >explicit regex(std::string const &amp;pattern)</code>:<blockquote >defines a <code >regex</code> object containing the regular expression found at
        <code >pattern</code>. This constructor is defined as a member template,
        accepting a <code >basic_string</code>-type argument which may also use
        non-standard character traits and allocators;</blockquote>
<p>
<li><code >regex(ForwardIterator first, ForwardIterator last)</code>:<blockquote >defines a <code >regex</code> object containing the regular expression found at
        the (forward) iterator range <code >[first, last)</code>. This constructor is
        defined as a member template, accepting any forward iterator type
        (e.g., plain <code >char</code> pointers) which can be used to define the
        regular expression's pattern;</blockquote>
<p>
<li><code >regex(std::initializer_list&lt;Char&gt; init)</code>:<blockquote >defines a <code >regex</code> object containing the regular expression from the
        characters in the initializer list <code >init</code>.</blockquote>
<p>
Here are some examples:
        <pre>
    std::regex re("\\w+");      // matches a sequence of alpha-numeric
                                // and/or underscore characters 

    std::regex re{'\\', 'w', '+'} ;     // idem

    std::regex re(R"(\w+xxx")", 3);     // idem
</pre>
    </ul>
<p>
<strong >Member functions</strong>
<p>
<ul>
    <li><code >regex &amp;operator=(RHS)</code>:<blockquote >The copy and move assignment operators are available. Otherwise, RHS
        may be:
        <ul>
        <li> an NTBS (of type <code >char const *</code>);
        <li> a <code >std::string const &amp;</code> (or any compatible
            <code >std::basic_string</code>); 
        <li> a <code >std::initializer_list&lt;char&gt;</code>;
        </ul></blockquote>
<p>
<li><code >regex &amp;assign(RHS)</code>:<blockquote >This member accepts the same arguments as <code >regex's</code> constructors,
        including the (optional) <code >regex_constants</code> values;</blockquote>
<p>
<li><code >regex::flag_type flag() const</code>:<blockquote >Returns the <code >regex_constants</code> flags that are active for the current
        <code >regex</code> object. E.g.,
            <pre>
    int main()
    {
        regex re;

        regex::flag_type flags = re.flags();
    
        cout &lt;&lt;                                 // displays: 16 0 0
            (re.flags() &amp; regex_constants::ECMAScript) &lt;&lt; ' '  &lt;&lt;
            (re.flags() &amp; regex_constants::icase) &lt;&lt; ' '  &lt;&lt;
            (re.flags() &amp; regex_constants::awk) &lt;&lt; ' '  &lt;&lt; '\n';
    }
</pre>
        </blockquote>
    Note that when a combination of <code >flag_type</code> values is specified at
        construction-time that only those flags that were specified are
        set. E.g., when <code >re(regex_constants::icase)</code> would have been
        specified the <code >cout</code> statement would have shown <code >0 1
        0</code>. It's also possible to specify conflicting combinations of
        flag-values like <code >regex_constants::awk | regex_constants::grep</code>. The
        construction of such <code >regex</code> objects succeeds, but should be
        avoided.
<p>
<li><code >locale_type get_loc() const</code>:<blockquote >Returns the locale that is associated with the current <code >regex</code>
        object;</blockquote>
<p>
<li><code >locale_type imbue(locale_type locale)</code>:<blockquote >Replaces the <code >regex</code> object's current locale setting with
        <code >locale</code>, returning the replaced locale;</blockquote>
<p>
<li><code >unsigned mark_count() const</code>:<blockquote >The number of <em >marked sub-expressions</em><a name="an2201"></a> in
        the <code >regex</code> objext is returned. E.g., 
            <pre>
    int main()
    {
        regex re("(\\w+)([[:alpha:]]+)"); 
        cout &lt;&lt; re.mark_count() &lt;&lt; '\n';        // displays: 2
    }
</pre>
        </blockquote>
<p>
<li><code >void swap(regex &amp;other) noexcept</code>:<blockquote >Swaps the current <code >regex</code> object with <code >other</code>. Also available as a
        free function: <code >void swap(regex &amp;lhs, regex &amp;rhs)</code>, swapping <code >lhs</code>
        and <code >rhs</code>.</blockquote>
    </ul>
<p>
<a name="SMATCH"></a><a name="l355"></a>
<h3 >18.8.3: Retrieving matches: std::match_results</h3>
    Once a <code >regex</code> object is available, it can be used to match some target text
against the regular expression. To match a target text against a regular
expression the following functions, described in the next section
(<a href="cplusplus18.html#REGALG">18.8.4</a>), are available:
    <ul>
    <li><code >regex_match</code> merely matches a target text against a regular
expression, informing the caller whether a match was found or not;
    <li><code >regex_search</code> also  matches a target text against a regular
expression, but allows retrieval of matches of marked sub-expressions (i.e.,
parenthesized regular expressions);
    <li><code >regex_replace</code> matches a target text against a regular
expression, and replaces pieces of matched sections of the target text by
another text.
    </ul>
<p>
These functions must be provided with a target text and a <code >regex</code> object
(which is not modified by these functions). Usually another argument, a
<code >std::match_results</code><a name="an2202"></a> object is also passed to these
functions, to contain the results of the regular expression matching
procedure.
<p>
Before using the <code >match_results</code> class the <a name="an2203"></a><code >&lt;regex&gt;</code> header file must be
included.
<p>
Examples of using <code >match_results</code> objects are provided in section
<a href="cplusplus18.html#REGALG">18.8.4</a>. This and the next section are primarily for referential
purposes. 
<p>
Various specializations of the class <code >match_results</code> exist. The
specialization that is used should match the specializations of the used
<code >regex</code> class. E.g., if the regular expression was specified as a <code >char
const *</code> the <code >match_results</code> specialization should also operate on <code >char
const *</code> values. The various specializations of <code >match_results</code> have been
given names that can easily be remembered, so selecting the appropriate
specialization is simple.
<p>
The class <code >match_results</code> has the following specializations:
    <ul>
    <li><code >cmatch</code>:<blockquote >defines <code >match_results&lt;char const *&gt;</code>, using a <code >char const *</code> type
        of iterator. It should be used with a <code >regex(char const *)</code> regular
        expression specification;</blockquote>
    <li><code >wcmatch</code>:<blockquote >defines <code >match_results&lt;wchar_ const *&gt;</code>, using a <code >wchar_t const *</code>
        type of iterator. It should be used with a <code >regex(wchar_t const *)</code>
        regular expression specification;</blockquote>
    <li><code >smatch</code>:<blockquote >defines <code >match_results&lt;std::string::const_iterator&gt;</code>, using a
        <code >std::string::const_iterator</code> type of iterator. It should be used
        with a <code >regex(std::string const &amp;)</code> regular expression
        specification;</blockquote>
    <li><code >wsmatch</code>:<blockquote >defines <code >match_results&lt;std::wstring::const_iterator&gt;</code>, using a
        <code >std::wstring::const_iterator</code> type of iterator. It should be used
        with a <code >regex(wstring const &amp;)</code> regular expression specification.</blockquote>
    </ul>
<p>
<strong >Constructors</strong>
<p>
The default, copy, and move constructors are available. The default
constructor defines an <code >Allocator const &amp;</code> parameter, which by default is
initialized to the default allocator. Normally, objects of the class
<code >match_results</code> receive their match-related information by passing them to
the above-mentioned functions, like <code >regex_match</code>. When returning from these
functions members of the class <code >match_results</code> can be used to retrieve
specific results of the matching process.
<p>
<strong >Member functions</strong>
<p>
<ul>
    <li><code >match_results &amp;operator=</code>:<blockquote >The copy and move assignment operators are available;</blockquote>
<p>
<li><code >std::string const &amp;operator[](size_t idx) const</code>:<blockquote >Returns a (const) reference to sub-match <code >idx</code>. With <code >idx</code> value 0
        a reference to the full match is returned. If <code >idx &gt;= size()</code> (see
        below) a reference to an empty sub-range of the target string is
        returned. The behavior of this member is undefined if the member
        <code >ready()</code> (see below) returns <code >false</code>;</blockquote>
<p>
<li><code >Iterator begin() const</code>:<blockquote >Returns an iterator to the first sub-match. <code >Iterator</code> is a
        const-iterator for <code >const match_results</code> objects;</blockquote>
<p>
<li><code >Iterator cegin() const</code>:<blockquote >Returns an iterator to the first sub-match. <code >Iterator</code> is a
        const-iterator;</blockquote>
<p>
<li><code >Iterator cend() const</code>:<blockquote >Returns an iterator pointing beyond the last sub-match. <code >Iterator</code>
        is a const-iterator;</blockquote>
<p>
<li><code >Iterator end() const</code>:<blockquote >Returns an iterator pointing beyond the last sub-match. <code >Iterator</code>
        is a const-iterator for <code >const match_results</code> objects;</blockquote>
<p>
<li><code >ReturnType format(Parameters) const</code>:<blockquote >As this member requires a fairly extensive description, it would break
        the flow of the current overview. This member is used in combination
        with the <code >regex_replace</code> function, and it is therefore covered in
        detail in that function's section (<a href="cplusplus18.html#REGREP">18.8.4.5</a>);</blockquote>
<p>
<li><code >allocator_type get_allocator() const</code>:<blockquote >Returns the object's allocator;</blockquote>
<p>
<li><code >bool empty() const</code>:<blockquote >Returns <code >true</code> if the <code >match_results</code> object contains
        no matches (which is also returned after merely using the default
        constructor). Otherwise it returns <code >false</code>;</blockquote>
<p>
<li><code >int length(size_t idx = 0) const</code>:<blockquote >Returns the length of sub-match <code >idx</code>. By default the length of
        the full match is returned. If <code >idx &gt;= size()</code> (see below) 0 is
        returned;</blockquote>
<p>
<li><code >size_type max_size() const</code>:<blockquote >Returns the maximum number of sub-matches that can be contained in a
        <code >match_results</code> object. This is an implementation dependent constant
        value;</blockquote>
<p>
<li><code >int position(size_t idx = 0) const</code>:<blockquote >Returns the offset in the target text of the first character of
        sub-match <code >idx</code>. By default the position of the first character of
        the full match is returned. If <code >idx &gt;= size()</code> (see below) -1 is
        returned;</blockquote>
<p>
<li><code >std::string const &amp;prefix() const</code>:<blockquote >Returns a (const) reference to a sub-string of the target text that
        ends at the first character of the full match;</blockquote>
<p>
<li><code >bool ready() const</code>:<blockquote >No match results are available from a default constructed
        <code >match_results</code> object. It receives its match results from one of
        the mentioned matching functions. Returns <code >true</code> once match results
        are available, and <code >false</code> otherwise.</blockquote>
<p>
<li><code >size_type size() const</code>:<blockquote >Returns the number of sub-matches. E.g., with a regular expression
        <code >(abc)|(def)</code> and target <code >defcon</code> three submatches are reported:
        the total match (def); the empty text for <code >(abc)</code>; and <code >def</code> for
        the <code >(def)</code> marked sub-expression. 
<p>
Note: when multipliers are used only the last match is counted and
        reported. E.g., for the pattern <code >(a|b)+</code> and target <code >aaab</code> <em >two</em>
        sub-matches are reported: the total match <code >aaab</code>, and the last match
        (<code >b</code>);</blockquote>
<p>
<li><code >std::string str(size_t idx = 0) const</code>:<blockquote >Returns the characters defining sub-match <code >idx</code>. By default this is
        the full match. If <code >idx &gt;= size()</code> (see below) an empty string
        returned;</blockquote>
<p>
<li><code >std::string const &amp;suffix() const</code>:<blockquote >Returns a (const) reference to a sub-string of the target text that
        starts beyond the last character of the full match;</blockquote>
<p>
<li><code >void swap(match_results &amp;other) noexcept</code>:<blockquote >Swaps the current <code >match_results</code> object with <code >other</code>. Also
        available as a free function: <code >void swap(match_results &amp;lhs,
        match_results &amp;rhs)</code>, swapping <code >lhs</code> and <code >rhs</code>.</blockquote>
    </ul>
<p>
<a name="REGALG"></a><a name="l356"></a>
<h3 >18.8.4: Regular expression matching functions</h3>
    Before using the functions presented in this section the <a name="an2204"></a><code >&lt;regex&gt;</code> header
file must be included.
<p>
There are three major families of functions that can be used to match a target
text against a regular expression. Each of these functions, as well as the
<code >match_results::format</code> member, has a final
<code >std::regex_constants::match_flag_type</code> parameter (see the next section),
which is given the default value <code >regex_constants::match_default</code> which can
be used to fine-tune the way the regular expression and the matching process
is being used. This
final parameter is not explicitly mentioned with the regular expression
matching functions or with the <code >format</code> member. The three families of
functions are:
    <ul>
    <li><a name="an2205"></a><code >bool std::regex_match(Parameters)</code>:<blockquote >This family of functions is used to match a regular expression against
        a target text. Only if the regular expression matches the full target
        text <code >true</code> is returned; otherwise <code >false</code> is returned. Refer to
        section <a href="cplusplus18.html#REGMATCH">18.8.4.2</a> for an overview of the available overloaded
        <code >regex_match</code> functions;</blockquote>
<p>
<li><a name="an2206"></a><code >bool std::regex_search(Parameters)</code>:<blockquote >This family of functions is also used to match a regular expression
        against a target text. This function returns true once the regular
        expression matches a sub-string of the target text; otherwise
        <code >false</code> is returned. See below for an overview of the available
        overloaded <code >regex_search</code> functions;</blockquote>
<p>
<li><a name="an2207"></a><code >ReturnType std::regex_replace(Parameters)</code>:<blockquote >This family of functions is used to produce modified texts, using the
        characters of a target string, a <code >regex</code> object and a format
        string. This member closely resembles the functionality of the 
        <code >match_results::format</code> member discussed in section <a href="cplusplus18.html#FORMAT">18.8.4.4</a>.</blockquote>
    </ul>
    The <code >match_results::format</code> member can be used after <code >regex_replace</code>
and is discussed after covering <code >regex_replace</code> (section <a href="cplusplus18.html#FORMAT">18.8.4.4</a>).
<p>
<a name="l357"></a>
<h4>18.8.4.1: The std::regex_constants::match_flag_type flags</h4>
        All overloaded <code >format</code> members and all regular expression matching
functions accept a final
<code >regex_constants::match_flag_type</code><a name="an2208"></a> argument, which is a
bit-masked type, for which the <code >bit_or</code> operator can be used. All <code >format</code>
members by default specify the argument <code >match_default</code>.
<p>
The <code >match_flag_type</code> enumeration defines the following values (below,
`<code >[first, last)</code>' refers to the character sequence being matched).
<p>
<ul>
<li><a name="an2209"></a><code >format_default</code> (not a bit-mask value, but a default value which is
	equal to 0). With just this specification ECMAScript rules are used to
	construct strings in <code >std::regex_replace</code>;
<p>
<li><a name="an2210"></a><code >format_first_only</code>: <code >std::regex_replace</code> only replaces the first
	match;
<p>
<li><a name="an2211"></a><code >format_no_copy</code>: non-matching strings are not passed to the output
	by <code >std::regex_replace</code>;
<p>
<li><a name="an2212"></a><code >format_sed</code>:  POSIX <strong >sed</strong>(1) rules are used to construct strings in
	<code >std::regex_replace</code>;
<p>
<li><a name="an2213"></a><code >match_any</code>: if multiple matches are possible, then any match is an
	acceptable result;
<p>
<li><a name="an2214"></a><code >match_continuous</code>: sub-sequences are only matching if they start at
	<code >first</code>; 
<p>
<li><a name="an2215"></a><code >match_not_bol</code>: the first character in <code >[first, last)</code> is treated
	as an ordinary character:  <code >^</code> does not match <code >[first, first)</code>;
<p>
<li><a name="an2216"></a><code >match_not_bow</code>: <code >\b</code> does not match <code >[first, first)</code>;
<p>
<li><a name="an2217"></a><code >match_default</code> (not a bit-mask value, but equal to 0): the default
    value of the final argument that's passed to the regular expression
    matching functions and <code >match_results::format</code> member. ECMAScript
	rules are used to construct strings in <code >std::regex_replace</code>;
<p>
<li><a name="an2218"></a><code >match_not_eol</code>: the last character in <code >[first, last)</code> is treated
	as an ordinary character: <code >$</code> does not match <code >[last,last)</code>;
<p>
<li><a name="an2219"></a><code >match_not_eow</code>: <code >\b</code> does  not match <code >[last, last)</code>;
<p>
<li><a name="an2220"></a><code >match_not_null</code>: empty sequences are not considered matches;
<p>
<li><a name="an2221"></a><code >match_prev_avail</code>: <code >--first</code> refers to a valid character
	position. When specified <code >match_not_bol</code> and <code >match_not_bow</code> are
	ignored;
</ul>
<p>
<a name="REGMATCH"></a><a name="l358"></a>
<h4>18.8.4.2: Matching full texts: std::regex_match</h4>
        The regular expression matching function <code >std::regex_match</code><a name="an2222"></a>
returns <code >true</code> if the regular expression defined in its provided
<code >regex</code> argument <em >fully</em> matches the provided target text. This means that
<code >match_results::prefix</code> and <code >match_results::suffix</code> must return empty
strings. But defining sub-expressions is OK.
<p>
The following overloaded variants of this function are available:
    <ul>
    <li><code >bool regex_match(BidirConstIter first, BidirConstIter last,
                  std::match_results &amp;results,
                  std::regex const &amp;re)</code>:<blockquote ><code >BidirConstIter</code> is a bidirectional const iterator. The range
        <code >[first, last)</code> defines the target text. The match results are
        returned in <code >results</code>. The types of the iterators must match the
        type of the <code >match_results</code> that's used. E.g., a <code >cmatch</code> should
        be used if the iterators are of <code >char const *</code> types, and a
        <code >smatch</code> should be used if the iterators are of
        <code >string::const_iterator</code> types. Similar correspondence requirements
        hold true for the other overloaded versions of this function;</blockquote>
<p>
<li><code >bool regex_match(BidirConstIter first, BidirConstIter last,
        std::regex const &amp;re)</code>:<blockquote >this function behaves like the previous function, but does not
        return the results of the matching process in a <code >match_results</code>
        object;</blockquote>
<p>
<li><code >bool regex_match(char const *target,
                  std::match_results &amp;results, std::regex const &amp;re)</code>:<blockquote >this function behaves like the first overloaded variant, using
        the characters in <code >target</code> as its target text;</blockquote>
<p>
<li><code >bool regex_match(char const *str, std::regex const &amp;re)</code>:<blockquote >this function behaves like the previous function but does not return
        the match results;</blockquote>
<p>
<li><code >bool regex_match(std::string const &amp;target,
                  std::match_results &amp;results, std::regex const &amp;re)</code>:<blockquote >this function behaves like the first overloaded variant, using
        the characters in <code >target</code> as its target text;</blockquote>
<p>
<li><code >bool regex_match(std::string const &amp;str, std::regex const &amp;re)</code>:<blockquote >this function behaves like the previous function but does not return
        the match results;</blockquote>
<p>
<li><code >bool regex_match(std::string const &amp;&amp;, std::match_results &amp;, 
                         std::regex &amp;) = delete</code>
       (the <code >regex_match</code> function does not accept temporary <code >string</code>
        objects as target strings, as this would result in invalid string
        iterators in the <code >match_result</code> argument.)
    </ul>
    Here is a small example: the regular expression matches the matched text
(provided by <code >argv[1]</code>) if it starts with 5 digits and then 
merely contains  letters (<code >[[:alpha:]]</code>). The digits can be retrieved as
sub-expression 1:
        <pre>
    #include &lt;iostream&gt;
    #include &lt;regex&gt;
    
    using namespace std;
    
    int main(int argc, char const **argv)
    {
        regex re("(\\d{5})[[:alpha:]]+"); 

        cmatch results;

        if (not regex_match(argv[1], results, re))
            cout &lt;&lt; "No match\n";
        else
            cout &lt;&lt; "size: " &lt;&lt; results.size() &lt;&lt; ": " &lt;&lt; 
                    results.str(1) &lt;&lt; " -- " &lt;&lt; results.str() &lt;&lt; '\n';
    }
</pre>
<p>
<a name="REGSRCH"></a><a name="l359"></a>
<h4>18.8.4.3: Partially matching text: std::regex_search</h4>
        Different from <code >regex_match</code> the regular expression matching function
<code >std::regex_search</code><a name="an2223"></a> returns <code >true</code> if the regular
expression defined in its <code >regex</code> argument partially matches the target
text.
<p>
The following overloaded variants of this function are available:
    <ul>
    <li><code >bool regex_search(BidirConstIter first, BidirConstIter last,
                  std::match_results &amp;results,
                  std::regex const &amp;re)</code>:<blockquote ><code >BidirConstIter</code> is a bidirectional const iterator. The range 
        <code >[first, last)</code> defines the target text. The match results are
        returned in <code >results</code>. The types of the iterators must match the
        type of the <code >match_results</code> that's used. E.g., a <code >cmatch</code> should
        be used if the iterators are of <code >char const *</code> types, and a
        <code >smatch</code> should be used if the iterators are of
        <code >string::const_iterator</code> types. Similar correspondence requirements
        hold true for the other overloaded versions of this function;</blockquote>
<p>
<li><code >bool regex_search(BidirConstIter first, BidirConstIter last,
        std::regex const &amp;re)</code>:<blockquote >this function behaves like the previous function, but does not
        return the results of the matching process in a <code >match_results</code>
        object;</blockquote>
<p>
<li><code >bool regex_search(char const *target,
                  std::match_results &amp;results, std::regex const &amp;re)</code>:<blockquote >this function behaves like the first overloaded variant, using
        the characters in <code >target</code> as its target text;</blockquote>
<p>
<li><code >bool regex_search(char const *str, std::regex const &amp;re)</code>:<blockquote >this function behaves like the previous function but does not return
        the match results;</blockquote>
<p>
<li><code >bool regex_search(std::string const &amp;target,
                  std::match_results &amp;results, std::regex const &amp;re)</code>:<blockquote >this function behaves like the first overloaded variant, using
        the characters in <code >target</code> as its target text;</blockquote>
<p>
<li><code >bool regex_search(std::string const &amp;str, std::regex const &amp;re)</code>:<blockquote >this function behaves like the previous function but does not return
        the match results;</blockquote>
<p>
<li><code >bool regex_search(std::string const &amp;&amp;, std::match_results &amp;, 
                         std::regex &amp;) = delete</code>:<blockquote >the <code >regex_search</code> function does not accept temporary <code >string</code>
        objects as target strings, as this would result in invalid string
        iterators in the <code >match_result</code> argument.</blockquote>
    </ul>
    The following example illustrates how <code >regex_search</code> could be used:
    <pre>
     1: #include &lt;iostream&gt;
     2: #include &lt;string&gt;
     3: #include &lt;regex&gt;
     4:
     5: using namespace std;
     6:
     7: int main()
     8: {
     9:     while (true)
    10:     {
    11:         cout &lt;&lt; "Enter a pattern or plain Enter to stop: ";
    12:
    13:         string pattern;
    14:         if (not getline(cin, pattern) or pattern.empty())
    15:             break;
    16:
    17:         regex re(pattern);
    18:         while (true)
    19:         {
    20:             cout &lt;&lt; "Enter a target text for `" &lt;&lt; pattern &lt;&lt; "'\n"
    21:                     "(plain Enter for the next pattern): ";
    22:
    23:             string text;
    24:             if (not getline(cin, text) or text.empty())
    25:                 break;
    26:
    27:             smatch results;
    28:             if (not regex_search(text, results, re))
    29:                 cout &lt;&lt; "No match\n";
    30:             else
    31:             {
    32:                 cout &lt;&lt; "Prefix: "  &lt;&lt; results.prefix() &lt;&lt; "\n"
    33:                         "Match:  "  &lt;&lt; results.str()    &lt;&lt; "\n"
    34:                         "Suffix: "  &lt;&lt; results.suffix() &lt;&lt; "\n";
    35:                 for (size_t idx = 1; idx != results.size(); ++idx)
    36:                     cout &lt;&lt; "Match " &lt;&lt; idx &lt;&lt; " at offset " &lt;&lt;
    37:                                 results.position(idx) &lt;&lt; ": " &lt;&lt;
    38:                                 results.str(idx) &lt;&lt; '\n';
    39:             }
    40:         }
    41:     }
    42: }
</pre>
<p>
<a name="FORMAT"></a><a name="l360"></a>
<h4>18.8.4.4: The member std::match:_results::format</h4>
        The <code >match_results::format</code><a name="an2224"></a><code >format</code> member is a rather complex member
function of the class <code >match_results</code>, which can be used to modify text
which was previously matched against a regular expression, e.g., using the
function <code >regex_search</code>. Because of its complexity and because the
functionality of another regular expression processing function
(<code >regex_replace</code>) offers similar functionality it is discussed at this point
in the <strong >C++</strong> Annotations, just before discussing the <code >regex_replace</code> function.
<p>
The <code >format</code> member operates on (sub-)matches contained in a
<code >match_results</code> object, using a <a name="an2225"></a><em >format string</em>, and producing text in
which <a name="an2226"></a> format specifiers (like <code >$&amp;</code>) are replaced by
matching sections of the originally provided target text. In addition, the
<code >format</code> member recognizes all standard <strong >C</strong> escape sequences (like
<code >\n</code>). The <code >format</code> member is used to create text that is modified with
respect to the original target text.
<p>
As a preliminary illustration: if <code >results</code> is a <code >match_results</code> object
and <code >match[0]</code> (the fully matched text) equals `<code >hello world</code>', then
calling <code >format</code> with the format string <code >this is [$&amp;]</code> produces the text
<code >this is [hello world]</code>. Note the specification <code >$&amp;</code> in this format
string: this is an example of a format specifier. Here is an overview of all
supported format specifiers:
    <ul>
    <li><code >$`</code>: corresponds to the text returned by the <code >prefix</code> member: all
        characters in the original target text up to the first character
        of the fully matched text;
    <li><code >$&amp;</code>: corresponds to the fully matched text (i.e., the text returned by
        the <code >match_results::str</code> member);
    <li><code >$n</code>: (where <code >n</code> is an integral natural number): corresponds to the
        text returned bu <code >operator[](n)</code>;
    <li><code >$'</code>: corresponds to the text returned by the <code >suffix</code> member: all
        characters in the original target string beyond the last character
        of the fully matched text;
    <li><code >$$</code>: corresponds to the single <code >$</code> character.
    </ul>
<p>
Four overloaded versions of the <code >format</code> members are available. All
overloaded versions define a final <code >regex_constants::match_flag_type</code>
parameter, which is by default initialized to <code >match_default</code>. This final
parameter is not explicitly mentioned in the following coverage of the
<code >format</code> members.
<p>
To further illustrate the way the <code >format</code> members can be used it is assumed
that the following code has been executed:
    <pre>
     1:     regex re("([[:alpha:]]+)\\s+(\\d+)");  // letters blanks digits
     2:
     3:     smatch results;
     4:     string target("this value 1024 is interesting");
     5:
     6:     if (not regex_search(target, results, re))
     7:         return 1;
</pre>
  After calling <code >regex_search</code> (line 6) the results of the regular
expression matching process are available in the <code >match_results results</code>
object that is defined in line 3.
<p>
The first two overloaded <code >format</code> functions expect an output-iterator to
where the formatted text is written. These overloaded members return the 
final output iterator, pointing just beyond the character that was last
written.
    <ul>
    <li><code >OutputIter format(OutputIter out, char const *first, char const
        *last)  const</code>:<blockquote >the characters in the range <code >[first, last)</code> are applied to the 
        sub-expressions stored in the <code >match_results</code> object, and the
        resulting string is inserted at <code >out</code>. An illustration is provided
        with the next overloaded version;</blockquote>
<p>
<li><code >OutputIter format(OutputIter out, std::string const &amp;fmt)  const</code>:<blockquote >the contents of <code >fmt</code> are applied to the sub-expressions stored in
        the <code >match_results</code> object, and the resulting string is inserted at
        <code >out</code>. The next line of code inserts the value 1024 into <code >cout</code>
        (note that <code >fmt</code> <em >must</em> be a <code >std::string</code>, hence the explicit
        use of the <code >string</code> constructor):
         <pre>
results.format(ostream_iterator&lt;char&gt;(cout, ""), string("$2"));
</pre>
        </blockquote>
    </ul>
<p>
The remaining two overloaded <code >format</code> members expect a <code >std::string</code> or
an NTBS defining the format string. Both members return a <code >std::string</code>
containing the formatted text:
    <ul>
    <li><code >std::string format(std::string const &amp;fmt) const</code>
    <li><code >std::string format(char const *fmt) const</code>
    </ul>
    The next example shows how a <code >string</code> can be obtained
in which the order of the first and second marked sub-expressions contained in
the previously obtained <code >match_results</code> object have been
swapped: 
    <pre>
    string reverse(results.format("$2 and $1"));
</pre>
<p>
<a name="REGREP"></a><a name="l361"></a>
<h4>18.8.4.5: Modifying target strings: std::regex_replace</h4>
        The family of <code >std::regex_replace</code><a name="an2227"></a> functions uses regular
expressions to perform substitution on sequences of characters. Their
functionality closely resembles the functionality of the
<code >match_results::format</code> member discussed in the previous section. The
following overloaded variants are available:
    <ul>
    <li><code >OutputIt regex_replace(OutputIter out, 
                        BidirConstIter first, BidirConstIter last,
                        std::regex const &amp;re, std::string const &amp;fmt)</code>:<blockquote ><code >OutputIter</code> is an output iterator; <code >BidirConstIter</code> a
        bidirectional const iterator.
<p>
The function returns the possibly modified text in an iterator range
            <code >[out, retvalue)</code>, where <code >out</code> is the output iterator
            passed as the first argument to <code >regex_replace</code>, and
            <code >retvalue</code> is the output iterator returned by
            <code >regex_replace</code>. 
<p>
The function matches the text at the range <code >[first, last)</code>
            against the regular expression stored in <code >re</code>. If the regular
            expression does <em >not</em> match the target text in the range
            <code >[first, last)</code> then the target text is literally copied to
            <code >out</code>. If the regular expression <em >does</em> match the target text
            then 
       <ul>
        <li> first, the match result's prefix is copied to <code >out</code>. The prefix
            equals the initial characters of the target text up to the very
            first character of the fully matched text.
        <li> next, the matched text is replaced by the contents of the <code >fmt</code>
            format string, in which the format specifiers can be used that
            were described in the previous section (section <a href="cplusplus18.html#FORMAT">18.8.4.4</a>), and
            the replaced text is copied to <code >out</code>;
        <li> finally, the match result's suffix is copied to <code >out</code>. The
            suffix equals all characters of the target text beyond the last
            character of the matched text.
        </ul>
        The workings of <code >regex_replace</code> is illustrated in the next example:
    <pre>
 1:     regex re("([[:alpha:]]+)\\s+(\\d+)");  // letters blanks digits
 2:
 3:     string target("this value 1024 is interesting");
 4:
 5:     regex_replace(ostream_iterator&lt;char&gt;(cout, ""), target.begin(),
 6:                     target.end(), re, string("$2"));
</pre>
       In line 5 <code >regex_replace</code> is called. Its format string merely
        contains <code >$2</code>, matching 1024 in the target text. The prefix ends at
        the word <code >value</code>, the suffix starts beyond 1024, so the statement in
        line 5 inserts the text <pre>
this 1024 is interesting
</pre>
 into the
        standard output stream.  </blockquote>
<p>
<li><code >OutputIt regex_replace( OutputIter out, BidirConstIter first,
        BidirConstIter last, std::regex const &amp;re, char const *fmt)</code>:<blockquote >This variant behaves like the first variant. When using, in the above
        example, <code >"$2"</code> instead of <code >string("$2")</code>, then this variant would
        have been used;</blockquote>
<p>
<li><code >std::string regex_replace(std::string const &amp;str,
                   std::regex const &amp;re, std::string const &amp;fmt)</code>:<blockquote >This variant returns a <code >std::string</code> containing the modified text,
        and expects a <code >std::string</code> containing the target text. Other than
        that, it behaves like the first variant. To use this overloaded
        variant in the above example the statement in line 5 could have been
        replaced by the following statement, initializing the <code >string
        result</code>:
       <pre>
string result(regex_replace(target, re, string("$2")));
</pre>
       </blockquote> 
<p>
<li><code >std::string regex_replace(std::string const &amp;str,
                   std::regex const &amp;re, char const *fmt)</code>:<blockquote >After changing, in the above statement, <code >string("$2")</code> into
        <code >"$2"</code>, this variant is used, behaving exactly like the previous
        variant;</blockquote>
<p>
<li><code >std::string regex_replace(char const *str,
                   std::regex const &amp;re, std::string const &amp;fmt)</code>:<blockquote >This variant uses a <code >char const *</code> to point to the target text, and
        behaves exactly like the previous but one variant;</blockquote>
<p>
<li><code >std::string regex_replace(char const *str,
                   std::regex const &amp;re, char const *fmt)</code>:<blockquote >This variant also uses a <code >char const *</code> to point to the target text,
        and also behaves exactly like the previous but one variant;</blockquote>
    </ul>
<p>
<a name="l362"></a>
<h2 >18.9: Randomization and Statistical Distributions</h2>
    Before the statistical distributions and accompanying random number
generators can be used the <a name="an2228"></a><code >&lt;random&gt;</code> header file must be included.
<p>
The STL offers several standard mathematical (statistical)
distributions. These distributions allow programmers to obtain randomly
selected values from a selected distribution.
<p>
These statistical distributions need to be provided with a random number
generating object. Several of such random number generating objects are
provided, extending the traditional <a name="an2229"></a><code >rand</code> function that is part of the
<strong >C</strong> standard library.
<p>
These random number generating objects produce pseudo-random numbers, which
are then processed by the statistical distribution to obtain values that are
randomly selected from the specified distribution.
<p>
Although the STL offers various statistical distributions their functionality
is fairly limited. The distributions allow us to obtain a random number from
these distributions, but
    <a name="an2230"></a>probability density functions
 or
    <a name="an2231"></a>cumulative distribution functions
 are currently not provided by the STL. These functions (distributions as well
as the density and the cumulative distribution functions) are, however,
available in other libraries, like the
    <a target=_top href="http://www.boost.org/">boost math library</a> (specifically:<br/>
     <a href="http://www.boost.org/doc/libs/1_44_0/libs/math/doc/sf_and_dist/html/index.html">http://www.boost.org/doc/libs/1_44_0/libs/math/doc/sf_and_dist/html/index.html</a>).
<p>
It is beyond the scope of the <strong >C++</strong> Annotations to discuss the mathematical
characteristics of the various statistical distributions. The interested
reader is referred to the pertinent mathematical textbooks (like Stuart and
Ord's (2009)
    <a name="an2232"></a>
    <a name="an2233"></a><em >Kendall's Advanced Theory of Statistics</em>, Wiley) or to web-locations
like <a href="http://en.wikipedia.org/wiki/Bernoulli_distribution">http://en.wikipedia.org/wiki/Bernoulli_distribution</a>.
<p>
<a name="l363"></a>
<h3 >18.9.1: Random Number Generators</h3>
    The following <a name="an2234"></a>generators are available:
<div style="text-align: center">
<table>

<td colspan=5><hr/></td>


<tr >
<td > Class template</td><td > Integral/Floating point</td><td > Quality</td><td > Speed</td><td > Size of state</td>
 
</tr>

<td colspan=5><hr/></td>


<tr >
<td > <a name="an2235"></a><code >linear_congruential_engine</code></td><td > Integral</td><td > Medium</td><td > Medium</td><td > 1</td>
 
</tr>


<tr >
<td > <a name="an2236"></a><code >subtract_with_carry_engine</code></td><td > Both</td><td > Medium</td><td > Fast</td><td > 25</td>
 
</tr>


<tr >
<td > mersenne_twister_engine</td><td > Integral</td><td > Good</td><td > Fast</td><td > 624</td>
 
</tr>

<td colspan=5><hr/></td>


</table></div>
<p>
The <a name="an2237"></a><code >linear_congruential_engine</code> random number generator computes
    <div style="text-align: center"><code >value</code><sub >i+1</sub><code > = OPENPAa * value</code><sub >i</sub><code > +
                                                              c+) % m</code></div>
    It expects template arguments for, respectively, the data type to contain
the generated random values; the multiplier <code >a</code>; the additive constant
<code >c</code>; and the modulo value <code >m</code>. Example:
        <pre>
    linear_congruential_engine&lt;int, 10, 3, 13&gt; lincon;
</pre>
    The <code >linear_congruential</code> generator may be seeded by providing its
constructor with a seeding-argument. E.g., <code >lincon(time(0))</code>.
<p>
The <a name="an2238"></a><code >subtract_with_carry_engine</code> random number generator computes
    <div style="text-align: center"><code >value</code><sub >i</sub><code > = (value</code><sub >i-s</sub><code > -
                                                            value</code><sub >i-r</sub><code > - carry</code><sub >i-1</sub><code >) % m</code></div>
    It expects template arguments for, respectively, the data type to contain
the generated random values; the modulo value <code >m</code>; and the subtractive
constants <code >s</code> and <code >r</code>. Example:
        <pre>
    subtract_with_carry_engine&lt;int, 13, 3, 13&gt; subcar;
</pre>
    The <code >subtract_with_carry_engine</code> generator may be seeded by providing
its constructor with a seeding-argument. E.g., <code >subcar(time(0))</code>.
<p>
The predefined <code >mersenne_twister_engine mt19937</code> (predefined using a
<code >typedef</code> defined by the <a name="an2239"></a><code >&lt;random&gt;</code> header file) is used in the examples
below. It can be constructed using
    <a name="an2240"></a>`<code >mt19937 mt</code>' or it can be seeded by providing its
constructor with an argument (e.g., <code >mt19937 mt(time(0))</code>).
    Other ways to initialize the <code >mersenne_twister_engine</code> are beyond the
scope of the <strong >C++</strong> Annotations (but see Lewis<a name="an2241"></a> <em >et
al.</em>&nbsp;(
    Lewis, P.A.W., Goodman, A.S., and Miller, J.M. (1969), A pseudorandom
number generator for the System/360, IBM Systems Journal, 8, 136-146.) (1969)).
<p>
The random number generators may also be seeded by calling their members
<code >seed</code>  accepting <code >unsigned long</code> values or generator functions (as in
<code >lc.seed(time(0)), lc.seed(mt)</code>).
<p>
The random number generators offer members <a name="an2242"></a><code >min</code> and <a name="an2243"></a><code >max</code>
returning, respectively, their minimum and maximum values (inclusive). If a
reduced range is required the generators can be nested in a function or class
adapting the range.
<p>
<a name="l364"></a>
<h3 >18.9.2: Statistical distributions</h3>
    In the following sections the various statistical distributions that are
supported by <strong >C++</strong> are covered. The notation <a name="an2244"></a><code >RNG</code> is used to
indicate a <em >Random Number Generator</em> and <a name="an2245"></a><code >URNG</code> is used to indicate a
<em >Uniform Random Number Generator</em>. With each distribution a
<code >struct param_type</code> is defined containing the distribution's parameters. The
organization of these <code >param_type</code> structs depends on (and is described
at) the actual distribution.
<p>
All distributions offer the following members (<em >result_type</em> refers to
the type name of the values returned by the distribution):
    <ul>
    <li><code >result_type max() const</code><br/>
        returns the distribution's least upper bound;
    <li><code >result_type min() const</code><br/>
        returns the distribution's greatest lower bound;
    <li><code >param_type param() const</code><br/>
        returns the object's <code >param_type</code> struct;
    <li><code >void param(const param_type &amp;param)</code>
        redefines the parameters of the distribution;
    <li><code >void reset():</code>
       clears all of its cached values;
    </ul>
<p>
All distributions support the following operators (<em >distribution-name</em>
        should be replaced by the name of the intended distribution, e.g.,
        <code >normal_distribution</code>):
    <ul>
    <li><code >template&lt;typename URNG&gt; result_type operator()(URNG &amp;urng)</code><br/>
       returns the next random value from the statistical distribution, with
        the function object <code >urng</code> returning the next random number selected
        from a uniform random distribution;
    <li><code >template&lt;typename URNG&gt; result_type operator()</code><br/>
       <code >(URNG &amp;urng, param_type &amp;param)</code><br/> returns the next random value
        from the statistical distribution initialized with the parameters
        provided by the <code >param</code> struct.  The function object <code >urng</code>
        returns the next random number selected from a uniform random
        distribution;
    <li><code >std::istream &amp;operator&gt;&gt;(std::istream &amp;in,
            distribution-name &amp;object):</code>
       The parameters of the distribution are extracted from an
        <code >std::istream</code>;
    <li><code >std::ostream &amp;operator&lt;&lt;(std::ostream &amp;out,
            distribution-name const &amp;bd):</code>
        The parameters of the distribution are inserted into an
        <code >std::ostream</code>
    </ul>
<p>
The following example shows how the distributions can be used. Replacing
the name of the distribution (<code >normal_distribution</code>) by another
distribution's name is all that is required to switch distributions. All
distributions have parameters, like the mean and standard deviation of the
normal distribution, and all parameters have default values. The names of the
parameters vary over distributions and are mentioned below at the individual
distributions. Distributions offer members returning or setting their
parameters.
<p>
Most distributions are defined as class templates, requiring the specification
of a data type that is used for the function's return type. If so, an empty
template parameter type specification (<code >&lt;&gt;</code>) will get you the default
type. The default types are either <code >double</code> (for real valued return types)
or <code >int</code> (for integral valued return types). The template parameter type
specification must be omitted with distributions that are not defined as
template classes.
<p>
Here is an example showing the use of the statistical distributions, applied
to the normal distribution:
<p>
<pre>
#include &lt;iostream&gt;
#include &lt;ctime&gt;
#include &lt;random&gt;
using namespace std;

int main()
{
    std::mt19937 engine(time(0));
    std::normal_distribution&lt;&gt; dist;

    for (size_t idx = 0; idx &lt; 10; ++idx)
        std::cout &lt;&lt; "a random value: " &lt;&lt; dist(engine) &lt;&lt; "\n";

    cout &lt;&lt; '\n' &lt;&lt;
        dist.min() &lt;&lt; " " &lt;&lt; dist.max() &lt;&lt; '\n';
}
</pre>
<p>
<a name="BERNOULLI"></a><a name="l365"></a>
<h4>18.9.2.1: Bernoulli distribution</h4>
        The <a name="an2246"></a><code >bernoulli_distribution</code> is used to generate logical truth (boolean)
values with a certain probability <code >p</code>. It is equal to a binomial
distribution for one experiment (cf <a href="cplusplus18.html#BINOMIAL">18.9.2.2</a>).
<p>
The bernoulli distribution is <em >not</em> defined as a class template.
<p>
Defined types:
            <pre>
    typedef bool result_type;
    struct param_type
    {
      explicit param_type(double prob = 0.5);
      double p() const;                     // returns prob
    };
</pre>
<p>
Constructor and members:
    <ul>
    <li><code >bernoulli_distribution(double prob = 0.5)</code><br/>
        constructs a bernoulli distribution with probability <code >prob</code> of
        returning <code >true</code>;
    <li><code >double p() const</code><br/>
        returns <code >prob</code>;
    <li><code >result_type min() const</code><br/>
        returns <code >false</code>;
    <li><code >result_type max() const</code><br/>
        returns <code >true</code>;
    </ul>
<p>
<a name="BINOMIAL"></a><a name="l366"></a>
<h4>18.9.2.2: Binomial distribution</h4>
        The <a name="an2247"></a><code >binomial_distribution&lt;IntType = int&gt;</code> is used to determine the
probability of the number of successes in a sequence of <code >n</code> independent
success/failure experiments, each of which yields success with probability
<code >p</code>.
<p>
The template type parameter <code >IntType</code> defines the type of the generated
random value, which must be an integral type.
<p>
Defined types:
            <pre>
    typedef IntType result_type;
    struct param_type
    {
      explicit param_type(IntType trials, double prob = 0.5);
      IntType t() const;                    // returns trials
      double p() const;                     // returns prob
    };
</pre>
<p>
Constructors and members and example:
    <ul>
    <li><code >binomial_distribution&lt;&gt;(IntType trials = 1, double prob = 0.5)</code>
        constructs a binomial distribution for <code >trials</code> experiments, each
        having probability <code >prob</code> of success.
    <li><code >binomial_distribution&lt;&gt;(param_type const &amp;param)</code>
        constructs a binomial distribution according to the values stored in
        the <code >param</code> struct.
    <li><code >IntType t() const</code><br/>
        returns <code >trials</code>;
    <li><code >double p() const</code><br/>
        returns <code >prob</code>;
    <li><code >result_type min() const</code> <br/>
        returns 0;
    <li><code >result_type max() const</code><br/>
        returns <code >trials</code>;
    </ul>
<p>
<a name="l367"></a>
<h4>18.9.2.3: Cauchy distribution</h4>
        The <a name="an2248"></a><code >cauchy_distribution&lt;RealType = double&gt;</code> looks similar to a normal
distribution. But cauchy distributions have heavier tails.  When studying
hypothesis tests that assume normality, seeing how the tests perform on data
from a Cauchy distribution is a good indicator of how sensitive the tests are
to heavy-tail departures from normality.
<p>
The mean and standard deviation of the Cauchy distribution are undefined.
<p>
Defined types:
        <pre>
    typedef RealType result_type;

    struct param_type
    {
        explicit param_type(RealType a = RealType(0),
                            RealType b = RealType(1));

        double a() const;
        double b() const;
    };
</pre>
<p>
Constructors and members:
    <ul>
    <li><code >cauchy_distribution&lt;&gt;(RealType a = RealType(0),
                            RealType b = RealType(1))</code>
        constructs a cauchy distribution with specified <code >a</code> and <code >b</code>
        parameters.
    <li><code >cauchy_distribution&lt;&gt;(param_type const &amp;param)</code>
        constructs a cauchy distribution according to the values stored in
        the <code >param</code> struct.
    <li><code >RealType a() const</code><br/>
        returns the distribution's <code >a</code> parameter;
    <li><code >RealType b() const</code><br/>
        returns the distribution's <code >b</code> parameter;
    <li><code >result_type min() const</code><br/>
        returns the smallest positive <code >result_type</code> value;
    <li><code >result_type max() const</code><br/>
        returns the maximum value of <code >result_type</code>;
    </ul>
<p>
<a name="CHISQUARED"></a><a name="l368"></a>
<h4>18.9.2.4: Chi-squared distribution</h4>
        The <a name="an2249"></a><code >chi_squared_distribution&lt;RealType = double&gt;</code> with <code >n</code> degrees of
freedom is the distribution of a sum of the squares of <code >n</code> independent
standard normal random variables.
<p>
Note that even though the distribution's parameter <code >n</code> usually is an
integral value, it doesn't have to be integral, as the chi_squared
distribution is defined in terms of functions (<code >exp</code> and <code >Gamma</code>) that
take real arguments (see, e.g., the formula shown in the <code >&lt;bits/random.h&gt;</code>
header file, provided with the Gnu <code >g++</code> compiler distribution).
<p>
The chi-squared distribution is used, e.g., when testing the goodness of fit
of an observed distribution to a theoretical one.
<p>
Defined types:
        <pre>
    typedef RealType result_type;

    struct param_type
    {
        explicit param_type(RealType n = RealType(1));

        RealType n() const;
    };
</pre>
<p>
Constructors and members:
    <ul>
    <li><code >chi_squared_distribution&lt;&gt;(RealType n = 1)</code>
       constructs a chi_squared distribution with specified number of degrees
        of freedom.
    <li><code >chi_squared_distribution&lt;&gt;(param_type const &amp;param)</code>
       constructs a chi_squared distribution according to the value stored in
        the <code >param</code> struct;
    <li><code >IntType n() const</code><br/>
        returns the distribution's degrees of freedom;
    <li><code >result_type min() const</code><br/>
        returns 0;
    <li><code >result_type max() const</code><br/>
        returns the maximum value of <code >result_type</code>;
    </ul>
<p>
<a name="l369"></a>
<h4>18.9.2.5: Extreme value distribution</h4>
        The <a name="an2250"></a><code >extreme_value_distribution&lt;RealType = double&gt;</code> is related to the
Weibull distribution and is used in statistical models where the variable of
interest is the minimum of many random factors, all of which can take positive
or negative values.
<p>
It has two parameters: a location parameter <code >a</code> and scale parameter <code >b</code>.
See also <br/>
    <a target=_top href="http://www.itl.nist.gov/div898/handbook/apr/section1/apr163.htm">http://www.itl.nist.gov/div898/handbook/apr/section1/apr163.htm</a>
<p>
Defined types:
        <pre>
typedef RealType result_type;

struct param_type
{
    explicit param_type(RealType a = RealType(0),
                        RealType b = RealType(1));

    RealType a() const;     // the location parameter
    RealType b() const;     // the scale parameter
};
</pre>
<p>
Constructors and members:
    <ul>
    <li><code >extreme_value_distribution&lt;&gt;(RealType a = 0, RealType b = 1)</code>
        constructs an extreme value distribution with specified <code >a</code> and
        <code >b</code> parameters;
    <li><code >extreme_value_distribution&lt;&gt;(param_type const &amp;param)</code>
        constructs an extreme value distribution according to the values
        stored in the <code >param</code> struct.
    <li><code >RealType a() const</code><br/>
        returns the distribution's location parameter;
    <li><code >RealType stddev() const</code><br/>
        returns the distribution's scale parameter;
    <li><code >result_type min() const</code><br/>
        returns the smallest positive value of <code >result_type</code>;
    <li><code >result_type max() const</code><br/>
        returns the maximum value of <code >result_type</code>;
    </ul>
<p>
<a name="l370"></a>
<h4>18.9.2.6: Exponential distribution</h4>
        The <a name="an2251"></a><code >exponential_distribution&lt;RealType = double&gt;</code> is used to describe the
lengths between events that can be modelled with a homogeneous Poisson
process. It can be interpreted as the continuous form of the
geometric distribution.
<p>
Its parameter <code >prob</code> defines the distribution's <em >lambda</em> parameter, called
its <em >rate</em> parameter. Its expected value and standard deviation are both
<code >1 / lambda</code>.
<p>
Defined types:
        <pre>
    typedef RealType result_type;

    struct param_type
    {
        explicit param_type(RealType lambda = RealType(1));

        RealType lambda() const;
    };
</pre>
<p>
Constructors and members:
    <ul>
    <li><code >exponential_distribution&lt;&gt;(RealType lambda = 1)</code>
       constructs an exponential distribution with specified <code >lambda</code>
        parameter.
    <li><code >exponential_distribution&lt;&gt;(param_type const &amp;param)</code>
       constructs an exponential distribution according to the value stored in
        the <code >param</code> struct.
    <li><code >RealType lambda() const</code><br/>
        returns the distribution's <code >lambda</code> parameter;
    <li><code >result_type min() const</code><br/>
        returns 0;
    <li><code >result_type max() const</code><br/>
        returns the maximum value of <code >result_type</code>;
    </ul>
<p>
<a name="l371"></a>
<h4>18.9.2.7: Fisher F distribution</h4>
        The <a name="an2252"></a><code >fisher_f_distribution&lt;RealType = double&gt;</code> is intensively used in
statistical methods like the Analysis of Variance. It is the distribution
resulting from dividing two <em >Chi-squared</em> distributions.
<p>
It is characterized by two parameters, being the degrees of freedom of the two
chi-squared distributions.
<p>
Note that even though the distribution's parameter <code >n</code> usually is an
integral value, it doesn't have to be integral, as the Fisher F distribution
is constructed from Chi-squared distributions that accept a non-integral
parameter value (see also section <a href="cplusplus18.html#CHISQUARED">18.9.2.4</a>).
<p>
Defined types:
        <pre>
    typedef RealType result_type;

    struct param_type
    {
        explicit param_type(RealType m = RealType(1),
                            RealType n = RealType(1));

        RealType m() const; // The degrees of freedom of the nominator
        RealType n() const; // The degrees of freedom of the denominator
    };
</pre>
<p>
Constructors and members:
    <ul>
    <li><code >fisher_f_distribution&lt;&gt;(RealType m = RealType(1),
                                RealType n = RealType(1))</code>
        constructs a fisher_f distribution with specified degrees of freedom.
    <li><code >fisher_f_distribution&lt;&gt;(param_type const &amp;param)</code>
        constructs a fisher_f distribution according to the values stored in
        the <code >param</code> struct.
    <li><code >RealType m() const</code><br/>
        returns the degrees of freedom of the nominator;
    <li><code >RealType n() const</code><br/>
        returns the degrees of freedom of the denominator;
    <li><code >result_type min() const</code><br/>
        returns 0;
    <li><code >result_type max() const</code><br/>
        returns the maximum value of <code >result_type</code>;
    </ul>
<p>
<a name="l372"></a>
<h4>18.9.2.8: Gamma distribution</h4>
        The <a name="an2253"></a><code >gamma_distribution&lt;RealType = double&gt;</code> is used when working with data
that are not distributed according to the normal distribution. It is often
used to model waiting times.
<p>
It has two parameters, <code >alpha</code> and <code >beta</code>. Its expected value is <code >alpha
* beta</code> and its standard deviation is <code >alpha * beta</code><sup >2</sup>.
<p>
Defined types:
        <pre>
    typedef RealType result_type;

    struct param_type
    {
        explicit param_type(RealType alpha = RealType(1),
                            RealType beta = RealType(1));

        RealType alpha() const;
        RealType beta() const;
    };
</pre>
<p>
Constructors and members:
    <ul>
    <li><code >gamma_distribution&lt;&gt;(RealType alpha = 1, RealType beta = 1)</code>
        constructs a gamma distribution with specified <code >alpha</code> and <code >beta</code>
        parameters.
    <li><code >gamma_distribution&lt;&gt;(param_type const &amp;param)</code>
        constructs a gamma distribution according to the values stored in
        the <code >param</code> struct.
    <li><code >RealType alpha() const</code><br/>
        returns the distribution's <code >alpha</code> parameter;
    <li><code >RealType beta() const</code><br/>
        returns the distribution's <code >beta</code> parameter;
    <li><code >result_type min() const</code><br/>
        returns 0;
    <li><code >result_type max() const</code><br/>
        returns the maximum value of <code >result_type</code>;
    </ul>
<p>
<a name="l373"></a>
<h4>18.9.2.9: Geometric distribution</h4>
        The <a name="an2254"></a><code >geometric_distribution&lt;IntType = int&gt;</code> is used to model the number
of bernoulli trials (cf. <a href="cplusplus18.html#BERNOULLI">18.9.2.1</a>) needed until the first success.
<p>
It has one parameter, <code >prob</code>, representing the probability of success in an
individual bernoulli trial.
<p>
Defined types:
        <pre>
    typedef IntType result_type;

    struct param_type
    {
        explicit param_type(double prob = 0.5);
        double p() const;
    };
</pre>
<p>
Constructors, members and example:
    <ul>
    <li><code >geometric_distribution&lt;&gt;(double prob = 0.5)</code>
        constructs a geometric distribution for bernoulli trials each having
        probability <code >prob</code> of success.
    <li><code >geometric_distribution&lt;&gt;(param_type const &amp;param)</code>
        constructs a geometric distribution according to the values stored in
        the <code >param</code> struct.
    <li><code >double p() const</code><br/>
        returns the distribution's <code >prob</code> parameter;
    <li><code >param_type param() const</code><br/>
        returns the object's <code >param_type</code> structure;
    <li><code >void param(const param_type &amp;param)</code>
        redefines the parameters of the distribution;
    <li><code >result_type min() const</code><br/>
        returns the distribution's lower bound (= <code >0</code>);
    <li><code >result_type max() const</code><br/>
        returns the distribution's upper bound;
    <li><code >template&lt;typename URNG&gt; result_type operator()(URNG &amp;urng)</code><br/>
        returns the next random value from the geometric distribution
    <li><code >template&lt;typename URNG&gt; result_type operator()</code><br/>
        <code >(URNG &amp;urng, param_type &amp;param)</code><br/>
        returns the next random value from a geometric distribution
        initialized by the provided <code >param</code> struct.
    <li> The random number generator that is passed to the generating
       functions must return integral values. Here is an example showing how
        the geometric distribution can be used:
        <pre>
#include &lt;iostream&gt;
#include &lt;ctime&gt;
#include &lt;random&gt;

int main()
{
    std::linear_congruential_engine&lt;unsigned, 7, 3, 61&gt; engine(0);

    std::geometric_distribution&lt;&gt; dist;

    for (size_t idx = 0; idx &lt; 10; ++idx)
        std::cout &lt;&lt; "a random value: " &lt;&lt; dist(engine) &lt;&lt; "\n";

    std::cout &lt;&lt; '\n' &lt;&lt;
        dist.min() &lt;&lt; " " &lt;&lt; dist.max() &lt;&lt; '\n';

}
</pre>
    </ul>
<p>
<a name="l374"></a>
<h4>18.9.2.10: Log-normal distribution</h4>
        The <a name="an2255"></a><code >lognormal_distribution&lt;RealType = double&gt;</code> is a probability
distribution of a random variable whose logarithm is normally distributed. If
a random variable <code >X</code> has a normal distribution, then <code >Y = e</code><sup >X</sup> has a
log-normal distribution.
<p>
It has two parameters, <em >m</em> and <em >s</em> representing, respectively, the mean
and standard deviation of <code >ln(X)</code>.
<p>
Defined types:
        <pre>
    typedef RealType result_type;

    struct param_type
    {
        explicit param_type(RealType m = RealType(0),
                            RealType s = RealType(1));

        RealType m() const;
        RealType s() const;
    };
</pre>
<p>
Constructor and members:
    <ul>
    <li><code >lognormal_distribution&lt;&gt;(RealType m = 0, RealType s = 1)</code>
       constructs a log-normal distribution for a random variable whose mean
        and standard deviation is, respectively, <code >m</code> and <code >s</code>.
    <li><code >lognormal_distribution&lt;&gt;(param_type const &amp;param)</code> constructs a
        log-normal distribution according to the values stored in the
        <code >param</code> struct.
    <li><code >RealType m() const</code><br/>
        returns the distribution's <code >m</code> parameter;
    <li><code >RealType stddev() const</code><br/>
        returns the distribution's <code >s</code> parameter;
    <li><code >result_type min() const</code><br/>
        returns 0;
    <li><code >result_type max() const</code><br/>
        returns the maximum value of <code >result_type</code>;
    </ul>
<p>
<a name="l375"></a>
<h4>18.9.2.11: Normal distribution</h4>
        The <a name="an2256"></a><code >normal_distribution&lt;RealType = double&gt;</code> is commonly used in science to
describe complex phenomena. When predicting or measuring variables, errors are
commonly assumed to be normally distributed.
<p>
It has two parameters, <em >mean</em> and <em >standard deviation</em>.
<p>
Defined types:
        <pre>
    typedef RealType result_type;

    struct param_type
    {
        explicit param_type(RealType mean = RealType(0),
                            RealType stddev = RealType(1));

        RealType mean() const;
        RealType stddev() const;
    };
</pre>
<p>
Constructors and members:
    <ul>
    <li><code >normal_distribution&lt;&gt;(RealType mean = 0, RealType stddev = 1)</code>
        constructs a normal distribution with specified <code >mean</code> and <code >stddev</code>
        parameters. The default parameter values define the
        <a name="an2257"></a><em >standard normal distribution</em>;
    <li><code >normal_distribution&lt;&gt;(param_type const &amp;param)</code>
        constructs a normal distribution according to the values stored in
        the <code >param</code> struct.
    <li><code >RealType mean() const</code><br/>
        returns the distribution's <code >mean</code> parameter;
    <li><code >RealType stddev() const</code><br/>
        returns the distribution's <code >stddev</code> parameter;
    <li><code >result_type min() const</code><br/>
        returns the lowest positive value of <code >result_type</code>;
    <li><code >result_type max() const</code><br/>
        returns the maximum value of <code >result_type</code>;
    </ul>
<p>
<a name="l376"></a>
<h4>18.9.2.12: Negative binomial distribution</h4>
        The <a name="an2258"></a><code >negative_binomial_distribution&lt;IntType = int&gt;</code> probability distribution
describes the number of successes in a sequence of Bernoulli trials before a
specified number of failures occurs. For example, if one throws a die
repeatedly until the third time 1 appears, then the probability distribution
of the number of other faces that have appeared is a negative binomial
distribution.
<p>
It has two parameters: (<code >IntType</code>) k (&gt; 0), being the number of failures
until the experiment is stopped and (<code >double</code>) p the probability of success
in each individual experiment.
<p>
Defined types:
        <pre>
    typedef IntType result_type;

    struct param_type
    {
        explicit param_type(IntType k = IntType(1), double p = 0.5);

        IntType k() const;
        double p() const;
    };
</pre>
<p>
Constructors and members:
    <ul>
    <li><code >negative_binomial_distribution&lt;&gt;(IntType k = IntType(1),
                                                            double p = 0.5)</code>
       constructs a negative_binomial distribution with specified <code >k</code> and
        <code >p</code> parameters;
    <li><code >negative_binomial_distribution&lt;&gt;(param_type const &amp;param)</code>
       constructs a negative_binomial distribution according to the values
        stored in the <code >param</code> struct.
    <li><code >IntType k() const</code><br/>
        returns the distribution's <code >k</code> parameter;
    <li><code >double p() const</code><br/>
        returns the distribution's <code >p</code> parameter;
    <li><code >result_type min() const</code><br/>
        returns 0;
    <li><code >result_type max() const</code><br/>
        returns the maximum value of <code >result_type</code>;
    </ul>
<p>
<a name="l377"></a>
<h4>18.9.2.13: Poisson distribution</h4>
        The <a name="an2259"></a><code >poisson_distribution&lt;IntType = int&gt;</code> is used to model the probability
of a number of events occurring in a fixed period of time if these events
occur with a known probability and independently of the time since the last
event.
<p>
It has one parameter, <code >mean</code>, specifying the expected number of events in
the interval under consideration. E.g., if on average 2 events are observed in
a one-minute interval and the duration of the interval under study is
10 minutes then <code >mean = 20</code>.
<p>
Defined types:
        <pre>
    typedef IntType result_type;

    struct param_type
    {
        explicit param_type(double mean = 1.0);

        double mean() const;
    };
</pre>
<p>
Constructors and members:
    <ul>
    <li><code >poisson_distribution&lt;&gt;(double mean = 1)</code>
        constructs a poisson distribution with specified <code >mean</code>
        parameter.
    <li><code >poisson_distribution&lt;&gt;(param_type const &amp;param)</code>
        constructs a poisson distribution according to the values stored in
        the <code >param</code> struct.
    <li><code >double mean() const</code><br/>
        returns the distribution's <code >mean</code> parameter;
    <li><code >result_type min() const</code><br/>
        returns 0;
    <li><code >result_type max() const</code><br/>
        returns the maximum value of <code >result_type</code>;
    </ul>
<p>
<a name="l378"></a>
<h4>18.9.2.14: Student t distribution</h4>
        The <a name="an2260"></a><code >student_t_distribution&lt;RealType = double&gt;</code> is a probability
distribution that is used when estimating the mean of a normally distributed
population from small sample sizes.
<p>
It is characterized by one parameter: the degrees of freedom, which is equal
to the sample size - 1.
<p>
Defined types:
        <pre>
    typedef RealType result_type;

    struct param_type
    {
        explicit param_type(RealType n = RealType(1));

        RealType n() const;    // The degrees of freedom
    };
</pre>
<p>
Constructors and members:
    <ul>
    <li><code >student_t_distribution&lt;&gt;(RealType n = RealType(1))</code>
        constructs a student_t distribution with indicated degrees of freedom.
    <li><code >student_t_distribution&lt;&gt;(param_type const &amp;param)</code>
        constructs a student_t distribution according to the values stored in
        the <code >param</code> struct.
    <li><code >RealType n() const</code><br/>
        returns the degrees of freedom;
    <li><code >result_type min() const</code><br/>
        returns 0;
    <li><code >result_type max() const</code><br/>
        returns the maximum value of <code >result_type</code>;
    </ul>
<p>
<a name="l379"></a>
<h4>18.9.2.15: Uniform int distribution</h4>
        The <a name="an2261"></a><code >uniform_int_distribution&lt;IntType = int&gt;</code> can be used to select integral
values randomly from a range of uniformly distributed integral values.
<p>
It has two parameters, <code >a</code> and <code >b</code>, specifying, respectively, the lowest
value that can be returned and the highest value that can be returned.
<p>
Defined types:
        <pre>
    typedef IntType result_type;

    struct param_type
    {
        explicit param_type(IntType a = 0, IntType b = max(IntType));

        IntType a() const;
        IntType b() const;
    };
</pre>
<p>
Constructors and members:
    <ul>
    <li><code >uniform_int_distribution&lt;&gt;(IntType a = 0, IntType b = max(IntType))</code>
        constructs a uniform_int distribution for the specified range of
        values.
    <li><code >uniform_int_distribution&lt;&gt;(param_type const &amp;param)</code>
        constructs a uniform_int distribution according to the values stored in
        the <code >param</code> struct.
    <li><code >IntType a() const</code><br/>
        returns the distribution's <code >a</code> parameter;
    <li><code >IntType b() const</code><br/>
        returns the distribution's <code >b</code> parameter;
    <li><code >result_type min() const</code><br/>
        returns the distribution's <code >a</code> parameter;
    <li><code >result_type max() const</code><br/>
        returns the distribution's <code >b</code> parameter;
    </ul>
<p>
<a name="l380"></a>
<h4>18.9.2.16: Uniform real distribution</h4>
        The <a name="an2262"></a><code >uniform_real_distribution&lt;RealType = double&gt;</code> can be used to select
<code >RealType</code> values randomly from a range of uniformly distributed
<code >RealType</code> values.
<p>
It has two parameters, <code >a</code> and <code >b</code>, specifying, respectively, the
half-open range of values (<code >[a, b)</code>) that can be returned by the
distribution.
<p>
Defined types:
        <pre>
    typedef RealType result_type;

    struct param_type
    {
        explicit param_type(RealType a = 0, RealType b = max(RealType));

        RealType a() const;
        RealType b() const;
    };
</pre>
<p>
Constructors and members:
    <ul>
    <li><code >uniform_real_distribution&lt;&gt;(RealType a = 0, RealType b = max(RealType))</code>
        constructs a uniform_real distribution for the specified range of
        values.
    <li><code >uniform_real_distribution&lt;&gt;(param_type const &amp;param)</code>
        constructs a uniform_real distribution according to the values stored in
        the <code >param</code> struct.
    <li><code >RealType a() const</code><br/>
        returns the distribution's <code >a</code> parameter;
    <li><code >RealType b() const</code><br/>
        returns the distribution's <code >b</code> parameter;
    <li><code >result_type min() const</code><br/>
        returns the distribution's <code >a</code> parameter;
    <li><code >result_type max() const</code><br/>
        returns the distribution's <code >b</code> parameter;
    </ul>
<p>
<a name="l381"></a>
<h4>18.9.2.17: Weibull distribution</h4>
        The <a name="an2263"></a><code >weibull_distribution&lt;RealType = double&gt;</code> is commonly used in
reliability engineering and in survival (life data) analysis.
<p>
It has two or three parameters and the two-parameter variant is offered by the
STL. The three parameter variant has a shape (or slope) parameter, a scale
parameter and a location parameter. The two parameter variant implicitly uses
the location parameter value 0. In the two parameter variant the shape
parameter (a) and the scale parameter (b) are provided. See <br/>
    <a target=_top href="http://www.weibull.com/hotwire/issue14/relbasics14.htm">http://www.weibull.com/hotwire/issue14/relbasics14.htm</a> for an
interesting coverage of the meaning of the Weibull distribution's parameters.
<p>
Defined types:
        <pre>
    typedef RealType result_type;

    struct param_type
    {
        explicit param_type(RealType a = RealType{ 1 },
                            RealType b = RealType{ 1 });

        RealType a() const;     // the shape (slope) parameter
        RealType b() const;     // the scale parameter
    };
</pre>
<p>
Constructors and members:
    <ul>
    <li><code >weibull_distribution&lt;&gt;(RealType a = 1, RealType b = 1)</code>
        constructs a weibull distribution with specified <code >a</code> and <code >b</code>
        parameters;
    <li><code >weibull_distribution&lt;&gt;(param_type const &amp;param)</code>
        constructs a weibull distribution according to the values stored in
        the <code >param</code> struct.
    <li><code >RealType a() const</code><br/>
        returns the distribution's shape (or slope) parameter;
    <li><code >RealType stddev() const</code><br/>
        returns the distribution's scale parameter;
    <li><code >result_type min() const</code><br/>
        returns 0;
    <li><code >result_type max() const</code><br/>
        returns the maximum value of <code >result_type</code>;
    </ul>
<p>

<hr>
<ul>
    <li> <a href="cplusplus.html">Table of Contents</a>
    <li> <a href="cplusplus17.html">Previous Chapter</a>
    <li> <a href="cplusplus19.html">Next Chapter</a>
</ul>
<hr>
</body>
</html>
