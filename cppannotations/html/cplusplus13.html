<!DOCTYPE html><html><head>
<meta charset="UTF-8">
<title> C++ Annotations Version 10.9.0 </title>
<link rel="stylesheet" type="text/css" href="cplusplus.css"><style type="text/css">
    figure {text-align: center;}
    img {vertical-align: center;}
</style>
<link rel="stylesheet" type="text/css" href="cplusplus.css"></head>
<body >
<hr>
<ul>
    <li> <a href="cplusplus.html">Table of Contents</a>
    <li> <a href="cplusplus12.html">Previous Chapter</a>
    <li> <a href="cplusplus14.html">Next Chapter</a>
</ul>
<hr>
<a name="INHERITANCE"></a><a name="l265"></a>
<h1 >Chapter 13: Inheritance</h1>
When programming in <strong >C</strong>, programming problems are commonly approached using
a top-down structured approach: functions and actions of the program are
defined in terms of sub-functions, which again are defined in
sub-sub-functions, etc..  This yields a <a name="an1678"></a>hierarchy of code: <code >main</code> at
the top, followed by a level of functions which are called from <code >main</code>,
etc..
<p>
In <strong >C++</strong> the <a name="an1679"></a>relationship between code and data is also frequently
defined in terms of dependencies among <em >classes</em>. This looks like
<a name="an1680"></a><em >composition</em> (see section <a href="cplusplus07.html#Composition">7.3</a>), where objects of a class
contain objects of another class as their data. But the relation described
here is of a different kind: a class can be <em >defined</em> in terms of an older,
pre-existing, class. This produces a new class having all the functionality of
the older class, and additionally defining its own specific functionality.
Instead of composition, where a given class <em >contains</em> another class, we
here refer to <a name="an1681"></a><em >derivation</em>, where a given class <em >is</em> or
<em >is-implemented-in-terms-of</em> another class.
<p>
Another term for derivation is <a name="an1682"></a><em >inheritance</em>: the new class inherits the
functionality of an existing class, while the existing class does not appear
as a data member in the interface of the new class. When discussing
inheritance the existing class is called the <a name="an1683"></a><em >base class</em>, while the new
class is called the <a name="an1684"></a><em >derived class</em>.
<p>
Derivation of classes is often used when the methodology of <strong >C++</strong> program
development is fully exploited. In this chapter we first address the
syntactic possibilities offered by <strong >C++</strong> for deriving classes. Following
this we address some of the specific possibilities offered by
class derivation (inheritance).
<p>
As we have seen in the introductory chapter (see section <a href="cplusplus02.html#OOP">2.4</a>), in the
object-oriented approach to problem solving classes are identified during the
<a name="an1685"></a>problem analysis. Under this approach objects of the defined classes
represent entities that can be observed in the problem at hand. The classes
are placed in a hierarchy, with the top-level class containing limited
functionality.  Each new derivation (and hence descent in the
 <a name="an1686"></a>class hierarchy) adds new functionality compared to yet existing classes.
<p>
In this chapter we shall use a simple vehicle classification system to build a
hierarchy of classes. The first class is <code >Vehicle</code>, which implements as its
functionality the possibility to set or retrieve the mass of a vehicle. The
next level in the object hierarchy are land-, water- and air vehicles.
<p>
The initial <a name="an1687"></a>object hierarchy is illustrated in Figure <a href="cplusplus13.html#hierarchy">14</a>.
    <p><a name="hierarchy"></a><figure >
<img src="inheritance/hierarchy.gif" >
<figcaption >Figure 14: Initial object hierarchy of vehicles.</figcaption>
</figure></p>

<p>
This chapter mainly focuses on the technicalities of class derivation. The
distinction between inheritance used to create derived classes whose objects
should be considered objects of the base class and inheritance used to
implement derived classes <em >in-terms-of</em> their base classes is postponed
until the next chapter (<a href="cplusplus14.html#POLYMORPHISM">14</a>).
<p>
Inheritance (and polymorphism, cf. chapter <a href="cplusplus14.html#POLYMORPHISM">14</a>) can be used with
classes and structs. It is not defined for unions.
<p>
<a name="VehicleSystem"></a><a name="l266"></a>
<h2 >13.1: Related types</h2>
    The relationship between the proposed classes representing different kinds of
vehicles is further investigated here. The figure shows the object hierarchy:
a <code >Car</code> is a special case of a <code >Land</code> vehicle, which in turn is a
special case of a <code >Vehicle</code>.
<p>
The class <code >Vehicle</code> represents the `greatest common divisor' in the
classification system. <code >Vehicle</code> is given limited functionality: it can
store and retrieve a vehicle's mass:
        <pre>
    class Vehicle
    {
        size_t d_mass;

        public:
            Vehicle();
            Vehicle(size_t mass);

            size_t mass() const;
            void setMass(size_t mass);
    };
</pre>
    Using this class, the vehicle's mass can be defined as soon as the
corresponding object has been created. At a later stage the mass can be
changed or retrieved.
<p>
To represent vehicles travelling over land, a new class <code >Land</code> can be
defined offering <code >Vehicle</code>'s functionality and adding its own specific
functionality. Assume we are interested in the speed of land vehicles <em >and</em>
in their mass. The relationship between <code >Vehicle</code>s and <code >Land</code>s could of
course be represented by composition but that would be awkward: composition
suggests that a <code >Land</code> vehicle <em >is-implemented-in-terms-of</em>, i.e.,
<em >contains</em>, a <code >Vehicle</code>, while the natural relationship clearly is that
the <code >Land</code> vehicle <em >is</em> a kind of <code >Vehicle</code>.
<p>
A relationship in terms of composition would also somewhat complicate our
<code >Land</code> class's design.  Consider the following example showing a class
<code >Land</code> using composition (only the <code >setMass</code> functionality is shown):
        <pre>
    class Land
    {
        Vehicle d_v;        // composed Vehicle
        public:
            void setMass(size_t mass);
    };

    void Land::setMass(size_t mass)
    {
        d_v.setMass(mass);
    }
</pre>
    Using composition, the <code >Land::setMass</code> function only passes its
argument on to <code >Vehicle::setMass</code>. Thus, as far as mass handling is
concerned, <code >Land::setMass</code> introduces no extra functionality, just extra
code. Clearly this code duplication is superfluous: a <code >Land</code> object <em >is</em> a
<code >Vehicle</code>; to state that a <code >Land</code> object <em >contains</em> a <code >Vehicle</code> is at
least somewhat peculiar.
<p>
The intended relationship is represented better by <a name="an1688"></a>inheritance.
        A <a name="an1689"></a>rule of thumb for choosing between inheritance and composition
distinguishes between <em >is-a</em> and <em >has-a</em> relationships. A truck <em >is</em> a
vehicle, so <code >Truck</code> should probably derive from <code >Vehicle</code>.  On the other
hand, a truck <em >has</em> an engine; if you need to model engines in your system,
you should probably express this by composing an <code >Engine</code> class inside the
<code >Truck</code> class.
<p>
Following the above rule of thumb, <code >Land</code> is <em >derived</em> from the base class
<code >Vehicle</code>:
        <pre>
    class Land: public Vehicle
    {
        size_t d_speed;
        public:
            Land();
            Land(size_t mass, size_t speed);

            void setSpeed(size_t speed);
            size_t speed() const;
    };
</pre>
    To derive a class (e.g., <code >Land</code>) from another class (e.g., <code >Vehicle</code>)
postfix the class name <code >Land</code> in its interface by <code >: public Vehicle</code>:
        <pre>
    class Land: public Vehicle
</pre>
 The class <code >Land</code> now contains all the functionality of its base class
<code >Vehicle</code> as well as its own features. Here those features are a constructor
expecting two arguments and member functions to access the <code >d_speed</code> data
member. Here is an example showing the possibilities of the derived class
<code >Land</code>:
        <pre>
    Land veh{ 1200, 145 };

    int main()
    {
        cout &lt;&lt; "Vehicle weighs " &lt;&lt; veh.mass() &lt;&lt; ";\n"
                "its speed is " &lt;&lt; veh.speed() &lt;&lt; '\n';
    }
</pre>
    This example illustrates two features of derivation.
    <ul>
    <li> First, <code >mass</code> is not mentioned as a member in <code >Land</code>'s
interface. Nevertheless it is used in <code >veh.mass</code>.  This member function is
an implicit part of the class, inherited from its `parent' vehicle.
    <li> Second, although the derived class <code >Land</code> contains the
functionality of <code >Vehicle</code>, the <code >Vehicle</code>'s private members remain
private: they can only be accessed by <code >Vehicle</code>'s own member functions. This
means that <code >Land</code>'s member functions <em >must</em> use <code >Vehicle</code>'s member
functions (like <code >mass</code> and <code >setMass</code>) to address the <code >mass</code>
field. Here there's no difference between the access rights granted to
<code >Land</code> and the access rights granted to other code outside of the class
<code >Vehicle</code>. The class <code >Vehicle</code> <a name="an1690"></a> <em >encapsulates</em> the
specific <code >Vehicle</code> characteristics, and <a name="an1691"></a>data hiding is one way to realize
encapsulation.
    </ul>
<p>
Encapsulation is a core principle of good class design. Encapsulation
reduces the dependencies among classes improving the maintainability and
testability of classes and allowing us to modify classes without the need to
modify depending code. By strictly complying with the principle of data hiding
a class's internal data organization may change without requiring depending
code to be changed as well. E.g., a class <code >Lines</code> originally storing
<strong >C</strong>-strings could at some point have its data organization changed. It could
abandon its <code >char **</code> storage in favor of a <code >vector&lt;string&gt;</code> based
storage. When <code >Lines</code> uses perfect data hiding depending source code
may use the new <code >Lines</code> class without requiring any modification at all.
<p>
As a <a name="an1692"></a>rule of thumb, derived classes must be fully recompiled (but don't
have to be modified) when the <em >data organization</em> (i.e., the data members)
of their base classes change.  Adding new member <em >functions</em> to the base
class doesn't alter the data organization so no <a name="an1693"></a>recompilation is needed
when new member <em >functions</em> are added.
<p>
There is one subtle exception to this rule of thumb: if a new member function
is added to a base class and that function happens to be declared as the first
<em >virtual</em> member function of the base class (cf. chapter <a href="cplusplus14.html#POLYMORPHISM">14</a>
for a discussion of the virtual member function concept) then that
<em >also</em> changes the data organization of the base class.
<p>
Now that <code >Land</code> has been derived from <code >Vehicle</code> we're ready for our next
class derivation. We'll define a class <code >Car</code> to represent
automobiles. Agreeing that a <code >Car</code> object is a <code >Land</code> vehicle, and that
a <code >Car</code> has a brand name it's easy to design the class <code >Car</code>:
        <pre>
    class Car: public Land
    {
        std::string d_brandName;

        public:
            Car();
            Car(size_t mass, size_t speed, std::string const &amp;name);

            std::string const &amp;brandName() const;
    };
</pre>
    In the above class definition, <code >Car</code> was derived from <code >Land</code>, which in
turn is derived from <code >Vehicle</code>. This is called <a name="an1694"></a><em >nested derivation</em>:
<code >Land</code> is called <code >Car</code>'s <a name="an1695"></a><em >direct base class</em>, while <code >Vehicle</code> is
called <code >Car</code>'s  <a name="an1696"></a><em >indirect base class</em>.
<p>
<a name="l267"></a>
<h3 >13.1.1: Inheritance depth: desirable?</h3>
        Now that <code >Car</code> has been derived from <code >Land</code> and <code >Land</code> has been derived
from <code >Vehicle</code> we might easily be seduced into thinking that these class
hierarchies are the way to go when designing classes. But maybe we should
temper our enthusiasm.
<p>
Repeatedly deriving classes from classes quickly results in big, complex class
hierarchies that are hard to understand, hard to use and hard to
maintain. Hard to understand and use as users of our derived class now also
have to learn all its (indirect) base class features as well. Hard to maintain
because all those classes are very closely coupled. While it may be true that
when data hiding is meticulously adhered to derived classes do not have to be
modified when their base classes alter their data organization, it also
quickly becomes practically infeasible to change those base classes once more
and more (derived) classes depend on their current organization.
<p>
What initially looks like a big gain, inheriting the base class's interface,
thus becomes a liability. The base class's interface is hardly ever completely
required and in the end a class may benefit from explicitly defining its own
member functions rather than obtaining them through inheritance.
<p>
Often classes can be defined <em >in-terms-of</em> existing classes: some of their
features are used, but others need to be shielded off. Consider the <code >stack</code>
container: it is commonly implemented in-terms-of a <code >deque</code>, returning
<code >deque::back</code>'s value as <code >stack::top</code>'s value.
<p>
When using inheritance to implement an <em >is-a</em> relationship make sure to get
the `direction of use' right: inheritance aiming at implementing an <em >is-a</em>
relationship should focus on the base class: the base class facilities aren't
there to be used by the derived class, but the derived class facilities should
redefine (reimplement) the base class facilities using polymorphism (which is
the topic of the <a href="cplusplus14.html#POLYMORPHISM">next chapter</a>), allowing
code to use the derived class facilities polymorphically through the base
class.  We've seen this approach when studying streams: the base class (e.g.,
<code >ostream</code>) is used time and again. The facilities defined by classes derived
from <code >ostream</code> (like <code >ofstream</code> and <code >ostringstream</code>) are then used by
code only relying on the facilities offered by the <code >ostream</code> class, never
using the derived classes directly.
<p>
When designing classes always aim at the lowest possible coupling. Big class
hierarchies usually indicate poor understanding of robust class design. When a
class's interface is only partially used and if the derived class is
implemented in terms of another class consider using composition rather than
inheritance and define the appropriate interface members in terms of the
members offered by the composed objects.
<p>
<a name="l268"></a>
<h2 >13.2: Access rights: public, private, protected</h2>
    Early in the <strong >C++</strong> Annotations (cf. section <a href="cplusplus03.html#HIDING">3.2.1</a>) we encountered two
important design principles when developing classes: <em >data hiding</em> and
<em >encapsulation</em>.  Data hiding restricts control over an object's data to the
members of its class, encapsulation is used to restrict access to the
functionality of objects. Both principles are invaluable tools for maintaining
data integrity.
<p>
The keyword <code >private</code> starts sections in class interfaces in which members
are declared which can only be accessed by members of the class itself. This
is our main tool for realizing data hiding. According to established good
practices of class design the public sections are populated with member
functions offering a clean interface to the class's functionality. These
members allow users to communicate with objects; leaving it to the objects how
requests sent to objects are handled. In a well-designed class its objects are
in full control of their data.
<p>
Inheritance doesn't change these principles, nor does it change the way the
`<code >private</code>' and `<code >protected</code>' keywords operate. A derived class does not
have access to a base class's private section.
<p>
Sometimes this is a bit too restrictive. Consider a class implementing a
random number generating <code >streambuf</code> (cf. chapter <a href="cplusplus06.html#IOStreams">6</a>). Such a
<code >streambuf</code> can be used to construct an <code >istream irand</code>, after which
extractions from <code >irand</code> produces series of random numbers, like in the next
example in which 10 random numbers are generated using stream I/O:
            <pre>
    RandBuf buffer;
    istream irand(&amp;buffer);

    for (size_t idx = 0; idx != 10; ++idx)
    {
        size_t next;
        irand &gt;&gt; next;
        cout &lt;&lt; "next random number: " &lt;&lt; next &lt;&lt; '\n';
    }
</pre>
    The question is, how many random numbers should <code >irand</code> be able to
generate? Fortunately, there's no need to answer this question, as
<code >RandBuf</code> can be made responsible for generating the next random
number. RandBuf, therefore, operates as follows:
        <ul>
        <li> It generates a random number;
        <li> It is passed in textual form to its base class <code >streambuf</code>;
        <li> The <code >istream</code> object extracts this random number, merely
            using <code >streambuf</code>'s interface;
        </ul>
        (this process is repeated for subsequent random numbers).
<p>
Once <code >RandBuf</code> has stored the text representation of the next
random number in some buffer, it must tell its base class (<code >streambuf</code>)
where to find the random number's characters. For this <code >streambuf</code> offers a
member <code >setg</code>, expecting the location and size of the buffer holding the
random number's characters.
<p>
The member <code >setg</code> clearly cannot be declared in <code >streambuf</code>'s
private section, as <code >RandBuf</code> must use it to prepare for the
extraction of the next random number. But it should also not be in
<code >streambuf</code>'s public section, as that could easily result in unexpected
behavior by <code >irand</code>. Consider the following hypothetical example:
        <pre>
    RandBuf randBuf;
    istream irand(&amp;randBuf);

    char buffer[] = "12";
    randBuf.setg(buffer, ...);  // setg public: buffer now contains 12

    size_t next;
    irand &gt;&gt; next;              // not a *random* value, but 12.
</pre>
<p>
Clearly there is a close connection between <code >streambuf</code> and its derived
class <code >RandBuf</code>. By allowing <code >RandBuf</code> to specify the buffer from
which <code >streambuf</code> reads characters <code >RandBuf</code> remains in control,
denying other parts of the program to break its well-defined behavior.
<p>
This close connection between base- and derived-classes is realized by a third
keyword related to the accessibility of class members: <a name="an1697"></a><code >protected</code>. Here is
how the member <code >setg</code> could have been be declared in a class <code >streambuf</code>:
        <pre>
    class streambuf
    {
        // private data here (as usual)
        protected:
            void setg(... parameters ...);  // available to derived classes

        public:
            // public members here
    };
</pre>
<p>
Protected members are members that can be accessed by derived classes, but are
not part of a class's public interface.
<p>
Avoid the temptation to declare <em >data members</em> in a class's protected
section: it's a sure sign of bad class design as it needlessly results in
tight coupling of base and derived classes. The principle of <a name="an1698"></a>data hiding
should not be abandoned now that the keyword <code >protected</code> has been
introduced. If a derived class (but not other parts of the software) should
be given access to its base class's data, use member functions:
accessors and modifiers declared in the base class's protected
section. This enforces the intended restricted access without resulting in
tightly coupled classes.
<p>
<a name="DERIVATIONTYPES"></a><a name="l269"></a>
<h3 >13.2.1: Public, protected and private derivation</h3>
        With inheritance public derivation is frequently used. When public derivation
is used the access rights of the base class's interface remains unaltered in
the derived class. But the type of inheritance may also be defined as
<em >private</em> or <em >protected</em>.
<p>
Protected derivation is used when the keyword <code >protected</code> is put in front of
the derived class's base class:
        <pre>
    class Derived: protected Base
</pre>
    When protected derivation is used all the base class's public and
protected members become protected members in the derived class. The derived
class may access all the base class's public and protected members. Classes
that are in turn derived from the derived class view the base class's members
as protected. Any other code (outside of the inheritance tree) is unable to
access the base class's members.
<p>
Private derivation is used when the keyword <code >private</code> is put in front of the
derived class's base class:
        <pre>
    class Derived: private Base
</pre>
    When private derivation is used all the base class's members turn into
private members in the derived class. The derived class members may access
all base class public and protected members but base class members cannot be
used elsewhere.
<p>
Public derivation should be used to define an <em >is-a</em> relationship
between a derived class and a base class: the derived class object <em >is-a</em>
base class object allowing the derived class object to be used polymorphically
as a base class object in code expecting a base class object. Private
inheritance is used in situations where a derived class object is defined
in-terms-of the base class where composition cannot be used. There's little
documented use for protected inheritance, but one could maybe encounter
protected inheritance when defining a base class that is itself a derived
class making its base class members available to classes derived from it.
<p>
Combinations of inheritance types do occur. For example, when designing a
stream-class it is usually derived from <code >std::istream</code> or
<code >std::ostream</code>. However, before a stream can be constructed, a
<code >std::streambuf</code> must be available. Taking advantage of the fact that the
inheritance order is defined in the class interface, we use multiple
inheritance (see section <a href="cplusplus13.html#MULTIPLE">13.6</a>) to derive the class from both
<code >std::streambuf</code> and (then) from <code >std::ostream</code>. To the class's users it
is a <code >std::ostream</code> and not a <code >std::streambuf</code>. So private derivation is
used for the latter, and public derivation for the former class:
        <pre>
    class Derived: private std::streambuf, public std::ostream
</pre>
<p>
<a name="ACCESSPROMOTION"></a><a name="l270"></a>
<h3 >13.2.2: Promoting access rights</h3>
        When private or protected derivation is used, users of derived class objects
are denied access to the base class members. Private derivation denies access
to all base class members to users of the derived class, protected derivation
does the same, but allows classes that are in turn derived from the derived
class to access the base class's public and protected members.
<p>
In some situations this scheme is too
    <a name="an1699"></a>
    <a name="an1700"></a>
        restrictive. Consider a class <code >RandStream</code> derived privately from a
class <code >RandBuf</code> which is itself derived from <code >std::streambuf</code> and also
publicly from <code >istream</code>:
        <pre>
    class RandBuf: public std::streambuf
    {
        // implements a buffer for random numbers
    };
    class RandStream: private RandBuf, public std::istream
    {
        // implements a stream to extract random values from
    };
</pre>
    Such a class could be used to extract, e.g., random numbers using the
standard <code >istream</code> interface.
<p>
Although the <code >RandStream</code> class is constructed with the
functionality of <code >istream</code> objects in mind, some of the members of the class
<code >std::streambuf</code> may be considered useful by themselves. E.g., the function
<code >streambuf::in_avail</code> returns a lower bound to the number of characters
that can be read immediately. The standard way to make this function available
is to define a <a name="an1701"></a><em >shadow member</em> calling the base class's member:
        <pre>
    class RandStream: private RandBuf, public std::istream
    {
        // implements a stream to extract random values from
        public:
            std::streamsize in_avail();
    };
    inline std::streamsize RandStream::in_avail()
    {
        return std::streambuf::in_avail();
    }
</pre>
    This looks like a lot of work for just making available a member from the
protected or private base classes. If the intent is to make available the
    <a name="an1702"></a> <code >in_avail</code> member
<a name="an1703"></a><em >access promotion</em> can be used. Access promotion allows us to specify which
members of private (or protected) base classes become available in the
protected (or public) interface of the derived class. Here is the above
example, now using access promotion:
        <pre>
    class RandStream: private RandBuf, public std::istream
    {
        // implements a stream to extract random values from
        public:
            using std::streambuf::in_avail;
    };
</pre>
    It should be noted that access promotion makes available all overloaded
versions of the declared base class member. So, if <code >streambuf</code> would offer
not only <code >in_avail</code> but also, e.g., <code >in_avail(size_t *)</code> <em >both</em>
members would become part of the public interface.
<p>
<a name="l271"></a>
<h2 >13.3: The constructor of a derived class</h2>
    A derived class inherits functionality from its base class (or base classes,
as <strong >C++</strong> supports multiple inheritance, cf. section <a href="cplusplus13.html#MULTIPLE">13.6</a>). When a
derived class object is constructed it is built on top of its base class
object. As a consequence the base class must have been constructed before the
actual derived class elements can be initialized. This results in some
requirements that must be observed when defining
 <a name="an1704"></a> derived class constructors.
<p>
A constructor exists to initialize the object's data members. A derived class
constructor is also responsible for the proper initialization of its base
class. Looking at the definition of the class <code >Land</code> introduced earlier
(section <a href="cplusplus13.html#VehicleSystem">13.1</a>), its constructor could simply be defined as
follows:
        <pre>
    Land::Land(size_t mass, size_t speed)
    {
        setMass(mass);
        setSpeed(speed);
    }
</pre>
    However, this implementation has several disadvantages.
    <ul>
    <li> When constructing a derived class object a base class constructor is
<em >always</em> called before any action is performed on the derived class object
itself. By default the base class's <a name="an1705"></a>default constructor is going to be
called.
    <li> Using the base class constructor only to reassign new values to its
data members in the derived class constructor's body usually is inefficient,
but sometimes sheer impossible as in situations where base class reference or
<code >const</code> data members must be initialized. In those cases a specialized base
class constructor must be used instead of the base class default constructor.
    </ul>
    A derived class's base class may be initialized using a dedicated base
class constructor by calling the base class constructor in the derived class
constructor's initializer clause. Calling a base class constructor in a
constructor's initializer clause is called a
 <a name="an1706"></a><em >base class initializer</em>. The base class initializer must be called before
initializing any of the derived class's data members and when using the base
class initializer none of the derived class data members may be used. When
constructing a derived class object the base class is constructed first and
only after that construction has successfully completed
the derived class data members are available for initialization. <code >Land</code>'s
constructor may therefore be improved:
        <pre>
    Land::Land(size_t mass, size_t speed)
    :
        Vehicle(mass),
        d_speed(speed)
    {}
</pre>
<p>
Derived class constructors always by default call their base class's
default constructor. This is of course not correct for a derived class's
 <a name="an1707"></a>copy constructor. Assuming that the class <code >Land</code> must be provided with a
copy constructor it may use the <code >Land const &amp;other</code> to represent the other's
base class:
        <pre>
    Land::Land(Land const &amp;other)   // assume a copy constructor is needed
    :
        Vehicle(other),             // copy-construct the base class part.
        d_speed(other.speed)        // copy-construct Land's data members
    {}
</pre>
<p>
<a name="l272"></a>
<h3 >13.3.1: Move construction</h3>
        As with classes using composition derived classes may benefit from defining a
 <a name="an1708"></a>move constructor.
A derived class may offer a move constructor for two reasons:
    <ul>
    <li> it supports move construction for its  data members
    <li> its base class is move-aware
    </ul>
<p>
The design of move constructors moving data members was covered in section
<a href="cplusplus09.html#MOVE">9.7</a>. A move constructor for a derived class whose base class is
move-aware must <em >anonimize</em> the rvalue reference before passing it to the
base class move constructor. The <code >std::move</code> function should be used when
implementing the move constructor to move the information in base classes or
composed objects to their new destination object.
<p>
The first example shows the move constructor for the class <code >Car</code>,
assuming it has a movable <code >char *d_brandName</code> data member and
assuming that <code >Land</code> is a move-aware class. The second example shows the
move constructor for the class <code >Land</code>, assuming that it does not itself have
movable data members, but that its <code >Vehicle</code> base class is move-aware:
        <pre>
    Car::Car(Car &amp;&amp;tmp)
    :
        Land(std::move(tmp)),           // anonimize `tmp'
        d_brandName(tmp.d_brandName)    // move the char *'s value
    {
        tmp.d_brandName = 0;
    }

    Land(Land &amp;&amp;tmp)
    :
        Vehicle(std::move(tmp)),    // move-aware Vehicle
        d_speed(tmp.d_speed)        // plain copying of plain data
    {}
</pre>
<p>
<a name="l273"></a>
<h3 >13.3.2: Move assignment</h3>
        Derived classes may also benefit from move assignment operations. If the
derived class and its base class support swapping then the implementation is
simple, following the standard shown earlier in section <a href="cplusplus09.html#MOVEASS">9.7.3</a>. For the
class <code >Car</code> this could boil down to:
        <pre>
    Car &amp;Car::operator=(Car &amp;&amp;tmp)
    {
        swap(tmp);
        return *this;
    }
</pre>
    If swapping is not supported then <code >std::move</code> can be used to call the
base class's move assignment operator:
        <pre>
    Car &amp;Car::operator=(Car &amp;&amp;tmp)
    {
        static_cast&lt;Land &amp;&gt;(*this) = std::move(tmp);
        // move Car's own data members next
        return *this;
    }
</pre>
<p>
<a name="BASECONS"></a><a name="l274"></a>
<h3 >13.3.3: Inheriting constructors</h3>
        Derived classes can be constructed without
        <a name="an1709"></a>
    explicitly defining derived class constructors. In those cases the
available base class constructors are called.
<p>
This feature is either used or not. It is not possible to omit some of the
derived class constructors, using the corresponding base class constructors
instead. To use this feature for classes that are derived from multiple base
classes (cf. section <a href="cplusplus13.html#MULTIPLE">13.6</a>) all the base class constructors must
have different signatures. Considering the complexities that are involved here
it's probably best to avoid using base class constructors for classes using
multiple inheritance.
<p>
The construction of derived class objects can be delegated to
 <a name="an1710"></a> base class constructor(s) using
the following syntax:
        <pre>
    class BaseClass
    {
        public:
            // BaseClass constructor(s)
    };

    class DerivedClass: public BaseClass
    {
        public:
            using BaseClass::BaseClass; // No DerivedClass constructors
                                        // are defined
    };
</pre>
<p>
subset(Aggregate Initializations)
            Aggregates <a name="an1711"></a>(e.g., structs) can be initialized
using the familiar curly-brace notation. Curly brace notations can also be
used when initializing base-structs of derived-structs. Each base-level struct
receives its own set of curly braces while initializing the derived-level
struct. Here is an example:
        <pre>
    struct Base
    {
        int value;
    };
    struct Derived: public Base
    {
        string text;
    };

    // Initializiation of a Derived object:
    
    Derived der{{value}, "hello world"};
    //          -------
    //          initialization of Derived's base struct.
</pre>
<p>
<a name="l275"></a>
<h2 >13.4: The destructor of a derived class</h2>
    Destructors
 <a name="an1712"></a> of classes are automatically called when an
object is destroyed. This also holds true for objects of classes derived from
other classes. Assume we have the following situation:
        <pre>
    class Base
    {
        public:
            ~Base();
    };

    class Derived: public Base
    {
        public:
            ~Derived();
    };

    int main()
    {
        Derived derived;
    }
</pre>
    At the end of <code >main</code>, the <code >derived</code> object ceases to exists. Hence,
its destructor (<code >~Derived</code>) is called. However, since <code >derived</code> is also a
<code >Base</code> object, the <code >~Base</code> destructor is called as well.  The base class
destructor is never explicitly called from the derived class destructor.
<p>
Constructors
 <a name="an1713"></a> <a name="an1714"></a> and destructors
are called in a stack-like fashion: when <code >derived</code> is constructed, the
appropriate base class constructor is called first, then the appropriate
derived class constructor is called. When the object <code >derived</code> is destroyed,
its destructor is called first, automatically followed by the activation of
the <code >Base</code> class destructor. A <a name="an1715"></a>derived class destructor is always called
before its <a name="an1716"></a>base class destructor is called.
<p>
When the construction of a derived class objects did not successfully complete
(i.e., the constructor threw an exception) then its destructor is not
called. However, the destructors of properly constructed base classes <em >will</em>
be called if a derived class constructor throws an exception. This, of course,
is it should be: a properly constructed object should also be destroyed,
eventually. Example:
        <pre>
    #include &lt;iostream&gt;
    struct Base
    {
        ~Base()
        {
            std::cout &lt;&lt; "Base destructor\n";
        }
    };
    struct Derived: public Base
    {
        Derived()
        {
            throw 1;    // at this time Base has been constructed
        }
    };
    int main()
    {
        try
        {
            Derived d;
        }
        catch(...)
        {}
    }
    /*
        This program displays `Base destructor'
    */
</pre>
<p>
<a name="Truck"></a><a name="l276"></a>
<h2 >13.5: Redefining member functions</h2>
    Derived classes may redefine base class members.  Let's assume that a vehicle
classification system must also cover trucks, consisting of two parts: the
front part, the tractor, pulls the rear part, the trailer. Both the
tractor and the trailer have their own mass, and the <code >mass</code> function
should return the combined mass.
<p>
The definition of a <code >Truck</code> starts with a class definition. Our initial
<code >Truck</code> class is derived from <code >Car</code> but it is then expanded to hold one
more <code >size_t</code> field representing the additional mass information. Here we
choose to represent the mass of the tractor in the <code >Car</code> class and to store
the mass of of full truck (tractor + trailer) in its own <code >d_mass</code> data
member: 
        <pre>
    class Truck: public Car
    {
        size_t d_mass;

        public:
            Truck();
            Truck(size_t tractor_mass, size_t speed, char const *name,
                  size_t trailer_mass);

            void setMass(size_t tractor_mass, size_t trailer_mass);
            size_t mass() const;
    };

    Truck::Truck(size_t tractor_mass, size_t speed, char const *name,
                 size_t trailer_mass)
    :
        Car(tractor_mass, speed, name),
        d_mass(tractor_mass + trailer_mass)
    {}
</pre>
    Note that the class <code >Truck</code> now contains two functions already
present in the base class <code >Car</code>: <code >setMass</code> and <code >mass</code>.
    <ul>
    <li> The redefinition of <code >setMass</code> poses no problems: this
function is simply redefined to perform actions which are specific to a
<code >Truck</code> object.
    <li> Redefining <code >setMass</code>, however,
    <a name="an1717"></a> <a name="an1718"></a> <em >hides</em>
<code >Car::setMass</code>. For a <code >Truck</code> only the <code >setMass</code> function having
two <code >size_t</code> arguments can be used.
    <li> The <code >Vehicle</code>'s <code >setMass</code> function remains available for a
<code >Truck</code>, but it must now be
 <a name="an1719"></a> called <em >explicitly</em>, as
<code >Car::setMass</code> is hidden from view.  This latter function is hidden,
even though <code >Car::setMass</code> has only one <code >size_t</code> argument. To implement
<code >Truck::setMass</code> we could write:
     <pre>
void Truck::setMass(size_t tractor_mass, size_t trailer_mass)
{
    d_mass = tractor_mass + trailer_mass;
    Car::setMass(tractor_mass);     // note: Car:: is required
}
</pre>
    <li> Outside of the class <code >Car::setMass</code> is
accessed using the <a name="an1720"></a>scope resolution operator. So, if a <code >Truck truck</code> needs
to set its <code >Car</code> mass, it must use
    <pre>
truck.Car::setMass(x);
</pre>
<p>
<li> An alternative to using the scope resolution operator is to add a
member having the same function prototype as the base class member to the
derived class's interface. This derived class member could be implemented
inline to call the base class member. E.g., we add the following member to the
<code >class Truck</code>:
    <pre>
// in the interface:
void setMass(size_t tractor_mass);

// below the interface:
inline void Truck::setMass(size_t tractor_mass)
{
    (d_mass -= Car::mass()) += tractor_mass;
    Car::setMass(tractor_mass);
}
</pre>
    Now the single argument <code >setMass</code> member function can be used by
<code >Truck</code> objects without using the scope resolution operator. As the
function is defined inline, no overhead of an additional function call is
involved.
<p>
<li> <a name="an1721"></a><a name="an1722"></a> To
prevent hiding the base class members a <code >using</code> declaration may be added to
the derived class interface. The relevant section of <code >Truck</code>'s class
interface then becomes:
    <pre>
class Truck: public Car
{
    public:
        using Car::setMass;
        void setMass(size_t tractor_mass, size_t trailer_mass);
};
</pre>
    A using declaration imports (all overloaded versions of) the mentioned
member function directly into the derived class's interface. If a base class
member has a signature that is identical to a derived class member then
compilation fails (a <code >using Car::mass</code> declaration cannot be added to
<code >Truck</code>'s interface). Now code may use <code >truck.setMass(5000)</code> as well as
<code >truck.setMass(5000, 2000)</code>.
<p>
Using declarations obey access rights. To prevent non-class members from
using <code >setMass(5000)</code> without a scope resolution operator but allowing
derived class members to do so the <code >using Car::setMass</code> declaration
should be put in the class <code >Truck</code>'s private section.
<p>
<li> The function <code >mass</code> is also already defined in <code >Car</code>, as
it was inherited from <code >Vehicle</code>. In this case, the class <code >Truck</code> 
<em >redefines</em> this member function to return the truck's full mass:
     <pre>
size_t Truck::mass() const
{
    return d_mass;
}
</pre>
    </ul>
    Example:
        <pre>
    int main()
    {
        Land vehicle{ 1200, 145 };
        Truck lorry{ 3000, 120, "Juggernaut", 2500 };
    
        lorry.Vehicle::setMass(4000);
    
        cout &lt;&lt; '\n' &lt;&lt; "Tractor weighs " &lt;&lt;
                        lorry.Vehicle::mass() &lt;&lt; '\n' &lt;&lt;
            "Truck + trailer weighs " &lt;&lt; lorry.mass() &lt;&lt; '\n' &lt;&lt;
            "Speed is " &lt;&lt; lorry.speed() &lt;&lt; '\n' &lt;&lt;
            "Name is " &lt;&lt; lorry.name() &lt;&lt; '\n';
    }
</pre>
<p>
The class <code >Truck</code> was derived from <code >Car</code>. However, one might question
this class design. Since a truck is conceived of as a combination of a
tractor and a trailer it is probably better defined using a mixed design,
using inheritance for the tractor part (inheriting from <code >Car</code>, and
composition for the trailer part).
<p>
This redesign changes our point of view from a <code >Truck</code> <em >being</em> a <code >Car</code>
(and some strangely added data members) to a <code >Truck</code> still <em >being</em> an
<code >Car</code> (the tractor) and <em >containing</em> a <code >Vehicle</code> (the trailer).
<p>
<code >Truck</code>'s interface is now very specific, not requiring users to study
<code >Car</code>'s and <code >Vehicle</code>'s interfaces and it opens up possibilities for
defining `road trains': tractors towing multiple trailers. Here is an example
of such an alternate class setup:
        <pre>
    class Truck: public Car    // the tractor
    {
        Vehicle d_trailer;      // use vector&lt;Vehicle&gt; for road trains

        public:
            Truck();
            Truck(size_t tractor_mass, size_t speed, char const *name,
                  size_t trailer_mass);

            void setMass(size_t tractor_mass, size_t trailer_mass);
            void setTractorMass(size_t tractor_mass);
            void setTrailerMass(size_t trailer_mass);

            size_t tractorMass() const;
            size_t trailerMass() const;
        // consider:
            Vehicle const &amp;trailer() const;
    };
</pre>
<p>
<a name="MULTIPLE"></a><a name="l277"></a>
<h2 >13.6: Multiple inheritance</h2>
    Except for the class <code >Randbuf</code> classes thus far have always been derived
from a single base class. In addition to <a name="an1723"></a>single inheritance 
    <a name="an1724"></a> 
    <strong >C++</strong> also supports <a name="an1725"></a><em >multiple inheritance</em>. In multiple inheritance a
class is derived from several base classes and hence inherits functionality
from multiple parent classes at the same time.
<p>
When using multiple inheritance it should be defensible to consider the
newly derived class an instantiation of both base classes. Otherwise,
<a name="an1726"></a>composition is more appropriate. In general, linear derivation (using only
one base class) is used much more frequently than multiple derivation. Good
class design dictates that a class should have a single, well described
responsibility and that principle often conflicts with multiple inheritance
where we can state that objects of class <code >Derived</code> are <em >both</em> <code >Base1</code>
<em >and</em> <code >Base2</code> objects.
<p>
But then, consider <em >the</em> prototype of an object for which
multiple inheritance was used to its extreme: the
    <a name="an1727"></a><em >Swiss army knife</em>! This object <em >is</em> a knife, it <em >is</em> a pair of
scissors, it <em >is</em> a can-opener, it <em >is</em> a corkscrew, it <em >is</em> ....
<p>
The `Swiss army knife' is an extreme example of multiple inheritance. In
<strong >C++</strong> there <em >are</em> various good arguments for using multiple inheritance as
well, without violating the `one class, one responsibility' principle. We
postpone those arguments until the <a href="cplusplus14.html#POLYMORPHISM">next chapter</a>. The
current section concentrates on the technical details of constructing classes
using multiple inheritance.
<p>
How to construct a `Swiss army knife' in <strong >C++</strong>? First we need (at least)
two base classes. For example, let's assume we are designing a toolkit
allowing us to construct an instrument panel of an aircraft's cockpit. We
design all kinds of instruments, like an artificial horizon and an
altimeter. One of the components that is often seen in aircraft is a
<em >nav-com set</em>: a combination of a navigational beacon receiver (the `nav'
part) and a radio communication unit (the `com'-part). To define the nav-com
set, we start by designing the <code >NavSet</code> class (assume the existence of the
classes <code >Intercom, VHF_Dial</code> and <code >Message</code>):
        <pre>
    class NavSet
    {
        public:
            NavSet(Intercom &amp;intercom, VHF_Dial &amp;dial);

            size_t activeFrequency() const;
            size_t standByFrequency() const;

            void setStandByFrequency(size_t freq);
            size_t toggleActiveStandby();
            void setVolume(size_t level);
            void identEmphasis(bool on_off);
    };
</pre>
    Next we design the class  <code >ComSet</code>:
        <pre>
    class ComSet
    {
        public:
            ComSet(Intercom &amp;intercom);

            size_t frequency() const;
            size_t passiveFrequency() const;

            void setPassiveFrequency(size_t freq);
            size_t toggleFrequencies();

            void setAudioLevel(size_t level);
            void powerOn(bool on_off);
            void testState(bool on_off);
            void transmit(Message &amp;message);
    };
</pre>
    Using objects of this class we can receive messages, transmitted
though the <code >Intercom</code>, but we can also <em >transmit</em> messages using a
<code >Message</code> object that's passed to the <code >ComSet</code> object using its
<code >transmit</code> member function.
<p>
Now we're ready to construct our <code >NavCom</code> set:
        <pre>
    class NavComSet: public ComSet, public NavSet
    {
        public:
            NavComSet(Intercom &amp;intercom, VHF_Dial &amp;dial);
    };
</pre>
    Done. Now we have defined a <code >NavComSet</code> which is <em >both</em> a <code >NavSet</code>
<em >and</em> a <code >ComSet</code>: the facilities of both base classes  are now
available in the derived class using multiple inheritance.
<p>
Please note the following:
    <ul>
    <li> The keyword <a name="an1728"></a><code >public</code> is present before both base class names
(<code >NavSet</code> and <code >ComSet</code>). By default inheritance uses
 <a name="an1729"></a><em >private derivation</em> and the keyword <code >public</code> must be repeated before
each of the base class specifications. Base classes are not required to use
the same derivation type. One base class could have <code >public</code> derivation and
another base class could use <code >private</code> derivation.
    <li> The multiply derived class <code >NavComSet</code> introduces no additional
functionality of its own, but merely combines two existing classes into a new
aggregate class. Thus, <strong >C++</strong> offers the possibility to simply sweep
multiple simple classes into one more complex class.
    <li> Here is the implementation of The <code >NavComSet</code> <a name="an1730"></a>constructor:
    <pre>
NavComSet::NavComSet(Intercom &amp;intercom, VHF_Dial &amp;dial)
:
    ComSet(intercom),
    NavSet(intercom, dial)
{}
</pre>
    The constructor requires no extra code: Its purpose is to activate
the constructors of its base classes. The order in which the base class
initializers <a name="an1731"></a>
    <a name="an1732"></a> are called is <em >not</em>
dictated by their calling order in the constructor's code, but by the ordering
of the base classes in the class interface.
    <li> The <code >NavComSet</code> class definition requires no additional data
members or member functions: here (and often) the inherited interfaces provide
all the required functionality and data for the multiply derived class to
operate properly.
    </ul>
    Of course, while defining the base classes, we made life easy on ourselves
by strictly using different member function names. So, there is a function
<code >setVolume</code> in the <code >NavSet</code> class and a function <code >setAudioLevel</code> in the
<code >ComSet</code> class. A bit cheating, since we could expect that both units in
fact have a composed object <code >Amplifier</code>, handling the volume setting. A
revised class might offer an <code >Amplifier &amp;amplifier() const</code> member function,
and leave it to the application to set up its own interface to the
amplifier. Alternatively, a revised class could define members for setting the
volume of either the <code >NavSet</code> or the <code >ComSet</code> parts.
<p>
In situations where two base classes offer identically named members
 <a name="an1733"></a><a name="an1734"></a>
special provisions need to be made to prevent ambiguity:
    <ul>
    <li> The intended base class can explicitly be specified using the base
class name and <a name="an1735"></a>scope resolution operator:
    <pre>
NavComSet navcom(intercom, dial);

navcom.NavSet::setVolume(5);    // sets the NavSet volume level
navcom.ComSet::setVolume(5);    // sets the ComSet volume level
</pre>
    <li> The class interface is provided with member functions that can be
called unambiguously. These additional members are usually defined <code >inline</code>:
    <pre>
class NavComSet: public ComSet, public NavSet
{
    public:
        NavComSet(Intercom &amp;intercom, VHF_Dial &amp;dial);
        void comVolume(size_t volume);
        void navVolume(size_t volume);
};
inline void NavComSet::comVolume(size_t volume)
{
    ComSet::setVolume(volume);
}
inline void NavComSet::navVolume(size_t volume)
{
    NavSet::setVolume(volume);
}
</pre>
    <li> If the <code >NavComSet</code> class is obtained from a third party, and cannot
be modified, a disambiguating <a name="an1736"></a>wrapper class may be used:
    <pre>
class MyNavComSet: public NavComSet
{
    public:
        MyNavComSet(Intercom &amp;intercom, VHF_Dial &amp;dial);
        void comVolume(size_t volume);
        void navVolume(size_t volume);
};
inline MyNavComSet::MyNavComSet(Intercom &amp;intercom, VHF_Dial &amp;dial)
:
    NavComSet(intercom, dial);
{}
inline void MyNavComSet::comVolume(size_t volume)
{
    ComSet::setVolume(volume);
}
inline void MyNavComSet::navVolume(size_t volume)
{
    NavSet::setVolume(volume);
}
</pre>
    </ul>
<p>
<a name="l278"></a>
<h2 >13.7: Conversions between base classes and derived classes</h2>
    When public inheritance is used to define classes, an object of a derived
class <em >is</em> at the same time an object of the base class.  This has important
consequences for object assignment and for the situation where pointers or
references to such objects are used. Both situations are now discussed.
<p>
<a name="l279"></a>
<h3 >13.7.1: Conversions with object assignments</h3>
        Continuing our discussion of the <code >NavCom</code> class, introduced in section
<a href="cplusplus13.html#MULTIPLE">13.6</a>, we now define two objects, a base class and a derived class
object:
        <pre>
    ComSet com(intercom);
    NavComSet navcom(intercom2, dial2);
</pre>
    The object <code >navcom</code> is constructed using an <code >Intercom</code> and a
<code >VHF_Dial</code> object. However, a <code >NavComSet</code> is at the same time a
<code >ComSet</code>, allowing the <a name="an1737"></a>assignment <em >from</em> <code >navcom</code> (a derived class
object) <em >to</em> <code >com</code> (a base class object):
        <pre>
    com = navcom;
</pre>
    The effect of this assignment is that the object <code >com</code> now
communicates with <code >intercom2</code>.  As a <code >ComSet</code> does not have a <code >VHF_Dial</code>,
the <code >navcom</code>'s <code >dial</code> is ignored by the assignment. When assigning a
base class object from a derived class object only the base class data members
are assigned, other data members are dropped, a phenomenon called
<a name="an1738"></a><em >slicing</em>. In situations like these slicing probably does not have serious
consequences, but when passing derived class objects to functions defining
base class parameters or when returning derived class objects from functions
returning base class objects slicing also occurs and might have unwelcome
side-effects.
<p>
The assignment from a base class object to a derived class object is
problematic. In a statement like
        <pre>
    navcom = com;
</pre>
    it isn't clear how to reassign the <code >NavComSet</code>'s <code >VHF_Dial</code> data
member as they are missing in the <code >ComSet</code> object <code >com</code>. Such an
assignment <a name="an1739"></a> is therefore refused by the
compiler. Although derived class objects are also base class objects, the
reverse does not hold true: a base class object is not also a derived class
object.
<p>
The following general rule applies: in assignments in which base class
objects and derived class objects are involved, assignments in which data are
dropped are legal (called <em >slicing</em>). Assignments in which data remain
unspecified are <em >not</em> allowed.  Of course, it is possible to overload an
assignment operator to allow the assignment of a derived class object from a
base class object.  To compile the statement
        <pre>
    navcom = com;
</pre>
    the class <code >NavComSet</code> must have defined an overloaded assignment
operator accepting a <code >ComSet</code> object for its argument. In that case it's up
to the programmer to decide what the assignment operator will do with the
missing data.
<p>
<a name="l280"></a>
<h3 >13.7.2: Conversions with pointer assignments</h3>
            We return to our <code >Vehicle</code> classes, and define the following objects and
pointer variable:
        <pre>
    Land land(1200, 130);
    Car car(500, 75, "Daf");
    Truck truck(2600, 120, "Mercedes", 6000);
    Vehicle *vp;
</pre>
    Now we can assign the  addresses of the three objects of
the derived classes to the <code >Vehicle</code> pointer:
        <pre>
    vp = &amp;land;
    vp = &amp;car;
    vp = &amp;truck;
</pre>
    Each of these assignments is acceptable. However, an
    <a name="an1740"></a>implicit conversion of the <a name="an1741"></a>derived class to the <a name="an1742"></a>base class
<code >Vehicle</code> is used, since <code >vp</code> is defined as a pointer to a
<code >Vehicle</code>. Hence, when using <code >vp</code> only the member functions manipulating
<code >mass</code> can be called as this is the <code >Vehicle</code>'s <em >only</em> functionality.
As far as the compiler can tell this is the object <code >vp</code> points to.
<p>
The same holds true for <a name="an1743"></a> references to
<code >Vehicles</code>. If, e.g., a function is defined having a <code >Vehicle</code> reference
parameter, the function may be passed an object of a class derived from
<code >Vehicle</code>. Inside the function, the specific <code >Vehicle</code> members remain
accessible. This analogy between pointers and references holds true in
general. Remember that a reference is nothing but a <a name="an1744"></a>pointer in disguise: it
mimics a plain variable, but actually it is a pointer.
<p>
This restricted functionality has an important consequence
for the class <code >Truck</code>. Following  <code >vp = &amp;truck</code>, <code >vp</code> points to
a <code >Truck</code> object. So, <code >vp-&gt;mass()</code> returns 2600 instead of
8600 (the combined mass of the cabin and of the trailer: 2600 + 6000),
which would have been returned by <code >truck.mass()</code>.
<p>
When a function is called using a <a name="an1745"></a>pointer to an object, then the
    <a name="an1746"></a><em >type of the pointer</em> (and not the type of the object) determines
which
    <a name="an1747"></a> <a name="an1748"></a> member
functions are available and can be executed.  In other words, <strong >C++</strong>
implicitly converts the type of an object reached through a pointer to the
pointer's type.
<p>
If the actual type of the object pointed to by a pointer is known, an
explicit type cast can be used to access the full set of member functions
that are available for the object: <a name="an1749"></a>
        <pre>
    Truck truck;
    Vehicle *vp;

    vp = &amp;truck;        // vp now points to a truck object

    Truck *trp;

    trp = static_cast&lt;Truck *&gt;(vp);
    cout &lt;&lt; "Make: " &lt;&lt; trp-&gt;name() &lt;&lt; '\n';
</pre>
    Here, the second to last statement specifically casts a <code >Vehicle *</code>
variable to a <code >Truck *</code>. As usual (when using casts), this code
is not without risk. It <em >only</em> works  if <code >vp</code> really points to a
<code >Truck</code>. Otherwise the program may produce unexpected results.
<p>
<a name="NONDEFINIT"></a><a name="l281"></a>
<h2 >13.8: Using non-default constructors with new[]</h2>
    An often heard complaint is that operator <code >new[]</code> calls the default
constructor
 <a name="an1750"></a> of a class to initialize the
allocated objects. For example, to allocate an array of 10 strings we can do
        <pre>
    new string[10];
</pre>
    but it is not possible to use another constructor. Assuming that we'd want
to initialize the strings with the text <code >hello world</code>, we can't write
something like:
        <pre>
    new string("hello world")[10];
</pre>
    The initialization of a dynamically allocated object usually consists of a
two-step process: first the array is allocated (implicitly calling the default
constructor); second the array's elements are initialized, as in the following
little example:
        <pre>
    string *sp = new string[10];
    fill(sp, sp + 10, string("hello world"));
</pre>
    These approaches all suffer from `<a name="an1751"></a>double initializations', comparable
to not using member initializers in constructors.
<p>
One way to avoid double initialization is to use inheritance.
Inheritance can profitably be used to call non-default constructors in
combination with operator <code >new[]</code>. The approach capitalizes on the
following:
    <ul>
    <li> A base class pointer may point to a derived class object;
    <li> A derived class without (non-static)
            <a name="an1752"></a>
            <a name="an1753"></a>
        data members has the same size as its base class.
    </ul>
<p>
The above also suggests a possible approach:
    <ul>
    <li> Derive a simple, member-less class from the class we're interested
in;
    <li> Use the appropriate base class initializer in its default
constructor;
    <li> Allocate the required number of derived class objects, and assign
<code >new[]</code>'s return expression to a pointer to base class objects.
    </ul>
    Here is a simple example, producing 10 lines containing
the text <code >hello world</code>:
        <pre>
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;
#include &lt;iterator&gt;

using namespace std;

struct Xstr: public string
{
    Xstr()
    :
        string("hello world")
    {}
};

int main()
{
    string *sp = new Xstr[10];
    copy(sp, sp + 10, ostream_iterator&lt;string&gt;{ cout, "\n" });
}
</pre>
    Of course, the above example is fairly unsophisticated, but it's easy to
polish the example: the class <code >Xstr</code> can be defined in
an anonymous namespace, accessible only to a function <code >getString()</code> which
may be given a <code >size_t nObjects</code> parameter, allowing users to specify the
number of <code >hello world</code>-initialized strings they would like to allocate.
<p>
Instead of hard-coding the base class arguments it's also possible to use
variables or functions providing the appropriate values for the base class
constructor's arguments. In the next example a
    <a name="an1754"></a><em >local class</em><a name="an1755"></a> <code >Xstr</code> is defined inside a function
<code >nStrings(size_t nObjects, char const *fname)</code>, expecting the number of
<code >string</code> objects to allocate and the name of a file whose subsequent lines
are used to initialize the objects. The local class
is invisible outside of the function <code >nStrings</code>, so no special namespace
safeguards are required.
<p>
As discussed in section <a href="cplusplus07.html#LOCAL">7.9</a>, members of local classes cannot access
local variables from their surrounding function. However, they can access
global and static data defined by the surrounding function.
<p>
Using a local class neatly allows us to hide the implementation details
within the function <code >nStrings</code>, which simply opens the file, allocates the
objects, and closes the file again. Since the local class is derived from
<code >string</code>, it can use any <code >string</code> constructor for its base class
initializer. In this particular case it calls the <code >string(char const *)</code>
constructor, providing it with subsequent lines of the just opened stream via
its static member function <code >nextLine()</code>. This latter function is, as it is a
static member function, available to <code >Xstr</code> default constructor's member
initializers even though no <code >Xstr</code> object is available by that time.
        <pre>
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;
#include &lt;iterator&gt;

using namespace std;

string *nStrings(size_t size, char const *fname)
{
    static thread_local ifstream in;

    struct Xstr: public string
    {
        Xstr()
        :
            string(nextLine())
        {}
        static char const *nextLine()
        {
            static string line;

            getline(in, line);
            return line.c_str();
        }
    };
    in.open(fname);
    string *sp = new Xstr[size];
    in.close();

    return sp;
}

int main()
{
    string *sp = nStrings(10, "nstrings.cc");
    copy(sp, sp + 10, ostream_iterator&lt;string&gt;{ cout, "\n" });
}
</pre>
    When this program is run, it displays the first 10 lines of the file
<code >nstrings.cc</code>.
<p>
Note that the example defines a <code >static thread_local ifstream</code>
object. Thread_local variables are formally introduced in chapter
<a href="cplusplus20.html#THREADING">20</a>. The <code >thread_local</code> specification assures that the function
can safely be used, even in multithreaded programs.
<p>
A completely different way to avoid the double initialization (not using
inheritance) is to use placement new (cf. section <a href="cplusplus09.html#PLACEMENT">9.1.5</a>): simply
allocate the required amount of memory followed by the proper in-place
allocation of the objects, using the appropriate constructors. In the next
example a pair of static <code >construct/destroy</code> members are used to perform the
required initialization. In the example <code >construct</code> expects an <code >istream</code>
that provides the initialization strings for objects of a class <code >String</code>
simply containing a <code >std::string</code> object. <code >Construct</code> first allocates
enough memory for the <code >n</code> <code >String</code> objects plus room for an initial
<code >size_t</code> value. This initial <code >size_t</code> value is then initialized with
<code >n</code>. Next, in a <code >for</code> statement, lines are read from the provided stream
and the lines are passed to the constructors, using placement new
calls. Finally the address of the first <code >String</code> object is returned. Then,
the destruction of the objects is handled by the member <code >destroy</code>. It
retrieves the number of objects to destroy from the <code >size_t</code> it finds just
before the location of the address of the first object to destroy. The objects
are then destroyed by explicitly calling their destructors. Finally the raw
memory, originally allocated by <code >construct</code> is returned.
        <pre>
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

class String
{
    union Ptrs
    {
        void *vp;
        String *sp;
        size_t *np;
    };

    std::string d_str;

    public:
        String(std::string const &amp;txt)
        :
            d_str(txt)
        {}
        ~String()
        {
            cout &lt;&lt; "destructor: " &lt;&lt; d_str &lt;&lt; '\n';
        }
        static String *construct(istream &amp;in, size_t n)
        {
            Ptrs p = {operator new(n * sizeof(String) + sizeof(size_t))};
            *p.np++ = n;

            string line;
            for (size_t idx = 0; idx != n; ++idx)
            {
                getline(in, line);
                new(p.sp + idx) String{ line };
            }

            return p.sp;
        }
        static void destroy(String *sp)
        {
            Ptrs p = {sp};
            --p.np;
            for (size_t n = *p.np; n--; )
                sp++-&gt;~String();

            operator delete(p.vp);
        }
};

int main()
{
    String *sp = String::construct(cin, 5);

    String::destroy(sp);
}

/*
    After providing 5 lines containing, respectively
        alpha, bravo, charley, delta, echo
    the program displays:
                destructor: alpha
                destructor: bravo
                destructor: charley
                destructor: delta
                destructor: echo
*/
</pre>
<p>

<hr>
<ul>
    <li> <a href="cplusplus.html">Table of Contents</a>
    <li> <a href="cplusplus12.html">Previous Chapter</a>
    <li> <a href="cplusplus14.html">Next Chapter</a>
</ul>
<hr>
</body>
</html>
