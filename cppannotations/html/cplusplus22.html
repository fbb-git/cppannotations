<!DOCTYPE html><html><head>
<meta charset="UTF-8">
<title> C++ Annotations Version 10.6.0 </title>
<link rel="stylesheet" type="text/css" href="cplusplus.css"><style type="text/css">
    figure {text-align: center;}
    img {vertical-align: center;}
</style>
<link rel="stylesheet" type="text/css" href="cplusplus.css"></head>
<body >
<hr>
<ul>
    <li> <a href="cplusplus.html">Table of Contents</a>
    <li> <a href="cplusplus21.html">Previous Chapter</a>
    <li> <a href="cplusplus23.html">Next Chapter</a>
</ul>
<hr>
<a name="TEMPCLASS"></a><a name="l527"></a>
<h1 >Chapter 22: Class Templates</h1>
Templates can not only be constructed for functions but also for complete
classes. Consider constructing a <a name="an2855"></a>class template when a class should be able
to handle different types of data. Class templates are frequently used in
<strong >C++</strong>: chapter <a href="cplusplus12.html#CONTAINERS">12</a> discusses data structures like <code >vector,
stack</code> and <code >queue</code>, that are implemented as <em >class templates</em>. With class
templates, the algorithms and the data on which the algorithms operate are
completely separated from each other. To use a particular data structure in
combination with a particular data type only the data type needs to be
specified when defining or declaring a class template object (as in
<code >stack&lt;int&gt; iStack</code>).
<p>
In this chapter constructing and using class templates is discussed. In a
sense, class templates compete with object oriented programming (cf. chapter
<a href="cplusplus14.html#POLYMORPHISM">14</a>), that uses a mechanism resembling that of
templates. Polymorphism allows the programmer to postpone the implementation
of algorithms by deriving classes from base classes in which algorithms are
only partially implemented. The actual definition and processing of the data
upon which the algorithms operate may be postponed until derived classes are
defined. Likewise, templates allow the programmer to postpone the
specification of the data upon which the algorithms operate. This is most
clearly seen with abstract containers, which completely specify the algorithms
and at the same time leave the data type on which the algorithms operate
completely unspecified. 
<p>
There exists an intriguing correspondence between the kind of polymorphism
we've encountered in chapter <a href="cplusplus14.html#POLYMORPHISM">14</a> and certain uses of class
templates.  In their book <strong >C++ Coding Standards</strong> (Addison-Wesley, 2005)
        <a name="an2856"></a><a name="an2857"></a>
    Sutter and Alexandrescu refer to
        <a name="an2858"></a><em >static polymorphism</em><a name="an2859"></a> and
        <a name="an2860"></a> <a name="an2861"></a><em >dynamic polymorphism</em>.
    <em >Dynamic</em> polymorphism is what we use when overriding virtual members.
Using <em >vtable</em>s the function that is actually called depends on the type of
object a (base) class pointer points at. <em >Static</em> polymorphism is
encountered in the context of templates, and is discussed and compared to
dynamic polymorphism in section <a href="cplusplus22.html#STATICPOLY">22.12</a>.
<p>
Generally, class templates are easier to use than polymorphism. It is
certainly easier to write <code >stack&lt;int&gt; istack</code> to create a stack of <code >ints</code>
than to derive a new class <code >Istack: public stack</code> and to implement all
necessary member functions defining a similar stack of <code >ints</code> using object
oriented programming. On the other hand, for each different type for which an
object of a class template is defined another, possibly complete class must be
reinstantiated.  This is not required in the context of object oriented
programming where derived classes <em >use</em>, rather than <em >copy</em>, the functions
that are already available in their base classes (but see also section
<a href="cplusplus22.html#DERIVEDTEMPCLASS">22.11</a>).
<p>
Previously we've already used class templates. Objects like <code >vector&lt;int&gt; vi</code>
and <code >vector&lt;string&gt; vs</code> are commonly used. The data types for which these
templates are defined and instantiated are an inherent part of such container
types. It is stressed that it is the <em >combination</em> of a class template type
and its template parameter(s), rather than the mere class template's type
that defines or generates a
 <a name="an2862"></a> type. So <code >vector&lt;int&gt;</code> is a type as is
<code >vector&lt;string&gt;</code>. Such types could very well be represented by typedefs:
        <pre>
    typedef std::vector&lt;int&gt;         IntVector;
    typedef std::vector&lt;std::string&gt; StringVector;

    IntVector vi;
    StringVector vs;
</pre>
<p>
<a name="TEMPCLASSDEF"></a><a name="l528"></a>
<h2 >22.1: Defining class templates</h2>
Having covered the construction of function templates, we're now ready for the
next step: constructing class templates. Many useful class templates already
exist. Rather than illustrating the construction of a class template by
looking at an already existing class template the construction of another
potentially useful new class template will be undertaken.
<p>
The new class implements a <a name="an2863"></a><em >circular queue</em>.  A circular queue has a fixed
number of <code >max_size</code> elements. New elements are inserted at its back and
only its head and tail elements can be accessed. Only the head element can be
removed from a circular queue. Once <code >n</code> elements have been appended the next
element is inserted again at the queue's (physical) first position. The
circular queue allows insertions until it holds <code >max_size</code> elements. As long
as a circular queue contains at least one element elements may be removed from
it. Trying to remove an element from an empty circular queue or to add another
element to a full circular queue results in exceptions being thrown. In
addition to other constructors a circular queue must offer a constructor
initializing its objects for <code >max_size</code> elements. This constructor must make
available the memory for the <code >max_size</code> elements but must not call those
elements default constructors (hinting at the use of the placement <code >new</code>
operator). A circular queue should offer value semantics as well as a move
constructor.
<p>
Please note that in the above description the actual data type that is used
for the circular queue is nowhere mentioned. This is a clear indication that
our class could very well be defined as a
 <a name="an2864"></a><a name="an2865"></a><em >class template</em>. Alternatively, the class could be
defined for some concrete data type which is then abstracted when converting
the class to a class template.
<p>
The actual construction of a class template is provided in the next section,
where the class template <code >CirQue</code> (circular queue) is developed.
<p>
<a name="l529"></a>
<h3 >22.1.1: Constructing the circular queue: CirQue</h3>
    The construction of a class template is illustrated in this section. Here,
we'll develop the class template <code >CirQue</code> (circular queue). This class
template has one template type parameter, <code >Data</code>, representing the data type
that is stored in the circular queue. The outline of the interface of this
class template looks like this:
    <a name="an2866"></a>
        <pre>
    template&lt;typename Data&gt;
    class CirQue
    {
        // member declarations
    };
</pre>
    A class template's definition starts like a function template's
definition:
    <ul>
    <li> The keyword <a name="an2867"></a><code >template</code>, starting a template definition or
declaration.
    <li> The angle bracket enclosed list following <code >template</code>: a
list containing one or more comma-separated elements is called the
 <a name="an2868"></a><em >template parameter list</em>. Template parameter lists may have multiple
elements, like this:
        <pre>
    typename Type1, typename Type2, typename Type3
</pre>
    When a class template defines multiple template type parameters they are
matched in sequence with the list of template type arguments provided when
defining objects of such a class template. Example:
        <pre>
template &lt;typename Type1, typename Type2, typename Type3&gt;
class MultiTypes
{
    ...
};

MultiTypes&lt;int, double, std::string&gt; multiType;
    // Type1 is int, Type2 is double, Type3 is std::string
</pre>
    <li> Inside the template parameter list we find the <a name="an2869"></a><em >formal type</em> name
(<code >Data</code> for <code >CirQue</code>). It is a formal (type) name, like the formal types
used in function template parameter lists.
    <li> Following the template header the class interface is defined. It may
use the formal type names defined in the template header as type names.
    </ul>
    Once the <code >CirQue</code> class template has been defined it can be used to
create all kinds of circular queues. As one of its constructors expects a
<code >size_t</code> argument defining the maximum number of elements that can be stored
in the circular queue, circular queues could be defined like this:
        <pre>
    CirQue&lt;int&gt; cqi(10);            // max 10 ints
    CirQue&lt;std::string&gt; cqstr(30);  // max 30 strings
</pre>
    As noted in the introductory section of this chapter the combination of
name of the class template and the data type for which it is instantiated
defines a data type. Also note the similarity between defining a
<code >std::vector</code> (of some data type) and a <code >CirQue</code> (of some data type).
<p>
Like <code >std::map</code> containers class templates may be defined with multiple
template type parameters.
<p>
Back to <code >CirQue</code>. A <code >CirQue</code> must be capable of storing <code >max_size</code>
<code >Data</code> elements. These elements are eventually stored in memory pointed at
by a pointer <code >Data *d_data</code>, initially pointing to raw memory. New elements
are added at the backside of the <code >CirQue</code>. A pointer <code >Data *d_back</code> is
used to point to the location where the next element is going to be
stored. Likewise, <code >Data *d_front</code> points to the location of the <code >CirQue</code>'s
first element. Two <code >size_t</code> data members are used to monitor the filling
state of the <code >CirQue</code>: <code >d_size</code> represents the number of elements
currently stored in the <code >CirQue</code>, <code >d_maxSize</code> represents the maximum
number of elements that the <code >CirQue</code> can contain. Thus, the <code >CirQue</code>'s
data members are:
    <pre>
    size_t d_size;
    size_t d_maxSize;
    Data *d_data;
    Data *d_front;
    Data *d_back;
</pre>
<p>
<a name="l530"></a>
<h3 >22.1.2: Non-type parameters</h3>
    Function template parameters are either template type parameters or template
non-type parameters (actually, a third type of template parameter exists, the
<em >template template parameter</em>, which is discussed in chapter
<a href="cplusplus23.html#ADVANCEDTEMPL">23</a> (section <a href="cplusplus23.html#TEMPTEMPPAR">23.4</a>)).
<p>
Class templates <a name="an2870"></a> may also define
non-type parameters. Like the function template non-type parameters they must
be (integral) constants whose values must be known at object instantiation
time.
<p>
Different from function template non-type parameters the values of class
template non-type parameters are <em >not</em> deduced by the compiler using
arguments passed to class template members.
<p>
Assume we extend our design of the class template <code >CirQue</code> so that it
defines a second (non-type) parameter <code >size_t Size</code>. Our intent is to use
this <code >Size</code> parameter in the constructor defining an array parameter of
<code >Size</code> elements of type <code >Data</code>.
<p>
The  <code >CirQue</code> class template now becomes (only showing the relevant
constructor):
        <pre>
    template &lt;typename Data, size_t Size&gt;
    class CirQue
    {
        // ... data members
        public:
            CirQue(Data const (&amp;arr)[Size]);
            ...
    };

    template &lt;typename Data, size_t Size&gt;
    CirQue&lt;Data, Size&gt;::CirQue(Data const (&amp;arr)[Size])
    :
        d_maxSize(Size),
        d_size(0),
        d_data(operator new(Size * sizeof(Data))),
        d_front(d_data),
        d_back(d_data),
    {
        std::copy(arr, arr + Size, back_inserter(*this));
    }
</pre>
    Unfortunately, this setup doesn't satisfy our needs as  the values of
template non-type parameters are not deduced by the compiler. When the
compiler is asked to compile the following <code >main</code> function it reports a
mismatch between the required and actual number of template parameters:
        <pre>
    int main()
    {
        int arr[30];

        CirQue&lt;int&gt; ap(arr);
    }
    /*
        Error reported by the compiler:

        In function `int main()':
            error: wrong number of template arguments (1, should be 2)
            error: provided for `template&lt;class Data, size_t Size&gt;
                   class CirQue'
    */
</pre>
    Defining <code >Size</code> as a non-type parameter having a default value doesn't
work either. The compiler always uses the default unless its value is
explicitly specified. Reasoning that <code >Size</code> can be 0 unless we need another
value, we might be tempted to specify <code >size_t Size = 0</code> in the template's
parameter type list.  Doing so we create  a mismatch between the default
value 0 and the actual size of the array <code >arr</code> as defined in the above
<code >main</code> function. The compiler, using the default value, reports:
        <pre>
    In instantiation of `CirQue&lt;int, 0&gt;':
    ...
    error: creating array with size zero (`0')
</pre>
    So, although class templates may use non-type parameters they must always
be specified like type parameters when an object of that class is
defined. Default values can be specified for those non-type parameters causing
the compiler to use the default when the non-type parameter is left
unspecified.
<p>
<a name="an2871"></a> Default template parameter values
(either type or non-type template parameters) may <em >not</em> be specified when
defining template member functions. In general: function template definitions
(and thus: class template member functions) may not be given default template
(non) type arguments. If default template arguments are to be used for class
template members, they <em >have</em> to be specified by the class interface.
<p>
Similar to non-type parameters of function templates default argument
values for non-type class template parameters may only be specified as
constants:
    <ul>
    <li> Global <a name="an2872"></a> variables have constant addresses, which
can be used as arguments for non-type parameters.
    <li> Local <a name="an2873"></a> and <a name="an2874"></a>dynamically allocated variables have
addresses that are <em >not</em> known by the compiler when the source file is
compiled. These addresses can therefore <em >not</em> be used as arguments for
non-type parameters.
    <li> Lvalue <a name="an2875"></a> transformations are allowed: if a
pointer is defined as a non-type parameter, an array name may be specified.
    <li> <a name="an2876"></a> Qualification <a name="an2877"></a>
conversions are allowed: a pointer to a non-const object may be used with a
non-type parameter defined as a <code >const</code> pointer.
    <li> Promotions <a name="an2878"></a> are allowed: a constant of a `narrower'
data type may be used when specifying a default argument for a non-type
parameter of a `wider' type (e.g., a <code >short</code> can be used when an <code >int</code> is
called for, a <code >long</code> when a <code >double</code> is called for).
    <li> Integral <a name="an2879"></a> conversions are allowed: if a
<code >size_t</code> parameter is specified, an <code >int</code> may be used as well.
    <li> Variables cannot be used to specify template non-type parameters as
their values are not constant expressions. Variables defined using the
<code >const</code> modifier, however, may be used as their values never change.
    </ul>
<p>
Although our attempts to define a constructor of the class <code >CirQue</code>
accepting an array as its argument has failed so far, we're not yet out of
options. In the next section a method is described that <em >does</em> allow us
to reach our goal.
<p>
<a name="MEMTEMP"></a><a name="l531"></a>
<h3 >22.1.3: Member templates</h3>
    Our previous attempt to define a template non-type parameter that is
initialized by the compiler to the number of elements of an array failed
because the template's parameters are not implicitly deduced when a
constructor is called. Instead, they must explicitly be specified when an
object of the class template is defined. As the template arguments are
specified just before the template's constructor is called the compiler
doesn't have to deduce anything and it can simply use the explicitly specified
template arguments.
<p>
In contrast, when <em >function</em> templates are used, the actual template
parameters are deduced from the arguments used when calling the function. This
opens up an alley leading to the solution of our problem. If the constructor
itself is turned into a function template (having its own template header),
then the compiler <em >will</em> be able to deduce the non-type parameter's value
and there is no need anymore to specify it explicitly using a class template
non-type parameter.
<p>
Members (functions or nested classes) of class templates that are themselves
templates are called
        <a name="an2880"></a>
        <a name="an2881"></a>
 <em >member templates</em>.
<p>
Member templates are defined as any other template, including its own template
header.
<p>
When converting our earlier <code >CirQue(Data const (&amp;array)[Size])</code> constructor
into a member template the class template's <code >Data</code> type parameter can still
be used, but we must provide the member template with a non-type parameter of
its own. Its declaration in the (partially shown) class interface looks like
this:
        <pre>
    template &lt;typename Data&gt;
    class CirQue
    {
        public:
            template &lt;size_t Size&gt;
            explicit CirQue(Data const (&amp;arr)[Size]);
    };
</pre>
    Its implementation becomes:
    <pre>
    template &lt;typename Data&gt;
    template &lt;size_t Size&gt;
    CirQue&lt;Data&gt;::CirQue(Data const (&amp;arr)[Size])
    :
        d_size(0),
        d_maxSize(Size),
        d_data(static_cast&lt;Data *&gt;(operator new(sizeof(arr)))),
        d_front(d_data),
        d_back(d_data)
    {
        std::copy(arr, arr + Size, back_inserter(*this));
    }
</pre>
<p>
The implementation uses the STL's <code >copy</code> algorithm and a
<code >back_inserter</code> adapter to insert the array's elements into the
<code >CirQue</code>. To use the <code >back_inserter</code> <code >CirQue</code> must define two (public)
<code >typedef</code>s (cf. section <a href="cplusplus18.html#INSERTER">18.2.2</a>):
    <pre>
    typedef Data value_type;
    typedef value_type const &amp;const_reference;
</pre>
<p>
Member templates have the following characteristics:
    <ul>
    <li> Two <code >template</code>
            <a name="an2882"></a>
     headers must be used: the class template's <code >template</code>
header is specified first followed by the member template's template header;
    <li> Normal access rules apply: the member template can be
used by programs to construct an <code >CirQue</code> object of a given data
type. As usual for class templates, the data type must be specified when the
object is constructed. To construct a <code >CirQue</code> object from the array
<code >int array[30]</code> we define:
        <pre>
CirQue&lt;int&gt; object(array);
</pre>
    <li> Any member can be defined as a member template, not just a
constructor;
    <li> When a template member is implemented below its class interface, the
template class header must precede the function template header of the member
template;
    <li> The implementation of the member template must specify its proper
scope.  The member template is defined as a member of the class <code >CirQue</code>,
instantiated for the formal template parameter type <code >Data</code>;
    <li> The template parameter names in the declaration and
implementation must be identical;
    <li> The member template should be defined inside its proper namespace
environment. The organization of files defining class templates within a
namespace should therefore be:
        <pre>
namespace SomeName
{
    template &lt;typename Type, ...&gt;   // class template definition
    class ClassName
    {
        ...
    };

    template &lt;typename Type, ...&gt;   // non-inline member definition(s)
    ClassName&lt;Type, ...&gt;::member(...)
    {
        ...
    }
}                                   // namespace closes
</pre>
    </ul>
<p>
A potentially occurring problem remains. Assume that in addition to the
above member template a <code >CirQue&lt;Data&gt;::CirQue(Data const *data)</code> has been
defined. Some (here not further elaborated) protocol could be defined allowing
the constructor to determine the number of elements that should be stored in
the <code >CirQue</code> object. When we now define
        <pre>
    CirQue&lt;int&gt; object(array);
</pre>
    it is this latter constructor, rather than the member template, that the
compiler will use.
<p>
The compiler selects this latter constructor as it is a more specialized
version of a constructor of the class <code >CirQue</code> than the member template
(cf. section <a href="cplusplus21.html#FUNCTIONSELECTION">21.14</a>). Problems like these can be solved by
defining the constructor <code >CirQue(Data const *data)</code> into a member template
as well or by defining a constructor using two parameters, the second
parameter defining the number of elements to copy.
<p>
When using the former constructor (i.e., the member template) it must define a
template type parameter <code >Data2</code>. Here `<code >Data</code>' cannot be used as template
parameters of a member template may not shadow
    <a name="an2883"></a> template parameters of its
class. Using <code >Data2</code> instead of <code >Data</code> takes care of this subtlety. The
following declaration of the constructor <code >CirQue(Data2 const *)</code> could
appear in <code >CirQue</code>'s header file:
        <pre>
    template &lt;typename Data&gt;
    class CirQue
    {
        template &lt;typename Data2&gt;
        explicit CirQue(Data2 const *data);
    }
</pre>
    Here is how the two constructors are selected in code defining two
<code >CirQue</code> objects:
        <pre>
    int main()
    {
        int array[30];
        int *iPtr = array;

        CirQue&lt;int&gt; ac(array);      // calls CirQue(Data const (&amp;arr)[Size])
        CirQue&lt;int&gt; acPtr(iPtr);    // calls CirQue(Data2 const *)
    }
</pre>
<p>
<a name="l532"></a>
<h3 >22.1.4: CirQue's constructors and member functions</h3>
        It's time to return to <code >Cirque</code>'s design and construction again.
<p>
The class <code >CirQue</code> offers various member functions.  Normal design
principles should be adhered to when constructing class template
members. Class template type parameters should preferably be defined as
<code >Type const &amp;</code>, rather than <code >Type</code>, to prevent unnecessary copying of
large data structures. Template class constructors should use member
initializers rather than member assignment within the body of the
constructors. Member function definitions should preferably not be provided
in-class but below the class interface. Since class template member functions
are function templates their  definitions should be provided in the header
file offering the class interface. They <em >may</em> be given the <code >inline</code>
attribute.
<p>
<code >CirQue</code> declares several constructors and (public) members (their
definitions are provided as well; all definitions are provided below the class
interface).
<p>
Here are the constructors and the destrctor:
<p>
<ul>
    <li><code >explicit CirQue(size_t maxSize = 0)</code>:<blockquote >Constructor initializing a
        <code >CirQue</code> capable of storing <code >max_size Data</code> elements. As the
constructor's parameter is given a default argument value this constructor can
also be used as a default constructor, allowing us to define, e.g., vectors of
<code >CirQue</code>s.  The constructor initializes the <code >Cirque</code> object's <code >d_data</code>
member to a block of raw memory and <code >d_front</code> and <code >d_back</code> are initialized
to <code >d_data</code>. As class template member functions are themselves function
templates their implementations outside of the class template's interface must
start with the class template's template header. Here is the implementation of
the <code >CirQue(size_t)</code> constructor:
        <pre>
    template&lt;typename Data&gt;
    CirQue&lt;Data&gt;::CirQue(size_t maxSize)
    :
        d_size(0),
        d_maxSize(maxSize),
        d_data(
            maxSize == 0 ?
                0
            :
                static_cast&lt;Data *&gt;(
                            operator new(maxSize * sizeof(Data)))
        ),
        d_front(d_data),
        d_back(d_data)
    {}
</pre>
<p>
</blockquote>
<p>
<li><code >CirQue(CirQue&lt;Data&gt; const &amp;other)</code>:<blockquote >The copy constructor has no
special features. It uses a private support member <code >inc</code> to increment
<code >d_back</code> (see below) and placement new to copy the other's <code >Data</code> elements
to the current object. The implementation of the copy constructor is
straightforward:
        <pre>
    template&lt;typename Data&gt;
    CirQue&lt;Data&gt;::CirQue(CirQue&lt;Data&gt; const &amp;other)
    :
        d_size(other.d_size),
        d_maxSize(other.d_maxSize),
        d_data(
            d_maxSize == 0 ?
                0
            :
                static_cast&lt;Data *&gt;(
                    operator new(d_maxSize * sizeof(Data)))
        ),
        d_front(d_data + (other.d_front - other.d_data))
    {
        Data const *src = other.d_front;
        d_back = d_front;
        for (size_t count = 0; count != d_size; ++count)
        {
            new(d_back) Data(*src);
            d_back = inc(d_back);
            if (++src == other.d_data + d_maxSize)
                src = other.d_data;
        }
    }
</pre>
<p>
</blockquote>
<p>
<li><code >CirQue(CirQue&lt;Data&gt; &amp;&amp;tmp)</code>:<blockquote >The move constructor merely
initializes the current object's <code >d_data</code> pointer to 0 and swaps (see the
member <code >swap</code>, below) the temporary object with the current
object. <code >CirQue</code>'s destructor inspects <code >d_data</code> and immediately
returns when it's zero. Implementation:
        <pre>
    template&lt;typename Data&gt;
    CirQue&lt;Data&gt;::CirQue(CirQue&lt;Data&gt; &amp;&amp;tmp)
    :
        d_data(0)
    {
        swap(tmp);
    }
</pre>
<p>
</blockquote>
<p>
<li><code >CirQue(CirQue(Data const (&amp;arr)[Size]))</code>:<blockquote >This constructor is declared
as a member template, providing the <code >Size</code> non-type parameter. It allocates
room for <code >Size</code> data elements and copies <code >arr</code>'s contents to the newly
allocated memory.Implementation:
        <pre>
    template &lt;typename Data&gt;
    template &lt;size_t Size&gt;
    CirQue&lt;Data&gt;::CirQue(Data const (&amp;arr)[Size])
    :
        d_size(0),
        d_maxSize(Size),
        d_data(static_cast&lt;Data *&gt;(operator new(sizeof(arr)))),
        d_front(d_data),
        d_back(d_data)
    {
        std::copy(arr, arr + Size, back_inserter(*this));
    }
</pre>
<p>
</blockquote>
<p>
<li><code >CirQue(CirQue(Data const *data, size_t size))</code>:<blockquote >This constructor acts
very much like the previous one, but is provided with a pointer to the first
<code >Data</code> element and with a <code >size_t</code> providing the number of elements to
copy. In our current design the member template variant of this constructor is
left out of the design. As the implementation of this constructor is very
similar to that of the previous constructor, it is left as an exercise to the
reader.
    </blockquote>
<p>
<li><code >~CirQue()</code>:<blockquote >The destructor inspects the <code >d_data</code> member. If it is
zero then nothing has been allocated and the destructor immediately
returns. This may occur in two situations: the circular queue contains no
elements or the information was grabbed from a temporary object by some move
operation, setting the temporary's <code >d_data</code> member to zero. Otherwise
<code >d_size</code> elements are destroyed by explicitly calling their destructors
followed by returning the element's raw memory to the common
pool. Implementation:
        <pre>
    template&lt;typename Data&gt;
    CirQue&lt;Data&gt;::~CirQue()
    {
        if (d_data == 0)
            return;
        for (; d_size--; )
        {
            d_front-&gt;~Data();
            d_front = inc(d_front);
        }
        operator delete(d_data);
    }
</pre>
<p>
</blockquote>
    </ul>
<p>
Here are <code >Cirque</code>'s members:
    <ul>
    <li><code >CirQue &amp;operator=(CirQue&lt;Data&gt; const &amp;other)</code>:<blockquote >The copy assignment
        operator has a  standard implementation:
        <pre>
    template&lt;typename Data&gt;
    CirQue&lt;Data&gt; &amp;CirQue&lt;Data&gt;::operator=(CirQue&lt;Data&gt; const &amp;rhs)
    {
        CirQue&lt;Data&gt; tmp(rhs);
        swap(tmp);
        return *this;
    }
</pre>
<p>
</blockquote>
    <li><code >CirQue &amp;operator=(CirQue&lt;Data&gt; &amp;&amp;tmp)</code>:<blockquote >The move assignment
        operator also has a standard implementation. As its implementation
        merely calls <code >swap</code> it is defined as an inline function template:
        <pre>
    template&lt;typename Data&gt;
    inline CirQue&lt;Data&gt; &amp;CirQue&lt;Data&gt;::operator=(CirQue&lt;Data&gt; &amp;&amp;tmp)
    {
        swap(tmp);
        return *this;
    }
</pre>
<p>
</blockquote>
    <li><code >void pop_front()</code>:<blockquote >removes the element pointed at by <code >d_front</code> from
        the <code >CirQue</code>.  Throws an exception if the <code >CirQue</code> is empty. The
        exception is thrown as a <code >CirQue&lt;Data&gt;::EMPTY</code> value, defined by the
        <code >enum CirQue&lt;Data&gt;::Exception</code> (see <code >push_back</code>). The
        implementation is straightforward (explicitly calling the destructor
        of the element that is removed):
       <pre>
    template&lt;typename Data&gt;
    void CirQue&lt;Data&gt;::pop_front()
    {
        if (d_size == 0)
            throw EMPTY;

        d_front-&gt;~Data();
        d_front = inc(d_front);
        --d_size;
    }
</pre>
<p>
</blockquote>
    <li><code >void push_back(Data const &amp;object)</code>:<blockquote >adds another element to the
        <code >CirQue</code>.  Throws a <code >CirQue&lt;Data&gt;::FULL</code> exception if the
        <code >CirQue</code> is full. The exceptions that can be thrown by a <code >CirQue</code>
        are defined in its <code >Exception</code> enum:
       <pre>
    enum Exception
    {
        EMPTY,
        FULL
    };
</pre>
<p>
A copy of <code >object</code> is installed in the <code >CirQue</code>'s raw memory using
        placement <code >new</code> and its <code >d_size</code> is incremented.
       <pre>
    template&lt;typename Data&gt;
    void CirQue&lt;Data&gt;::push_back(Data const &amp;object)
    {
        if (d_size == d_maxSize)
            throw FULL;

        new (d_back) Data(object);
        d_back = inc(d_back);
        ++d_size;
    }
</pre>
<p>
</blockquote>
    <li><code >void swap(CirQue&lt;Data&gt; &amp;other)</code>:<blockquote >swaps the current <code >CirQue</code> object
        with another <code >CirQue&lt;Data&gt;</code> object;
       <pre>
    template&lt;typename Data&gt;
    void CirQue&lt;Data&gt;::swap(CirQue&lt;Data&gt; &amp;other)
    {
        char tmp[sizeof(CirQue&lt;Data&gt;)];
        memcpy(tmp, &amp;other, sizeof(CirQue&lt;Data&gt;));
        memcpy(&amp;other, this, sizeof(CirQue&lt;Data&gt;));
        memcpy(this, tmp, sizeof(CirQue&lt;Data&gt;));
    }
</pre>
<p>
</blockquote>
</ul>
    The remaining public members all consist of one-liners and were
implemented as inline function templates:
    <ul>
    <li><code >Data &amp;back()</code>:<blockquote >returns a reference to the element pointed at by
        <code >d_back</code> (undefined result if the <code >CirQue</code> is empty):
       <pre>
    template&lt;typename Data&gt;
    inline Data &amp;CirQue&lt;Data&gt;::back()
    {
        return d_back == d_data ? d_data[d_maxSize - 1] : d_back[-1];
    }
</pre>
<p>
</blockquote>
    <li><code >Data &amp;front()</code>:<blockquote >returns reference to the element pointed at by
        <code >d_front</code> (undefined result if the <code >CirQue</code> is empty);
       <pre>
    template&lt;typename Data&gt;
    inline Data &amp;CirQue&lt;Data&gt;::front()
    {
        return *d_front;
    }
</pre>
<p>
</blockquote>
    <li><code >bool empty() const</code>:<blockquote >returns <code >true</code> if the <code >CirQue</code> is empty;
       <pre>
    template&lt;typename Data&gt;
    inline bool CirQue&lt;Data&gt;::empty() const
    {
        return d_size == 0;
    }
</pre>
<p>
</blockquote>
    <li><code >bool full() const</code>:<blockquote >returns <code >true</code> if the <code >CirQue</code> is full;
       <pre>
    template&lt;typename Data&gt;
    inline bool CirQue&lt;Data&gt;::full() const
    {
        return d_size == d_maxSize;
    }
</pre>
<p>
</blockquote>
    <li><code >size_t size() const</code>:<blockquote >returns the number of elements currently stored
        in the  <code >CirQue</code>;
       <pre>
    template&lt;typename Data&gt;
    inline size_t CirQue&lt;Data&gt;::size() const
    {
        return d_size;
    }
</pre>
<p>
</blockquote>
    <li><code >size_t maxSize() const</code>:<blockquote >returns the maximum number of elements that
        can be stored in the <code >CirQue</code>;
       <pre>
    template&lt;typename Data&gt;
    inline size_t CirQue&lt;Data&gt;::maxSize() const
    {
        return d_maxSize;
    }
</pre>
<p>
</blockquote>
</ul>
<p>
Finally, the class has one private member, <code >inc</code>, returning a
cyclically incremented pointer into <code >CirQue</code>'s raw memory:
       <pre>
    template&lt;typename Data&gt;
    Data *CirQue&lt;Data&gt;::inc(Data *ptr)
    {
        ++ptr;
        return ptr == d_data + d_maxSize ? d_data : ptr;
    }
</pre>
<p>
<a name="l533"></a>
<h3 >22.1.5: Using CirQue objects</h3>
        When objects of a class template are instantiated, <em >only</em> the
definitions of all the template's member functions that are actually used must
have been seen by the compiler.
<p>
That characteristic of templates could be refined to the point where each
definition is stored in a separate function template definition file. In that
case only the definitions of the function templates that are actually needed
would have to be included. However, it is hardly ever done that way. Instead,
the usual way to define class templates is to define the interface and to
define the remaining function templates immediately below the class template's
interface (defining some functions inline).
<p>
Now that the class <code >CirQue</code> has been defined, it can be used. To use the
class its object must be instantiated for a particular data type. In the
following example it is initialized for data type <code >std::string</code>:
        <pre>
#include "cirque.h"
#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

int main()
{
    CirQue&lt;string&gt; ci(4);
    ci.push_back("1");
    ci.push_back("2");
    cout &lt;&lt; ci.size() &lt;&lt; ' ' &lt;&lt; ci.front() &lt;&lt; ' ' &lt;&lt; ci.back() &lt;&lt; '\n';

    ci.push_back("3");
    ci.pop_front();
    ci.push_back("4");
    ci.pop_front();
    ci.push_back("5");
    cout &lt;&lt; ci.size() &lt;&lt; ' ' &lt;&lt; ci.front() &lt;&lt; ' ' &lt;&lt; ci.back() &lt;&lt; '\n';

    CirQue&lt;string&gt; copy(ci);
    copy.pop_front();
    cout &lt;&lt; copy.size() &lt;&lt; ' ' &lt;&lt; copy.front() &lt;&lt; ' ' &lt;&lt; copy.back() &lt;&lt; '\n';

    int arr[] = {1, 3, 5, 7, 9};
    CirQue&lt;int&gt; ca(arr);
    cout &lt;&lt; ca.size() &lt;&lt; ' ' &lt;&lt; ca.front() &lt;&lt; ' ' &lt;&lt; ca.back() &lt;&lt; '\n';

//    int *ap = arr;
//    CirQue&lt;int&gt; cap(ap);
}
</pre>
<p>
This program produces the following output:
        <pre>
    2 1 2
    3 3 5
    2 4 5
    5 1 9
</pre>
<p>
<a name="l534"></a>
<h3 >22.1.6: Default class template parameters</h3>
    Different from function templates, template parameters of template classes may
be given default argument
        <a name="an2884"></a> values.
    This holds true for both template type- and template non-type
parameters. If default template arguments were defined and if a class template
object is instantiated without specifying arguments for its template
parameters then the template parameter's defaults are used.
<p>
When defining defaults keep in mind that they should be suitable for the
majority of instantiations of the class. E.g., for the class template
<code >CirQue</code> the template's type parameter list could have been altered
by specifying <code >int</code> as its default type:
        <pre>
    template &lt;typename Data = int&gt;
</pre>
<p>
Even though default arguments can be specified, the compiler must still be
informed that object definitions refer to templates. When instantiating class
template objects using default template arguments the type specifications may
be omitted but the angle brackets must be retained. Assuming a default
type for the <code >CirQue</code> class, an object of that class may be defined
as:
        <pre>
    CirQue&lt;&gt; intCirQue(10);
</pre>
<p>
Default template arguments cannot be specified when defining template
members. So, the definition of, e.g., the <code >push_back</code> member must always
begin with the same <code >template</code> specification:
        <pre>
    template &lt;typename Data&gt;
</pre>
<p>
When a class template uses multiple template parameters, all may be given
default values. Like default function arguments, once a default value is used
all remaining template parameters must also use their default values. A
template type specification list may not start with a comma, nor may it
contain multiple consecutive commas.
<p>
<a name="DECLCLASSTEMP"></a><a name="l535"></a>
<h3 >22.1.7: Declaring class templates</h3>
        Class templates may also be <em >declared</em>. This may be useful in
situations where forward class declarations are required. To declare a
        <a name="an2885"></a>
    class template, simply remove its interface (the part between the curly
braces):
        <pre>
    template &lt;typename Data&gt;
    class CirQue;
</pre>
    Default <a name="an2886"></a> template arguments may also
be specified when declaring class templates. However, default template
arguments cannot be specified for both the declaration and the definition of a
class template. As a <a name="an2887"></a>rule of thumb default template arguments should be
omitted from <em >declarations</em>, as class template declarations are never used
when instantiating objects but are only occasionally used as forward
references. Note that this differs from default parameter value specifications
for member functions in ordinary classes. Such defaults are always specified
when declaring the member functions in the class interface.
<p>
<a name="l536"></a>
<h3 >22.1.8: Preventing template instantiations</h3>
    In <strong >C++</strong> templates
    <a name="an2888"></a>
 are instantiated when the address of a function template or class template
object is taken or when a function template or class template is used. As
described in section <a href="cplusplus22.html#DECLCLASSTEMP">22.1.7</a> it is possible to (forward) declare a
class template to allow the definition of a pointer or reference to
that template class or to allow it being used as a return type.
<p>
In other situations templates are instantiated when they are being used.  If
this happens many times (i.e., in many different source files) then this may
slow down the compilation process considerably. Furtunately, <strong >C++</strong> allows
programmers to <em >prevent</em> templates
    <a name="an2889"></a>
 from being instantiated, using the 
<a name="an2890"></a><code >extern template</code> syntax. Example:
        <pre>
    extern template class std::vector&lt;int&gt;;
</pre>
    Having declared the class template it can be used in its translation
unit. E.g., the following function  properly compiles:
        <pre>
#include &lt;vector&gt;
#include &lt;iostream&gt;
using namespace std;

extern template class vector&lt;int&gt;;

void vectorUser()
{
    vector&lt;int&gt; vi;
    cout &lt;&lt; vi.size() &lt;&lt; '\n';
}
</pre>
<p>
But be careful:
    <ul>
    <li> The declaration by itself does <em >not</em> make the class definition
available. The <code >vector</code> header file <em >still</em> needs to be included to make
the features of the class vector known to the compiler. But due to the
<code >extern template</code> declaration none of the used members will be instantiated
for the current compilation unit;
    <li> The compiler <em >assumes</em> (as it always does) that what is declared
has been implemented elsewhere. In this case the compiler encounters an
<em >implicit declaration</em>: the features of the vector class that are actually
used by the above program are not individually declared but they are declared
as a group, using the <a name="an2891"></a><code >extern template</code> declaration. This not only holds
true for explicitly used members but hidden members (copy constructors, move
constructors, conversion operators, constructors called during promotions, to
name a few): all are assumed by the compiler to have been instantiated
elsewhere;
    <li> Although the above source file <em >compiles</em>, the <em >instantiations</em>
of the templates must be available before the linker can build the final
program. To accomplish this one or more sourcefiles may be constructed in
which all required instantiations are made available.
<p>
In a stand-alone program one might postpone defining the required members
and wait for the linker to complain about unresolved external
references. These may then be used to create a series of instantiation
declarations which are then linked to the program to satisfy the linker. Not
a very simple task, though, as the declarations must strictly match the way
the members are declared in the class interface. An easier approach is to
define an <a name="an2892"></a><em >instantiation source</em> <em >file</em> in which all facilities that
are used by the program are actually instantiated in a function that is never
called by the program. By adding this <a name="an2893"></a>instantiation function to the source
file containing <code >main</code> we can be sure that all required members are
instantiated as well. Here is an example of how this can be done:
        <pre>
#include &lt;vector&gt;
#include &lt;iostream&gt;

extern void vectorUser();

int main()
{
    vectorUser();
}

// this part is never called. It is added to make sure all required
// features of declared templates will also be instantiated.

namespace
{
    void instantiator()
    {
        std::vector&lt;int&gt; vi;
        vi.size();
    }
}
</pre>
<p>
<li> Last, but certainly not least: a fully matching
        <a name="an2894"></a>instantiation declaration of a class template (e.g., for
<code >std::vector&lt;int&gt;</code>) looks like this:
            <pre>
template class std::vector&lt;int&gt;;
</pre>
    Adding this to a source file, however, will instantiate the <em >full
class</em>, i.e., all its members are now instantiated. This may not what you
want, as it might needlessly inflate your final executable.
    <li> On the other hand, if it is known that the required template members
have already been instantiated elsewhere, then an <a name="an2895"></a><em >extern template</em>
declaration can be used to prevent member instantiations in the current
compilation unit, which may speed up compilation. E.g.,
        <pre>
        // the compiler assumes that required members of
        // vector&lt;int&gt; have already been instantiated elsewhere
extern template class std::vector&lt;int&gt;;

int main()
{
    std::vector&lt;int&gt; vi(5);     // constructor and operator[]
    ++vi[0];                    // are NOT instantiated
}
</pre>
    </ul>
<p>
<a name="l537"></a>
<h2 >22.2: Static data members</h2>
    When <a name="an2896"></a>static members are defined in class templates, they
        <a name="an2897"></a>
    are defined for every new type for which the class template is
instantiated. As they are static
members, there will only be one member per type for which the class template
is instantiated. For example, in a class like:
        <pre>
    template &lt;typename Type&gt;
    class TheClass
    {
        static int s_objectCounter;
    };
</pre>
    There will be <em >one</em> <code >TheClass&lt;Type&gt;::objectCounter</code> for each different
<code >Type</code> specification. The following object definitions result in the
instantiation of just one single static variable, shared among the two
objects:
        <pre>
    TheClass&lt;int&gt; theClassOne;
    TheClass&lt;int&gt; theClassTwo;
</pre>
    Mentioning static members in interfaces does not mean these members are
actually defined. They are only <em >declared</em> and must be <em >defined</em>
separately.  With static members of class templates this is no different. The
definitions of static members
        <a name="an2898"></a>
    are usually provided immediately following (i.e., below) the template
class interface. For example, the static member
<code >s_objectCounter</code>'s definition, positioned just below its class interface,
looks like this:
        <pre>
    template &lt;typename Type&gt;                    // definition, following
    int TheClass&lt;Type&gt;::s_objectCounter = 0;    // the interface
</pre>
    Here <code >s_objectCounter</code> is an <code >int</code> and is thus independent of the
template type parameter <code >Type</code>. Multiple instantiations of
<code >s_objectCounter</code> for identical <code >Type</code>s cause no problem, as the linker
will remove all but one instantation from the final executable (cf. section
<a href="cplusplus21.html#TEMPFUNDECL">21.5</a>).
<p>
In list-like constructions, where a <a name="an2899"></a>pointer to objects of the class
itself is required, the template type parameter <code >Type</code> must be used when
defining the static variable. Example:
        <pre>
    template &lt;typename Type&gt;
    class TheClass
    {
        static TheClass *s_objectPtr;
    };

    template &lt;typename Type&gt;
    TheClass&lt;Type&gt; *TheClass&lt;Type&gt;::s_objectPtr = 0;
</pre>
<p>
As usual, the definition can be read from the variable name back to the
beginning of the definition: <code >s_objectPtr</code> of the class <code >TheClass&lt;Type&gt;</code>
is a pointer to an object of <code >TheClass&lt;Type&gt;</code>.
<p>
When a static variable of a template's type parameter's type is defined,
it should of course not be given the initial value 0. The default constructor
(e.g., <code >Type()</code>) is usually more appropriate. Example:
        <pre>
    template &lt;typename Type&gt;                    // s_type's definition
    Type TheClass&lt;Type&gt;::s_type = Type();
</pre>
<p>
<a name="DISTINGUISH"></a><a name="l538"></a>
<h3 >22.2.1: Extended use of the keyword `typename'</h3>
Until now the keyword <code >typename</code> has been used to indicate a template type
parameter. However, it is also used to
    <a name="an2900"></a>
 disambiguate code inside templates. Consider the following function template:
        <pre>
    template &lt;typename Type&gt;
    Type function(Type t)
    {
        Type::Ambiguous *ptr;

        return t + *ptr;
    }
</pre>
    When this code is processed by the compiler, it complains with an -at
first sight puzzling- error message like:
        <pre>
    4: error: 'ptr' was not declared in this scope
</pre>
    The error message is puzzling as it was the programmer's intention to
declare a pointer to a type <code >Ambiguous</code> defined within the class template
<code >Type</code>. But the compiler, confronted with <code >Type::Ambiguous</code> may interpret
the statement in various ways. Clearly it cannot inspect <code >Type</code> itself
trying to uncover <code >Type</code>'s true nature as <code >Type</code> is a template
type. Because of this <code >Type</code>'s actual definition isn't available yet.
<p>
The compiler is confronted with two possibilities: either
<code >Type::Ambiguous</code> is a <em >static member</em> of the as yet mysterious template
<code >Type</code>, or it is a <em >subtype</em> of <code >Type</code>. As the standard
specifies that the compiler must assume the former, the statement
        <pre>
    Type::Ambiguous *ptr;
</pre>
    is interpreted as a <em >multiplication</em> of the static member
<code >Type::Ambiguous</code> and the (now undeclared) entity <code >ptr</code>. The reason for
the error message should now be clear: in this context <code >ptr</code> is unknown.
<p>
To disambiguate code in which an identifier refers to a
        <a name="an2901"></a>
        <a name="an2902"></a>
        <a name="an2903"></a>
 subtype of a template type parameter the keyword <code >typename</code> must be
used. Accordingly, the above code is altered into:
        <pre>
    template &lt;typename Type&gt;
    Type function(Type t)
    {
        typename Type::Ambiguous *ptr;

        return t + *ptr;
    }
</pre>
    Classes fairly often define subtypes. When such subtypes appear inside
template definitions as subtypes of template type parameters the <code >typename</code>
keyword <em >must</em> be used to identify them as subtypes. Example: a class
template <code >Handler</code> defines a <code >typename Container</code> as its template type
parameter. It also defines a data member storing the iterator returned by the
container's <code >begin</code> member. In addition <code >Handler</code> offers a constructor
accepting any container supporting a <code >begin</code> member.  <code >Handler</code>'s class
interface could then look like this:
        <pre>
    template &lt;typename Container&gt;
    class Handler
    {
        Container::const_iterator d_it;

        public:
            Handler(Container const &amp;container)
            :
                d_it(container.begin())
            {}
    };
</pre>
    What did  we have in mind when designing this class?
    <ul>
    <li> The typename <code >Container</code> represents any container supporting
iterators.
    <li> The container presumably supports a member <code >begin</code>. The
initialization <code >d_it(container.begin())</code> clearly depends on the
template's type parameter, so it's only checked for basic syntactic
correctness.
    <li> Likewise, the container presumably supports a <em >subtype</em>
<code >const_iterator</code>, defined in the class <code >Container</code>.
    </ul>
    The final consideration is an indication that <code >typename</code> is required. If
this is omitted and a <code >Handler</code> is instantiated the compiler produces a
peculiar compilation error:
        <pre>
    #include "handler.h"
    #include &lt;vector&gt;
    using namespace std;

    int main()
    {
        vector&lt;int&gt; vi;
        Handler&lt;vector&lt;int&gt; &gt; ph(vi);
    }
    /*
        Reported error:

    handler.h:4: error: syntax error before `;' token
    */
</pre>
    Clearly the line
        <pre>
    Container::const_iterator d_it;
</pre>
    in the class <code >Handler</code> causes a problem. It is interpreted by the
compiler as a <em >static member</em> instead of a subtype. The problem is
solved  using <code >typename</code>:
        <pre>
    template &lt;typename Container&gt;
    class Handler
    {
        typename Container::const_iterator d_it;
        ...
    };
</pre>
    An interesting illustration that the compiler indeed assumes <code >X::a</code> to
be a member <code >a</code> of the class <code >X</code> is provided by the error message we get
when we try to compile <code >main</code> using the following implementation of
<code >Handler</code>'s constructor:
        <pre>
    Handler(Container const &amp;container)
    :
        d_it(container.begin())
    {
        size_t x = Container::ios_end;
    }
    /*
        Reported error:

        error: `ios_end' is not a member of type `std::vector&lt;int,
                std::allocator&lt;int&gt; &gt;'
    */
</pre>
<p>
Now consider what happens if the function template introduced at the
beginning of this section doesn't return a <code >Type</code> value, but a
<code >Type::Ambiguous</code> value. Again, a subtype of a template type is referred to,
and <code >typename</code> must be used:
        <pre>
    template &lt;typename Type&gt;
    typename Type::Ambiguous function(Type t)
    {
        return t.ambiguous();
    }
</pre>
    Using <code >typename</code> in the specification of a return type is further
discussed in section <a href="cplusplus23.html#RETURNNESTED">23.1.1</a>.
<p>
<code >Typename</code>s can be embedded in <code >typedef</code>s. As is often the case, this
        <a name="an2904"></a>
reduces the complexities of declarations and definitions appearing
elsewhere. In the next example the type <code >Iterator</code> is defined as a subtype
of the template type <code >Container</code>. <code >Iterator</code> may now be used without
requiring the use of the keyword <code >typename</code>:
        <pre>
    template &lt;typename Container&gt;
    class Handler
    {
        typedef typename Container::const_iterator Iterator;

        Iterator d_it;
        ...
    };
</pre>
<p>
<a name="l539"></a>
<h2 >22.3: Specializing class templates for deviating types</h2>
The class <code >CirQue</code> can be used for many different types. Their common
characteristic is that they can simply be pointed at by the class's <code >d_data</code>
member. But this is not always as simple as it looks. What if <code >Data</code> turns
out to be a <code >vector&lt;int&gt;</code>? For such data types the vanilla <code >CirQue</code>
implementation cannot be used and a specialization could be considered. When
considering a specialization one should also consider inheritance. Often a
class derived from the class template accepting the incompatible data
structure as its argument but otherwise equal to the original class template
can easily be designed. The developmental advantage of inheritance over
specialization is clear: the inherited class inherits the members of its base
class while the specialization inherits nothing. All members defined by the
original class template must be implemented again by the class template's
specialization.
<p>
The specialization considered here is a true specialization in that the
data members and representation used by the specialization greatly differ from
the original <code >CirQue</code> class template. Therefore all members defined by the
orginal class template must be modified to fit the specialization's data
organization.
<p>
Like function template specializations class template specializations
start with a template header that may or may not have an empty template
parameter list. If the template parameters are directly specialized by the
specialization it remains empty (e.g., <code >CirQue</code>'s template type parameter
<code >Data</code> is specialized for <code >char *</code> data). But the template parameter list
may show <code >typename Data</code> when specializing for a <code >vector&lt;Data&gt;</code>, i.e., a
vector storing any type of data. This leads to the following principle:
    <blockquote ><a name="an2905"></a> A template specialization is recognized
by the template argument list following a function or class template's
<em >name</em> and <em >not</em> by an empty template parameter list. Class template
specializations may have non-empty template parameter lists. If so, a
<a name="an2906"></a><em >partial class template specialization</em> is defined.</blockquote>
<p>
A completely specialized class has the following characteristics:
    <ul>
    <li> The class template specialization must be provided after the generic
class template definition. As it is a specialization the compiler
must first have seen the original class template;
    <li> The completely specialized class template's template parameter list
is empty;
    <li> All of the class's template parameters are given explicit type names
or (for the non-type parameters) explicit values. These explicitations are
provided in a template parameter specification list (surrounded by angle
brackets) that is inserted immediately after the specialized template's class
<em >name</em>;
    <li> All members of the specialized class template use specialized types
and values where original template parameters are used in the original
template definition;
    <li> All original template's members (maybe with the exception of some
constructors) <em >should</em> be redefined by the specialization. If a member is
left out of the specialization, it cannot be used for a specialized class
template object;
    <li> The specialization may define additional members (but maybe shouldn't
as it breaks the one-to-one correspondence between the original and
specialized class template);
    <li> Member functions of specialized class templates may be declared by
the specializing class and implemented below their class interface. If their
implementations follow the class interface they may <em >not</em> begin with a
<code >template &lt;&gt;</code> header, but must immediately start with the member function's
header.
    </ul>
<p>
<a name="l540"></a>
<h3 >22.3.1: Example of a class specialization</h3>
    Here is an example of a completely specialized <code >CirQue</code> class, specialized
for a <code >vector&lt;int&gt;</code>. All members of the specialized class are declared, but
only non-trivial implementations of its members are provided. The specialized
class uses a copy of the <code >vector</code> passed to the constructor and implements a
circular queue using its <code >vector</code> data member:
    <pre>
#ifndef INCLUDED_CIRQUEVECTOR_H_
#define INCLUDED_CIRQUEVECTOR_H_

#include &lt;vector&gt;
#include "cirque.h"

template&lt;&gt;
class CirQue&lt;std::vector&lt;int&gt;&gt;
{
    typedef std::vector&lt;int&gt; IntVect;

    IntVect d_data;
    size_t d_size;

    typedef IntVect::iterator iterator;
    iterator d_front;
    iterator d_back;

    public:
        typedef int value_type;
        typedef value_type const &amp;const_reference;

        enum Exception
        {
            EMPTY,
            FULL
        };

        CirQue();
        CirQue(IntVect const &amp;iv);
        CirQue(CirQue&lt;IntVect&gt; const &amp;other);

        CirQue &amp;operator=(CirQue&lt;IntVect&gt; const &amp;other);

        int &amp;back();
        int &amp;front();
        bool empty() const;
        bool full() const;
        size_t maxSize() const;
        size_t size() const;
        void pop_front();
        void push_back(int const &amp;object);
        void swap(CirQue&lt;IntVect&gt; &amp;other);

    private:
        iterator inc(iterator const &amp;iter);
};

CirQue&lt;std::vector&lt;int&gt;&gt;::CirQue()
:
    d_size(0)
{}
CirQue&lt;std::vector&lt;int&gt;&gt;::CirQue(IntVect const &amp;iv)
:
    d_data(iv),
    d_size(iv.size()),
    d_front(d_data.begin()),
    d_back(d_data.begin())
{}
CirQue&lt;std::vector&lt;int&gt;&gt;::CirQue(CirQue&lt;IntVect&gt; const &amp;other)
:
    d_data(other.d_data),
    d_size(other.d_size),
    d_front(d_data.begin() + (other.d_front - other.d_data.begin())),
    d_back(d_data.begin() + (other.d_back - other.d_data.begin()))
{}
CirQue&lt;std::vector&lt;int&gt;&gt; &amp;CirQue&lt;std::vector&lt;int&gt;&gt;::operator=(
                                        CirQue&lt;IntVect&gt; const &amp;rhs)
{
    CirQue&lt;IntVect&gt; tmp(rhs);
    swap(tmp);
}
void CirQue&lt;std::vector&lt;int&gt;&gt;::swap(CirQue&lt;IntVect&gt; &amp;other)
{
    char tmp[sizeof(CirQue&lt;IntVect&gt;)];
    memcpy(tmp, &amp;other, sizeof(CirQue&lt;IntVect&gt;));
    memcpy(&amp;other, this, sizeof(CirQue&lt;IntVect&gt;));
    memcpy(this, tmp, sizeof(CirQue&lt;IntVect&gt;));
}
void CirQue&lt;std::vector&lt;int&gt;&gt;::pop_front()
{
    if (d_size == 0)
        throw EMPTY;

    d_front = inc(d_front);
    --d_size;
}
void CirQue&lt;std::vector&lt;int&gt;&gt;::push_back(int const &amp;object)
{
    if (d_size == d_data.size())
        throw FULL;

    *d_back = object;
    d_back = inc(d_back);
    ++d_size;
}
inline int &amp;CirQue&lt;std::vector&lt;int&gt;&gt;::back()
{
    return d_back == d_data.begin() ? d_data.back() : d_back[-1];
}
inline int &amp;CirQue&lt;std::vector&lt;int&gt;&gt;::front()
{
    return *d_front;
}
CirQue&lt;std::vector&lt;int&gt;&gt;::iterator CirQue&lt;std::vector&lt;int&gt;&gt;::inc(
    CirQue&lt;std::vector&lt;int&gt;&gt;::iterator const &amp;iter)
{
    iterator tmp(iter + 1);
    tmp =  tmp == d_data.end() ? d_data.begin() : tmp;
    return tmp;
}

#endif
</pre>
<p>
The next example shows how to use the specialized <code >CirQue</code> class:
    <pre>
static int iv[] = {1, 2, 3, 4, 5};

int main()
{
    vector&lt;int&gt; vi(iv, iv + 5);
    CirQue&lt;vector&lt;int&gt;&gt; ci(vi);

    cout &lt;&lt; ci.size() &lt;&lt; ' ' &lt;&lt; ci.front() &lt;&lt; ' ' &lt;&lt; ci.back() &lt;&lt; '\n';
    ci.pop_front();
    ci.pop_front();

    CirQue&lt;vector&lt;int&gt;&gt; cp;

    cp = ci;
    cout &lt;&lt; cp.size() &lt;&lt; ' ' &lt;&lt; cp.front() &lt;&lt; ' ' &lt;&lt; cp.back() &lt;&lt; '\n';
    cp.push_back(6);
    cout &lt;&lt; cp.size() &lt;&lt; ' ' &lt;&lt; cp.front() &lt;&lt; ' ' &lt;&lt; cp.back() &lt;&lt; '\n';
}

/*
    Displays:
        5 1 5
        3 3 5
        4 3 6
*/
</pre>
<p>
<a name="PARTIAL"></a><a name="l541"></a>
<h2 >22.4: Partial specializations</h2>
In the previous section class template specializations were introduced.  In
this section we'll introduce a variant of this specialization, both in
number and type of template parameters that are specialized.  <em >Partial
specializations</em> may be defined for class templates having
        <a name="an2907"></a>
        <a name="an2908"></a>
    multiple template parameters. 
<p>
Function templates cannot be partially specialized: there is no need for
        <a name="an2909"></a>
    that, as a `partially specialized function template' merely is a function
template that is tailored to particular types of some of its parameters. Since
function templates can be overloaded, `partially specializing' a function
template simply means that overloads have to be defined for those specialized
parameter types.
<p>
With partial specializations a subset (any subset) of template type parameters
are given specific values. It is also possible to use a class template partial
specialization when the intent is to specialize the class template, but to
parameterize the data type that is processed by the specialization.
<p>
To start our discussion with an example of the latter use of a partial class
template specialization consider the class <code >CirQue&lt;vector&lt;int&gt;&gt;</code>
developed in the previous section. When designing <code >CirQue&lt;vector&lt;int&gt;&gt;</code>
you may have asked yourself how many specializations you'd have to
implement. One for <code >vector&lt;int&gt;</code>, one for <code >vector&lt;string&gt;</code>, one for
<code >vector&lt;double&gt;</code>?  As long as the data types handled by the <code >vector</code> used
by the class <code >CirQue&lt;vector&lt;...&gt;&gt;</code> behaves like an <code >int</code> (i.e., is a
value-type of class) the answer is: zero. Instead of defining full
specializations for each new data type the data type itself can be
parameterized, resulting in a partial specialization:
        <pre>
    template &lt;typename Data&gt;
    class CirQue&lt;std::vector&lt;Data&gt;&gt;
    {
        ...
    };
</pre>
    The above class is a specialization as a template argument list is
appended to the <code >CirQue</code> class name. But as the class template itself has a
non-empty template parameter list it is in fact recognized as a partial
specialization. There is one characteristic that distinguishes the
implementation (subsequent to the class template's interface) of a class
template member function of a partial specialization from the implementation
of a member function of a full specialization. Implementations of partially
specialized class template member functions receive a template header. No
template headers are used when implementing fully specialized class template
members.
<p>
Implementing the partial specialization for <code >CirQue</code> is not difficult and is
left as an exercise for the reader (hints: simply change <code >int</code> into <code >Data</code>
in the <code >CirQue&lt;vector&lt;int&gt;&gt;</code> specialization of the previous section).
Remember to prefix the type <code >iterator</code> by <code >typename</code> (as in <code >typedef
typename DataVect::iterator iterator</code>) (as discussed in section
<a href="cplusplus22.html#DISTINGUISH">22.2.1</a>).
<p>
In the next subsections we'll concentrate on specializing class template
non-type template parameters. These partial specializations are now
illustrated using some simple concepts defined in matrix algebra, a branch of
linear algebra.
<p>
<a name="l542"></a>
<h3 >22.4.1: Intermezzo: some simple matrix algebraic concepts</h3>
    In this section some simple matrix algebraic terms are introduced. These terms
are used in the next sections to illustrate and discuss partial
specializations of class templates.  Readers proficient in matrix algebra may
skip this section without loss of continuity.
<p>
A matrix is commonly thought of as a table of some rows and columns,
filled with numbers. Immediately we recognize an opening for using templates:
the numbers might be plain <code >double</code> values, but they could also be complex
numbers, for which our complex container (cf. section <a href="cplusplus12.html#COMPLEX">12.5</a>) might
prove useful. Our class template is therefore provided with a <code >DataType</code>
template type parameter. It is  specified when a
matrix is constructed. Some simple matrices using <code >double</code> values, are:
        <pre>
    1   0   0           An identity matrix,
    0   1   0           (a 3 x 3 matrix).
    0   0   1

    1.2  0    0    0    A rectangular matrix,
    0.5  3.5  18  23    (a 2 x 4 matrix).

    1   2   4   8       A matrix of one row
                        (a 1 x 4 matrix), also known as a
                        `row vector' of 4 elements.
                        (column vectors are analogously defined)
</pre>
<p>
Various operations are defined on matrices. They may, for example be
added, subtracted or multiplied. Here we will not focus on these
operations. Rather, we concentrate on some simple operations: computing
marginals and sums.
<p>
Marginals are the sums of row elements or the sums of column elements of a
matrix. These two kinds of marginals are also known as, respectively,
<em >row marginals</em> and
<em >column marginals</em>.
<p>
<ul>
    <li> <em >Row marginals</em> are obtained by adding, for each row,
all the row's elements and putting these (<code >Rows</code>) sums in corresponding
elements of a (column) vector of <code >Rows</code> elements.
    <li> Column marginals are
obtained by adding, for each column, all the column's elements and putting
these (<code >Columns</code>) sums in corresponding elements of a (row) vector of
<code >Columns</code> elements.
    <li> The sum of all elements of a matrix can of course be computed as the
sum of the elements of one of its marginals.
    </ul>
    The following example shows a matrix, its marginals, and the sum of its
values:
        <pre>
    -------------------------------------
                                row
                matrix          marginals
                ---------
                1   2   3        6
                4   5   6       15
                ---------
    column      5   7   9       21  (sum)
    marginals
    -------------------------------------
</pre>
<p>
<a name="l543"></a>
<h3 >22.4.2: The Matrix class template</h3>
    We'll start out by introducing a class template defining a matrix. Having
defined this class template we'll continue with defining several
specializations.
<p>
Since matrices consist of well defined numbers of rows and columns (the
<em >dimensions</em> of the matrix), that normally do not change when matrices are
used, we might consider specifying their values as template non-type
parameters. The <code >DataType = double</code> will be used in the majority of
cases. Therefore, <code >double</code> can be selected as the template's default type
argument. Since it's a sensible default, the <code >DataType</code> template type
parameter is used last in the template type parameter list.
<p>
Our template class <code >Matrix</code> begins its life as:
        <pre>
    template &lt;size_t Rows, size_t Columns, typename DataType = double&gt;
    class Matrix
    ...
</pre>
<p>
What do we want our class template to offer?
    <ul>
    <li> It needs a place to store its matrix elements. This can be defined as
an array of `<code >Rows</code>' rows each containing `<code >Columns</code>' elements of type
<code >DataType</code>. It can be an array, rather than a pointer, since the matrix'
dimensions are known <em >a priori</em>. Since a vector of <code >Columns</code> elements (a
<em >row</em> of the matrix), as well as a vector of <code >Row</code> elements (a <em >column</em>
of the matrix) is often used, the class could use <em >typedefs</em> to represent
them. The class interface's initial section thus contains:
        <pre>
        typedef Matrix&lt;1, Columns, DataType&gt;    MatrixRow;
        typedef Matrix&lt;Rows, 1, DataType&gt;       MatrixColumn;

        MatrixRow d_matrix[Rows];
</pre>
<p>
<li> It should offer constructors: a default constructor and (e.g.,) a
constructor initializing the matrix from a stream. A copy or move constructor
is not required as the class does not use pointers. Likewise, no overloaded
assignment operator or destructor is required. Implementations:
        <pre>
    template &lt;size_t Rows, size_t Columns, typename DataType&gt;
    Matrix&lt;Rows, Columns, DataType&gt;::Matrix()
    {
        std::fill(d_matrix, d_matrix + Rows, MatrixRow());
    }
    template &lt;size_t Rows, size_t Columns, typename DataType&gt;
    Matrix&lt;Rows, Columns, DataType&gt;::Matrix(std::istream &amp;str)
    {
        for (size_t row = 0; row &lt; Rows; row++)
            for (size_t col = 0; col &lt; Columns; col++)
                str &gt;&gt; d_matrix[row][col];
    }
</pre>
<p>
<li> The class's <code >operator[]</code> member (and its <code >const</code> variant) only
handles the first index, returning a reference to a complete
<code >MatrixRow</code>. How elements in a <code >MatrixRow</code> can be retrieved is shortly
covered. To keep the example simple, no array bound check has been
implemented:
        <pre>
    template &lt;size_t Rows, size_t Columns, typename DataType&gt;
    Matrix&lt;1, Columns, DataType&gt;
    &amp;Matrix&lt;Rows, Columns, DataType&gt;::operator[](size_t idx)
    {
        return d_matrix[idx];
    }
</pre>
<p>
<li> Now we get to the interesting parts: computing marginals and the sum
of all elements in a <code >Matrix</code>. We'll define the type <code >MatrixColumn</code> as the
type containing the row marginals of a matrix, and the type <code >MatrixRow</code> as
the type containing the column marginals of a matrix.
<p>
There is also the sum of all the elements of a matrix. This sum of all the
elements of a matrix is a number that itself can be thought of as a <code >1 x 1</code>
matrix.
<p>
Marginals can be considered as special forms of matrices. To represent these
marginals we can construct <em >partial specializations</em> defining the class
templates <code >MatrixRow</code> and <code >MatrixColumn</code> objects; and we construct a
partial specialization handling <code >1 x 1</code> matrices.  These partial
specializations are used to compute marginals and the sum of all the elements
of a matrix.
<p>
Before concentrating on these partial specializations themselves we'll use
them here to implement the members computing the marginals and the sum of all
elements of a matrix:
        <pre>
    template &lt;size_t Rows, size_t Columns, typename DataType&gt;
    Matrix&lt;1, Columns, DataType&gt;
    Matrix&lt;Rows, Columns, DataType&gt;::columnMarginals() const
    {
        return MatrixRow(*this);
    }

    template &lt;size_t Rows, size_t Columns, typename DataType&gt;
    Matrix&lt;Rows, 1, DataType&gt;
    Matrix&lt;Rows, Columns, DataType&gt;::rowMarginals() const
    {
        return MatrixColumn(*this);
    }

    template &lt;size_t Rows, size_t Columns, typename DataType&gt;
    DataType Matrix&lt;Rows, Columns, DataType&gt;::sum()  const
    {
        return rowMarginals().sum();
    }
</pre>
<p>
</ul>
<p>
<a name="l544"></a>
<h3 >22.4.3: The MatrixRow partial specialization</h3>
        Class template <em >partial specializations</em> can be defined for any (subset)
        <a name="an2910"></a>
    of template parameters. They can be defined for template type parameters
and for template non-type parameters alike. Our first partial specialization
defines a row of a generic <code >Matrix</code>, mainly (but not only) used for the
construction of column marginals. Here is how such a partial specialization is
designed:
    <ul>
    <li> The partial specialization starts with a template header defining all
template parameters that are <em >not</em> specialized in the partial
specialization. This template header cannot specify any defaults (like
<code >DataType = double</code>) since defaults were already specified by the generic
class template definition.  The specialization <em >must</em> follow the definition
of the generic class template's definition, or the compiler complains that it
doesn't know what class is being specialized. Following the template header,
the class's interface starts. It's a class template (partial) specialization
so the class name must be followed by a template argument list specifying the
template arguments used by the partial specialization. The arguments specify
explicit types or values for some of the template's parameters. Remaining
types are simply copied from the class template partial specialization's
template parameter list. E.g., the <code >MatrixRow</code> specialization specifies 1
for the generic class template's <code >Rows</code> non-type parameter (as we're talking
here about a single row). Both <code >Columns</code> and <code >DataType</code> remain to be
specified. The <code >MatrixRow</code> partial specialization therefore starts as
follows:
        <pre>
    template &lt;size_t Columns, typename DataType&gt;  // no default allowed
    class Matrix&lt;1, Columns, DataType&gt;
</pre>
<p>
<li> A <code >MatrixRow</code> holds the data of a single row. So it needs a
data member storing <code >Columns</code> values of type <code >DataType</code>. Since <code >Columns</code>
is a constant value, the <code >d_row</code> data member can be defined as an array:
        <pre>
        DataType d_column[Columns];
</pre>
<p>
<li> The class template partial specialization's constructors require some
attention. The default constructor is simple. It merely initializes the
<code >MatrixRow</code>'s data elements using <code >DataType</code>'s default constructor:
        <pre>
    template &lt;size_t Columns, typename DataType&gt;
    Matrix&lt;1, Columns, DataType&gt;::Matrix()
    {
        std::fill(d_column, d_column + Columns, DataType());
    }
</pre>
<p>
Another constructor is needed initializing a <code >MatrixRow</code> object
with the column marginals of a generic <code >Matrix</code> object. This requires us to
provide the constructor with a non-specialized <code >Matrix</code> parameter.
<p>
The <a name="an2911"></a>rule of thumb here is to define a member template that allows us to
keep the general nature of the parameter. The generic <code >Matrix</code>
template requires three template parameters. Two of these were already
provided by the template specialization. The third parameter is mentioned in
the member template's template header. Since this parameter refers to the
number of rows of the generic matrix it is simply called <code >Rows</code>.
<p>
Here then is the implementation of the second constructor, initializing the
<code >MatrixRow</code>'s data with the column marginals of a generic <code >Matrix</code> object:
        <pre>
    template &lt;size_t Columns, typename DataType&gt;
    template &lt;size_t Rows&gt;
    Matrix&lt;1, Columns, DataType&gt;::Matrix(
                            Matrix&lt;Rows, Columns, DataType&gt; const &amp;matrix)
    {
        std::fill(d_column, d_column + Columns, DataType());

        for (size_t col = 0; col &lt; Columns; col++)
            for (size_t row = 0; row &lt; Rows; row++)
                d_column[col] += matrix[row][col];
    }
</pre>
<p>
The constructor's parameter is a reference to a <code >Matrix</code> template using
the additional <code >Row</code> template parameter as well as the template parameters
of the partial specialization.
    <li> We don't really require additional members to satisfy our current
needs. To access the data elements of the <code >MatrixRow</code> an overloaded
<code >operator[]()</code> is of course useful. Again, the <code >const</code> variant can be
implemented like the non-<code >const</code> variant. Here is its implementation:
        <pre>
    template &lt;size_t Columns, typename DataType&gt;
    DataType &amp;Matrix&lt;1, Columns, DataType&gt;::operator[](size_t idx)
    {
        return d_column[idx];
    }
</pre>
<p>
</ul>
    Now that we have defined the generic <code >Matrix</code> class and the
partial specialization defining a single row the compiler selects the
row's specialization whenever a <code >Matrix</code> is defined using <code >Row = 1</code>. For
example:
        <pre>
    Matrix&lt;4, 6&gt; matrix;        // generic Matrix template is used
    Matrix&lt;1, 6&gt; row;           // partial specialization is used
</pre>
<p>
<a name="l545"></a>
<h3 >22.4.4: The MatrixColumn partial specialization</h3>
        The partial specialization for a <code >MatrixColumn</code> is constructed
similarly. Let's present its highlights (the full <code >Matrix</code> class template
definition as well as all its specializations are provided in the
<code >cplusplus.yo.zip</code> archive (at <a href="http://sourceforge.net/projects/cppannotations/">SourceForge</a>) in the
file <code >yo/classtemplates/examples/matrix.h</code>):
    <ul>
    <li> The class template partial specialization once again starts with a
template header. Now the class interface specifies a fixed value for the
second template parameter of the generic class template. This illustrates that
we can construct partial specializations for every single template parameter;
not just for the first or the last:
        <pre>
    template &lt;size_t Rows, typename DataType&gt;
    class Matrix&lt;Rows, 1, DataType&gt;
</pre>
<p>
<li> Its constructors are implemented completely analogously to the way
the <code >MatrixRow</code> constructors were implemented. Their implementations are
left as an exercise to the reader (and they can be found in <code >matrix.h</code>).
    <li> An additional member <code >sum</code> is defined to compute the sum of the
elements of a <code >MatrixColumn</code> vector. It's simply implemented
using the <code >accumulate</code> generic algorithm:
        <pre>
    template &lt;size_t Rows, typename DataType&gt;
    DataType Matrix&lt;Rows, 1, DataType&gt;::sum()
    {
        return std::accumulate(d_row, d_row + Rows, DataType());
    }
</pre>
<p>
</ul>
<p>
<a name="l546"></a>
<h3 >22.4.5: The 1x1 matrix: avoid ambiguity</h3>
        The reader might wonder what happens if we define the following matrix:
        <pre>
    Matrix&lt;1, 1&gt; cell;
</pre>
    Is this a <code >MatrixRow</code> or a <code >MatrixColumn</code> specialization? The answer
is: neither.
<p>
It's ambiguous, precisely because <em >both</em> the columns <em >and</em> the rows could
be used with a (different) template partial specialization. If such a
<code >Matrix</code> is actually required, yet another specialized template must be
designed.
<p>
Since this template specialization can be useful to obtain the sum of the
elements of a <code >Matrix</code>, it's covered here as well.
    <ul>
    <li> This class template partial specialization also needs a template
header, this time only specifying <code >DataType</code>. The class definition specifies
two fixed values: 1 for the number of rows and 1 for the number of columns:
        <pre>
    template &lt;typename DataType&gt;
    class Matrix&lt;1, 1, DataType&gt;
</pre>
<p>
<li> The specialization defines the usual batch of constructors.
Constructors expecting a more generic <code >Matrix</code> type are again implemented as
member templates. For example:
        <pre>
    template &lt;typename DataType&gt;
    template &lt;size_t Rows, size_t Columns&gt;
    Matrix&lt;1, 1, DataType&gt;::Matrix(
                            Matrix&lt;Rows, Columns, DataType&gt; const &amp;matrix)
    :
        d_cell(matrix.rowMarginals().sum())
    {}

    template &lt;typename DataType&gt;
    template &lt;size_t Rows&gt;
    Matrix&lt;1, 1, DataType&gt;::Matrix(Matrix&lt;Rows, 1, DataType&gt; const &amp;matrix)
    :
        d_cell(matrix.sum())
    {}
</pre>
<p>
<li> Since <code >Matrix&lt;1, 1&gt;</code> is basically a wrapper around a <code >DataType</code>
value, we need members to access that latter value. A type conversion
operator might be useful, but we also defined a <code >get</code> member to obtain
the value if the conversion operator isn't used by the compiler (which
happens when the compiler is given a choice, see section
<a href="cplusplus11.html#ConversionOperators">11.3</a>). Here are the accessors (leaving out their <code >const</code>
variants):
        <pre>
    template &lt;typename DataType&gt;
    Matrix&lt;1, 1, DataType&gt;::operator DataType &amp;()
    {
        return d_cell;
    }

    template &lt;typename DataType&gt;
    DataType &amp;Matrix&lt;1, 1, DataType&gt;::get()
    {
        return d_cell;
    }
</pre>
<p>
</ul>
<p>
Finally, the <code >main</code> function shown below illustrates how the <code >Matrix</code>
class template and its partial specializations can be used:
    <pre>
    #include &lt;iostream&gt;
    #include "matrix.h"
    using namespace std;

    int main(int argc, char **argv)
    {
        Matrix&lt;3, 2&gt; matrix(cin);

        Matrix&lt;1, 2&gt; colMargins(matrix);
        cout &lt;&lt; "Column marginals:\n";
        cout &lt;&lt; colMargins[0] &lt;&lt; " " &lt;&lt; colMargins[1] &lt;&lt; '\n';

        Matrix&lt;3, 1&gt; rowMargins(matrix);
        cout &lt;&lt; "Row marginals:\n";
        for (size_t idx = 0; idx &lt; 3; idx++)
            cout &lt;&lt; rowMargins[idx] &lt;&lt; '\n';

        cout &lt;&lt; "Sum total: " &lt;&lt; Matrix&lt;1, 1&gt;(matrix) &lt;&lt; '\n';
    }
    /*
        Generated output from input: 1 2 3 4 5 6

        Column marginals:
        9 12
        Row marginals:
        3
        7
        11
        Sum total: 21
    */
</pre>
<p>
<a name="VARIADIC"></a><a name="l547"></a>
<h2 >22.5: Variadic templates</h2>
Up to this point we've encountered templates defining a fixed number of
template parameters. However, templates may also defined as
    <a name="an2912"></a><a name="an2913"></a><em >variadic templates</em>, allowing any number of
arguments to be passed to their instantiations.
<p>
Variadic templates are defined for function templates and for class
templates. Variadic templates allow us to specify an arbitrary number of
template arguments of any type.
<p>
Variadic templates were added to the language to prevent us from having to
define many overloaded templates and to be able to create <em >type safe</em>
variadic functions.
<p>
Although <strong >C</strong> (and <strong >C++</strong>) support <a name="an2914"></a>variadic functions, their use has
always been deprecated in <strong >C++</strong> as those functions are notoriously
type-<em >un</em>safe. Variadic function templates can be used to process objects
that until now couldn't be processed properly by <strong >C</strong>-style variadic
functions.
<p>
Template headers of variadic templates use the phrase
 <a name="an2915"></a><code >typename ...Params</code> (<code >Params</code> being a formal
name). A variadic class template <code >Variadic</code> could be declared as follows:
        <pre>
    template&lt;typename ...Params&gt; class Variadic;
</pre>
    Assuming the class template's definition is available then this template
can be instantiated using any number of template arguments. Example:
        <pre>
    class Variadic&lt;
            int,
            std::vector&lt;int&gt;,
            std::map&lt;std::string, std::vector&lt;int&gt;&gt;
    &gt; v1;
</pre>
    The template argument list of a variadic template can also be
empty. Example:
        <pre>
    class Variadic&lt;&gt; empty;
</pre>
    If this is considered undesirable using an empty template argument list
can be prevented by providing one or more fixed parameters. Example:
        <pre>
    template&lt;typename First, typename ...Rest&gt;
    class tuple;
</pre>
<p>
<strong >C</strong>'s function <a name="an2916"></a><code >printf</code> is a well-known example of a type-unsafe
function. It is turned into a type-safe function when it is implemented as a
variadic function template. Not only does this turn the function into a
type-safe function but it is also automatically extended to accept any type
that can be defined by <strong >C++</strong>. Here is a possible declaration of a variadic
function template <code >printcpp</code>:
        <pre>
    template&lt;typename ...Params&gt;
    void printcpp(std::string const &amp;strFormat, Params ...parameters);
</pre>
    The <a name="an2917"></a>ellipsis (<a name="an2918"></a>...) used in the declaration serves two purposes:
    <ul>
    <li> In the template header it is written to the <em >left</em> of a template
        parameter name where it declares a <a name="an2919"></a><em >parameter pack</em>. A parameter
        pack allows us to specify any number of template arguments when
        instantiating the template. Parameter packs can be used to
        bind type and non-type template arguments to template parameters.
    <li> In a template implementation it appears to the <em >right</em> of the
        template pack's parameter name. In that case it represents a series of
        template arguments that are subsequently matched with a function
        parameter that in turn is provided to the right of the ellipsis. Here
        the ellipsis is known as the <a name="an2920"></a><em >unpack operator</em> as it `unpacks' a
        series of arguments in a function's argument list thereby implicitly
        defining its parameters.
    </ul>
    <strong >C++</strong> offers no syntax to access the individual template arguments
directly. However, the arguments can be visited recursively. An example is
provided in the next section. The <em >number</em>
 <a name="an2921"></a> of arguments is determined using a
new invocation of the <a name="an2922"></a><code >sizeof</code> operator:
        <pre>
    template&lt;typename ...Params&gt;
    struct StructName
    {
        enum: size_t { s_size = sizeof ...(Params) };
    };

    // StructName&lt;int, char&gt;::s_size          -- initialized to 2
</pre>
<p>
<a name="DEFVARTEMP"></a><a name="l548"></a>
<h3 >22.5.1: Defining and using variadic templates</h3>
    The arguments associated with a variadic template parameter are not directly
available to the implementation of a function or class template. We have to
resort to other means to obtain them.
<p>
By defining a partial specialization of a variadic template, explicitly
defining an additional template type parameter, we can associate the first
template argument of a parameter pack with this additional (first) type
parameter. The setup of such a variadic function template (e.g., <code >printcpp</code>,
see the previous section) is as follows:
    <ul>
    <li> The <code >printcpp</code> function receives at least a format
string. Following the format string any number of additional arguments may be
specified.
    <li> If there are no arguments trailing the format string then there is no
need to use a function template. An overloaded (non-template) function
is defined to handle this situation.
    <li> A variadic function template handles all remaining situations. In
this case there is always at least one  argument trailing the format
string. That argument's type is matched with the variadic template function's
first (ordinary) template type parameter <code >First</code>. The types of any remaining
arguments are bound to the template function's second template parameter,
which is a parameter pack.
    <li> The variadic function template processes the argument trailing the
format string. Then it recursively calls itself passing the format string and
the parameter pack to the recursive call
    <li> If the recursive call merely receives the format string the
overloaded (non-template) function is called (cf. section
<a href="cplusplus21.html#FUNCTIONSELECTION">21.14</a>) ending the recursion. Otherwise the parameter pack's
first argument is matched with the recursive call's <code >First</code> parameter. As
this reduces the size of the recursive call's parameter pack the recursion
eventually stops.
    </ul>
<p>
The overloaded non-template function prints the remainder of the format
string, <em >en passant</em> checking for any left-over format specifications:
        <pre>
    void printcpp(string const &amp;format)
    {
        size_t left = 0;
        size_t right = 0;

        while (true)
        {
            if ((right = format.find('%', right)) == string::npos)
                break;
            if (format.find("%%", right) != right)
                throw std::runtime_error(
                            "printcpp: missing arguments");
            ++right;
            cout &lt;&lt; format.substr(left, right - left);
            left = ++right;
        }
        cout &lt;&lt; format.substr(left);
    }
</pre>
<p>
Here is the variadic function template's implementation:
        <pre>
    template&lt;typename First, typename ...Params&gt;
    void printcpp(std::string const &amp;format, First value, Params ...params)
    {
        size_t left = 0;
        size_t right = 0;
        while (true)
        {
            if ((right = format.find('%', right)) == string::npos)      // 1
                throw std::runtime_error("printcpp: too many arguments");

            if (format.find("%%", right) != right)                      // 2
                break;

            ++right;
            cout &lt;&lt; format.substr(left, right - left);
            left = ++right;
        }
        cout &lt;&lt; format.substr(left, right - left) &lt;&lt; value;
        printcpp(format.substr(right + 1), params...);
   }
</pre>
    <ul>
    <li> At 1 the format string is searched for a parameter specification
<code >%</code>. If none is found then the function is called with too many arguments
and it throws an exception;
    <li> At 2 it verifies that it has not encountered <code >%%</code>. If only a single
<code >%</code> has been seen the <code >while</code>-loop ends, the format string is inserted
into <code >cout</code> up to the <code >%</code> followed by <code >value</code>, and the recursive call
receives the remaing part of the format string as well as the remaining
parameter pack;
    <li> If <code >%%</code> was seen the format string is inserted up to the second
<code >%</code>, which is ignored, and processing of the format string continues beyond
the <code >%%</code>.
    </ul>
    Make sure that the overloaded function is at least declared before the
compiler processes the function template's definition or it won't
call the overloaded function <code >printcpp</code> when compiling the function
template.
<p>
Different from <strong >C</strong>'s <code >printf</code> function <code >printcpp</code> only recognizes
<code >%</code> and <code >%%</code> as format specifiers. The above implementation does not
recognize, e.g., field widths. Type specifiers like <code >%c</code> and <code >%x</code> are of
course not needed as <code >ostream</code>'s insertion operator is aware of the types of
the arguments that are inserted into the <code >ostream</code>.  Extending the format
specifiers so that field widths etc. are recognized by this <code >printcpp</code>
implementation is left as an exercise to the reader. Here is an example
showing how <code >printcpp</code> can be called:
        <pre>
    printcpp("Hello % with %%main%% called with % args"
                                            " and a string showing %\n",
        "world", argc, string("A String"));
</pre>
<p>
<a name="PERFECT"></a><a name="l549"></a>
<h3 >22.5.2: Perfect forwarding</h3>
    Consider <code >string</code>'s member <code >insert</code>. <code >String::insert</code> has several
overloaded implementations. It can be used to insert text (completely or
partially) provided by a <code >string</code> or by a <code >char const *</code> argument; to
insert single characters a specified number of times; iterators can be used to
specify the range of characters to be inserted; etc., etc.. All in all,
<code >string</code> offers as many as five overloaded <code >insert</code> members.
<p>
Assume the existence of a class <code >Inserter</code> that is used to insert
information into all kinds of objects. Such a class could have a <code >string</code>
data member into which information can be inserted. <code >Inserter</code>'s interface
only partially has to copy <code >string</code>'s interface to realize this: only
<code >string::insert</code>'s interfaces must be duplicated. The members duplicating
interfaces often contain one statement (calling the appropriate member
function of the object's data member) and are for this reason often
implemented in-line. Such <em >wrapper functions</em> merely <a name="an2923"></a><em >forward</em> their
parameters to the matching member functions of the object's data member.
<p>
Another example is found in <em >factory functions</em> that also frequently forward
their parameters to the constructors of objects that they return.
<p>
<strong >C++</strong> simplifies and generalizes forwarding of parameters by
offering <a name="an2924"></a><em >perfect forwarding</em>, implemented through rvalue references and
variadic templates. With perfect forwarding the arguments passed to functions
are `perfectly forwarded' to nested functions. Forwarding is called
<em >perfect</em> as the arguments are forwarded in a type-safe way. To use perfect
forwarding nested functions must define parameter lists matching the
forwarding parameters both in types and number.
<p>
Perfect forwarding is easily implemented:
    <ul>
    <li> The forwarding function is defined as a template<br/>
        (usually a <em >variadic</em> template, but single argument forwarding is
        also possible. To define and forward a single argument omit the
        ellipsis from the following code);
    <li> The forwarding function's parameter list is an
        <a name="an2925"></a>
        <em >rvalue reference parameter pack</em> (e.g., <code >Params &amp;&amp;...params</code>);
    <li><a name="an2926"></a><code >std::forward</code> is used to forward the forwarding function's
        arguments to the nested function, keeping track of their types and
        number. Before <code >forward</code> can be used the <a name="an2927"></a><code >&lt;utility&gt;</code> header file
        must be included.
    <li> The nested function is called using this stanza to specify its
        arguments: <br/>
        <code >std::forward&lt;Params&gt;(params)...</code>.
    </ul>
<p>
In the next example perfect forwarding is used to implement <em >one</em> member
<code >Inserter::insert</code> that can be used to call any of the five overloaded
<code >string::insert</code> members. The <code >insert</code> function that's actually called now
simply depends on the types and number of arguments that are passed to
<code >Inserter::insert</code>:
        <pre>
    class Inserter
    {
        std::string d_str;  // somehow initialized
        public:
                            // constructors not implemented,
                            // but see below
            Inserter();
            Inserter(std::string const &amp;str);
            Inserter(Inserter const &amp;other);
            Inserter(Inserter &amp;&amp;other);

            template&lt;typename ...Params&gt;
            void insert(Params &amp;&amp;...params)
            {
                d_str.insert(std::forward&lt;Params&gt;(params)...);
            }
    };
</pre>
<p>
A factory function returning an <code >Inserter</code> can also easily be implemented
using perfect forwarding. Rather than defining four overloaded factory
functions a single one now suffices. By providing the factory function with an
additional template type parameter specifying the class of the object to
construct the factory function is turned into a completely general factory
function:
        <pre>
    template &lt;typename Class, typename ...Params&gt;
    Class factory(Params &amp;&amp;...params)
    {
        return Class(std::forward&lt;Params&gt;(params)...);
    }
</pre>
Here are some examples showing its use:
        <pre>
    Inserter inserter(factory&lt;Inserter&gt;("hello"));
    string delimiter(factory&lt;string&gt;(10, '='));
    Inserter copy(factory&lt;Inserter&gt;(inserter));
</pre>
<p>
The function <code >std::forward</code> is provided by the  standard library. It
performs no magic, but merely returns <code >params</code> as a nameless object. That
way it acts like <code >std::move</code> that also removes the name from an object,
returning it as a nameless object. The unpack operator has nothing to do with
the use of <code >forward</code> but merely tells the compiler to apply <code >forward</code> to
each of the arguments in turn. Thus it behaves similarly to <strong >C</strong>'s ellipsis
operator used by variadic functions.
<p>
Perfect forwarding was introduced in section <a href="cplusplus21.html#CONTRACTIONS">21.4.5</a>: a template
function defining a <code >Type &amp;&amp;param</code>, with <code >Type</code> being a template type
parameter converts <code >Type &amp;&amp;</code> to <code >Tp &amp;</code> if the function is called with
an argument of type <code >Tp &amp;</code>. Otherwise it binds <code >Type</code> to <code >Tp</code>,
with <code >param</code> being defined as  <code >Tp &amp;&amp;param</code>. As a result an <em >lvalue</em>
argument binds to an lvalue-type (<code >Tp &amp;</code>), while an <em >rvalue</em> argument
binds to an rvalue-type (<code >Tp &amp;&amp;</code>).
<p>
The function <code >std::forward</code> merely passes the argument (and its type) on to
the called function or object. Here is its simplified implementation:
        <pre>
    typedef &lt;type T&gt;
    T &amp;&amp;forward(T &amp;&amp;a)
    {
        return a;
    }
</pre>
    Since <code >T &amp;&amp;</code> turns into an lvalue reference when <code >forward</code> is called
with an lvalue (or lvalue reference) and remains an rvalue reference if
<code >forward</code> is called with an rvalue reference, and since <code >forward</code> (like
<code >std::move</code>) anonymizes the variable passed as argument to <code >forward</code>, the
argument value is forwarded while passing its type from the function's
parameter to the called function's argument.
<p>
This is called <em >perfect forwarding</em> as the nested function can only be
called if the types of the arguments that were used when calling the `outer'
function (e.g., <code >factory</code>) exactly match the types of the parameters of the
nested function (e.g., <code >Class</code>'s constructor). Perfect forwarding therefore
is a tool to realize type safety.
<p>
A cosmetic improvement to <code >forward</code> requires users of <code >forward</code> to
specify the type to use rather than to have the compiler deduct the type as a
result of the function template parameter type deduction's process. This is
realized by a small support struct template:
        <pre>
    template &lt;typename T&gt;
    struct identity
    {
        typedef T type;
    };
</pre>
    This struct merely defines <code >identity::type</code> as <code >T</code>, but as it is a
struct it must be specified explicitly. It cannot be determined from the
function's argument itself. The subtle modification to the above
implementation of <code >forward</code> thus becomes (cf. section <a href="cplusplus22.html#DISTINGUISH">22.2.1</a> for
an explanation of the use of <code >typename</code>):
        <pre>
    typedef &lt;type T&gt;
    T &amp;&amp;forward(typename identity&lt;T&gt;::type &amp;&amp;arg)
    {
        return arg;
    }
</pre>
    Now <code >forward</code> must explicitly state <code >arg</code>'s type, as in:
        <pre>
    std::forward&lt;Params&gt;(params)
</pre>
<p>
Using the <code >std::forward</code> function and the rvalue reference specification
is not restricted to the context of parameter packs. Because of the special
way rvalue references to template type parameters are treated (cf. section
<a href="cplusplus21.html#CONTRACTIONS">21.4.5</a>) they can profitably be used to forward individual function
    <a name="an2928"></a>
 parameters as well. Here is an example showing how an argument to a function
can be forwarded from a template to a function that is itself passed to the
template as a pointer to an (unspecified) function:
        <pre>
    template&lt;typename Fun, typename ArgType&gt;
    void caller(Fun fun, ArgType &amp;&amp;arg)
    {
        fun(std::forward&lt;ArgType&gt;(arg));
    }
</pre>
    A function <code >display(ostream &amp;out)</code> and <code >increment(int &amp;x)</code> may now
both be called through <code >caller</code>. Example:
        <pre>
    caller(display, cout);
    int x = 0;
    caller(increment, x);
</pre>
<p>
<a name="UNPACK"></a><a name="l550"></a>
<h3 >22.5.3: The unpack operator</h3>
        The <a name="an2929"></a><em >unpack operator</em> is used to obtain template arguments in many
situations. No mechanism other than recursion (as shown in section
<a href="cplusplus22.html#DEFVARTEMP">22.5.1</a>) is available to obtain the individual types and values of a
variadic template.
<p>
The unpack operator can also be used to define template classes that are
derived from any number of base classes.
  <a name="an2930"></a> Here is how it's done:
        <pre>
    template &lt;typename ...BaseClasses&gt;
    class Combi: public BaseClasses...          // derive from base classes
    {
        public:
                                                // specify base class objects
                                                // to its constructor using
                                                // perfect forwarding
            Combi(BaseClasses &amp;&amp;...baseClasses)
            :
                BaseClasses(baseClasses)...     // use base class initializers
            {}                                  // for each of the base
    };                                          // classes
</pre>
    This allows us to define classes that combine the features of any number
of other classes. If the class <code >Combi</code> is derived of classes <code >A, B,</code> and
<code >C</code> then <code >Combi</code> is-an <code >A, B,</code> and <code >C</code>. It should of course be given a
virtual destructor. A <code >Combi</code> object can be passed to functions expecting
pointers or references to any of its base class type objects. Here is an
example defining <code >Combi</code> as a class derived from a vector of complex
numbers, a string and a pair of ints and doubles (using uniform intializers in
a sequence matching the sequence of the types specified for the used <code >Combi</code>
type):
        <pre>
    typedef Combi&lt;
        vector&lt;complex&lt;double&gt;&gt;, string, pair&lt;int, double&gt;
    &gt; MultiTypes;

    MultiTypes mt = {{3.5, 4}, "mt", {1950, 1.72}};
</pre>
<p>
The same construction can also be used to define template data members
supporting variadic type lists such as <code >tuples</code> (cf. section
<a href="cplusplus22.html#TUPLES">22.6</a>). Such a class could be designed along these lines:
        <pre>
    template &lt;typename ...Types&gt;
    struct Multi
    {
        std::tuple&lt;Types...&gt; d_tup;        // define tuple for Types types

        Multi(Types ...types)
        :                                   // initialize d_tup from Multi's
            d_tup(std::forward&lt;Types&gt;(types)...)   //             arguments
        {}
    };
</pre>
<p>
The ellipses that are used when forwarding parameter packs are
essential. The compiler considers their omission an error. In the following
<code >struct</code> definition it was the intent of the programmer to pass a parameter
pack on to a nested object construction but ellipses were omitted while
specifying the template parameters, resulting in a
    <a name="an2931"></a>
 <em >parameter packs not expanded with `...'</em> error message:
        <pre>
    template &lt;int size, typename ...List&gt;
    struct Call
    {
        Call(List &amp;&amp;...list)
        {
            Call&lt;size - 1, List &amp;&amp;&gt; call(std::forward&lt;List&gt;(list)...);
        }
    };
</pre>
    Instead of the above definition of the <code >call</code> object the programmer
should have used:
        <pre>
    Call&lt;size - 1, List &amp;&amp;...&gt; call(std::forward&lt;List&gt;(list)...);
</pre>
<p>
<a name="l551"></a>
<h3 >22.5.4: Non-type variadic templates</h3>
    Variadic templates not necesssarily define template types. Non-types can also
be used with
    <a name="an2932"></a>
        variadic templates. The following function template accepts any series
of <code >int</code> values, forwarding these values to a class template. The class
template defines an <code >enum</code> value <code >result</code> which is returned by the
function, unless no int values were specified, in which case 0 is returned.
        <pre>
    template &lt;int ... Ints&gt;
    int forwarder()
    {
        return computer&lt;Ints ...&gt;::result;  // forwarding the Ints
    }

    template &lt;&gt;     // specialization if no ints are provided
    int forwarder&lt;&gt;()
    {
        return 0;
    }

    // use as:
    cout &lt;&lt; forwarder&lt;1, 2, 3&gt;() &lt;&lt; ' ' &lt;&lt; forwarder&lt;&gt;() &lt;&lt; '\n';
</pre>
    The <code >sizeof</code> operator can be used for variadic non-type parameters as
well: <code >sizeof...(Ints)</code> would return 3 when used in the first function
template for <code >forwarder&lt;1, 2, 3&gt;()</code>.
<p>
Variadic non-type parameters are used to define variadic literal
operators, introduced in section <a href="cplusplus23.html#UDL">23.3</a>.
<p>
<a name="NOTFN"></a><a name="l552"></a>
<h3 >22.5.5: A bare bones `not_fn' negator</h3>
    Section <a href="cplusplus18.html#NEGATORS">18.1.4.2</a> covered the <code >not1</code> and <code >not2</code> negators. These
negators cannot always be used in combination with the <code >bind</code> function
template, and there use is limited to situations where one or two arguments
are used. It is likely that in the upcoming <a name="an2933"></a>C++17 standard they will either
be deprecated or they will be augmented with a more generic negator, for which
the name <a name="an2934"></a><code >not_fn</code> has been coined.
<p>
In this section we'll have a look at a possible bare bones implementation of
such a <code >not_fn</code> negator.
<p>
Let's first have a look at how <code >not_fn</code> can be used. When discussing the
negators it was noted that the second of the following two statements won't
compile:
        <pre>
    count_if(vs.begin(), vs.end(), 
        bind(not2(greater_equal&lt;string&gt;()), _1, reftext));

    count_if(vs.begin(), vs.end(),
        not1(bind(greater_equal&lt;string&gt;()), _1, reftext));
</pre>
    Here we'll develop an alternative, <code >not_fn</code>, replacing <code >not1</code> and
<code >not2</code> in the above statements:
        <pre>
    count_if(vs.begin(), vs.end(),                          // 1
        bind(not_fn(greater_equal&lt;string&gt;()), _1, reftext));

    count_if(vs.begin(), vs.end(),                          // 2
        not_fn(bind(greater_equal&lt;string&gt;()), _1, reftext));
</pre>
  In statement 1 <code >not_fn</code> is passed the <code >greater_equal&lt;string&gt;()</code> functor,
in statement 2 <code >not_fn</code> is passed a functor, returned by <code >bind</code>. By
defining <code >not_fn</code> as a template function the compiler is able to determine
the argument's type. Thus <code >not_fn</code> merely needs a <code >typename Fun</code> template
type parameter.
<p>
When used, <code >not_fn's</code> function call operators may receive different
types and numbers of arguments (in statement 1 it receives two arguments from
<code >bind's</code> function call operator, in statement 2 it receives one argument
from <code >count_if</code>).  Those arguments must in turn be forwarded to the function
call operator of the function object that was passed to
<code >not_fn</code>. Summarizing we have this situation (see figure <a href="cplusplus22.html#NOTFNFIG">26</a>):
    <ol>
    <li> Some function or functor must be called, e.g., <code >greater_equal</code>,
        but its return value must be negated;
    <li> The function is passed to the function template <code >not_fn</code>. The
        compiler determines its type. This type is used to construct a
        <code >not_fn_</code> class template, which is returned by <code >not_fn</code>;
    <li> The <code >not_fn_</code> object itself is a functor, and its <code >operator()</code>
        member perfectly forwards its arguments to the function originally
        specified a steps 1 and 2, and returns the negated return value of the
        original function;
    <li> Some calling function receives the <code >not_fn_</code> object, and calls its
        <code >operator()</code> with the appropriate argument(s). 
    </ol>
<p>
<p><a name="NOTFNFIG"></a><figure >
<img src="classtemplates/notfn.gif" >
<figcaption >Figure 26: Using not_fn</figcaption>
</figure></p>

<p>
In step 2 <code >not_fn</code> is used. It is defined like this:
        <pre>
    template &lt;typename Fun&gt;
    not_fn_&lt;Fun&gt; not_fn(Fun const &amp;fun)
    {
        return not_fn_&lt;Fun&gt;(fun);
    }
</pre>
    This function returns a <code >not_fn_</code> function object, initialized with the
functor to call (e.g., <code >greater_equal&lt;string&gt;()</code> or the functor returned by
<code >bind</code>).
<p>
Also in step 2 <code >not_fn_</code>'s constructor is mentioned, saving
a reference to the function mentioned in step 1:
        <pre>
    template &lt;typename Fun&gt;
    struct not_fn_
    {
        Fun const &amp;d_fun;
    
        not_fn_(Fun const &amp;fun)
        :
            d_fun(fun)
        {}
        ...
    };
</pre>
<p>
In step 3 <code >not_fn_</code>'s function call operator is used. It perfectly
forwards its arguments to step 1's function, which can be accessed via its
<code >d_fun</code> data member. The function call operator returns <code >d_fun's</code> negated 
return value:
        <pre>
    template &lt;typename ... ParTypes&gt;
    bool operator()(ParTypes &amp;&amp; ...types)
    {
        return not d_fun(std::forward&lt;ParTypes&gt;(types)...);
    }
</pre>
<p>
The next example shows how <code >not_fn</code> can be used: using
<code >equal_to&lt;string&gt;()</code> two ways to count the number of elements in a string
vector that are not equal to <code >"b"</code> are shown. The program's output displays
two twos:
        <pre>
     1: int main()
     2: {
     3:     vector&lt;string&gt; vs {"a", "a", "b"};
     4:     string reftext {"b"};
     5:
     6:     cout &lt;&lt;
     7:         count_if(vs.begin(), vs.end(),
     8:             bind(not_fn(equal_to&lt;string&gt;()), _1, reftext)) &lt;&lt; '\n' &lt;&lt;
     9:         count_if(vs.begin(), vs.end(),
    10:             not_fn(bind(equal_to&lt;string&gt;(), _1, reftext))) &lt;&lt; '\n';
    11: }
</pre>
<p>
<a name="TUPLES"></a><a name="l553"></a>
<h2 >22.6: Tuples</h2>
<strong >C++</strong> offers a <a name="an2935"></a><em >generalized pair</em> container: the <a name="an2936"></a><em >tuple</em>, covered in
this section.  Before tuples can be used the header file <a name="an2937"></a><code >&lt;tuple&gt;</code> must be
included.
<p>
Whereas <code >std::pair</code> containers have limited functionality and only support
two members, tuples have slightly more functionality and may contain an
unlimited number of different data types. In that respect a tuple can be
considered the `template's answer to <strong >C</strong>'s struct'.
<p>
A tuple's generic declaration (and definition) uses the variadic template
notation:
        <pre>
    template &lt;class ...Types&gt;
    class tuple;
</pre>
Here is an example of its use:
        <pre>
    typedef std::tuple&lt;int, double &amp;, std::string, char const *&gt; tuple_idsc;

    double pi = 3.14;
    tuple_idsc idsc(59, pi, "hello", "fixed");

    // access a field:
    std::get&lt;2&gt;(idsc) = "hello world";
</pre>
    The <a name="an2938"></a><code >std::get&lt;idx&gt;(tupleObject)</code> function template returns a
reference to the <code >idx</code><sup >th</sup> (zero based) field of the tuple
<code >tupleObject</code>. The index is specified as the function template's non-type
template argument.
<p>
Type-based tuple addressing (<a name="an2939"></a>) can be
used for tuple types used once in a tuple definition (if the same type is used
repeatedly referring to that type introduces an ambiguity). The next example
shows how to refer to the elements in the above example by type:
        <pre>
    get&lt;int&gt;(idsc)              // 59
    get&lt;double &amp;&gt;(idsc)         // 3.14
    get&lt;string&gt;(idsc)           // "hello"s
    get&lt;char const *&gt;(idsc)     // "fixed"
</pre>
<p>
Tuples may be constructed without specifying initial values. Primitive
types are initialized to zeroes; class type fields are initialized by their
default constructors. Be aware that in some situations the construction of a
tuple may succeed but its use may fail. Consider:
        <pre>
    tuple&lt;int &amp;&gt; empty;
    cout &lt;&lt; get&lt;0&gt;(empty);
</pre>
    Here the tuple <code >empty</code> cannot be used as its <code >int &amp;</code> field is an
undefined reference. However, <code >empty</code>'s construction succeeds.
<p>
Tuples may be assigned to each other if their type lists are identical; if
supported by their constituent types copy constructors are available as
well. Copy construction and assignment is also available if a right-hand type
can be converted to its matching left-hand type or if the left-hand type can
be constructed from the matching right-hand type. Tuples
(matching in number and (convertible) types) can be compared using relational
operators as long as their constituent types support comparisons. In this
respect tuples are like pairs.
<p>
Tuples offer the following static elements (using compile-time
initialization):
    <ul>
    <li><a name="an2940"></a><code >std::tuple_size&lt;Tuple&gt;::value</code> returns the number of
types defined for the tuple type <code >Tuple</code>. Example:
        <pre>
cout &lt;&lt; tuple_size&lt;tuple_idsc&gt;::value &lt;&lt; '\n';  // displays: 4
</pre>
    <li><a name="an2941"></a><code >std::tuple_element&lt;idx, Tuple&gt;::type</code>
        returns the type of element <code >idx</code> of <code >Tuple</code>. Example:
        <pre>
tuple_element&lt;2, tuple_idsc&gt;::type text;  // defines std::string text
</pre>
    </ul>
<p>
The unpack operator can also be used to forward the arguments of a
constructor to a tuple data member. Consider a class <code >Wrapper</code> that is
defined as a variadic template:
        <pre>
    template &lt;typename ...Params&gt;
    class Wrapper
    {
        ...
        public:
            Wrapper(Params &amp;&amp;...params);
    };
</pre>
    This class may be given a tuple data member which should be initialized by
the types and values that are used when initializing an object of the class
 <a name="an2942"></a> <code >Wrapper</code> using perfect
forwarding. Comparable to the way a class may inherit from its template types
(cf. section <a href="cplusplus22.html#UNPACK">22.5.3</a>) it may forward its types and constructor arguments
to its tuple data member:
        <pre>
    template &lt;typename ...Params&gt;
    class Wrapper
    {
        std::tuple&lt;Params...&gt; d_tuple;     // same types as used for
                                            // Wrapper itself
        public:
            Wrapper(Params &amp;&amp;...params)
            :                               // initialize d_tuple with
                                            // Wrapper's arguments
                d_tuple(std::forward&lt;Params&gt;(params)...)
            {}
    };
</pre>
<p>
<a name="l554"></a>
<h2 >22.7: Computing the return type of function objects</h2>
As amply illustrated in chapter <a href="cplusplus19.html#GENERIC">19</a> function objects play an
important role with generic algorithms. Like generic algorithms themselves,
function objects can be generically defined as members of class templates. If
the function call operators (<code >operator()</code>) of such classes define parameters
then the types of those parameters may also be abstracted by defining the
function call operators themselves as member templates.  Example:
        <pre>
    template &lt;typename Class&gt;
    class Filter
    {
        Class obj;
        public:
            template &lt;typename Param&gt;
            Param operator()(Param const &amp;param) const
            {
                return obj(param);
            }
    };
</pre>
    The template class <code >Filter</code> is a wrapper around <code >Class</code>, filtering
<code >Class</code>'s function call operator through its own function call operator. In
the above example the return value of <code >Class</code>'s function call operator is
simply passed on, but any other manipulation is of course also possible.
<p>
A type that is specified as <code >Filter</code>'s template type argument may of
course have multiple function call operators:
        <pre>
    struct Math
    {
        int operator()(int x);
        double operator()(double x);
    };
</pre>
    <code >Math</code> objects can now be filtered using <code >Filter&lt;Math&gt; fm</code> using
<code >Math</code>'s first or second function call operator, depending on the actual
argument type. With <code >fm(5)</code> the <code >int</code>-version is used, with <code >fm(12.5)</code>
the <code >double</code>-version is used.
<p>
However, this scheme doesn't work if the function call operators have
different return and argument types. Because of this the following class
<code >Convert</code> cannot be used with <code >Filter</code>:
        <pre>
    struct Convert
    {
        double operator()(int x);           // int-to-double
        std::string operator()(double x);   // double-to-string
    };
</pre>
    This problem can be tackled successfully by the class template
 <a name="an2943"></a><a name="an2944"></a>
 <code >std::result_of&lt;Functor(Typelist)&gt;</code>. Before using <code >std::result_of</code> the
header file <a name="an2945"></a><code >&lt;functional&gt;</code> must be included.
<p>
The <code >result_of</code> class template offers a <code >typedef</code> (<code >type</code>), representing
the type that is returned by <code >Functor&lt;TypeList&gt;</code>. It can be used  as follows
to improve the implementation of <code >Filter</code>:
        <pre>
    template &lt;typename Class&gt;
    class Filter
    {
        Class obj;
        public:
            template &lt;typename Arg&gt;
                typename std::result_of&lt;Class(Arg)&gt;::type
                operator()(Arg const &amp;arg) const
                {
                    return obj(arg);
                }
    };
</pre>
    Using this definition, <code >Filter&lt;Convert&gt; fc</code> can be constructed. Now
<code >fc(5)</code> returns a <code >double</code>, while <code >fc(4.5)</code> returns a
<code >std::string</code>.
<p>
The class <code >Convert</code> must define the relationships between its function call
operators and their return types. Predefined function objects (like those in
the standard template library) already do so, but self-defined function
objects must do this explicitly.
<p>
If a function object class defines only one function call operator it can
define its return type by a <code >typedef</code>. If the above class <code >Convert</code> would
only define the first of its two function call operators then the <code >typedef</code>
(in the class's <code >public</code> section) should be:
        <pre>
    typedef double type;
</pre>
<p>
If multiple function call operators are defined, each with its own signature
and return type, then the association between signature and return type is set
up as follows (all in the class's <code >public</code> section):
    <ul>
    <li> define a generic <code >struct result</code> like this:
        <pre>
template &lt;typename Signature&gt;
struct result;
</pre>
    <li> For each function call signature define a <em >specialization</em> of
<code >struct result</code>. <code >Convert</code>'s first function call operator gives rise to:
        <pre>
template &lt;typename Class&gt;
struct result&lt;Class(int)&gt;
{
    typedef double type;
};
</pre>
    and <code >Convert</code>'s second function call operator to:
        <pre>
template &lt;typename Class&gt;
struct result&lt;Class(double)&gt;
{
    typedef std::string type;
};
</pre>
    <li> In cases where function call operators have multiple arguments the
specifications should again provide for the correct signatures. A function
call operator called with an <code >int</code> and a <code >double</code>, returning a <code >size_t</code>
gets:
        <pre>
template &lt;typename Class&gt;
struct result&lt;Class(int, double)&gt;
{
    typedef size_t type;
};
</pre>
    </ul>
<p>
<a name="l555"></a>
<h2 >22.8: Instantiating class templates</h2>
Class templates <a name="an2946"></a> are instantiated when an
object of a class template is defined. When a class template object is
defined or declared its template parameters must explicitly be specified.
<p>
Template parameters are <em >also</em> specified when default template parameter
values are specified albeit that in that case the compiler provides the
defaults (cf. section <a href="cplusplus22.html#PARTIAL">22.4</a> where <code >double</code> is used as the default
type to use for the template's <code >DataType</code> parameter).  The actual values or
types of template parameters are
    <a name="an2947"></a>
 <em >never</em> deduced from arguments as is done with function template
parameters. So to define a <code >Matrix</code> of complex-valued elements, the
following syntax is used:
        <pre>
    Matrix&lt;3, 5, std::complex&gt; complexMatrix;
</pre>
 Since the class template <code >Matrix</code> uses a default data type
a matrix of <code >double</code>-valued elements can be defined like this:
        <pre>
    Matrix&lt;3, 5&gt; doubleMatrix;
</pre>
    A class template object may be <em >declared</em> using the keyword <a name="an2948"></a><code >extern</code>.
        <a name="an2949"></a>
    For example, to <em >declare</em> the matrix <code >complexMatrix</code> use:
        <pre>
    extern Matrix&lt;3, 5, std::complex&gt; complexMatrix;
</pre>
        <a name="an2950"></a>
        <a name="an2951"></a>
        <a name="an2952"></a>
        <a name="an2953"></a>
    A class template declaration suffices to compile return values or
parameters that are of class template types. Example: the following source
file may be compiled, although the compiler hasn't seen the definition of the
<code >Matrix</code> class template.  Generic classes and (partial) specializations may
all be declared. A function expecting or returning a class template object,
reference, or parameter automatically becomes a function template itself. This
is necessary to allow the compiler to tailor the function to the types of
various actual arguments that may be passed to the function:
        <pre>
    #include &lt;cstddef&gt;

    template &lt;size_t Rows, size_t Columns, typename DataType = double&gt;
    class Matrix;

    template &lt;size_t Columns, typename DataType&gt;
    class Matrix&lt;1, Columns, DataType&gt;;

    Matrix&lt;1, 12&gt; *function(Matrix&lt;2, 18, size_t&gt; &amp;mat);
</pre>
<p>
When class templates are <em >used</em> the compiler must first have seen their
implementations. So, template member functions must be known to the compiler
when the template is instantiated.  This does not mean that <em >all</em> members of
a template class are instantiated or must have been seen when a class template
object is defined.
        <a name="an2954"></a>
    The compiler only instantiates those members that are actually used. This
is illustrated by the following simple class <code >Demo</code> that has two
constructors and two members. When we use one constructor and call one member
in <code >main</code> note the sizes of the resulting object file and executable
program. Next the class definition is modified in that the unused constructor
and member are commented out. Again we compile and link the program. Now
observe that these latter sizes are identical to the former sizes.  There are
other ways to illustrate that only used members are instantiated. The <a name="an2955"></a><code >nm</code>
program could be used. It shows the symbolic contents of object files.  Using
<code >nm</code> we'll reach the same conclusion: <em >only template member functions that
are actually used are instantiated</em>.  Here is the class template <code >Demo</code> that
was used for our little experiment. In <code >main</code> only the first constructor
and the first member function are called and thus only these members were
instantiated:
        <pre>
    #include &lt;iostream&gt;

    template &lt;typename Type&gt;
    class Demo
    {
        Type d_data;
        public:
            Demo();
            Demo(Type const &amp;value);
            void member1();
            void member2(Type const &amp;value);
    };
    template &lt;typename Type&gt;
    Demo&lt;Type&gt;::Demo()
    :
        d_data(Type())
    {}
    template &lt;typename Type&gt;
    void Demo&lt;Type&gt;::member1()
    {
        d_data += d_data;
    }

    // the following members should be commented out before
    // compiling for the 2nd time:

    template &lt;typename Type&gt;
    Demo&lt;Type&gt;::Demo(Type const &amp;value)
    :
        d_data(value)
    {}
    template &lt;typename Type&gt;
    void Demo&lt;Type&gt;::member2(Type const &amp;value)
    {
        d_data += value;
    }

    int main()
    {
        Demo&lt;int&gt; demo;
        demo.member1();
    }
</pre>
<p>
<a name="l556"></a>
<h2 >22.9: Processing class templates and instantiations</h2>
In section <a href="cplusplus21.html#NAMERESFUN">21.13</a> the distinction between code depending on template
parameters and code not depending on template parameters was introduced.
The same distinction also holds true when class templates are defined and
used.
<p>
Code not depending on template parameters is verified by the compiler when
the template is defined. If a member function in a class template uses a
<a name="an2956"></a><code >qsort</code> function, then <code >qsort</code> does not depend on a template
parameter. Consequently, <code >qsort</code> must be known to the compiler when it
encounters <code >qsort</code>'s function call. In practice this implies that the
<a name="an2957"></a><code >&lt;cstdlib&gt;</code> header file must have been read by the compiler before it
is able to compile the class template definition.
<p>
On the other hand, if a template defines a <code >&lt;typename Ret&gt;</code> template
type parameter to parameterize the return type of some template member
function as in:
        <pre>
    Ret member();
</pre>
    then the compiler may encounter <code >member</code> or the class to which
<code >member</code> belongs in the following locations:
    <ul>
    <li> the location where a class template object is defined. This is called
the
        <a name="an2958"></a><em >point of instantiation</em> of the class template object.
    The compiler must have read the class template's implementation and has
performed a basic check for syntactic correctness of member functions like
<code >member</code>. It won't accept a definition or declaration like <code >Ret &amp;&amp;
*member</code>, because <strong >C++</strong> does not support functions returning pointers to
rvalue references. Furthermore, it checks whether the actual type name
that is used for instantiating the object is valid. This type name must be
known to the compiler at the object's point of instantiation.
    <li> the location where the template member function is used. This is
called the template member function's point of instantiation. Here
the <code >Ret</code> parameter must have been specified (or deduced) and at this point
<code >member</code>'s
statements that depend on the <code >Ret</code> template parameter are checked for
syntactic correctness. For example, if <code >member</code> contains a statement
like
        <pre>
    Ret tmp(Ret(), 15);
</pre>
    then this is in principle a syntactically valid statement. However, when
<code >Ret = int</code> the statement fails to compile as <code >int</code> does not have a
constructor expecting two <code >int</code> arguments. Note that this is <em >not</em> a
problem when the compiler instantiates an object of <code >member</code>'s class.  At
the point of instantiation of the object its member function `<code >member</code>' is
not instantiated and so the invalid <code >int</code> construction remains undetected.
    </ul>
<p>
<a name="TEMPFRIENDS"></a><a name="l557"></a>
<h2 >22.10: Declaring friends</h2>
    Friend <a name="an2959"></a> functions are normally constructed as <em >support</em> (free)
functions of a class that cannot be implemented and declared as class
members. The insertion operator for output streams is a well known
example. Friend classes are most often seen in the context of nested classes.
Here the inner class declares the outer class as its friend (or the other way
around). Again we see a support mechanism: the inner class is constructed to
support the outer class.
<p>
Like ordinary classes, class templates may declare other functions and
classes as their friends. Conversely, ordinary classes may declare template
classes as their friends. Here too, the friend is constructed as a special
function or class augmenting or supporting the functionality of the declaring
class. Although the <code >friend</code> keyword can be used by any type of class
        <a name="an2960"></a>
        <a name="an2961"></a>
    (ordinary or template) when using class templates the following cases
should be distinguished:
    <ul>
    <li> A class template may declare an ordinary function or class as its
friend. This is a common friend declaration, such as the insertion operator
for <code >ostream</code> objects.
    <li> A class template may declare another function template or class
template as its friend. In this case, the friend's template parameters may
have to be specified.
<p>
If the actual values of the friend's template parameters <em >must</em> be equal
to the template parameters of the class declaring the friend, the friend is
said to be a <a name="an2962"></a><em >bound friend</em><a name="an2963"></a> class or function template. In
this case the template parameters of the template specifying the <code >friend</code>
declaration determine (<em >bind</em>) the values of the template parameters of the
friend class or function. Bound friends result in a one-to-one correspondence
between the template's parameters and the friend's template parameters.
    <li> In the most general case a class template may declare another
function template or class template to be its friend, irrespective of the
friend's actual template arguments.
<p>
In this case an <a name="an2964"></a><em >unbound friend</em> class or function template is
declared. The template parameters of the friend class or function template
remain to be specified and are not related in some predefined way to the
template parameters of the class declaring the friend. If a class template has
data members of various types, specified by its template parameters and
another class should be allowed direct access to these data members we want to
specify any of the current template arguments when specifying such a
friend. Rather than specifying multiple bound friends, a single generic
(unbound) friend may be declared, specifying the friend's actual template
parameters only when this is required.
    <li> The above cases, in which a template is declared as a friend, may
also be encountered when ordinary classes are used:
        <ul>
        <li> The ordinary class declaring ordinary friends has already been
covered (chapter <a href="cplusplus15.html#Friends">15</a>).
        <li> The equivalent of bound friends occurs if an ordinary class
specifies specific actual template parameters when declaring its friend.
        <li> The equivalent of unbound friends occurs if an ordinary class
declares a generic template as its friend.
        </ul>
    </ul>
<p>
<a name="l558"></a>
<h3 >22.10.1: Non-templates used as friends in templates</h3>
        A class template may declare an ordinary function, ordinary member
function or ordinary class as its friend.  Such a <a name="an2965"></a>friend may access the
class template's <a name="an2966"></a>private members.
<p>
Concrete classes and ordinary functions can be declared as friends, but
before a single member function of a class can be declared as a friend, the
compiler must have seen the <a name="an2967"></a>class interface declaring that member. Let's
consider the various possibilities:
    <ul>
    <li> A class template may declare an ordinary function to be its
friend. It is not completely clear <em >why</em> we would like to declare an
ordinary function as a friend. Usually we pass an object of the class
declaring the friend to such a function. With class templates this requires us
to provide the (friend) function with a template parameter without specifying
its types. As the language does not support constructions like
        <pre>
void function(std::vector&lt;Type&gt; &amp;vector)
</pre>
    unless <code >function</code> itself is a template, it is not immediately clear how
and why such a friend should be constructed. One reason could be to allow the
function access to the class's private static members. In addition such
friends could instantiate objects of classes that declare them as their
friends. This would allow the friend functions direct access to such object's
private members. For example:
        <pre>
    template &lt;typename Type&gt;
    class Storage
    {
        friend void basic();
        static size_t s_time;
        std::vector&lt;Type&gt; d_data;
        public:
            Storage();
    };
    template &lt;typename Type&gt;
    size_t Storage&lt;Type&gt;::s_time = 0;
    template &lt;typename Type&gt;
    Storage&lt;Type&gt;::Storage()
    {}

    void basic()
    {
        Storage&lt;int&gt;::s_time = time(0);
        Storage&lt;double&gt; storage;
        std::random_shuffle(storage.d_data.begin(), storage.d_data.end());
    }
</pre>
<p>
<li> Declaring an ordinary class to be a class template's friend probably
finds more applications. Here the ordinary (friend) class may instantiate any
kind of object of the class template. The friend class may then access all
private members of the instantiated class template:
        <pre>
    template &lt;typename Type&gt;
    class Composer
    {
        friend class Friend;
        std::vector&lt;Type&gt; d_data;
        public:
            Composer();
    };

    class Friend
    {
        Composer&lt;int&gt; d_ints;
        public:
            Friend(std::istream &amp;input);
    };

    inline::Friend::Friend(std::istream &amp;input)
    {
        std::copy(std::istream_iterator&lt;int&gt;(input),
                  std::istream_iterator&lt;int&gt;(),
                  back_inserter(d_ints.d_data));
    }
</pre>
<p>
<li> Alternatively, just a single member function of an ordinary class may
be declared as a friend. This requires that the compiler has read the friend
class's interface before declaring the friend. Omitting the required
destructor and overloaded assignment operators, the following shows an example
of a class whose member <code >randomizer</code> is declared as a friend of the class
<code >Composer</code>:
        <pre>
    template &lt;typename Type&gt;
    class Composer;

    class Friend
    {
        Composer&lt;int&gt; *d_ints;
        public:
            Friend(std::istream &amp;input);
            void randomizer();
    };

    template &lt;typename Type&gt;
    class Composer
    {
        friend void Friend::randomizer();
        std::vector&lt;Type&gt; d_data;
        public:
            Composer(std::istream &amp;input)
            {
                std::copy(std::istream_iterator&lt;int&gt;(input),
                          std::istream_iterator&lt;int&gt;(),
                          back_inserter(d_data));
            }
    };

    inline Friend::Friend(std::istream &amp;input)
    :
        d_ints(new Composer&lt;int&gt;(input))
    {}

    inline void Friend::randomizer()
    {
        std::random_shuffle(d_ints-&gt;d_data.begin(), d_ints-&gt;d_data.end());
    }
</pre>
<p>
In this example <code >Friend::d_ints</code> is a pointer member. It
cannot be a <code >Composer&lt;int&gt;</code> object as the <code >Composer</code> class interface
hasn't yet been seen by the compiler when it reads <code >Friend</code>'s class
interface. Disregarding this and defining a data member <code >Composer&lt;int&gt;
d_ints</code> results in the compiler generating the error
        <a name="an2968"></a>
        <pre>
error: field `d_ints' has incomplete type
</pre>
    `Incomplete type', as the compiler at this points knows of the existence
of the class <code >Composer</code>, but as it hasn't seen <code >Composer</code>'s interface it
doesn't know what size the <code >d_ints</code> data member has.
    </ul>
<p>
<a name="l559"></a>
<h3 >22.10.2: Templates instantiated for specific types as friends</h3>
        With <a name="an2969"></a><em >bound friend</em><a name="an2970"></a> class or function templates there
is a one-to-one mapping between the template arguments of the friend templates
and the template arguments of the class templates declaring them as
friends. In this case, the friends themselves are templates too. Here are the
various possibilities:
    <ul>
    <li> A function template is a friend of a class template. In this case we
don't experience the problems we encountered with ordinary functions declared
as friends of class templates. Since the friend function template itself is a
template it may be provided with the required template arguments allowing it
to become the declaring class's friend. The various declarations are organized
like this:
    <ul>
    <li> The class template declaring the bound template friend function is
defined;
    <li> The (friend) function template is defined, now having access to all
the class template's (private) members.
        </ul>
    The bound template friend declaration specifies the required template
arguments immediately following the template's function name. Without the
template argument list affixed to the function name it would remain an
ordinary friend function. Here is an example showing a bound friend to create
a subset of the entries of a dictionary. For real life examples, a dedicated
function object returning <code >!key1.find(key2)</code> is probably more useful.  For
the current example, <code >operator==</code> is acceptable:
        <pre>
    template &lt;typename Key, typename Value&gt;
    class Dictionary
    {
        friend Dictionary&lt;Key, Value&gt;
            subset&lt;Key, Value&gt;(Key const &amp;key,
                               Dictionary&lt;Key, Value&gt; const &amp;dict);

        std::map&lt;Key, Value&gt; d_dict;
        public:
            Dictionary();
    };

    template &lt;typename Key, typename Value&gt;
    Dictionary&lt;Key, Value&gt;
               subset(Key const &amp;key, Dictionary&lt;Key, Value&gt; const &amp;dict)
    {
        Dictionary&lt;Key, Value&gt; ret;

        std::remove_copy_if(dict.d_dict.begin(), dict.d_dict.end(),
                            std::inserter(ret.d_dict, ret.d_dict.begin()),
                            std::bind2nd(std::equal_to&lt;Key&gt;(), key));
        return ret;
    }
</pre>
<p>
<li> By declaring a full class template as a class template's friend, all
members of the friend class may access all private members of the class
declaring the friend. As the friend class only needs to be declared, the
organization of the declaration is much easier than when function templates
are declared as friends. In the following example a class <code >Iterator</code> is
declared as a friend of a class <code >Dictionary</code>. Thus, the <code >Iterator</code> is able
to access <code >Dictionary</code>'s private data. There are some interesting points to
note here:
        <ul>
        <li> To declare a class template as a friend, that class only needs to
be declared as a class template before it is declared as a friend:
            <pre>
    template &lt;typename Key, typename Value&gt;
    class Iterator;

    template &lt;typename Key, typename Value&gt;
    class Dictionary
    {
        friend class Iterator&lt;Key, Value&gt;;
</pre>
<p>
<li> However, members of the friend class may already be used, even
though the compiler hasn't seen  the friend class's interface yet:
            <pre>
    template &lt;typename Key, typename Value&gt;
    template &lt;typename Key2, typename Value2&gt;
    Iterator&lt;Key2, Value2&gt; Dictionary&lt;Key, Value&gt;::begin()
    {
        return Iterator&lt;Key, Value&gt;(*this);
    }
    template &lt;typename Key, typename Value&gt;
    template &lt;typename Key2, typename Value2&gt;
    Iterator&lt;Key2, Value2&gt; Dictionary&lt;Key, Value&gt;::subset(Key const &amp;key)
    {
        return Iterator&lt;Key, Value&gt;(*this).subset(key);
    }
</pre>
<p>
<li> Of course, the friend class's interface must eventually be seen
by the compiler. Since it's a support class for <code >Dictionary</code> it can safely
define a <code >std::map</code> data member that is initialized by the friend class's
constructor. The constructor may then access the <code >Dictionary</code>'s private data
member <code >d_dict</code>:
            <pre>
    template &lt;typename Key, typename Value&gt;
    class Iterator
    {
        std::map&lt;Key, Value&gt; &amp;d_dict;

        public:
            Iterator(Dictionary&lt;Key, Value&gt; &amp;dict)
            :
                d_dict(dict.d_dict)
            {}
</pre>
<p>
<li> The <code >Iterator</code> member <code >begin</code> may return a <code >map</code>
iterator. Since the compiler does not know what the instantiation of the map
looks like, a <code >map&lt;Key, Value&gt;::iterator</code> is a template subtype. So it
cannot be used as-is, but it must be prefixed by
<code >typename</code> (see the function <code >begin</code>'s return type in the next example):
            <pre>
    template &lt;typename Key, typename Value&gt;
    typename std::map&lt;Key, Value&gt;::iterator Iterator&lt;Key, Value&gt;::begin()
    {
        return d_dict.begin();
    }
</pre>
<p>
</ul>
<p>
<li> In the previous example we might decide that only a <code >Dictionary</code>
should be able to construct an <code >Iterator</code> (maybe because we conceptually
consider <code >Iterator</code> to be a sub-type of <code >Dictionary</code>). This is easily
accomplished by defining <code >Iterator</code>'s constructor in its private section,
and by declaring <code >Dictionary</code> to be a friend of <code >Iterator</code>. Consequently,
only a <code >Dictionary</code> can create an <code >Iterator</code>. By declaring the constructor
of a <em >specific</em> <code >Dictionary</code> type as a friend of <code >Iterator</code>'s we declare
a <em >bound</em> friend. This ensures that only that particular type of
<code >Dictionary</code> can create <code >Iterator</code>s using template parameters identical to
its own. Here is how it's done:
        <pre>
    template &lt;typename Key, typename Value&gt;
    class Iterator
    {
        friend Dictionary&lt;Key, Value&gt;::Dictionary();
        std::map&lt;Key, Value&gt; &amp;d_dict;
        Iterator(Dictionary&lt;Key, Value&gt; &amp;dict);
        public:
</pre>
<p>
In this example, <code >Dictionary</code>'s constructor is <code >Iterator</code>'s
friend. The friend is a template member. Other members can be declared as
a class's friend as well. In those cases their prototypes must be used, also
specifying the types of their return values. Assuming that
        <pre>
std::vector&lt;Value&gt; sortValues()
</pre>
    is a member of <code >Dictionary</code> then the matching bound friend declaration
is:
        <pre>
friend std::vector&lt;Value&gt; Dictionary&lt;Key, Value&gt;::sortValues();
</pre>
<p>
<li> A class template may define free members, which should have access to
the data of instantiations of the class template, but only for matching
types. An example is a class template for which the free member <code >operator==</code>
must be available. If this is required for a template <code >ClassTemplate</code>,
requiring a <code >typename Type</code> template type argument, then
a free member 
        <pre>
    template&lt;typename Type&gt;
    bool operator==(ClassTemplate&lt;Type&gt; const &amp;lhs, 
                    ClassTemplate&lt;Type&gt; const &amp;rhs);
</pre>
    must have been declared prior to <code >ClassTemplate</code>'s interface
itself. Within the class interface <code >operator==</code> may then be declared as a
friend, specifying <code >operator==</code> as a specialized function template (note the
<code >&lt;&gt;</code> following the function name) like this:
        <pre>
    template &lt;typename Type&gt;
    class ClassTemplate
    {
        friend  bool operator==&lt;&gt;(ClassTemplate&lt;Type&gt; const &amp;lhs, 
                                ClassTemplate&lt;Type&gt; const &amp;rhs);
        ...
    };
</pre>
    Now that the class has been declared, <code >operator==</code>'s implementation may
follow. 
    </ul>
<p>
Finally, the following example can be used as a prototype for
situations where bound friends are useful:
        <pre>
    template &lt;typename T&gt;   // a function template
    void fun(T *t)
    {
        t-&gt;not_public();
    };
    template&lt;typename X&gt;    // a free member function template
    bool operator==(A&lt;X&gt; const &amp;lhs, A&lt;X&gt; const &amp;rhs);
    template &lt;typename X&gt;   // a class template
    class A
    {                       // fun() is used as friend bound to A,
                            // instantiated for X, whatever X may be
        friend void fun&lt;A&lt;X&gt;&gt;(A&lt;X&gt; *);
                            // operator== is a friend for A&lt;X&gt; only
        friend  bool operator==&lt;&gt;(A&lt;X&gt; const &amp;lhs, A&lt;X&gt; const &amp;rhs);

        int d_data = 10;

        public:
            A();

        private:
            void not_public();
    };
    template &lt;typename X&gt;
    A&lt;X&gt;::A()
    {
        fun(this);
    }
    template &lt;typename X&gt;
    void A&lt;X&gt;::not_public()
    {}
    template&lt;typename X&gt;    // may access lhs/rhs's private data
    bool operator==(A&lt;X&gt; const &amp;lhs, A&lt;X&gt; const &amp;rhs)
    {
        return lhs.d_data == rhs.d_data;
    }

    int main()
    {
        A&lt;int&gt; a;

        fun(&amp;a);            // fun instantiated for A&lt;int&gt;.
    }
</pre>
<p>
<a name="l560"></a>
<h3 >22.10.3: Unbound templates as friends</h3>
        When a friend is declared as an
 <a name="an2971"></a><a name="an2972"></a><em >unbound</em> friend it merely declares an
existing template to be its friend (no matter how it is instantiated). This
may be useful in situations where the friend should be able to instantiate
objects of class templates declaring the friend, allowing the friend to access
the instantiated object's private members.  Functions, classes, and member
functions may all be declared as unbound friends.
<p>
Here are  the syntactic conventions  declaring unbound friends:
    <ul>
        <li> Declaring a function template as an unbound friend: any
instantiation of the function template may instantiate objects of the template
class and may access its private members. Assume the following
function template has been defined
        <pre>
template &lt;typename Iterator, typename Class, typename Data&gt;
Class &amp;ForEach(Iterator begin, Iterator end, Class &amp;object,
                    void (Class::*member)(Data &amp;));
</pre>
    This function template can be declared as an unbound friend in the
following class template <code >Vector2</code>:
        <pre>
template &lt;typename Type&gt;
class Vector2: public std::vector&lt;std::vector&lt;Type&gt; &gt;
{
    template &lt;typename Iterator, typename Class, typename Data&gt;
    friend Class &amp;ForEach(Iterator begin, Iterator end, Class &amp;object,
                void (Class::*member)(Data &amp;));
    ...
};
</pre>
    If the function template is defined inside some namespace this namespace
must be mentioned as well. Assuming that <code >ForEach</code> is defined in the
namespace <code >FBB</code> its friend declaration becomes:
        <pre>
template &lt;typename Iterator, typename Class, typename Data&gt;
friend Class &amp;FBB::ForEach(Iterator begin, Iterator end, Class &amp;object,
                void (Class::*member)(Data &amp;));
</pre>
    The following example illustrates the use of an unbound friend. The class
<code >Vector2</code> stores vectors of elements of template type parameter
<code >Type</code>. Its <code >process</code> member allows <code >ForEach</code> to call its private
<code >rows</code> member. The <code >rows</code> member, in turn, uses another <code >ForEach</code> to
call its private <code >columns</code> member. Consequently, <code >Vector2</code> uses two
instantiations of <code >ForEach</code> which is a clear hint for using an unbound
friend. It is assumed that <code >Type</code> class objects can be inserted into
<code >ostream</code> objects (the definition of the <code >ForEach</code> function template can
be found in the <code >cplusplus.yo.zip</code> archive at
<a href="http://sourceforge.net/projects/cppannotations/">http://sourceforge.net/projects/cppannotations/</a>). Here is the program:
        <pre>
    template &lt;typename Type&gt;
    class Vector2: public std::vector&lt;std::vector&lt;Type&gt; &gt;
    {
        typedef typename Vector2&lt;Type&gt;::iterator iterator;

        template &lt;typename Iterator, typename Class, typename Data&gt;
        friend Class &amp;ForEach(Iterator begin, Iterator end, Class &amp;object,
                    void (Class::*member)(Data &amp;));
        public:
            void process();

        private:
            void rows(std::vector&lt;Type&gt; &amp;row);
            void columns(Type &amp;str);
    };

    template &lt;typename Type&gt;
    void Vector2&lt;Type&gt;::process()
    {
        ForEach&lt;iterator, Vector2&lt;Type&gt;, std::vector&lt;Type&gt; &gt;
                (this-&gt;begin(), this-&gt;end(), *this, &amp;Vector2&lt;Type&gt;::rows);
    }

    template &lt;typename Type&gt;
    void Vector2&lt;Type&gt;::rows(std::vector&lt;Type&gt; &amp;row)
    {
        ForEach(row.begin(), row.end(), *this,
                                        &amp;Vector2&lt;Type&gt;::columns);
        std::cout &lt;&lt; '\n';
    }

    template &lt;typename Type&gt;
    void Vector2&lt;Type&gt;::columns(Type &amp;str)
    {
        std::cout &lt;&lt; str &lt;&lt; " ";
    }

    using namespace std;

    int main()
    {
        Vector2&lt;string&gt; c;
        c.push_back(vector&lt;string&gt;(3, "Hello"));
        c.push_back(vector&lt;string&gt;(2, "World"));

        c.process();
    }
    /*
        Generated output:

        Hello Hello Hello
        World World
    */
</pre>
<p>
<li> Analogously, a full class template may be declared as friend. This
allows all instantiations of the friend's member functions to instantiate
objects of the class template declaring the friend class. In this case, the
class declaring the friend should offer functionality that is useful to
different instantiations of its friend class (i.e., instantiations using
different template arguments). The syntactic convention is comparable to the
convention used when declaring an unbound friend function template:
        <pre>
template &lt;typename Type&gt;
class PtrVector
{
    template &lt;typename Iterator, typename Class&gt;
    friend class Wrapper;      // unbound friend class
};
</pre>
    All members of the class template <code >Wrapper</code> may now instantiate
<code >PtrVector</code>s using any actual type for its <code >Type</code> parameter. This allows
the <code >Wrapper</code> instantiation to access all of <code >PtrVector</code>'s private
members.
    <li> When only some members of a class template need access to private
members of another class template (e.g., the other class template has private
constructors and only some members of the first class template need to
instantiate objects of the second class template), then the latter class
template may declare only those members of the former class template requiring
access to its private members as its friends. Again, the friend class's
interface may be left unspecified. However, the compiler must be informed that
the friend member's class is indeed a class. A forward declaration of that
class must therefore be provided. In the next example <code >PtrVector</code>
declares <code >Wrapper::begin</code> as its friend. Note the forward declaration of
the class <code >Wrapper</code>:
        <pre>
template &lt;typename Iterator&gt;
class Wrapper;

template &lt;typename Type&gt;
class PtrVector
{
    template &lt;typename Iterator&gt; friend
        PtrVector&lt;Type&gt; Wrapper&lt;Iterator&gt;::begin(Iterator const &amp;t1);
    ...
};
</pre>
    </ul>
<p>
<a name="l561"></a>
<h3 >22.10.4: Extended friend declarations</h3>
    Through <a name="an2973"></a><em >extended friend</em> <em >declarations</em>, which are also available for
class templates, template type parameters can be declared as friends. A
template type argument, however, does not necessarily have to be a type for
which the keyword <code >friend</code> makes sense, like <code >int</code>. In those cases the
friend declaration is simply ignored.
<p>
Consider the following class template, declaring <code >Friend</code> as a friend:
        <pre>
    template &lt;typename Friend&gt;
    class Class
    {
        friend Friend;
        void msg();             // private, displays some message
    };
</pre>
    Now, an actual <code >Friend</code> class may access all of <code >Class</code>'s members
        <pre>
    class Concrete
    {
        Class&lt;Concrete&gt; d_class;
        Class&lt;std::string&gt; d_string;

       public:
            void msg()
            {
                d_class.msg();    // OK: calls private Class&lt;Concrete&gt;::msg()
                //d_string.msg(); // fails to compile: msg() is private
            }
    };
</pre>
    A declaration like <code >Class&lt;int&gt; intClass</code> is also OK, but here the friend
declaration is simply ignored. After all, there are no `int members' to access
<code >Class&lt;int&gt;</code>'s private members.
<p>
<a name="DERIVEDTEMPCLASS"></a><a name="l562"></a>
<h2 >22.11: Class template derivation</h2>
Class templates can be used for inheritance purposes as well. When a
class template is used in class derivation, the following situations should be
distinguished:
    <ul>
    <li> An existing class template is used as base class when deriving a
ordinary class. The derived class itself will partially be a class template,
but this is somewhat hidden from view when an object of the derived class is
defined.
    <li> An existing class template is used as the base class when deriving
another class template. Here the class template characteristics remain clearly
visible.
    <li> An ordinary class is used as the base class when deriving a template
class. This interesting hybrid allows us to construct class templates that
        <a name="an2974"></a>
are <em >partially compiled</em>.
    </ul>
    These three variants of <a name="an2975"></a> class template
derivation are elaborated in this and the upcoming sections.
<p>
Consider the following base class:
        <pre>
    template&lt;typename T&gt;
    class Base
    {
        T const &amp;t;

        public:
            Base(T const &amp;t);
    };
</pre>
    The above class is a class template that can be used as a base class for
the following derived class template <code >Derived</code>:
        <pre>
    template&lt;typename T&gt;
    class Derived: public Base&lt;T&gt;
    {
        public:
            Derived(T const &amp;t);
    };
    template&lt;typename T&gt;
    Derived&lt;T&gt;::Derived(T const &amp;t)
    :
        Base(t)
    {}
</pre>
    Other combinations are also possible. The base class may be instantiated
by specifying template arguments, turning the derived class into an ordinary
class (showing a class object's definition as well):
        <pre>
    class Ordinary: public Base&lt;int&gt;
    {
        public:
            Ordinary(int x);
    };
    inline Ordinary::Ordinary(int x)
    :
        Base(x)
    {}

    Ordinary ordinary(5);
</pre>
    This approach allows us to
 <a name="an2976"></a>
    add functionality to a class template, without the need for constructing a
derived class template.
<p>
Class template derivation pretty much follows the same rules as ordinary
class derivation, not involving class templates. Some subtleties that are
specific for class template derivation may easily cause confusion like the use
of <code >this</code> when members of a template base class are called from a derived
class. The reasons for using <code >this</code> are discussed in section <a href="cplusplus23.html#SUBTLE">23.1</a>. In
the upcoming sections the focus will be on the class derivation proper.
<p>
<a name="l563"></a>
<h3 >22.11.1: Deriving ordinary classes from class templates</h3>
    When an existing class template is used as a base class for deriving an
ordinary class, the class template parameters are specified when defining the
derived class's interface.  If in a certain context an existing class template
lacks a particular functionality, then it may be useful to derive an ordinary
class from a class template. For example, although the class <code >map</code> can
easily be used in combination with the <code >find_if()</code> generic algorithm
(section <a href="cplusplus19.html#FINDIF">19.1.16</a>), it requires the construction of a class and at least
two additional function objects of that class. If this is considered too much
overhead then extending a class template with tailor-made functionality
might be considered.
<p>
Example: a program executing commands entered at the keyboard might accept all
unique initial abbreviations of the commands it defines. E.g., the command
<code >list</code> might be entered as <code >l, li, lis</code> or <code >list</code>. By deriving a class
<code >Handler</code> from
        <pre>
    map&lt;string, void (Handler::*)(string const &amp;cmd)&gt;
</pre>
    and by defining a member function <code >process(string const &amp;cmd)</code> to do the
actual command processing a program might simply execute the following
<code >main()</code> function:
        <pre>
    int main()
    {
        string line;
        Handler cmd;

        while (getline(cin, line))
            cmd.process(line);
    }
</pre>
<p>
The class <code >Handler</code> itself is derived from a <code >std::map</code>, in which
the map's values are pointers to <code >Handler</code>'s member functions, expecting the
command line entered by the user. Here are <code >Handler</code>'s characteristics:
    <ul>
    <li> The class is derived from a <code >std::map</code>, expecting the command
associated with each command-processing member as its keys. Since
<code >Handler</code> uses the map merely to define associations between
        <a name="an2977"></a> the commands and the processing
member functions and to make available <code >map</code>'s <code >typedef</code>s, private
derivation is used:
        <pre>
    class Handler: private std::map&lt;std::string,
                            void (Handler::*)(std::string const &amp;cmd)&gt;
</pre>
<p>
<li> The actual association can be defined using static private data
members: <code >s_cmds</code> is an array of <code >Handler::value_type</code> values, and
<code >s_cmds_end</code> is a constant pointer pointing beyond the array's last element:
        <pre>
        static value_type s_cmds[];
        static value_type *const s_cmds_end;
</pre>
<p>
<li> The constructor simply initializes the map from these two static data
members. It could be implemented inline:
        <pre>
    inline Handler::Handler()
    :
        std::map&lt;std::string,
                    void (Handler::*)(std::string const &amp;cmd)&gt;
        (s_cmds, s_cmds_end)
    {}
</pre>
<p>
<li> The member <code >process</code> iterates along the map's elements. Once the
first word on the command line matches the initial characters of the command,
the corresponding command is executed. If no such command is found, an error
message is issued:
        <pre>
    void Handler::process(std::string const &amp;line)
    {
        istringstream istr(line);
        string cmd;
        istr &gt;&gt; cmd;
        for (iterator it = begin(); it != end(); it++)
        {
            if (it-&gt;first.find(cmd) == 0)
            {
                (this-&gt;*it-&gt;second)(line);
                return;
            }
        }
        cout &lt;&lt; "Unknown command: " &lt;&lt; line &lt;&lt; '\n';
    }
</pre>
<p>
</ul>
<p>
<a name="l564"></a>
<h3 >22.11.2: Deriving class templates from class templates</h3>
        Although it's perfectly acceptable to derive an ordinary class from a
class template, the resulting class of course has limited generality compared
to its template base class. If generality is important, it's probably a better
idea to derive a class template from a class template. This allows us to
extend an existing class template with new functionality or to override the
functionality of the existing class template.
<p>
The class template <code >SortVector</code> presented below is derived from the
existing class template <code >std::vector</code>. It allows us to perform a
<a name="an2978"></a><em >hierarchic sort</em> of its elements using any ordering of any data members
its data elements may contain. To accomplish this there is but one
requirement. <code >SortVector</code>'s data type must offer dedicated member
functions comparing its members.
<p>
For example, if <code >SortVector</code>'s data type is an object of class
<code >MultiData</code>, then <code >MultiData</code> should implement member functions having the
following prototypes for each of its data members which can be compared:
        <pre>
    bool (MultiData::*)(MultiData const &amp;rhv)
</pre>
    So, if <code >MultiData</code> has two data members, <code >int d_value</code> and
<code >std::string d_text</code> and both may be used by a hierarchic sort, then
<code >MultiData</code> should offer the following two members:
        <pre>
    bool intCmp(MultiData const &amp;rhv);  // returns d_value &lt; rhv.d_value
    bool textCmp(MultiData const &amp;rhv); // returns d_text  &lt; rhv.d_text
</pre>
    Furthermore, as a convenience it is assumed that <code >operator</code>&lt;&lt; and
<code >operator</code>&gt;&gt; have been defined for <code >MultiData</code> objects.
<p>
The class template <code >SortVector</code> is directly derived from the template
class <code >std::vector</code>. Our implementation inherits all members from that base
class. It also offers two simple constructors:
        <pre>
    template &lt;typename Type&gt;
    class SortVector: public std::vector&lt;Type&gt;
    {
        public:
            SortVector()
            {}
            SortVector(Type const *begin, Type const *end)
            :
                std::vector&lt;Type&gt;(begin, end)
            {}
</pre>
<p>
Its member <code >hierarchicSort</code> is the true <em >raison d'&ecirc;tre</em> for the
class. It defines the hierarchic sort criteria. It expects
        <a name="an2979"></a>
    a pointer to a series of pointers to member functions of the class
<code >Type</code> as well as a <code >size_t</code> representing the size of the array.
<p>
The array's first element indicates <code >Type</code>'s most significant sort
criterion, the array's last element indicates the class's least significant
sort criterion. Since the <a name="an2980"></a><code >stable_sort</code> generic algorithm was designed
explicitly to support hierarchic sorting, the member uses this generic
algorithm to sort <code >SortVector</code>'s elements. With hierarchic sorting, the
least significant criterion should be sorted first. <code >hierarchicSort</code>'s
implementation is therefore easy. It requires a support class <code >SortWith</code>
whose objects are initialized by the addresses of the member functions passed
to the <code >hierarchicSort()</code> member:
        <pre>
    template &lt;typename Type&gt;
    void SortVector&lt;Type&gt;::hierarchicSort(
                bool (Type::**arr)(Type const &amp;rhv) const,
                size_t n)
    {
        while (n--)
            stable_sort(this-&gt;begin(), this-&gt;end(), SortWith&lt;Type&gt;(arr[n]));
    }
</pre>
<p>
The class <code >SortWith</code> is a simple wrapper class around a pointer to
a predicate function. Since it depends on <code >SortVector</code>'s actual data
type the class <code >SortWith</code> must also be a class template:
        <pre>
    template &lt;typename Type&gt;
    class SortWith
    {
       bool (Type::*d_ptr)(Type const &amp;rhv) const;
</pre>
<p>
<code >SortWith</code>'s constructor receives a pointer to a predicate function and
initializes the class's <code >d_ptr</code> data member:
        <pre>
    template &lt;typename Type&gt;
    SortWith&lt;Type&gt;::SortWith(bool (Type::*ptr)(Type const &amp;rhv) const)
    :
        d_ptr(ptr)
    {}
</pre>
<p>
Its binary predicate member (<code >operator()</code>) must return <code >true</code> if its
first argument should eventually be placed ahead of its second argument:
        <pre>
    template &lt;typename Type&gt;
    bool SortWith&lt;Type&gt;::operator()(Type const &amp;lhv, Type const &amp;rhv) const
    {
        return (lhv.*d_ptr)(rhv);
    }
</pre>
<p>
The following examples, which can be embedded in a <code >main</code>
function, provides an illustration:
    <ul>
    <li> First, A <code >SortVector</code> object is created for <code >MultiData</code> objects.
It uses the <a name="an2981"></a><code >copy</code> generic algorithm to fill the <code >SortVector</code> object from
information appearing at the program's standard input stream. Having
initialized the object its elements are displayed to the standard output
stream:
        <pre>
        SortVector&lt;MultiData&gt; sv;

        copy(istream_iterator&lt;MultiData&gt;(cin),
                istream_iterator&lt;MultiData&gt;(),
                back_inserter(sv));
</pre>
<p>
<li> An array of pointers to members is initialized with the addresses of
two member functions. The text comparison is the most significant sort
criterion:
        <pre>
        bool (MultiData::*arr[])(MultiData const &amp;rhv) const =
        {
            &amp;MultiData::textCmp,
            &amp;MultiData::intCmp,
        };
</pre>
<p>
<li> Next, the array's elements are sorted and displayed to the standard
output stream:
        <pre>
        sv.hierarchicSort(arr, 2);
</pre>
<p>
<li> Then the two elements of the array of pointers to <code >MultiData</code>'s
member functions are swapped, and the previous step is repeated:
        <pre>
        swap(arr[0], arr[1]);
        sv.hierarchicSort(arr, 2);
</pre>
<p>
</ul>
    After compiling the program the following command can be given:
        <pre>
    echo a 1 b 2 a 2 b 1 | a.out
</pre>
    This results in the following output:
        <pre>
    a 1 b 2 a 2 b 1
    ====
    a 1 a 2 b 1 b 2
    ====
    a 1 b 1 a 2 b 2
    ====
</pre>
<p>
<a name="TFROMC"></a><a name="l565"></a>
<h3 >22.11.3: Deriving class templates from ordinary classes</h3>
        An ordinary class may be used as the base class for deriving a template
        <a name="an2982"></a> class. The advantage
of such an inheritance tree is that the base class's members may all be
compiled beforehand. When objects of the class template are now instantiated
only the actually used members of the derived class template must be
instantiated.
<p>
This approach may be used for all class templates having member functions
whose implementations do not depend on template parameters. These members may
be defined in a separate class which is then used as a base class of the
class template derived from it.
<p>
As an illustration of this approach we'll develop such a class template
below. We'll develop a class <code >Table</code> derived from an ordinary class
<code >TableType</code>. The class <code >Table</code> displays elements of some type in a
table having a configurable number of columns. The elements are either
displayed horizontally (the first <em >k</em> elements occupy the first row) or
vertically (the first <em >r</em> elements occupy a first column).
<p>
When displaying the table's elements they are inserted into a stream.  The
table is handled by a separate class (<code >TableType</code>), implementing the table's
presentation. Since the table's elements are inserted into a stream, the
conversion to text (or <code >string</code>) is implemented in <code >Table</code>, but the
handling of the strings themselves is left to <code >TableType</code>. We'll cover some
characteristics of <code >TableType</code> shortly, concentrating on <code >Table</code>'s
interface first:
    <ul>
    <li> The class <code >Table</code> is a class template, requiring only one template
type parameter: <code >Iterator</code> referring to an iterator to some data type:
        <pre>
template &lt;typename Iterator&gt;
class Table: public TableType
{
</pre>
<p>
<li> <code >Table</code> doesn't need any data members. All data manipulations are
performed by <code >TableType</code>.
    <li> <code >Table</code> has two constructors. The constructor's first two
parameters are <code >Iterator</code>s used to iterate over the elements that must be
entered into the table. The constructors require us to specify the number of
columns we would like our table to have as well as a
<em >FillDirection</em>. <code >FillDirection</code> is an <code >enum</code>, defined by <code >TableType</code>,
having values <code >HORIZONTAL</code> and <code >VERTICAL</code>. To allow <code >Table</code>'s users to
exercise control over headers, footers, captions, horizontal and vertical
separators, one constructor has a <code >TableSupport</code> reference parameter. The
class <code >TableSupport</code> is developed at a later stage as a virtual class
allowing clients to exercise this control. Here are the class's constructors:
        <pre>
        Table(Iterator const &amp;begin, Iterator const &amp;end,
                size_t nColumns, FillDirection direction);
        Table(Iterator const &amp;begin, Iterator const &amp;end,
                TableSupport &amp;tableSupport,
                size_t nColumns, FillDirection direction);
</pre>
<p>
<li> The constructors are <code >Table</code>'s only two public members. Both
constructors use a base class initializer to initialize their <code >TableType</code>
base class and then call the class's private member <code >fill</code> to insert data
into the <code >TableType</code> base class object. Here are the constructor's
implementations:
        <pre>
template &lt;typename Iterator&gt;
Table&lt;Iterator&gt;::Table(Iterator const &amp;begin, Iterator const &amp;end,
                TableSupport &amp;tableSupport,
                size_t nColumns, FillDirection direction)
:
    TableType(tableSupport, nColumns, direction)
{
    fill(begin, end);
}

template &lt;typename Iterator&gt;
Table&lt;Iterator&gt;::Table(Iterator const &amp;begin, Iterator const &amp;end,
                size_t nColumns, FillDirection direction)
:
    TableType(nColumns, direction)
{
    fill(begin, end);
}
</pre>
<p>
<li> The class's <code >fill</code> member iterates over the range of elements
<code >[begin, end)</code>, as defined by the constructor's first two parameters.
As we will see shortly, <code >TableType</code> defines a protected data member
<code >std::vector&lt;std::string&gt; d_string</code>. One of the requirements of the data
type to which the iterators point is that this data type can be inserted into
streams. So, <code >fill</code> uses an <code >ostringstream</code> object to obtain the textual
representation of the data, which is then appended to <code >d_string</code>:
        <pre>
template &lt;typename Iterator&gt;
void Table&lt;Iterator&gt;::fill(Iterator it, Iterator const &amp;end)
{
    while (it != end)
    {
        std::ostringstream str;
        str &lt;&lt; *it++;
        d_string.push_back(str.str());
    }
    init();
}
</pre>
<p>
</ul>
<p>
This completes the implementation of the class <code >Table</code>. Note that this
class template only has three members, two of them being
constructors. Therefore, in most cases only two function templates must be
instantiated: a constructor and the class's <code >fill</code> member. For example, the
following defines a table having four columns, vertically filled by
<code >string</code>s extracted from the standard input stream:
        <pre>
    Table&lt;istream_iterator&lt;string&gt; &gt;
        table(istream_iterator&lt;string&gt;(cin), istream_iterator&lt;string&gt;(),
              4, TableType::VERTICAL);
</pre>
    The fill-direction is specified as
<code >TableType::VERTICAL</code>. It could also have been specified using <code >Table</code>,
but since <code >Table</code> is a class template its specification would have been
slightly more complex: <code >Table&lt;istream_iterator&lt;string&gt; &gt;::VERTICAL</code>.
<p>
Now that the <code >Table</code> derived class has been designed, let's turn our
attention to the class <code >TableType</code>. Here are its essential characteristics:
    <ul>
    <li> It is an ordinary class, designed to operate as <code >Table</code>'s base
class.
    <li> It uses various private data members, among which <code >d_colWidth</code>, a
vector storing the width of the widest element per column and <code >d_indexFun</code>,
pointing to the class's member function returning the element in
<code >table[row][column]</code>, conditional to the table's fill
direction. <code >TableType</code> also uses a <code >TableSupport</code> pointer and a
reference. The constructor not requiring a <code >TableSupport</code> object uses the
<code >TableSupport *</code> to allocate a (default) <code >TableSupport</code> object and then
uses the <code >TableSupport &amp;</code> as the object's alias. The other constructor
initializes the pointer to 0 and uses the reference data member to refer to
the <code >TableSupport</code> object provided by its parameter. Alternatively, a static
<code >TableSupport</code> object could have been used to initialize the reference data
member in the former constructor. The remaining private data members are
probably self-explanatory:
        <pre>
        TableSupport           *d_tableSupportPtr;
        TableSupport           &amp;d_tableSupport;
        size_t                d_maxWidth;
        size_t                d_nRows;
        size_t                d_nColumns;
        WidthType               d_widthType;
        std::vector&lt;size_t&gt;   d_colWidth;
        size_t               (TableType::*d_widthFun)
                                        (size_t col) const;
        std::string const     &amp;(TableType::*d_indexFun)
                                        (size_t row, size_t col) const;
</pre>
<p>
<li> The actual <code >string</code> objects populating the table are stored in a
protected data member:
        <pre>
        std::vector&lt;std::string&gt; d_string;
</pre>
<p>
<li> The (protected) constructors perform basic tasks: they initialize the
object's data members. Here is the constructor expecting a reference to a
<code >TableSupport</code> object:
        <pre>
#include "tabletype.ih"

TableType::TableType(TableSupport &amp;tableSupport, size_t nColumns,
                        FillDirection direction)
:
    d_tableSupportPtr(0),
    d_tableSupport(tableSupport),
    d_maxWidth(0),
    d_nRows(0),
    d_nColumns(nColumns),
    d_widthType(COLUMNWIDTH),
    d_colWidth(nColumns),
    d_widthFun(&amp;TableType::columnWidth),
    d_indexFun(direction == HORIZONTAL ?
                    &amp;TableType::hIndex
                :
                    &amp;TableType::vIndex)
{}
</pre>
<p>
<li> Once <code >d_string</code> has been filled, the table is initialized by
<code >Table::fill</code>. The <code >init</code> protected member resizes <code >d_string</code> so
that its size is exactly <code >rows x columns</code>, and it determines the maximum
width of the elements per column. Its implementation is straightforward:
        <pre>
#include "tabletype.ih"

void TableType::init()
{
    if (!d_string.size())                   // no elements
        return;                             // then do nothing

    d_nRows = (d_string.size() + d_nColumns - 1) / d_nColumns;
    d_string.resize(d_nRows * d_nColumns);  // enforce complete table

                                            // determine max width per column,
                                            // and max column width
    for (size_t col = 0; col &lt; d_nColumns; col++)
    {
        size_t width = 0;
        for (size_t row = 0; row &lt; d_nRows; row++)
        {
            size_t len = stringAt(row, col).length();
            if (width &lt; len)
                width = len;
        }
        d_colWidth[col] = width;

        if (d_maxWidth &lt; width)             // max. width so far.
            d_maxWidth = width;
    }
}
</pre>
<p>
<li> The public member <code >insert</code> is used by the insertion operator
(<code >operator</code>&lt;&lt;) to insert a <code >Table</code> into a stream. First it informs the
<code >TableSupport</code> object about the table's dimensions. Next it displays the
table, allowing the <code >TableSupport</code> object to write headers, footers and
separators:
        <pre>
#include "tabletype.ih"

ostream &amp;TableType::insert(ostream &amp;ostr) const
{
    if (!d_nRows)
        return ostr;

    d_tableSupport.setParam(ostr, d_nRows, d_colWidth,
                            d_widthType == EQUALWIDTH ? d_maxWidth : 0);

    for (size_t row = 0; row &lt; d_nRows; row++)
    {
        d_tableSupport.hline(row);

        for (size_t col = 0; col &lt; d_nColumns; col++)
        {
            size_t colwidth = width(col);

            d_tableSupport.vline(col);
            ostr &lt;&lt; setw(colwidth) &lt;&lt; stringAt(row, col);
        }

        d_tableSupport.vline();
    }
    d_tableSupport.hline();

    return ostr;
}
</pre>
<p>
<li> The <code >cplusplus.yo.zip</code> archive contains <code >TableSupport</code>'s full
implementation. This implementation is found in the directory
<code >yo/classtemplates/examples/table</code>. Most of its remaining members are
private. Among those, these two members return table element
<code >[row][column]</code> for, respectively, a horizontally filled table and a
vertically filled table:
      <pre>
    inline std::string const &amp;TableType::hIndex(size_t row, size_t col) const
    {
        return d_string[row * d_nColumns + col];
    }
    inline std::string const &amp;TableType::vIndex(size_t row, size_t col) const
    {
        return d_string[col * d_nRows + row];
    }
</pre>
<p>
</ul>
<p>
The support class <code >TableSupport</code> is used to display headers, footers,
captions and separators. It has four virtual members to perform those tasks
(and, of course, a virtual constructor):
    <ul>
    <li><code >hline(size_t rowIndex)</code>: called just before displaying
the elements in row
<code >rowIndex</code>.
    <li><code >hline()</code>: called immediately after displaying the final row.
    <li><code >vline(size_t colIndex)</code>: called just before displaying the element in
column <code >colIndex</code>.
    <li><code >vline()</code>: called immediately after displaying all elements in a row.
    </ul>
    The reader is referrred to the <code >cplusplus.yo.zip</code> archive for the full
implementation of the classes <code >Table</code>, <code >TableType</code> and <code >TableSupport</code>.
Here is a little program showing their use:
    <pre>
    /*
                                  table.cc
    */

    #include &lt;fstream&gt;
    #include &lt;iostream&gt;
    #include &lt;string&gt;
    #include &lt;iterator&gt;
    #include &lt;sstream&gt;

    #include "tablesupport/tablesupport.h"
    #include "table/table.h"

    using namespace std;
    using namespace FBB;

    int main(int argc, char **argv)
    {
        size_t nCols = 5;
        if (argc &gt; 1)
        {
            istringstream iss(argv[1]);
            iss &gt;&gt; nCols;
        }

        istream_iterator&lt;string&gt;   iter(cin);   // first iterator isn't const

        Table&lt;istream_iterator&lt;string&gt; &gt;
            table(iter, istream_iterator&lt;string&gt;(), nCols,
                  argc == 2 ? TableType::VERTICAL : TableType::HORIZONTAL);

        cout &lt;&lt; table &lt;&lt; '\n';
    }
    /*
        Example of generated output:
        After: echo a b c d e f g h i j | demo 3
            a e i
            b f j
            c g
            d h
        After: echo a b c d e f g h i j | demo 3 h
            a b c
            d e f
            g h i
            j
    */
</pre>
<p>
<a name="STATICPOLY"></a><a name="l566"></a>
<h2 >22.12: Static Polymorphism</h2>
Chapter <a href="cplusplus14.html#POLYMORPHISM">14</a> introduced polymorphism. Polymorphism allows us to
use a base class's interface to call implementations which are defined in
derived classes. Traditionally this involves defining <em >Vtables</em> for
polymorphic classes, containing pointers to functions that can be overridden
in derived classes.  Objects of polymorphic classes harbor hidden pointers,
pointing to their class's Vtables. This type of polymorphism is called
<a name="an2983"></a><em >dynamic polymorphism</em>, and it uses <a name="an2984"></a><em >late binding</em> as the function to
call is determined run-time, rather than compile-time.
<p>
In many cases, however, dynamic polymorphism isn't really required. Usually
the derived class objects that are passed to functions expecting base class
references are invariants: at fixed locations in programs fixed class types
are used to create objects. The polymorphic nature of these objects is used
inside the functions that receive these objects, expecting references to their
base classes. As an example consider reading information from a network
socket. A class <code >SocketBuffer</code> is derived from <code >std::streambuf</code>, and the
<code >std::stream</code> receiving a pointer to the <code >SocketBuffer</code> merely uses
<code >std::streambuf's</code> interface. However, the implementation, by using
polymorphism, in fact communicates with functions defined in <code >SocketBuffer</code>.
<p>
The disadvantages of this scheme are that, firstly, inside the functions
expecting references to polymorphic base classes execution is somewhat slowed
down precisely because of late-binding. Member functions aren't
directly called, but are called indirectly via the object's <em >vpointer</em> and
their derived class's <em >Vtable</em>. Secondly, programs using dynamic
polymorphism tend to become somewhat bloated compared to programs using static
binding. The <a name="an2985"></a>code bloat is caused by the requirement to satisfy at
link-time all the references that are mentioned in all the object files
comprising the final program. This requirement forces the linker to link all
the functions whose addresses are stored in the <em >Vtables</em> of all polymorphic
classes, even if these functions are never actually called.
<p>
Static polymorphism <a name="an2986"></a> allows us to avoid these
disadvantages. It can be used instead of dynamic polymorphism in cases where
the abovementioned invariant holds. Static polymorphism, also called the
    <a name="an2987"></a><em >curiously recurring template pattern</em>, is an example of 
    <a name="an2988"></a><em >template meta programming</em> (see also chapter <a href="cplusplus23.html#ADVANCEDTEMPL">23</a> for
additional examples of template meta programming).
<p>
Whereas dynamic polymorphism is based on the concepts of <em >vpointers,
Vtables</em>, and <em >function overriding</em>, static polymorphism capitalizes on the
fact that function templates (c.q., member templates) are only compiled into
executable code when they are actually called. This allows us to write code in
which functions are called which are completely non-existent at the time we
write our code. This, however, shouldn't worry us too much. After all, we use
a comparable approach when calling a purely virtual function of an abstract
base class. The function is really called, but which function is eventually
called is determined later in time. With dynamic polymorphism it is determined
run-time, with static polymorphism it is determined compile-time.
<p>
There's no need to consider static and dynamic polymorphism as mutually
exclusive variants of polymorphism. Rather, both can be used together,
combining their strengths. 
<p>
This section contains several subsections.
    <ul>
    <li> First, the syntax used with static polymorphism is introduced and
        illustrated;
    <li> Next, it is shown how  classes that use dynamic polymorphism can be
        converted to classes that use static polymorphism;
    <li> Finally it is illustrated how static polymorphism can be used to
        reduce implementation effort. Static polymorphism allows us to
        implement only once what would have to be implemented repeatedly when
        only dynamic polymorphism is used.
    </ul>
<p>
<a name="l567"></a>
<h3 >22.12.1: An example of static polymorphism</h3>
    With static polymorphism a class template takes the role of a base class in
dynamic polymorphism. This class template declares several members, which are
comparable to members of a polymorphic base class: they are either support
members or they call members that are overridden in derived classes.
<p>
In the context of dynamic polymorphism these overridable members are the base
class's virtual members. In the context of static polymorphism there are no
virtual members. Instead, the statically polymorphic base class (referred to
as the `base class' below) declares a <em >template type parameter</em> (referred to
as the `derived class type' below). Next, the base class's interfacing members
call members of the derived class type.
<p>
Here is a simple example: a class template acting as a base class. Its public
interface consists of one member. But different from dynamic polymorphism
there's no reference in the class's interface to any member showing
polymorphic behavior (i.e, no `virtual' members are declared):
        <pre>
    template &lt;class Derived&gt;
    struct Base
    {
        void interface();
    }
</pre>
<p>
Let's have a closer look at the member `<code >interface</code>'. This member is called
by functions receiving a reference or pointer to the base class, but it may
call members that must be available in the derived class type at the point
where <code >interface</code> is called. Before we can call members of the derived class
type an object of the derived class type must be available. This object is
obtained through inheritance. The derived class type is going to be derived
from the base class. Thus <code >Base's this</code> pointer is also <code >Derived's this</code>
pointer.
<p>
Forget about polymorphism for a second: when we have a <code >class Derived:
public Base</code> then (because of inheritance) a <code >static_cast&lt;Derived *&gt;</code> can be
used to cast a <code >Base *</code> to a <code >Derived</code> object. A <code >dynamic_cast</code> of
course doesn't apply, as we don't use dynamic polymorphism. But a
<code >static_cast</code> is appropriate since our <code >Base *</code> <em >does</em> in fact point to
a <code >Derived</code> class object.
<p>
So, to call a <code >Derived</code> class member from inside <code >interface</code> we
can use the following implementation (remember that <code >Base</code> is a base class
of <code >Derived</code>):
        <pre>
    template&lt;class Derived&gt;
    void Base&lt;Derived&gt;::interface()
    {
        static_cast&lt;Derived *&gt;(this)-&gt;polymorphic();
    }
</pre>
    It's remarkable that, when the compiler is given this implementation it
cannot determine whether <code >Derived</code> is <em >really</em> derived from
<code >Base</code>. Neither can it determine whether the class <code >Derived</code> indeed offers
a member <code >polymorphic</code>. The compiler simply <em >assumes</em> this to be true. If
so, then the provided implementation is syntactically correct. One of the
key characteristics of using templates is that the implementation's viability
is eventually determined at the function's point of instantiation (cf. section
<a href="cplusplus21.html#TEMPFUNINST">21.6</a>). At that point the compiler will verify that, e.g., the
function <code >polymorphic</code> really is available.
<p>
Thus, in order to use the above scheme we must ensure that 
        <ul>
        <li> derived class type is actually derived from the base class and
        <li> that the derived class type defines a member
            `<code >polymorphic</code>'. 
        </ul>
    The first requirement is satisfied by using the 
        <a name="an2989"></a><em >curiously recurring template pattern</em>:
        <pre>
    class First: public Base&lt;First&gt;
</pre>
    In this curious pattern the class <code >First</code> is derived from <code >Base</code>,
which itself is instantiated for <code >First</code>. This is acceptable, as the
compiler already has determined that the type <code >First</code> exists. At this point
that is all it needs.
<p>
The second requirement is simply satisfied by defining the member
<code >polymorphic</code>. In chapter <a href="cplusplus14.html#POLYMORPHISM">14</a> we saw that virtual and
overriding members belong to the class's private interface. We can apply the
same philosophy here, by placing <code >polymorphic</code> in <code >First's</code> private
interface, allowing it to be accessed from the base class by declaring
        <pre>
    friend void Base&lt;First&gt;::interface();
</pre>
<p>
<code >First's</code> complete class interface can now be designed, followed by
<code >polymorphic's</code> implementation:
        <pre>
    class First: public Base&lt;First&gt;
    {
        friend void Base&lt;First&gt;::interface();

        private:
            void polymorphic();
    };
    void First::polymorphic()
    {
        std::cout &lt;&lt; "polymorphic from First\n";
    }
</pre>
    Note that the class <code >First</code> itself is not a class template: its members
can be separately compiled and stored in, e.g., a library. Also, as is the
case with dynamic polymorphism, the member <code >polymorphic</code> has full access to
all of <code >First</code>'s data members and member functions.
<p>
Multiple classes can now be designed like <code >First</code>, each offering their
own implementation of <code >polymorphic</code>. E.g., the member
<code >Second::polymorphic</code> of the class <code >Second</code>, designed like <code >First</code>,
could be implemented like this:
        <pre>
    void Second::polymorphic()
    {
        std::cout &lt;&lt; "polymorphic from Second\n";
    }
</pre>
<p>
The polymorphic nature of <code >Base</code> becomes apparent once a function
template is defined in which <code >Base::interface</code> is called. Again, the
compiler simply assumes a member <code >interface</code> exists when it reads the
definition of the following function template:
        <pre>
    template &lt;class Class&gt;
    void fun(Class &amp;object)
    {
        object.interface();
    }
</pre>
<p>
Only where this function is actually called will the compiler verify the
viability of the generated code. In the following <code >main</code> function a
<code >First</code> object is passed to <code >fun</code>: <code >First</code> declares <code >interface</code>
through its base class, and <code >First::polymorphic</code> is called by
<code >interface</code>. The compiler will at this point (i.e., where <code >fun</code> is called)
check whether <code >first</code> indeed has a member <code >polymorphic</code>. Next a <code >Second</code>
object is passed to <code >fun</code>, and here again the compiler checks whether
<code >Second</code> has a member <code >Second::polymorphic</code>:
        <pre>
    int main()
    {
        First first;
        fun(first);

        Second second;
        fun(second);
    }
</pre>
<p>
There are also downsides to 
        <a name="an2990"></a> 
    using static polymorphism:
        <ul>
        <li> First, the sentence `a <code >Second</code> object is passed to <code >fun</code>'
formally isn't correct, since <code >fun</code> is a function template the functions
<code >fun</code> called as <code >fun(first)</code> and <code >fun(second)</code> are
<em >different</em> functions, not just calls of one function with different
arguments. With static polymorphism every instantiation using its own template
parameters results in completely new code which is generated when the template
(e.g., <code >fun</code>) is instantiated. This is something to consider when creating
statically polymorphic base classes. If the base class defines data members
and member functions, and if these additional members are used by derived
class types, then each member has its own instantiation for each derived class
type. This also results in <a name="an2991"></a>code bloat, albeit of a different kind than
obeserved with dynamic polymorphism. This kind of code bloat can often be
somewhat reduced by deriving the base class from its own (ordinary,
non-template) base class, encapsulating all elements of the statically
polymorphic base class that do not depend on its template type parameters.
        <li> Second, if different types of statically polymorphic objects are
dynamically created (using the <code >new</code> operator) then the types of the
returned pointers are all different. In addition, the types of the pointers to
their statically polymorphic base classes differ from each other. These
latter pointers are different because they are pointers to <code >Base&lt;Derived&gt;</code>,
representing different types for different <code >Derived</code> types. Consequently,
and different from dynamic polymorphism, these pointers cannot be collected
in, e.g., a vector of shared pointers to base class pointers. There simply
isn't one base class pointer type. Thus, because of the different base class
types, there's no direct statically polymorphic equivalent to virtual
destructors.
        <li> Third, as illustrated in the next section, designing static
polymorphic classes using multiple levels of inheritance is not a trivial
task.
        </ul>
    Summarizing, static polymorphism is best used in situations where a small
number of different derived class types are used, where a fixed number of
derived class objects are used, and where the statically polymorphic base
classes themselves are lean (possibly encapsulating some of their code in
ordinary base classes of their own).
<p>
<a name="l568"></a>
<h3 >22.12.2: Converting dynamic polymorphic classes to static
            polymorphic classes</h3>
    So you've decided that you want to convert some of your dynamically
polymorphic classes into statically polymorphic classes. Now what?
<p>
In chapter <a href="cplusplus14.html#POLYMORPHISM">14</a> the base class <code >Vehicle</code> and some derived
classes were introduced. <code >Vehicle, Car</code> and <code >Truck</code>'s interfaces look like
this (regarding the members that are involved in their polymorphic behaviors):
        <pre>
    class Vehicle
    {
        public:
            int mass() const;

        private:
            virtual int vmass() const;
    };

    class Car: public Vehicle
    {
        private:
            int vmass() const override;
    };
        
    class Truck: public Car
    {
        private:
            int vmass() const override;
    };
</pre>
<p>
When converting dynamically polymorphic classes to statically polymorphic
classes we must realize that polymorphic classes show two important
characteristics:
    <ul>
    <li> they define facilities (data members, member functions) that are
inherited by derived classes (e.g., <code >Vecicle::mass</code>) (i.e., the inheritable
interface), and
    <li> derived classes implement the redefinable interface in a way that
suits their purpose (e.g., <code >Truck::vmass</code>).
    </ul>
<p>
With statically polymorphic classes these two characteristics should
completely be separated.  As we've seen in the previous section, a
statically polymorphic derived class derives from its base class by using its
own class type as argument to the base class's type parameter. This works fine
if there's only one level of inheritance (i.e., one base class, and one or
more classes that are directly derived from that base class).
<p>
With multiple levels of inheritance (e.g., <code >Truck -&gt; Car -&gt; Vehicle</code>)
<code >Truck</code>'s inheritance specification becomes a problem. Here's an intial
attempt to use atatic polymorphism and multiple levels of inheritance:
        <pre>
    template &lt;class Derived&gt;
    class Vehicle
    {
        public:
            void mass() 
            {
                static_cast&lt;Derived *&gt;(this)-&gt;vmass();
            }
    };
    
    class Car: public Vehicle&lt;Car&gt;
    {
        friend void Vehicle&lt;Car&gt;::mass();
        void vmass();
    };

    class Truck: public Car
    {
        void vmass();
    };
</pre>
        <ul>
        <li> If <code >Truck</code> inherits from <code >Car</code>, then <code >Truck</code> implicitly
derives from <code >Vehicle&lt;Car&gt;</code>, as <code >Car</code> derives from
<code >Vehicle&lt;Car&gt;</code>. Consequently, when <code >Truck{}.mass()</code> is called it is not
<code >Truck::vmass</code> that's activated, but <em >Car's</em> <code >vmass</code> function. But
<code >Truck</code> <em >must</em> derive from <code >Car</code> in order to use <code >Car's</code> protected
features and to add <code >Car's</code> public features to its own public
interface. 
        <li> Multiple inheritance also doesn't solve the issue: when
inheriting <code >Truck</code> from <code >Vehicle&lt;Truck&gt;</code> <em >and</em> from <code >Car</code> 
results in a class <code >Truck</code> that <em >also</em> inherits from
<code >Vehicle&lt;Car&gt;</code> (through <code >Truck's Car</code> base class), and compilation fails
as the compiler encounters an ambiguity when instantiating <code >Vehicle::mass</code>:
should it call <code >Class::vmass</code> or should it call <code >Truck::vmass</code>?
    
    </ul>
    To solve this problem (i.e., to ensure that <code >Truck{}.mass()</code> calls
<code >Truck::vmass</code>) the redefinable interface must be separated 
from the inheritable interface.
<p>
In derived classes the protected and public interfaces of (direct or indirect)
base classes are made available using standard inheritance. This is shown in
the left-hand side of figure <a href="cplusplus22.html#STATPOLY">27</a>.  
<p>
<p><a name="STATPOLY"></a><figure >
<img src="classtemplates/converting.gif" >
<figcaption >Figure 27: Vehicle Static Polymorphic Class Design</figcaption>
</figure></p>

<p>
The left-hand side classes are used as base classes for the next level of
inheritance (except for <code >TruckBase</code>, but <code >TruckBase</code> could be used as base
class for yet another level of class inheritance). This line of inheritance
declares the inheritable interface of the classes.
<p>
Each of the classes to the left is a base class of a single class to the
right: <code >VehicleBase</code> is a base class for <code >Vehicle</code>, <code >TruckBase</code> for
<code >Truck</code>. The classes to the left contain all members that are completely
independent of the elements that are involved in realizing the static
polymorphism. As that's a mere design principle to realize multiple levels of
static polymorphism the common data hiding principles are relaxed, and the
left-hand side classes declare their matching right-hand side derived class
templates as friend, to allow full access to all members of a left-hand side
class, including the private members, from the matching derived class template
to the right. E.g., <code >VehicleBase</code> declares <code >Vechicle</code> as its friend:
        <pre>
    class VehicleBase
    {
        template &lt;class Derived&gt;
        friend class Vehicle;

        // all members originally in Vehicle, but not involved 
        // in realizing static polymorphism are declared here. E.g.,
        size_t d_massFactor = 1;
    };
</pre>
<p>
The top level class to the right (<code >VehicleBase</code>) lays the foundation of
static polymorphism, by defining that part of the interface that uses the
statically redefinable functions. E.g, using the curiously recurring template
pattern it defines a class member <code >mass</code> that calls the function <code >vmass</code>
of its derived class (in addition it can use all members of its non-class
template base class). E.g,:
        <pre>
    template &lt;class Derived&gt;
    class Vehicle: public VehicleBase
    {
        public:
            int mass() const
            {
                return d_massFactor *
                        static_cast&lt;Derived const *&gt;(this)-&gt;vmass();
            }
    };
</pre>
<p>
Which function actually is called when <code >vmass</code> is called depends on the
implementation in the class <code >Derived</code>, which is handled by the remaining
classes, shown below <code >Vehicle</code>, which are all derived from <code >Vehicle</code> (as
well as from their own <code >...Base</code> class). These classes use the curiously
recurring template pattern. E.g.,
        <pre>
    class Car: public CarBase, public Vehicle&lt;Car&gt;
</pre>
    So, if <code >Car</code> now implements its own <code >vmass</code> function, which can use
any of its own (i.e., <code >CarBase's</code> members), then <em >that</em> function is called
when calling a <code >Vehicle's mass</code> function. E.g.,
        <pre>
    template &lt;class Vehicle&gt;
    void fun(Vehicle &amp;vehicle)
    {
        cout &lt;&lt; vehicle.mass() &lt;&lt; '\n';
    }
    
    int main()
    {
        Car car;
        fun(car);       // Car's vmass is called
    
        Truck truck;
        fun(truck);     // Truck's vmass is called
    }
</pre>
<p>
Now that we've analyzed the design of statically polymorphic classes using
multiple levels of inheritance let's summarize the steps that took to
implement static polymorphism
    <ul>
    <li> First, starting at the base class,
the class <code >Vehicle</code>. <code >Vehicle's</code> non-redifinable interface is moved
to a class <code >VehicleBase</code>, and <code >Vehicle</code> itself is turned into a statically
polymorphic base class. In general all members of the original 
polymorphic base class that do not use or implement virtual members should be
moved to the <code >XBase</code> class. 
<p>
<li> <code >VehicleBase</code> declares <code >Vehicle</code> to be a <code >friend</code>, to allow
<code >Vehicle</code> full access to its former members, that are now in
<code >VehicleBase</code>.
<p>
<li> <code >Vehicle's</code> members refer to the redefinable interface. I.e., its
members call members of its <code >Derived</code> template type parameter.  In this
implementation <code >Vehicle</code> does not implement its own <code >vmass</code> member. We
cannot define <code >Vehicle&lt;Vehicle&gt;</code>, and with static polymorphism the base
class is essentially comparable to an abstract base class. If this is
inconvenient then a default class can be specified for <code >Vehicle's Derived</code>
class, implementing the redefinable interface of the original 
polymorphic base class (allowing for definitions like <code >Vehicle&lt;&gt; vehicle</code>).
<p>
<li> Likewise the remaining classes have their members not involved in
static polymorphism moved to a base class. E.g., 
class <code >Car</code> moves these members to  <code >CarBase</code> and
<code >Truck</code> moves those members to  <code >TruckBase</code>.  
<p>
<li> A standard linear line of inheritance is used from <code >VehicleBase</code> to
<code >CarBase</code> and from there to <code >TruckBase</code>.
<p>
<li> Each of the remaining classes (here: <code >Car</code> and <code >Truck</code>) is a
class template that derives from its base classes, and also, using the
curiously recurrent template pattern, from <code >Vehicle</code>.
<p>
<li> Each of these remaining classes can now implement its own version of
the redefinable interface, as used by the members of <code >Vehicle</code>.
    </ul>
<p>
This design pattern can be extended to any level of inheritance: for each
new level a base class is constructed, deriving from the most deeply nested
<code >XXXBase</code> class so far, and deriving from <code >Vehicle&lt;XXX&gt;</code>, implementing its
own ideas about the redefinable interface.
<p>
Functions that are used in combination with statically polymorphic classes
themselves must be function templates. E.g.,
        <pre>
    template &lt;class Vehicle&gt;
    void fun(Vehicle &amp;vehicle)
    {
        cout &lt;&lt; vehicle.mass() &lt;&lt; '\n';
    }
</pre>
    Here, <code >Vehicle</code> is just a formal name. When an object is passed to
<code >fun</code> it must offer a member <code >mass</code>, or compilation will fail. If the
object is in fact a <code >Car</code> or <code >Truck</code>, then their <code >Vehicle&lt;Type&gt;</code> static
base class member <code >mass</code> is called, which in turn uses static polymorphism
to call the member <code >vmass</code> as implemented by the actually passed class
type. The following <code >main</code> function displays, respectively, 1000 and 15000:
        <pre>
    int main()
    {
        Car car;
        fun(car);
    
        Truck truck;
        fun(truck);
    }
</pre>
    Note that this program implements <code >fun</code> twice, rather than once in the
case of dynamic polymorphism. The same holds true for the <code >Vehicle</code> class
template: two implementations, one for the <code >Car</code> type, and one for the
<code >Truck</code> type. The statically polumorphic program will be slightly faster,
though.
<p>
(A compilable example using static polymorphism is found in the
annotation()'s source distribution's file
<code >yo/classtemplates/examples/staticpolymorphism/polymorph.cc</code>.)
<p>
<a name="l569"></a>
<h3 >22.12.3: Using static polymorphism to avoid reimplementations</h3>
    Static polymorphism may profitably be used to avoid reimplementing code in an
otherwise dynamic polymorphic environment.
<p>
Consider the situation where we have a class containing a container of
pointers to some polymorphic base class type (like the class <code >Vehicle</code> from
chapter <a href="cplusplus14.html#POLYMORPHISM">14</a>). How to copy such a container to another container?
We're not hinting at using shared pointers here, but would like to make a full
copy. Clearly, we'll need to duplicate the objects the pointers point at, and
assign these new pointers to the copied object's container.
<p>
The prototype design patttern is commonly used to create copies of objects of
polymorphic classes, given pointers to their base classes. 
<p>
To apply the prototype design pattern we have to implement <code >newCopy</code> in all
derived classes. Not by itself a big deal, but static polymorphism can nicely
be used here to avoid having to  reimplement this function for each derived
class. 
<p>
We start off with an abstract base class <code >VehicleBase</code> declaring a pure
virtual member <code >newCopy</code>:
        <pre>
    struct VehicleBase
    {
        virtual ~VehicleBase();
        VehicleBase *clone() const; // calls newCopy

        // declare any additional members defining the 
        // public user interface here

        private:
            VehicleBase *newCopy() const = 0;   
    };
</pre>
<p>
Next we define a static polymorphic class <code >CloningVehicle</code> which is derived
from <code >VehicleBase</code> (note that we thus combine dynamic and static
polymorphism). This class provides the generic implementation of
<code >newCopy</code>. This is possible because all derived classes can use this
implementation. Also, <code >CloningVehicle</code> will be re-implemented for each
concrete type of vehicle that is eventually used: a <code >Car</code>, a <code >Truck</code>, an
<code >AmphibiousVehicle</code>, etc, etc. <code >CloningVehicle</code> thus isn't shared (like
<code >VehicleBase</code>), but instantiated for each new type of vehicle. 
<p>
The core characteristic of a statically polymorphic class is that it can use
its class template type parameter via a <code >static_cast</code> of its own type. A
member function like <code >newCopy</code> is implemented always the same way, viz.,
by using the derived class's copy constructor. Here is the class
<code >CloningVehicle</code>:
        <pre>
    template &lt;class Derived&gt;
    class CloningVehicle: public VehicleBase
    {
        VehicleBase *newCopy() const
        {
            return new Derived(*static_cast&lt;Derived const *&gt;(this));
        }
    };
</pre>
<p>
And we're done. All types of vehicles should now be derived from
<code >CloningVehicle</code>, which automatically provides them with their own
implementation of <code >newCopy</code>. E.g., a class <code >Car</code> looks like this:
        <pre>
    class Car: public CloningVehicle&lt;Car&gt;
    {
        // Car's interface, no need to either
        // declare or implement newCopy,
        // but a copy constructor is required.
    };
</pre>
<p>
Having defined a <code >std::vector&lt;VehicleBase *&gt; original</code> we could create a
copy of <code >original</code> like this:
            <pre>
    for(auto pointer: original)
        duplicate.push_back(pointer-&gt;clone());
</pre>
    Irrespective of the actual type of vehicle to which the pointers point,
their <code >clone</code> members will return pointers to newly allocated copies of
objects of their own types.
<p>
<a name="l570"></a>
<h2 >22.13: Class templates and nesting</h2>
When a class is nested within a class template, it automatically becomes a
class template itself.
        <a name="an2992"></a>
    The nested class may use the template parameters of the surrounding
class, as shown by the following skeleton program. Within a class
<code >PtrVector</code>, a class <code >iterator</code> is defined. The nested class receives its
information from its surrounding class, a <code >PtrVector&lt;Type&gt;</code> class. Since
this surrounding class should be the only class constructing its iterators,
<code >iterator</code>'s constructor is made <a name="an2993"></a>private and the surrounding class is
given access to the private members of <code >iterator</code> using a
 <a name="an2994"></a><em >bound friend</em> declaration.
    Here is the initial section of <code >PtrVector</code>'s class interface:
        <pre>
    template &lt;typename Type&gt;
    class PtrVector: public std::vector&lt;Type *&gt;
</pre>
<p>
This shows that the <code >std::vector</code> base class stores pointers to <code >Type</code>
values, rather than the values themselves. Of course, a destructor is now
required as the (externally allocated) memory for the <code >Type</code> objects must
eventually be freed. Alternatively, the allocation might be part of
<code >PtrVector</code>'s tasks, when it stores new elements. Here it is assumed that
<code >PtrVector</code>'s clients do the required allocations and that the destructor is
implemented later on.
<p>
The nested class defines its constructor as a private member, and allows
<code >PtrVector&lt;Type&gt;</code> objects access to its private members. Therefore only
objects of the surrounding <code >PtrVector&lt;Type&gt;</code> class type are allowed to
construct their <code >iterator</code> objects. However, <code >PtrVector&lt;Type&gt;</code>'s clients
may construct <em >copies</em> of the <code >PtrVector&lt;Type&gt;::iterator</code> objects they
use.
<p>
Here is the nested class <code >iterator</code>, using a (required) <code >friend</code>
declaration. Note the use of the <code >typename</code> keyword: since
<code >std::vector&lt;Type *&gt;::iterator</code> depends on a template parameter, it is not
yet an instantiated class. Therefore <code >iterator</code> becomes an implicit
typename.  The compiler issues a warning if <code >typename</code> has been
omitted. Here is the class interface:
        <pre>
            class iterator
            {
                friend class PtrVector&lt;Type&gt;;
                typename std::vector&lt;Type *&gt;::iterator d_begin;

                iterator(PtrVector&lt;Type&gt; &amp;vector);

                public:
                    Type &amp;operator*();
            };
</pre>
<p>
The implementation of the members shows that the base class's <code >begin</code>
member is called to initialize <code >d_begin</code>.  <code >PtrVector&lt;Type&gt;::begin</code>'s
return type must again be preceded by <code >typename</code>:
        <pre>
    template &lt;typename Type&gt;
    PtrVector&lt;Type&gt;::iterator::iterator(PtrVector&lt;Type&gt; &amp;vector)
    :
        d_begin(vector.std::vector&lt;Type *&gt;::begin())
    {}

    template &lt;typename Type&gt;
    Type &amp;PtrVector&lt;Type&gt;::iterator::operator*()
    {
        return **d_begin;
    }
</pre>
<p>
The remainder of the class is simple. Omitting all other functions that
might be implemented, the function <code >begin</code> returns a newly constructed
<code >PtrVector&lt;Type&gt;::iterator</code> object. It may call the constructor since the
class <code >iterator</code> declared its surrounding class as its friend:
        <pre>
    template &lt;typename Type&gt;
    typename PtrVector&lt;Type&gt;::iterator PtrVector&lt;Type&gt;::begin()
    {
        return iterator(*this);
    }
</pre>
<p>
Here is a simple skeleton program, showing how the nested class
<code >iterator</code> might be used:
        <pre>
    int main()
    {
        PtrVector&lt;int&gt; vi;

        vi.push_back(new int(1234));

        PtrVector&lt;int&gt;::iterator begin = vi.begin();

        std::cout &lt;&lt; *begin &lt;&lt; '\n';
    }
</pre>
<p>
Nested <a name="an2995"></a> enumerations and <a name="an2996"></a>
nested typedefs can also be defined by class templates. The class <code >Table</code>,
mentioned before (section <a href="cplusplus22.html#TFROMC">22.11.3</a>) inherited the enumeration
<code >TableType::FillDirection</code>. Had <code >Table</code> been implemented as a full class
template, then this enumeration would have been defined in <code >Table</code> itself
as:
        <pre>
    template &lt;typename Iterator&gt;
    class Table: public TableType
    {
        public:
            enum FillDirection
            {
                HORIZONTAL,
                VERTICAL
            };
        ...
    };
</pre>
    In this case, the actual value of the template type parameter must be
specified when referring to a <code >FillDirection</code> value or to its type. For
example (assuming <code >iter</code> and <code >nCols</code> are defined as in section
<a href="cplusplus22.html#TFROMC">22.11.3</a>):
        <pre>
    Table&lt;istream_iterator&lt;string&gt; &gt;::FillDirection direction =
                argc == 2 ?
                    Table&lt;istream_iterator&lt;string&gt; &gt;::VERTICAL
                :
                    Table&lt;istream_iterator&lt;string&gt; &gt;::HORIZONTAL;

    Table&lt;istream_iterator&lt;string&gt; &gt;
        table(iter, istream_iterator&lt;string&gt;(), nCols, direction);
</pre>
<p>
<a name="ITERATORCONS"></a><a name="l571"></a>
<h2 >22.14: Constructing iterators</h2>
    In section <a href="cplusplus18.html#ITERATORS">18.2</a> the iterators used with generic algorithms were
introduced. We've seen that several types of iterators were distinguished:
InputIterators, ForwardIterators, OutputIterators, BidirectionalIterators and
RandomAccessIterators.
<p>
To ensure that an object of a class is interpreted as a particular type of
iterator, the class must be derived from the class
    <a name="an2997"></a><code >std::iterator</code>.  Before a class can be derived from this
class the <a name="an2998"></a><code >&lt;iterator&gt;</code> header file must be included.
<p>
In section <a href="cplusplus18.html#ITERATORS">18.2</a> the characteristics of iterators were
discussed. All iterators
        <a name="an2999"></a>
        <a name="an3000"></a>
    should support (using <code >Iterator</code> as the generic name of the designed
iterator class and <code >Type</code> to represent the (possibly <code >const</code>, in which
case the associated operator should be a <code >const</code> member as well) data type to
which <code >Iterator</code> objects refer):
    <ul>
    <li> a prefix increment operator (<code >Iterator &amp;operator++()</code>);
    <li> a dereference operator (<code >Type &amp;operator*()</code>);
    <li> a 'pointer to' operator (<code >Type *operator-&gt;()</code>);
    <li> comparison operators testing the (in)equality of two iterator objects
(<code >bool operator==(Iterator const &amp;other)</code>, <code >bool operator!=(Iterator const
&amp;other)</code>).
    </ul>
<p>
When
        <a name="an3001"></a>
    iterators are to be used in the context of generic algorithms they must
meet additional requirements. This is caused by the fact that generic
algorithms perform checks on the types of the iterators they receive. Simple
pointers are usually accepted, but if an iterator-object is used it must be
able to specify the kind of iterator it represents.
<p>
When deriving a class from the class <code >iterator</code> the
        <a name="an3002"></a>
    type of iterator is defined by the class template's <em >first</em> parameter,
and the
        <a name="an3003"></a>
    data type to which the iterator refers is defined by the class template's
<em >second</em> parameter.
<p>
The type of iterator that is implemented by the derived class
is specified using a so-called <a name="an3004"></a><em >iterator_tag</em>, provided as the
first template argument of the class <code >iterator</code>. For the five basic iterator
types, these tags are:
    <ul>
    <li><a name="an3005"></a><code >std::input_iterator_tag</code>. This tag defines an
<a name="an3006"></a>InputIterator.  Iterators of this type allow reading operations, iterating
from the first to the last element of the series to which the iterator
refers.
<p>
The InputIterator  dereference operator should be declared as follows:
        <pre>
    Type const &amp;operator*() const;
</pre>
    Except for the standard operators there are no further requirements for
InputIterators.
<p>
<li><a name="an3007"></a><code >std::output_iterator_tag</code>. This tag defines an
<a name="an3008"></a>OutputIterator.  Iterators of this type allow for assignment operations,
iterating from the first to the last element of the series to which the
iterator refers.
<p>
The OutputIterator  dereference operator should allow assignment to the
data its dereference operator refers to. Therefore, the OutputIterator
dereference operator should be declared as follows:
        <pre>
    Type &amp;operator*();
</pre>
    Except for the standard operators there are no further requirements for
OutputIterators.
<p>
<li><a name="an3009"></a><code >std::forward_iterator_tag</code>. This tag defines a
        <a name="an3010"></a>ForwardIterator.  Iterators of this type allow reading <em >and</em>
assignment operations, iterating from the first to the last element of the
series to which the iterator refers.
<p>
The ForwardIterator  dereference operator should allow assignment to the
data its dereference operator refers to. Therefore, the ForwardIterator
dereference operator should be declared as follows:
        <pre>
    Type &amp;operator*();
</pre>
    Except for the standard operators there are no further requirements for
ForwardIterators.
<p>
<li><a name="an3011"></a><code >std::bidirectional_iterator_tag</code>. This
tag defines a <a name="an3012"></a>BidirectionalIterator. Iterators of this type allow reading
<em >and</em> assignment operations, iterating step by step, possibly in alternating
directions, over all elements of the series to which the iterator refers.
<p>
The Bidirectional dereference operator should allow assignment to the data
its dereference operator refers to and it should allow stepping
backward. BidirectionalIterator should therefore, in addition to the standard
operators required for iterators, offer the following operators:
        <pre>
    Type &amp;operator*();
    Iterator &amp;operator--();
</pre>
<p>
<li><a name="an3013"></a><code >std::random_access_iterator_tag</code>. This
tag defines a <a name="an3014"></a>RandomAccessIterator.  Iterators of this type allow reading
<em >and</em> assignment operations, iterating, possibly in alternating directions,
over all elements of the series to which the iterator refers using any
available (random) stepsize.
<p>
RandomIterator class dereference operators should allow assignment to the
data they refer to, and, in addition to the standard operators required for
iterators, offer the following operators:
    <ul>
    <li><code >Type &amp;operator*()</code>, allowing assignment to the data the dereference
operator refers to;
    <li><code >Iterator &amp;operator--()</code>, allowing single steps backward;
    <li><code >Type operator-(Iterator const &amp;rhs) const</code>, returning the number of
data elements between the current and <code >rhs</code> iterator (returning a negative
value if <code >rhs</code> refers to a data element beyond the data element <code >this</code>
iterator refers to);
    <li><code >Iterator operator+(int step) const</code>, returning an iterator referring
to a data element <code >step</code> data elements beyond the data element <code >this</code>
iterator refers to;
    <li><code >Iterator operator-(int step) const</code>, returning an iterator referring
to a data element <code >step</code> data elements before the data element <code >this</code>
iterator refers to;
    <li><code >bool operator&lt;(Iterator const &amp;rhs) const</code>, returning <code >true</code> if
the data element <code >this</code> iterator refers to is located before the data
element the <code >rhs</code> iterator refers to.
        </ul>
    </ul>
    Each iterator tag assumes that a certain set of operators is
available. The <em >RandomAccessIterator</em> is the most complex of iterators, as
it implies all other iterators.
<p>
Note that iterators are always defined over a certain range
(<code >[begin, end)</code>). Increment and decrement operations may result in
undefined behavior of the iterator if the resulting iterator value would refer
to a location outside of this range.
<p>
Often, iterators only access the elements of the series to which they
refer. Internally, an iterator may use an ordinary pointer but it is hardly
ever necessary for the iterator to allocate its own memory. Therefore, as the
assignment operator and the copy constructor do not have to allocate any
memory, their <em >default implementations</em> usually suffice.  For the same
reason iterators usually don't require destructors.
<p>
Most classes offering members returning iterators do so by having members
construct the required iterators that are thereupon returned as objects by
those member functions. As the <em >caller</em> of these member functions only has
to <em >use</em> or sometimes <em >copy</em> the returned iterator objects, there is
usually no need to provide any publicly available constructor, except for the
copy constructor. Therefore these constructors are usually defined as
<em >private</em> or <em >protected</em> members. To allow an outer class to create
iterator objects, the iterator class usually declares the outer class as its
<em >friend</em>.
<p>
In the following sections the construction of a <em >RandomAccessIterator</em>,
the most complex of all iterators, and the construction of a <em >reverse
RandomAccessIterator</em> is discussed. The container class for which a random
access iterator must be developed may actually store its data elements in many
different ways (e.g., using containers or pointers to pointers).  Therefore it
is difficult to construct a template iterator class which is suitable for a
large variety of container classes.
<p>
In the following sections the available <code >std::iterator</code> class is used to
construct an inner class representing a random access iterator.  The reader
may follow the approach illustrated there to construct iterator classes for
other contexts. An example of such a template iterator class is provided in
section <a href="cplusplus24.html#CONCRETEITER">24.7</a>.
<p>
The random access iterator developed in the next sections reaches data
elements that are only accessible through pointers. The iterator class is
designed as an inner class of a class derived from a vector of string
pointers.
<p>
<a name="RANDOMIT"></a><a name="l572"></a>
<h3 >22.14.1: Implementing a `RandomAccessIterator'</h3>
    In the chapter about containers (chapter <a href="cplusplus12.html#CONTAINERS">12</a>) it was noted that
containers own the information they contain. If they contain objects, then
those objects are destroyed once the containers are destroyed. As pointers are
not objects their use in containers is discouraged (STL's <a name="an3015"></a><code >unique_ptr</code> and
<a name="an3016"></a><code >shared_ptr</code> type objects may be used, though).  Although discouraged, we
might be able to use pointer data types in specific contexts. In the following
class <code >StringPtr</code>, an ordinary class is derived from the <code >std::vector</code>
container that uses <code >std::string *</code> as its data type:
        <pre>
    #ifndef INCLUDED_STRINGPTR_H_
    #define INCLUDED_STRINGPTR_H_

    #include &lt;string&gt;
    #include &lt;vector&gt;

    class StringPtr: public std::vector&lt;std::string *&gt;
    {
        public:
            StringPtr(StringPtr const &amp;other);
            ~StringPtr();

            StringPtr &amp;operator=(StringPtr const &amp;other);
    };

    #endif
</pre>
<p>
This class needs a destructor: as the object stores string pointers, a
destructor is required to destroy the strings once the <code >StringPtr</code> object
itself is destroyed.  Similarly, a copy constructor and overloaded assignment
is required. Other members (in particular: constructors) are not explicitly
declared here as they are not relevant to this section's topic.
<p>
Assume that we want to be able to use the <code >sort</code> generic
algorithm with <code >StringPtr</code> objects. This algorithm (see section <a href="cplusplus19.html#SORT">19.1.58</a>)
requires two <em >RandomAccessIterators</em>. Although these iterators are available
(via <code >std::vector</code>'s <code >begin</code> and <code >end</code> members), they return
iterators to <code >std::string *</code>s, which cannot sensibly be compared.
<p>
To remedy this, we may define an internal type <code >StringPtr::iterator</code>,
not returning iterators to pointers, but iterators to the <em >objects</em> these
pointers point to. Once this <code >iterator</code> type is available, we can add the
following members to our <code >StringPtr</code> class interface, hiding the identically
named, but useless members of its base class:
        <pre>
    StringPtr::iterator begin();    // returns iterator to the first element
    StringPtr::iterator end();      // returns iterator beyond the last
                                    // element
</pre>
    Since these two members return the (proper) iterators, the elements in a
<code >StringPtr</code> object can easily be sorted:
        <pre>
    int main()
    {
        StringPtr sp;               // assume sp is somehow filled

        sort(sp.begin(), sp.end()); // sp is now sorted
    }
</pre>
    To make this all work, the type <code >StringPtr::iterator</code> must be
defined. As suggested by its type name, <code >iterator</code> is a nested type of
<code >StringPtr</code>. To use a <code >StringPtr::iterator</code> in combination
with the <code >sort</code> generic algorithm it must also be a
<a name="an3017"></a><code >RandomAccessIterator</code>. Therefore, <code >StringPtr::iterator</code> itself must be
derived from the existing class <code >std::iterator</code>.
<p>
To derive a class from <code >std::iterator</code>, both the iterator type and the
data type the iterator points to must be specified. Caveat: our iterator takes
care of the <code >string *</code> dereferencing; so the required data type is
<code >std::string</code>, and <em >not</em> <code >std::string *</code>. The class <code >iterator</code>
therefore starts its interface as:
        <pre>
    class iterator:
        public std::iterator&lt;std::random_access_iterator_tag, std::string&gt;
</pre>
    Since its base class specification is quite complex, we could consider
associating this type with a shorter name using the following <code >typedef</code>:
        <pre>
    typedef std::iterator&lt;std::random_access_iterator_tag, std::string&gt;
            Iterator;
</pre>
    In practical situations, if the type (<code >Iterator</code>) is used only once or
twice, the type definition only adds clutter to the interface, and is better
not used.
<p>
Now we're ready to redesign <code >StringPtr</code>'s class interface. It offers
members returning (reverse) iterators, and a nested <code >iterator</code> class. Here
is its interface:
        <pre>
class StringPtr: public std::vector&lt;std::string *&gt;
{
    public:
    class iterator: public
            std::iterator&lt;std::random_access_iterator_tag, std::string&gt;
    {
        friend class StringPtr;
        std::vector&lt;std::string *&gt;::iterator d_current;

        iterator(std::vector&lt;std::string *&gt;::iterator const &amp;current);

        public:
            iterator &amp;operator--();
            iterator operator--(int);
            iterator &amp;operator++();
            iterator operator++(int);
            bool operator==(iterator const &amp;other) const;
            bool operator!=(iterator const &amp;other) const;
            int operator-(iterator const &amp;rhs) const;
            std::string &amp;operator*() const;
            bool operator&lt;(iterator const &amp;other) const;
            iterator operator+(int step) const;
            iterator operator-(int step) const;
            iterator &amp;operator+=(int step); // increment over `n' steps
            iterator &amp;operator-=(int step); // decrement over `n' steps
            std::string *operator-&gt;() const;// access the fields of the
                                            // struct an iterator points
                                            // to. E.g., it-&gt;length()
    };

    typedef std::reverse_iterator&lt;iterator&gt; reverse_iterator;

    iterator begin();
    iterator end();
    reverse_iterator rbegin();
    reverse_iterator rend();
};
</pre>
<p>
As usual, the interface offers hooks for a more detailed study of the
class.
<p>
First we have a look at <code >StringPtr::iterator</code>'s characteristics:
    <ul>
    <li><code >iterator</code> defines <code >StringPtr</code> as its friend, so <code >iterator</code>'s
constructor may remain private. Only the <code >StringPtr</code> class itself is now
able to construct <code >iterator</code>s, which seems like a sensible thing to
do. Under the current implementation, <em >copy-construction</em> should of course
also be possible. Furthermore, since an iterator is already provided by
<code >StringPtr</code>'s base class, we can use that iterator to access the information
stored in the <code >StringPtr</code> object.
    <li> <code >StringPtr::begin</code> and <code >StringPtr::end</code> may simply return
<code >iterator</code> objects. They are implementated like this:
        <pre>
inline StringPtr::iterator StringPtr::begin()
{
    return iterator(this-&gt;std::vector&lt;std::string *&gt;::begin());
}
inline StringPtr::iterator StringPtr::end()
{
    return iterator(this-&gt;std::vector&lt;std::string *&gt;::end());
}
</pre>
<p>
<li> All of <code >iterator</code>'s remaining members are public. It's very easy to
implement them, mainly manipulating and dereferencing the available iterator
<code >d_current</code>. A <code >RandomAccessIterator</code> (which is the most
complex of iterators) requires a series of operators. They usually
have very simple implementations, making them good candidates for
inline-members:
        <ul>
        <li><code >iterator &amp;operator++()</code>; the pre-increment operator:
            <pre>
inline StringPtr::iterator &amp;StringPtr::iterator::operator++()
{
    ++d_current;
    return *this;
}
</pre>
<p>
<li> <code >iterator operator++(int)</code>; the post-increment operator:
            <pre>
inline StringPtr::iterator StringPtr::iterator::operator++(int)
{
    return iterator(d_current++);
}
</pre>
<p>
<li> <code >iterator &amp;</code><code >operator</code>--<code >()</code>; the pre-decrement operator:
            <pre>
inline StringPtr::iterator &amp;StringPtr::iterator::operator--()
{
    --d_current;
    return *this;
}
</pre>
<p>
<li> <code >iterator</code> <code >operator</code>--<code >(int)</code>; the post-decrement operator:
            <pre>
inline StringPtr::iterator StringPtr::iterator::operator--(int)
{
    return iterator(d_current--);
}
</pre>
<p>
<li><code >iterator &amp;operator=(iterator const &amp;other)</code>; the overloaded
            assignment operator. Since <code >iterator</code> objects do not allocate
            any memory themselves, the default assignment operator can be
            used.
        <li><code >bool operator==(iterator const &amp;rhv) const</code>; testing the equality
            of two <code >iterator</code> objects:
                <pre>
inline bool StringPtr::iterator::operator==(iterator const &amp;other) const
{
    return d_current == other.d_current;
}
</pre>
<p>
<li><code >bool operator&lt;(iterator const &amp;rhv) const</code>; testing whether the
            left-hand side iterator points to an element of the series located
            <em >before</em> the element pointed to by the right-hand side
            iterator:
                <pre>
inline bool StringPtr::iterator::operator&lt;(iterator const &amp;other) const
{
    return d_current &lt; other.d_current;
}
</pre>
<p>
<li><code >int operator-(iterator const &amp;rhv) const</code>; returning the number of
            elements between the element pointed to by the left-hand side
            iterator and the right-hand side iterator (i.e., the value to add
            to the left-hand side iterator to make it equal to the value of
            the right-hand side iterator):
                <pre>
inline int StringPtr::iterator::operator-(iterator const &amp;rhs) const
{
    return d_current - rhs.d_current;
}
</pre>
<p>
<li><code >Type &amp;operator*() const</code>; returning a reference to the object to
            which the current iterator points. With an <code >InputIterator</code> and
            with all <code >const_iterators</code>, the return type of this overloaded
            operator should be <code >Type const &amp;</code>. This operator returns a
            reference to a string. This string is obtained by dereferencing
            the dereferenced <code >d_current</code> value. As <code >d_current</code> is an
            iterator to <code >string *</code> elements, two dereference operations are
            required to reach the string itself:
                <pre>
inline std::string &amp;StringPtr::iterator::operator*() const
{
    return **d_current;
}
</pre>
<p>
<li><code >iterator operator+(int stepsize) const</code>; this operator
            advances the current iterator by <code >stepsize</code>:
                <pre>
inline StringPtr::iterator StringPtr::iterator::operator+(int step) const
{
    return iterator(d_current + step);
}
</pre>
<p>
<li><code >iterator operator-(int stepsize) const</code>; this operator
            decreases the current iterator by <code >stepsize</code>:
                <pre>
inline StringPtr::iterator StringPtr::iterator::operator-(int step) const
{
    return iterator(d_current - step);
}
</pre>
<p>
<li><code >iterator(iterator const &amp;other)</code>; iterators may be constructed
            from existing iterators. This constructor doesn't have to be
            implemented, as the default copy constructor can be used.
        <li><code >std::string *operator-&gt;() const</code> is an additionally added
            operator. Here only one dereference operation is required,
            returning a pointer to the string, allowing us to access the
            members of a string via its pointer.
                <pre>
inline std::string *StringPtr::iterator::operator-&gt;() const
{
    return *d_current;
}
</pre>
<p>
<li> Two more additionally added operators are <code >operator+=</code> and
            <code >operator-=</code>. They are not formally required by
            <code >RandomAccessIterators</code>, but they come in handy anyway:
                <pre>
inline StringPtr::iterator &amp;StringPtr::iterator::operator+=(int step)
{
    d_current += step;
    return *this;
}
inline StringPtr::iterator &amp;StringPtr::iterator::operator-=(int step)
{
    d_current -= step;
    return *this;
}
</pre>
<p>
</ul>
    </ul>
    The interfaces required for other iterator types are simpler, requiring
only a subset of the interface required by a random access iterator. E.g.,
the forward iterator is never decremented and never incremented over arbitrary
step sizes. Consequently, in that case all decrement operators and
<code >operator+(int step)</code> can be omitted from the interface. Of course, the tag
to use would then be <code >std::forward_iterator_tag</code>. The tags (and the set of
required operators) vary accordingly for the other iterator types.
<p>
<a name="REVERSEIT"></a><a name="l573"></a>
<h3 >22.14.2: Implementing a `reverse_iterator'</h3>
        Once we've implemented an iterator, the matching <a name="an3018"></a><em >reverse iterator</em> can
be implemented in a jiffy. Comparable to the <code >std::iterator</code> a
<code >std::reverse_iterator</code> <a name="an3019"></a>
    exists, that nicely implements the reverse iterator for us once we
have defined an iterator class. Its constructor merely requires an object of
the iterator type for which we want to construct a reverse iterator.
<p>
To implement a reverse iterator for <code >StringPtr</code> we only need to define
the <code >reverse_iterator</code> type in its interface. This requires us to specify
only one line of code, which must be inserted after the interface of the class
<code >iterator</code>:
        <pre>
    typedef std::reverse_iterator&lt;iterator&gt; reverse_iterator;
</pre>
    Also, the well known members <a name="an3020"></a><code >rbegin</code> and <a name="an3021"></a><code >rend</code> are added to
<code >StringPtr</code>'s interface. Again, they can easily be implemented inline:
        <pre>
inline StringPtr::reverse_iterator StringPtr::rbegin()
{
    return reverse_iterator(end());
}
inline StringPtr::reverse_iterator StringPtr::rend()
{
    return reverse_iterator(begin());
}
</pre>
<p>
Note the arguments the <code >reverse_iterator</code> constructors receive: the
        <a name="an3022"></a>
    <em >begin point</em> of the reversed iterator is obtained by providing
<code >reverse_iterator</code>'s constructor with the value returned by the member
<code >end</code>: the <em >endpoint</em> of the normal iterator range; the <em >endpoint</em> of
the reversed iterator is obtained by providing <code >reverse_iterator</code>'s
constructor with the value returned by the member <code >begin</code>: the <em >begin
point</em> of the normal iterator range.
<p>
The following small program illustrates the use of <code >StringPtr</code>'s
<code >RandomAccessIterator</code>:
        <pre>
    #include &lt;iostream&gt;
    #include &lt;algorithm&gt;
    #include "stringptr.h"
    using namespace std;

    int main(int argc, char **argv)
    {
        StringPtr sp;

        while (*argv)
            sp.push_back(new string(*argv++));

        sort(sp.begin(), sp.end());
        copy(sp.begin(), sp.end(), ostream_iterator&lt;string&gt;(cout, " "));

        cout &lt;&lt; "\n======\n";

        sort(sp.rbegin(), sp.rend());
        copy(sp.begin(), sp.end(), ostream_iterator&lt;string&gt;(cout, " "));

        cout &lt;&lt; '\n';
    }
    /*
            when called as:
        a.out bravo mike charlie zulu quebec

            generated output:
        a.out bravo charlie mike quebec zulu
        ======
        zulu quebec mike charlie bravo a.out
    */
</pre>
<p>
Although it is thus possible to construct a reverse iterator from a normal
iterator, the opposite does not hold true: it is not possible to
initialize a normal iterator from a reverse iterator.
<p>
Assume we would like to process all lines stored in <code >vector&lt;string&gt;
lines</code> up to any trailing empty lines (or lines only containing blanks) it
might contain. How should we proceed? One approach is to start the processing
from the first line in the vector, continuing until the first of the trailing
empty lines. However, once we encounter an empty line it does of course not
have to be the first line of the set of trailing empty lines. In that case,
we'd better use the following algorithm:
    <ul>
    <li> First, use
        <pre>
    rit = find_if(lines.rbegin(), lines.rend(), NonEmpty());
</pre>
    to obtain a <code >reverse_iterator rit</code> pointing to the last non-empty
        line.
    <li> Next, use
        <pre>
    for_each(lines.begin(), --rit, Process());
</pre>
        to process all lines up to the first empty line.
    </ul>
    However, we can't mix iterators and reverse iterators when using generic
algorithms. So how can we initialize the second iterator using the available
<code >reverse_iterator</code>? The solution is not very difficult, as an iterator may
be initialized from a pointer. Although the reverse iterator <code >rit</code> is not a
pointer, <code >&amp;*(rit - 1)</code> or <code >&amp;*--rit</code> <em >is</em>. So we use
        <pre>
    for_each(lines.begin(), &amp;*--rit, Process());
</pre>
    to process all the lines up to the first of the set of trailing empty
lines. In general, if <code >rit</code> is a <code >reverse_iterator</code> pointing to some
element and we need an <code >iterator</code> to point to that element, we may use
<code >&amp;*rit</code> to initialize the iterator. Here, the dereference operator is
applied to reach the element the reverse iterator refers to. Then the address
operator is applied to obtain its address with which we can initialize the
iterator.
<p>
When defining a <code >const_reverse_iterator</code> (e.g., matching a
<code >const_iterator</code> class), then the <code >const_iterator's operator*</code> member
should be a member returning a non-modifiable value or object. Since a
<code >const_reverse_iterator</code> uses the iterator's <code >operator--</code> member, we're
running against a small conceptual conflict. On the one hand, a
<code >std::input_iterator_tag</code> is inappropriate, since we must allow decrementing
the iterator. On the other hand, a <code >std::bidirectional_iterator</code> is
inappropriate, since we don't allow modification of the data.
<p>
Iterator tags are primarily conceptual. If <code >const_iterators</code> and
<code >const_reverse_iterators</code> only allow increment operations, then an
<code >input_iterator_tag</code> most closely matches the iterator's intended use. Hence
this tag is used below.
<p>
Furthermore, in line with the nature of a <code >input_iterator_tag</code> our
<code >const_iterator</code> should not offer an <code >operator--</code>. This, of course, causes
problems: a reverse iterator must be able to use the iterator's <code >operator--</code>
member. This can easily be solved by stashing the iterator's <code >operator--</code> in
the iterator's private section, and declaring
<code >std::reverse_iterator&lt;(const_)iterator&gt;</code> its friend (note that declaring a
<code >(const_)reverse_iterator</code> that is derived from <code >std::reverse_iterator</code>
doesn't solve the issue: it is <code >std::reverse_iterator</code> that calls the
iterator's <code >operator--</code>, not a class that is derived from it).
<p>
There is, however, another issue. After deriving a
<code >const_reverse_iterator</code> from <code >const_iterator</code>, and subsequently
dereferencing a <code >const_reverse_iterator</code>, the compiler generates an error
message like the following (using <code >Type = int</code>):
    <pre>
error: invalid initialization of non-const reference of type
'std::reverse_iterator&lt;const_iterator&gt;::reference {aka int&amp;}' from an rvalue
of type 'int' 
  return *--__tmp;
</pre>
<p>
This message is caused by <code >std::reverse_iterator</code> by default expecting
that the iterator's <code >operator*</code> returns a reference to a modifiable
<code >Type</code>. 
<p>
To control such default expectancies, iterators can use <code >typedefs</code> to
fine-tune these expectancies. The following <code >typedefs</code> are interpreted by
<code >std::reverse_iterator</code>:
        <a name="an3023"></a>
        <pre>
    pointer         -   the type of the pointer to the data 
                        (e.g., Type *)
    const_pointer   -   the type of a pointer to immutable data
                        (e.g., Type const *)
    reference       -   the type of a reference to the data
                        (e.g., Type &amp;)
    const_reference -   the type of a reference to immmutable data
                        (e.g., Type const &amp;)
    difference_type -   the type representing differences between
                        pointers (by default `ptrdiff_t')
</pre>
<p>
The mentioned error can simply be prevented by declaring `<code >typedef int
const &amp;reference</code>' in the <code >iterator</code> class. Alternatively, <code >int const</code> may
be specified as the data type for the <code >std::iterator</code>'s base class.
<p>
To define a <code >iterator, const_iterator, reverse_iterator</code> and
<code >const_reverse_iterator</code> for a class <code >Data</code> the following framework can be
used:
<p>
<pre>
#include &lt;string&gt;
#include &lt;iterator&gt;

class Data
{
    std::string *d_data;
    size_t d_n;

    public:
        class iterator;
        class const_iterator;

        typedef std::reverse_iterator&lt;iterator&gt; reverse_iterator;
        typedef std::reverse_iterator&lt;const_iterator&gt; const_reverse_iterator;
};

class Data::iterator: public std::iterator&lt;std::input_iterator_tag,
                                           std::string&gt;
{
    public:
        iterator() = default;

        iterator &amp;operator++();
        std::string &amp;operator*();

    private:
        friend class Data;
        iterator(std::string *data, size_t idx);

        friend class std::reverse_iterator&lt;iterator&gt;;
        iterator &amp;operator--();
};

bool operator==(Data::iterator const &amp;lhs, Data::iterator const &amp;rhs);



class Data::const_iterator: public std::iterator&lt;std::input_iterator_tag,
                                                 std::string const&gt;
{
    public:
        const_iterator() = default;

        const_iterator &amp;operator++();
        std::string const &amp;operator*() const;

    private:
        friend class Data;
        const_iterator(std::string const *data, size_t idx);

        friend class std::reverse_iterator&lt;const_iterator&gt;;
        const_iterator &amp;operator--();
};

bool operator==(Data::const_iterator const &amp;lhs,
                Data::const_iterator const &amp;rhs);


int main()
{
    Data::iterator iter;
    Data::reverse_iterator riter(iter);

    *riter;

    Data::const_iterator citer;
    Data::const_reverse_iterator criter(citer);

    *criter;

};
</pre>
<p>

<hr>
<ul>
    <li> <a href="cplusplus.html">Table of Contents</a>
    <li> <a href="cplusplus21.html">Previous Chapter</a>
    <li> <a href="cplusplus23.html">Next Chapter</a>
</ul>
<hr>
</body>
</html>
