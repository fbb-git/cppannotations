<!DOCTYPE html><html><head>
<meta charset="UTF-8">
<title> C++ Annotations Version 10.8.1 </title>
<link rel="stylesheet" type="text/css" href="cplusplus.css"><style type="text/css">
    figure {text-align: center;}
    img {vertical-align: center;}
</style>
<link rel="stylesheet" type="text/css" href="cplusplus.css"></head>
<body >
<hr>
<ul>
    <li> <a href="cplusplus.html">Table of Contents</a>
    <li> <a href="cplusplus18.html">Previous Chapter</a>
    <li> <a href="cplusplus20.html">Next Chapter</a>
</ul>
<hr>
<a name="GENERIC"></a><a name="l382"></a>
<h1 >Chapter 19: The STL Generic Algorithms</h1>
<a name="l383"></a>
<h2 >19.1: The Generic Algorithms</h2>
Before using the generic algorithms presented in this chapter, except for
those in the <code >Operators</code> category (defined below), the <a name="an2264"></a><code >&lt;algorithm&gt;</code> header
file must be included. Before using a generic algorithm in the
<code >Operators</code> category the <a name="an2265"></a><code >&lt;numeric&gt;</code> header file must be included.
<p>
In the previous chapter the Standard Template Library (STL) was introduced. An
important element of the STL, the <a name="an2266"></a><em >generic algorithms</em>, was not covered in
that chapter as they form a fairly extensive part of the STL.  Over time the
STL has grown considerably, mainly as a result of a growing importance and
appreciation of <em >templates</em>. Covering generic algorithm in the STL chapter
itself would turn that chapter into an unwieldy one and so the generic
algorithms were moved to a chapter of their own.
<p>
Generic algorithms perform an amazing task. Due to the strength of templates,
algorithms could be developed that can be applied to a wide range of different
data types while maintaining type safety. The prototypical example of this is
the <a href="cplusplus19.html#SORT"><code >sort</code></a> generic algorithm. To contrast: while <strong >C</strong> requires
programmers to write callback functions in which type-unsafe <code >void const *</code>
parameters have to be used, internally forcing the programmer to resort to
casts, STL's <code >sort</code> frequently allows the programmer merely to state
something akin to
        <pre>
    sort(first-element, last-element)
</pre>
<p>
Generic algoritms should be used wherever possible. Avoid the urge to design
your own code for commonly encountered algorithms. Make it a habit to
<em >first</em> thoroughly search the generic algorithms for an available
candidate. The generic algorithms should become your <em >weapon of choice</em> when
writing code: acquire full familiarity with them and make their use your
`second nature'.
<p>
This chapter's sections cover the STL's <a name="an2267"></a>generic algorithms in alphabetical
order. For each algorithm the following information is provided:
    <ul>
    <li> The required header file;
    <li> The function prototype;
    <li> A short description;
    <li> A short example.
    </ul>
    In the prototypes of the algorithms <code >Type</code> is used to specify a
<a name="an2268"></a>generic data type. Furthermore, the particular type of iterator (see
section <a href="cplusplus18.html#ITERATORS">18.2</a>) that is required is mentioned as well as other generic
types that might be required (e.g., performing <code >BinaryOperations</code>, like
<code >plus&lt;Type&gt;</code>). Although iterators are commonly provided by abstract
containers and comparable pre-defined data structrues, at some point you may
want to design your own iterators. Section <a href="cplusplus22.html#ITERATORCONS">22.14</a> offers guidelines
for constructing your own iterator classes and provides an overview of of
operators that must be implemented for the various types of iterators.
<p>
Almost every generic algorithm expects an iterator range <a name="an2269"></a><code >[first, last)</code>,
defining the series of elements on which the algorithm operates. The iterators
point to objects or values. When an iterator points to a <code >Type</code> value or
object, function objects used by the algorithms usually receive <code >Type const
&amp;</code> objects or values. Usually function objects cannot modify the objects they
receive as their arguments. This does not hold true for <em >modifying generic
algorithms</em>, which <em >are</em> of course able to modify the objects they operate
upon.
<p>
Generic algorithms may be categorized.
The <strong >C++</strong> Annotations distinguishes the following categories
 <a name="an2270"></a> of generic algorithms:
    <ul>
    <li> Comparators: comparing (ranges of) elements:
        <blockquote >
            <a href="cplusplus19.html#EQUAL">equal</a>;
            <a href="cplusplus19.html#INCLUDES">includes</a>;
            <a href="cplusplus19.html#LEXCOMP">lexicographical_compare</a>;
            <a href="cplusplus19.html#MAX">max</a>;
            <a href="cplusplus19.html#MIN">min</a>;
            <a href="cplusplus19.html#MISMATCH">mismatch</a>;
        </blockquote>
    <li> Copiers: performing copy operations:
        <blockquote >
            <a href="cplusplus19.html#COPY">copy</a>;
            <a href="cplusplus19.html#COPYBACK">copy_backward</a>;
            <a href="cplusplus19.html#PARTSORTCP">partial_sort_copy</a>;
            <a href="cplusplus19.html#REMOVECP">remove_copy</a>;
            <a href="cplusplus19.html#REMOVECPIF">remove_copy_if</a>;
            <a href="cplusplus19.html#REPLACECP">replace_copy</a>;
            <a href="cplusplus19.html#REPLACECPIF">replace_copy_if</a>;
            <a href="cplusplus19.html#REVERSECP">reverse_copy</a>;
            <a href="cplusplus19.html#ROTATECP">rotate_copy</a>;
            <a href="cplusplus19.html#UNIQUECP">unique_copy</a>;
        </blockquote>
    <li> Counters: performing count operations:
        <blockquote >
            <a href="cplusplus19.html#COUNT">count</a>;
            <a href="cplusplus19.html#COUNTIF">count_if</a>;
        </blockquote>
    <li> Heap operators: manipulating a <a name="an2271"></a>max-heap:
        <blockquote >
            <a href="cplusplus19.html#MAKEHEAP">make_heap</a>;
            <a href="cplusplus19.html#POPHEAP">pop_heap</a>;
            <a href="cplusplus19.html#PUSHHEAP">push_heap</a>;
            <a href="cplusplus19.html#SORTHEAP">sort_heap</a>;
        </blockquote>
    <li> Initializers: initializing data:
        <blockquote >
            <a href="cplusplus19.html#FILL">fill</a>;
            <a href="cplusplus19.html#FILLN">fill_n</a>;
            <a href="cplusplus19.html#GEN">generate</a>;
            <a href="cplusplus19.html#GENN">generate_n</a>;
        </blockquote>
    <li> Operators: performing arithmetic operations of some sort:
        <blockquote >
            <a href="cplusplus19.html#ACCU">accumulate</a>;
            <a href="cplusplus19.html#ADJDIFF">adjacent_difference</a>;
            <a href="cplusplus19.html#INNERPROD">inner_product</a>;
            <a href="cplusplus19.html#PARTSUM">partial_sum</a>;
        </blockquote>
    <li> Searchers: performing search (and find) operations:
        <blockquote >
            <a href="cplusplus19.html#ADJFIND">adjacent_find</a>;
            <a href="cplusplus19.html#BINSRCH">binary_search</a>;
            <a href="cplusplus19.html#EQUALRANGE">equal_range</a>;
            <a href="cplusplus19.html#FIND">find</a>;
            <a href="cplusplus19.html#FINDEND">find_end</a>;
            <a href="cplusplus19.html#FINDFIRST">find_first_of</a>;
            <a href="cplusplus19.html#FINDIF">find_if</a>;
            <a href="cplusplus19.html#LOWERBOUND">lower_bound</a>;
            <a href="cplusplus19.html#MAXEL">max_element</a>;
            <a href="cplusplus19.html#MINEL">min_element</a>;
            <a href="cplusplus19.html#SEARCH">search</a>;
            <a href="cplusplus19.html#SEARCHN">search_n</a>;
            <a href="cplusplus19.html#SETDIF">set_difference</a>;
            <a href="cplusplus19.html#SETINT">set_intersection</a>;
            <a href="cplusplus19.html#SETSYM">set_symmetric_difference</a>;
            <a href="cplusplus19.html#SETUNI">set_union</a>;
            <a href="cplusplus19.html#UPPERBOUND">upper_bound</a>;
        </blockquote>
    <li> Shufflers: performing reordering operations (<a name="an2272"></a>sorting,
            <a name="an2273"></a>merging, <a name="an2274"></a>permuting, <a name="an2275"></a>shuffling, <a name="an2276"></a>swapping):
        <blockquote >
            <a href="cplusplus19.html#INMERGE">inplace_merge</a>;
            <a href="cplusplus19.html#ITERSWAP">iter_swap</a>;
            <a href="cplusplus19.html#MERGE">merge</a>;
            <a href="cplusplus19.html#NEXTPERM">next_permutation</a>;
            <a href="cplusplus19.html#NTHEL">nth_element</a>;
            <a href="cplusplus19.html#PARTSORT">partial_sort</a>;
            <a href="cplusplus19.html#PARTSORTCP">partial_sort_copy</a>;
            <a href="cplusplus19.html#PARTIT">partition</a>;
            <a href="cplusplus19.html#PREVPERM">prev_permutation</a>;
            <a href="??">random_shuffle</a>;
            <a href="cplusplus19.html#REMOVE">remove</a>;
            <a href="cplusplus19.html#REMOVECP">remove_copy</a>;
            <a href="cplusplus19.html#REMOVECPIF">remove_copy_if</a>;
            <a href="cplusplus19.html#REMOVEIF">remove_if</a>;
            <a href="cplusplus19.html#REVERSE">reverse</a>;
            <a href="cplusplus19.html#REVERSECP">reverse_copy</a>;
            <a href="cplusplus19.html#ROTATE">rotate</a>;
            <a href="cplusplus19.html#ROTATECP">rotate_copy</a>;
            <a href="cplusplus19.html#SORT">sort</a>;
            <a href="cplusplus19.html#STABPART">stable_partition</a>;
            <a href="cplusplus19.html#STABSORT">stable_sort</a>;
            <a href="cplusplus19.html#SWAP">swap</a>;
            <a href="cplusplus19.html#UNIQUE">unique</a>;
        </blockquote>
    <li> Visitors: visiting elements in a range:
        <blockquote >
            <a href="cplusplus19.html#FOREACH">for_each</a>;
            <a href="cplusplus19.html#REPLACE">replace</a>;
            <a href="cplusplus19.html#REPLACECP">replace_copy</a>;
            <a href="cplusplus19.html#REPLACEIF">replace_copy_if</a>;
            <a href="cplusplus19.html#REPLACEIF">replace_if</a>;
            <a href="cplusplus19.html#TRANSFORM">transform</a>;
            <a href="cplusplus19.html#UNIQUECP">unique_copy</a>;
        </blockquote>
    </ul>
<p>
<a name="ACCU"></a><a name="l384"></a>
<h3 >19.1.1: accumulate</h3>
        <a name="an2277"></a>
    <ul>
    <li> Header file: <code >&lt;numeric&gt;</code>
    <li> Function prototypes:
        <ul>
        <li><code >Type accumulate(InputIterator first, InputIterator last,
            Type init);</code>
        <li><code >Type accumulate(InputIterator first, InputIterator
            last, Type init, BinaryOperation op);</code>
        </ul>
    <li> Description:
        <ul>
        <li> The first prototype: <a name="an2278"></a><code >operator+</code> is applied to all
elements implied by the iterator range and to the initial value <code >init</code>.
The resulting value is returned.
        <li> The second prototype: the binary operator <code >op</code> is applied to
all elements implied by the iterator range and to the initial value <code >init</code>,
and the resulting value is returned.
        </ul>
        <li> Example:
        <pre>
    #include &lt;numeric&gt;
    #include &lt;vector&gt;
    #include &lt;iostream&gt;
    using namespace std;

    int main()
    {
        int         ia[] = {1, 2, 3, 4};
        vector&lt;int&gt; iv(ia, ia + 4);

        cout &lt;&lt;
            "Sum of values: " &lt;&lt; accumulate(iv.begin(), iv.end(), int()) &lt;&lt;
            "\n"
            "Product of values: " &lt;&lt; accumulate(iv.begin(), iv.end(), int(1),
                                            multiplies&lt;int&gt;()) &lt;&lt; '\n';
    }
    /*
        Displays:
            Sum of values: 10
            Product of values: 24
    */
</pre>
    </ul>
<p>
<a name="ADJDIFF"></a><a name="l385"></a>
<h3 >19.1.2: adjacent_difference</h3>
        <a name="an2279"></a>
    <ul>
    <li> Header file: <code >&lt;numeric&gt;</code>
    <li> Function prototypes:
        <ul>
        <li><code >OutputIterator adjacent_difference(InputIterator first,
InputIterator last, OutputIterator result);</code>
        <li><code >OutputIterator adjacent_difference(InputIterator first,
InputIterator last, OutputIterator result, BinaryOperation op);</code>
        </ul>
        <li> Description:
            All operations are performed on the original values, all computed
values are returned values.
            <ul>
            <li> The first prototype: the first returned element is equal to
the first element of the input range. The remaining returned elements are
equal to the difference of the corresponding element in the input range and
its previous element.
            <li> The second prototype: the first returned element is equal to
    the first element of the input range. The remaining returned elements are
equal to the result of the binary operator <code >op</code> applied to the
corresponding element in the input range (left operand) and its previous
element (right operand).
        </ul>
        <li> Example:
        <pre>
    #include &lt;numeric&gt;
    #include &lt;vector&gt;
    #include &lt;iterator&gt;
    #include &lt;iostream&gt;
    using namespace std;

    int main()
    {
        int             ia[] = {1, 2, 5, 10};
        vector&lt;int&gt;     iv(ia, ia + 4);
        vector&lt;int&gt;     ov(iv.size());

        adjacent_difference(iv.begin(), iv.end(), ov.begin());

        copy(ov.begin(), ov.end(), ostream_iterator&lt;int&gt;(cout, " "));
        cout &lt;&lt; '\n';

        adjacent_difference(iv.begin(), iv.end(), ov.begin(), minus&lt;int&gt;());

        copy(ov.begin(), ov.end(), ostream_iterator&lt;int&gt;(cout, " "));
        cout &lt;&lt; '\n';
    }
    /*
        Displays:
            1 1 3 5
            1 1 3 5
    */
</pre>
    </ul>
<p>
<a name="ADJFIND"></a><a name="l386"></a>
<h3 >19.1.3: adjacent_find</h3>
        <a name="an2280"></a>
    <ul>
        <li> Header file: <code >&lt;algorithm&gt;</code>
        <li> Function prototypes:
        <ul>
            <li><code >ForwardIterator adjacent_find(ForwardIterator first,
ForwardIterator last);</code>
            <li><code >OutputIterator adjacent_find(ForwardIterator first,
ForwardIterator last, Predicate pred);</code>
        </ul>
        <li> Description:
        <ul>
            <li> The first prototype: the iterator pointing to the first
element of the first pair of two adjacent equal elements is returned. If no
such element exists, <code >last</code> is returned.
            <li> The second prototype: the iterator pointing to the first
element of the first pair of two adjacent elements for which the binary
predicate <code >pred</code> returns <code >true</code> is returned. If no such element exists,
<code >last</code> is returned.
        </ul>
        <li> Example:
        <pre>
    #include &lt;algorithm&gt;
    #include &lt;string&gt;
    #include &lt;iostream&gt;
    using namespace std;

    class SquaresDiff
    {
        size_t d_minimum;
        public:
            SquaresDiff(size_t minimum)
            :
                d_minimum(minimum)
            {}
            bool operator()(size_t first, size_t second)
            {
                return second * second - first * first  &gt;= d_minimum;
            }
    };
    int main()
    {
        string sarr[] =
            {
                "Alpha", "bravo", "charley", "delta", "echo", "echo",
                "foxtrot", "golf"
            };
        string *last = sarr + sizeof(sarr) / sizeof(string);
        string *result = adjacent_find(sarr, last);

        cout &lt;&lt; *result &lt;&lt; '\n';
        result = adjacent_find(++result, last);

        cout &lt;&lt; "Second time, starting from the next position:\n" &lt;&lt;
            (
                result == last ?
                    "** No more adjacent equal elements **"
                :
                    "*result"
            ) &lt;&lt; '\n';

        size_t iv[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
        size_t *ilast = iv + sizeof(iv) / sizeof(size_t);
        size_t *ires = adjacent_find(iv, ilast, SquaresDiff(10));

        cout &lt;&lt;
            "The first numbers for which the squares differ at least 10: "
            &lt;&lt; *ires &lt;&lt; " and " &lt;&lt; *(ires + 1) &lt;&lt; '\n';
    }
    /*
    Displays:

    echo
    Second time, starting from the next position:
    ** No more adjacent equal elements **
    The first numbers for which the squares differ at least 10: 5 and 6
    */
</pre>
    </ul>
<p>
<a name="BINSRCH"></a><a name="l387"></a>
<h3 >19.1.4: binary_search</h3>
        <a name="an2281"></a>
    <ul>
        <li> Header file: <code >&lt;algorithm&gt;</code>
        <li> Function prototypes:
        <ul>
            <li><code >bool binary_search(ForwardIterator first, ForwardIterator
last, Type const &amp;value);</code>
            <li><code >bool binary_search(ForwardIterator first, ForwardIterator
last, Type const &amp;value, Comparator comp);</code>
        </ul>
        <li> Description:
        <ul>
            <li> The first prototype: <code >value</code> is looked up using binary
search in the series of elements implied by the iterator range <code >[first,
last)</code>. The elements in the range must have been sorted by the
<code >Type::operator&lt;</code> function. <code >True</code> is returned if the element was found,
<code >false</code> otherwise.
            <li> The second prototype: <code >value</code> is looked up using binary
search in the series of elements implied by the iterator range <code >[first,
last)</code>. The elements in the range must have been sorted by the <code >Comparator</code>
function object. <code >True</code> is returned if the element was found, <code >false</code>
otherwise.
        </ul>
        <li> Example:
        <pre>
    #include &lt;algorithm&gt;
    #include &lt;string&gt;
    #include &lt;iostream&gt;
    #include &lt;functional&gt;
    using namespace std;

    int main()
    {
        string sarr[] =
            {
                "alpha", "bravo", "charley", "delta", "echo",
                "foxtrot", "golf", "hotel"
            };
        string *last = sarr + sizeof(sarr) / sizeof(string);
        bool result = binary_search(sarr, last, "foxtrot");

        cout &lt;&lt; (result ? "found " : "didn't find ") &lt;&lt; "foxtrot" &lt;&lt; '\n';

        reverse(sarr, last);                // reverse the order of elements
                                            // binary search now fails:
        result = binary_search(sarr, last, "foxtrot");
        cout &lt;&lt; (result ? "found " : "didn't find ") &lt;&lt; "foxtrot" &lt;&lt; '\n';
                                            // ok when using appropriate
                                            // comparator:
        result = binary_search(sarr, last, "foxtrot", greater&lt;string&gt;());
        cout &lt;&lt; (result ? "found " : "didn't find ") &lt;&lt; "foxtrot" &lt;&lt; '\n';
    }
    /*
        Displays:
            found foxtrot
            didn't find foxtrot
            found foxtrot
    */
</pre>
    </ul>
<p>
<a name="COPY"></a><a name="l388"></a>
<h3 >19.1.5: copy</h3>
        <a name="an2282"></a>
    <ul>
        <li> Header file: <code >&lt;algorithm&gt;</code>
        <li> Function prototype:
        <ul>
            <li><code >OutputIterator copy(InputIterator first, InputIterator last,
OutputIterator destination);</code>
        </ul>
        <li> Description:
        <ul>
            <li> The series of elements implied by the iterator range
<code >[first, last)</code> is copied to an output range, starting at <code >destination</code>
using the assignment operator of the underlying data type. The return value is
the OutputIterator pointing just beyond the last element that was copied to
the destination range (so, `last' in the destination range is returned).
        </ul>
        <li> Example:<br/>
    Note the second call to <code >copy</code>. It uses an <code >ostream_iterator</code> for
<code >string</code> objects. This iterator writes the <code >string</code> values to the
specified <code >ostream</code> (i.e., <code >cout</code>), separating the values by the specified
separation string (i.e., <code >" "</code>).
        <pre>
    #include &lt;algorithm&gt;
    #include &lt;string&gt;
    #include &lt;iostream&gt;
    #include &lt;iterator&gt;
    using namespace std;

    int main()
    {
        string sarr[] =
            {
                "alpha", "bravo", "charley", "delta", "echo",
                "foxtrot", "golf", "hotel"
            };
        string  *last = sarr + sizeof(sarr) / sizeof(string);

        copy(sarr + 2, last, sarr); // move all elements two positions left

                                    // copy to cout using an ostream_iterator
                                    // for strings,
        copy(sarr, last, ostream_iterator&lt;string&gt;(cout, " "));
        cout &lt;&lt; '\n';
    }
    //  Displays: charley delta echo foxtrot golf hotel golf hotel
</pre>
        <li> See also:
            <a href="cplusplus19.html#UNIQUECP"><code >unique_copy</code></a>
    </ul>
<p>
<a name="COPYBACK"></a><a name="l389"></a>
<h3 >19.1.6: copy_backward</h3>
        <a name="an2283"></a>
    <ul>
        <li> Header file: <code >&lt;algorithm&gt;</code>
        <li> Function prototype:
        <ul>
            <li><code >BidirectionalIterator copy_backward(InputIterator first,
InputIterator last, BidirectionalIterator last2);</code>
        </ul>
        <li> Description:
        <ul>
            <li> The series of elements implied by the iterator range
<code >[first, last)</code> are copied from the element at position <code >last - 1</code>
until (and including) the element at position <code >first</code> to the element range,
<em >ending</em> at position <code >last2 - 1</code> using the assignment operator of the
underlying data type. The destination range is therefore <code >[last2 - (last
- first), last2)</code>.
<p>
Note that this algorithm does <em >not</em> reverse the order of the elements when
copying them to the destination range.
<p>
The return value is the BidirectionalIterator pointing to the last element that
was copied to the destination range (so, `first' in the destination range, pointed to by <code >last2 - (last - first)</code>, is returned).
        </ul>
        <li> Example:
        <pre>
    #include &lt;algorithm&gt;
    #include &lt;string&gt;
    #include &lt;iostream&gt;
    #include &lt;iterator&gt;
    using namespace std;

    int main()
    {
        string sarr[] =
            {
                "alpha", "bravo", "charley", "delta", "echo",
                "foxtrot", "golf", "hotel"
            };
        string *last = sarr + sizeof(sarr) / sizeof(string);

        copy
        (
            copy_backward(sarr + 3, last, last - 3),
            last,
            ostream_iterator&lt;string&gt;(cout, " ")
        );
        cout &lt;&lt; '\n';
    }
    // Displays:    golf hotel foxtrot golf hotel foxtrot golf hotel
</pre>
    </ul>
<p>
<a name="COUNT"></a><a name="l390"></a>
<h3 >19.1.7: count</h3>
        <a name="an2284"></a>
    <ul>
        <li> Header file: <code >&lt;algorithm&gt;</code>
        <li> Function prototype:
        <ul>
            <li><code >size_t count(InputIterator first, InputIterator last, Type
const &amp;value);</code>
        </ul>
        <li> Description:
        <ul>
            <li> The number of times <code >value</code> occurs in the iterator range
<code >[first, last)</code> is returned.  Uses <code >Type::operator==</code> to determine
whether <code >value</code> is equal to an element in the iterator range.
        </ul>
        <li> Example:
        <pre>
    #include &lt;algorithm&gt;
    #include &lt;iostream&gt;
    using namespace std;

    int main()
    {
        int ia[] = {1, 2, 3, 4, 3, 4, 2, 1, 3};

        cout &lt;&lt; "Number of times the value 3 is available: " &lt;&lt;
            count(ia, ia + sizeof(ia) / sizeof(int), 3) &lt;&lt;
            '\n';
    }
    // Displays:    Number of times the value 3 is available: 3
</pre>
    </ul>
<p>
<a name="COUNTIF"></a><a name="l391"></a>
<h3 >19.1.8: count_if</h3>
        <a name="an2285"></a>
    <ul>
        <li> Header file: <code >&lt;algorithm&gt;</code>
        <li> Function prototype:
        <ul>
            <li><code >size_t count_if(InputIterator first,
                InputIterator last, Predicate predicate);</code>
        </ul>
        <li> Description:
        <ul>
            <li> The number of times <a name="an2286"></a>unary predicate `<code >predicate</code>'
returns <code >true</code> when applied to the elements implied by the iterator range
<code >[first, last)</code> is returned.
        </ul>
        <li> Example:
        <pre>
    #include &lt;algorithm&gt;
    #include &lt;iostream&gt;
    using namespace std;

    class Odd
    {
        public:
            bool operator()(int value) const
            {
                return value &amp; 1;
            }
    };
    int main()
    {
        int     ia[] = {1, 2, 3, 4, 3, 4, 2, 1, 3};

        cout &lt;&lt; "The number of odd values in the array is: " &lt;&lt;
            count_if(ia, ia + sizeof(ia) / sizeof(int), Odd{}) &lt;&lt; '\n';
    }
    // Displays:    The number of odd values in the array is: 5
</pre>
    </ul>
<p>
<a name="EQUAL"></a><a name="l392"></a>
<h3 >19.1.9: equal</h3>
        <a name="an2287"></a>
    <ul>
        <li> Header file: <code >&lt;algorithm&gt;</code>
        <li> Function prototypes:
        <ul>
            <li><code >bool equal(InputIterator first, InputIterator
                last, InputIterator otherFirst);</code>
            <li><code >bool equal(InputIterator first, InputIterator last,
                InputIterator otherFirst, BinaryPredicate pred);</code>
        </ul>
        <li> Description:
        <ul>
            <li> The first prototype: the elements in the range <code >[first,
last)</code> are compared to a range of equal length starting at <code >otherFirst</code>. The
function returns <code >true</code> if the visited elements in both ranges are equal
pairwise. The ranges need not be of equal length, only the elements in the
indicated range are considered (and must be available).
            <li> The second prototype: the elements in the range
<code >[first, last)</code> are compared to a range of equal length starting at
<code >otherFirst</code>. The function returns <code >true</code> if the binary predicate, applied
to all corresponding elements in both ranges returns <code >true</code> for every pair
of corresponding elements.  The ranges need not be of equal length, only the
elements in the indicated range are considered (and must be available).
        </ul>
        <li> Example:
        <pre>
    #include &lt;algorithm&gt;
    #include &lt;string&gt;
    #include &lt;cstring&gt;
    #include &lt;iostream&gt;
    using namespace std;

    class CaseString
    {
        public:
            bool operator()(string const &amp;first,
                            string const &amp;second) const
            {
                return !strcasecmp(first.c_str(), second.c_str());
            }
    };
    int main()
    {
        string first[] =
            {
                "Alpha", "bravo", "Charley", "delta", "Echo",
                "foxtrot", "Golf", "hotel"
            };
        string second[] =
            {
                "alpha", "bravo", "charley", "delta", "echo",
                "foxtrot", "golf", "hotel"
            };
        string *last = first + sizeof(first) / sizeof(string);

        cout &lt;&lt; "The elements of `first' and `second' are pairwise " &lt;&lt;
            (equal(first, last, second) ? "equal" : "not equal") &lt;&lt;
            '\n' &lt;&lt;
            "compared case-insensitively, they are " &lt;&lt;
            (
                equal(first, last, second, CaseString{}) ?
                    "equal" : "not equal"
            ) &lt;&lt; '\n';
    }
    /*
        Displays:
            The elements of `first' and `second' are pairwise not equal
            compared case-insensitively, they are equal
    */
</pre>
    </ul>
<p>
<a name="EQUALRANGE"></a><a name="l393"></a>
<h3 >19.1.10: equal_range</h3>
        <a name="an2288"></a>
    <ul>
        <li> Header file: <code >&lt;algorithm&gt;</code>
        <li> Function prototypes:
        <ul>
            <li><code >pair&lt;ForwardIterator, ForwardIterator&gt;
            equal_range(ForwardIterator first, ForwardIterator last, Type
const &amp;value);</code>
            <li><code >pair&lt;ForwardIterator, ForwardIterator&gt;
            equal_range(ForwardIterator first, ForwardIterator last, Type
const &amp;value, Compare comp);</code>
        </ul>
        <li> Description (see also identically named member functions of,
e.g., the <code >map</code> (section <a href="cplusplus12.html#MAP">12.4.7</a>) and <code >multimap</code> (section
<a href="cplusplus12.html#MULTIMAP">12.4.8</a>)):
        <ul>
            <li> The first prototype: starting from a sorted sequence (where
the <code >operator&lt;</code> of the data type to which the iterators point was used to
sort the elements in the provided range), a pair of iterators is returned
representing the return value of, respectively, <code >lower_bound</code> (returning
the first element that is not smaller than the provided reference value, see
section <a href="cplusplus19.html#LOWERBOUND">19.1.26</a>) and <code >upper_bound</code> (returning the first element
beyond the provided reference value, see section <a href="cplusplus19.html#UPPERBOUND">19.1.66</a>).
            <li> The second prototype: starting from a sorted sequence (where
the <code >comp</code> function object was used to sort the elements in the provided
range), a pair of iterators is returned representing the return values of,
respectively, the functions <code >lower_bound</code> (section <a href="cplusplus19.html#LOWERBOUND">19.1.26</a>) and
<code >upper_bound</code> (section <a href="cplusplus19.html#UPPERBOUND">19.1.66</a>).
        </ul>
        <li> Example:
        <pre>
    #include &lt;algorithm&gt;
    #include &lt;functional&gt;
    #include &lt;iterator&gt;
    #include &lt;iostream&gt;
    using namespace std;

    int main()
    {
        int                 range[] = {1, 3, 5, 7, 7, 9, 9, 9};
        size_t const      size = sizeof(range) / sizeof(int);

        pair&lt;int *, int *&gt;  pi;

        pi = equal_range(range, range + size, 6);

        cout &lt;&lt; "Lower bound for 6: " &lt;&lt; *pi.first &lt;&lt; '\n';
        cout &lt;&lt; "Upper bound for 6: " &lt;&lt; *pi.second &lt;&lt; '\n';

        pi = equal_range(range, range + size, 7);

        cout &lt;&lt; "Lower bound for 7: ";
        copy(pi.first, range + size, ostream_iterator&lt;int&gt;(cout, " "));
        cout &lt;&lt; '\n';

        cout &lt;&lt; "Upper bound for 7: ";
        copy(pi.second, range + size, ostream_iterator&lt;int&gt;(cout, " "));
        cout &lt;&lt; '\n';

        sort(range, range + size, greater&lt;int&gt;());

        cout &lt;&lt; "Sorted in descending order\n";

        copy(range, range + size, ostream_iterator&lt;int&gt;(cout, " "));
        cout &lt;&lt; '\n';

        pi = equal_range(range, range + size, 7, greater&lt;int&gt;());

        cout &lt;&lt; "Lower bound for 7: ";
        copy(pi.first, range + size, ostream_iterator&lt;int&gt;(cout, " "));
        cout &lt;&lt; '\n';

        cout &lt;&lt; "Upper bound for 7: ";
        copy(pi.second, range + size, ostream_iterator&lt;int&gt;(cout, " "));
        cout &lt;&lt; '\n';
    }
    /*
        Displays:
            Lower bound for 6: 7
            Upper bound for 6: 7
            Lower bound for 7: 7 7 9 9 9
            Upper bound for 7: 9 9 9
            Sorted in descending order
            9 9 9 7 7 5 3 1
            Lower bound for 7: 7 7 5 3 1
            Upper bound for 7: 5 3 1
    */
</pre>
    </ul>
<p>
<a name="EXCHANGE"></a><a name="l394"></a>
<h3 >19.1.11: exchange</h3>
    <a name="an2289"></a>
<ul>
    <li> Header file: <code >&lt;utility&gt;</code>
    <li> Function prototype:
    <ul>
        <li><code >Type exchange(Type &amp;object1, ValueType &amp;&amp;newValue);</code>
    </ul>
    <li> Description:
    <ul>
        <li> <code >newValue</code> is assigned to <code >object1</code>, and <code >object1's</code>
                previous value is returned.
    </ul>
    <li> Example:
    <pre>
    #include &lt;utility&gt;
    #include &lt;iostream&gt;
    using namespace std;

    int main(int argc, char **argv)
    {
        bool more = argc &gt; 5;

        cout &lt;&lt; "more than 5: " &lt;&lt; exchange(more, argc &gt; 2) &lt;&lt;
                ", more than 2: " &lt;&lt; more &lt;&lt; '\n';
    }
    /*
        Using g++ at least version 7.0.0:
        With `a.out one two three' displays:

        more than 5: 0, more than 2: 1

    */
</pre>
</ul>
<p>
<a name="FILL"></a><a name="l395"></a>
<h3 >19.1.12: fill</h3>
        <a name="an2290"></a>
    <ul>
        <li> Header file: <code >&lt;algorithm&gt;</code>
        <li> Function prototype:
        <ul>
            <li><code >void fill(ForwardIterator first, ForwardIterator last, Type
                const &amp;value);</code>
        </ul>
        <li> Description:
        <ul>
            <li> all the elements implied by the iterator range
<code >[first, last)</code> are initialized to <code >value</code>, overwriting the previously
stored values.
        </ul>
        <li> Example:
        <pre>
    #include &lt;algorithm&gt;
    #include &lt;vector&gt;
    #include &lt;iterator&gt;
    #include &lt;iostream&gt;
    using namespace std;

    int main()
    {
        vector&lt;int&gt;     iv(8);

        fill(iv.begin(), iv.end(), 8);

        copy(iv.begin(), iv.end(), ostream_iterator&lt;int&gt;(cout, " "));
        cout &lt;&lt; '\n';
    }
    // Displays:    8 8 8 8 8 8 8 8
</pre>
    </ul>
<p>
<a name="FILLN"></a><a name="l396"></a>
<h3 >19.1.13: fill_n</h3>
        <a name="an2291"></a>
    <ul>
        <li> Header file: <code >&lt;algorithm&gt;</code>
        <li> Function prototype:
        <ul>
            <li><code >void fill_n(ForwardIterator first, Size n, Type
                const &amp;value);</code>
        </ul>
        <li> Description:
        <ul>
            <li> <code >n</code> elements starting at the element pointed to by
<code >first</code> are  initialized to <code >value</code>, overwriting the previous
stored values.
        </ul>
        <li> Example:
        <pre>
    #include &lt;algorithm&gt;
    #include &lt;vector&gt;
    #include &lt;iterator&gt;
    #include &lt;iostream&gt;
    using namespace std;

    int main()
    {
        vector&lt;int&gt;     iv(8);

        fill_n(iv.begin() + 2, 4, 8);

        copy(iv.begin(), iv.end(), ostream_iterator&lt;int&gt;(cout, " "));
        cout &lt;&lt; '\n';
    }
    // Displays:    0 0 8 8 8 8 0 0
</pre>
    </ul>
<p>
<a name="FIND"></a><a name="l397"></a>
<h3 >19.1.14: find</h3>
        <a name="an2292"></a>
    <ul>
        <li> Header file: <code >&lt;algorithm&gt;</code>
        <li> Function prototype:
        <ul>
            <li><code >InputIterator find(InputIterator first,
    InputIterator last, Type const &amp;value);</code>
        </ul>
        <li> Description:
        <ul>
            <li> Element <code >value</code> is searched for in the range of the elements
implied by the iterator range <code >[first, last)</code>. An iterator pointing to
the first element found is returned. If the element was not found, <code >last</code> is
returned. The <code >operator==</code> of the underlying data type is used to
compare the elements.
        </ul>
        <li> Example:
        <pre>
    #include &lt;algorithm&gt;
    #include &lt;string&gt;
    #include &lt;iterator&gt;
    #include &lt;iostream&gt;
    using namespace std;

    int main()
    {
        string sarr[] =
            {
                "alpha", "bravo", "charley", "delta", "echo"
            };
        string  *last = sarr + sizeof(sarr) / sizeof(string);

        copy
        (
            find(sarr, last, "delta"), last,
                                       ostream_iterator&lt;string&gt;(cout, " ")
        );
        cout &lt;&lt; '\n';

        if (find(sarr, last, "india") == last)
        {
            cout &lt;&lt; "`india' was not found in the range\n";
            copy(sarr, last, ostream_iterator&lt;string&gt;(cout, " "));
            cout &lt;&lt; '\n';
        }
    }
    /*
        Displays:
            delta echo
            `india' was not found in the range
            alpha bravo charley delta echo
    */
</pre>
    </ul>
<p>
<a name="FINDEND"></a><a name="l398"></a>
<h3 >19.1.15: find_end</h3>
        <a name="an2293"></a>
    <ul>
        <li> Header file: <code >&lt;algorithm&gt;</code>
        <li> Function prototypes:
        <ul>
            <li><code >ForwardIterator1 find_end(ForwardIterator1 first1,
    ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2)</code>
            <li><code >ForwardIterator1 find_end(ForwardIterator1 first1,
    ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2,
                                            BinaryPredicate pred)</code>
        </ul>
        <li> Description:
        <ul>
            <li> The first prototype: the sequence of elements implied by
<code >[first1, last1)</code> is searched for the last occurrence of the sequence of
elements implied by the range <code >[first2, last2)</code>. If the sequence
<code >[first2, last2)</code> is not found, <code >last1</code> is returned, otherwise an
iterator pointing to the first element of the matching sequence is
returned. The <code >operator==</code> of the underlying data type is used to compare
the elements in the two sequences.
            <li> The second prototype: the sequence of elements implied by
<code >[first1, last1)</code> is searched for the last occurrence of the sequence of
elements implied by <code >[first2, last2)</code>. If the sequence <code >[first2,
last2)</code> is not found, <code >last1</code> is returned, otherwise an iterator pointing to
the first element of the matching sequence is returned. The provided binary
predicate is used to compare the elements in the two sequences.
        </ul>
        <li> Example:
        <pre>
    #include &lt;algorithm&gt;
    #include &lt;string&gt;
    #include &lt;iterator&gt;
    #include &lt;iostream&gt;
    using namespace std;

    class Twice
    {
        public:
            bool operator()(size_t first, size_t second) const
            {
                return first == (second &lt;&lt; 1);
            }
    };
    int main()
    {
        string sarr[] =
            {
                "alpha", "bravo", "charley", "delta", "echo",
                "foxtrot", "golf", "hotel",
                "foxtrot", "golf", "hotel",
                "india", "juliet", "kilo"
            };
        string search[] =
            {
                "foxtrot",
                "golf",
                "hotel"
            };
        string  *last = sarr + sizeof(sarr) / sizeof(string);

        copy
        (
            find_end(sarr, last, search, search + 3),   // sequence starting
            last, ostream_iterator&lt;string&gt;{ cout, " " } // at 2nd 'foxtrot'
        );
        cout &lt;&lt; '\n';

        size_t range[] = {2, 4, 6, 8, 10, 4, 6, 8, 10};
        size_t nrs[]   = {2, 3, 4};

        copy                // sequence of values starting at last sequence
        (                   // of range[] that are twice the values in nrs[]
            find_end(range, range + 9, nrs, nrs + 3, Twice{}),
            range + 9, ostream_iterator&lt;size_t&gt;{ cout, " " }
        );
        cout &lt;&lt; '\n';
    }
    /*
        Displays:
            foxtrot golf hotel india juliet kilo
            4 6 8 10
    */
</pre>
    </ul>
<p>
<a name="FINDFIRST"></a><a name="l399"></a>
<h3 >19.1.16: find_first_of</h3>
        <a name="an2294"></a>
    <ul>
        <li> Header file: <code >&lt;algorithm&gt;</code>
        <li> Function prototypes:
        <ul>
            <li><code >ForwardIterator1 find_first_of(ForwardIterator1 first1,
    ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2)</code>
            <li><code >ForwardIterator1 find_first_of(ForwardIterator1 first1,
    ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2,
    BinaryPredicate pred)</code>
        </ul>
        <li> Description:
        <ul>
            <li> The first prototype: the sequence of elements implied by
<code >[first1, last1)</code> is searched for the first occurrence of an element in
the sequence of elements implied by the range <code >[first2, last2)</code>. If no
element in the sequence <code >[first2, last2)</code> is found, <code >last1</code> is
returned, otherwise an iterator pointing to the first element in
<code >[first1, last1)</code> that is equal to an element in <code >[first2, last2)</code>
is returned. The <code >operator==</code> of the underlying data type is used to compare
the elements in the two sequences.
            <li> The second prototype: the sequence of elements implied by
<code >[first1, last1)</code> is searched for the first occurrence of an element in
the sequence of elements implied by <code >[first2, last2)</code>. Each element in
the range <code >[first1, last1)</code> is compared to each element in the range
<code >[first2, last2)</code>, and an iterator to the first element in
<code >[first1, last1)</code> for which the binary predicate <code >pred</code> (receiving an
the element out of the range <code >[first1, last1)</code> and an element from the
range <code >[first2, last2)</code>) returns <code >true</code> is returned. Otherwise,
<code >last1</code> is returned.
        </ul>
        <li> Example:
        <pre>
    #include &lt;algorithm&gt;
    #include &lt;string&gt;
    #include &lt;iterator&gt;
    #include &lt;iostream&gt;
    using namespace std;

    class Twice
    {
        public:
            bool operator()(size_t first, size_t second) const
            {
                return first == (second &lt;&lt; 1);
            }
    };
    int main()
    {
        string sarr[] =
            {
                "alpha", "bravo", "charley", "delta", "echo",
                "foxtrot", "golf", "hotel",
                "foxtrot", "golf", "hotel",
                "india", "juliet", "kilo"
            };
        string search[] =
            {
                "foxtrot",
                "golf",
                "hotel"
            };
        string  *last = sarr + sizeof(sarr) / sizeof(string);

        copy
        (                                                 // sequence starting
            find_first_of(sarr, last, search, search + 3),// at 1st 'foxtrot'
            last, ostream_iterator&lt;string&gt;{ cout, " " }
        );
        cout &lt;&lt; '\n';

        size_t range[] = {2, 4, 6, 8, 10, 4, 6, 8, 10};
        size_t nrs[]   = {2, 3, 4};

            // copy the sequence of values in 'range', starting at the
            // first element in 'range' that is equal to twice one of the
            // values in 'nrs', and ending at the last element of 'range'
        copy
        (
            find_first_of(range, range + 9, nrs, nrs + 3, Twice{}),
            range + 9, ostream_iterator&lt;size_t&gt;{ cout, " " }
        );
        cout &lt;&lt; '\n';
    }
    /*
        Displays:
            foxtrot golf hotel foxtrot golf hotel india juliet kilo
            4 6 8 10 4 6 8 10
    */
</pre>
    </ul>
<p>
<a name="FINDIF"></a><a name="l400"></a>
<h3 >19.1.17: find_if</h3>
        <a name="an2295"></a>
    <ul>
        <li> Header file: <code >&lt;algorithm&gt;</code>
        <li> Function prototype:
        <ul>
            <li><code >InputIterator find_if(InputIterator first,
    InputIterator last, Predicate pred);</code>
        </ul>
        <li> Description:
        <ul>
            <li> An iterator pointing to the first element in the range
implied by the iterator range <code >[first, last)</code> for which the (unary)
predicate <code >pred</code> returns <code >true</code> is returned. If the element was not found,
<code >last</code> is returned.
        </ul>
        <li> Example:
        <pre>
    #include &lt;algorithm&gt;
    #include &lt;string&gt;
    #include &lt;cstring&gt;
    #include &lt;iterator&gt;
    #include &lt;iostream&gt;
    using namespace std;

    class CaseName
    {
        std::string  d_string;

        public:
            CaseName(char const *str): d_string(str)
            {}
            bool operator()(std::string const &amp;element) const
            {
                return strcasecmp(element.c_str(), d_string.c_str()) == 0;
            }
    };
    int main()
    {
        string sarr[] =
            {
                "Alpha", "Bravo", "Charley", "Delta", "Echo"
            };
        string  *last = sarr + sizeof(sarr) / sizeof(string);

        copy
        (
            find_if(sarr, last, CaseName{ "charley" }),
            last, ostream_iterator&lt;string&gt;{ cout, " " }
        );
        cout &lt;&lt; '\n';

        if (find_if(sarr, last, CaseName{ "india" }) == last)
        {
            cout &lt;&lt; "`india' was not found in the range\n";
            copy(sarr, last, ostream_iterator&lt;string&gt;{ cout, " " });
            cout &lt;&lt; '\n';
        }
    }
    /*
        Displays:
            Charley Delta Echo
            `india' was not found in the range
            Alpha Bravo Charley Delta Echo
    */
</pre>
    </ul>
<p>
<a name="FOREACH"></a><a name="l401"></a>
<h3 >19.1.18: for_each</h3>
        <a name="an2296"></a>
    <ul>
        <li> Header file: <code >&lt;algorithm&gt;</code>
        <li> Function prototype:
        <ul>
            <li><code >Function for_each(ForwardIterator first,
                ForwardIterator last, Function func);</code>
        </ul>
        <li> Description:
        <ul>
            <li> Each of the elements implied by the iterator range
<code >[first, last)</code> is passed in turn as a reference to the function (or
function object) <code >func</code>. The function may modify the elements it receives
(as the used iterator is a forward iterator). Alternatively, if the elements
should be transformed, <code >transform</code> (see section <a href="cplusplus19.html#TRANSFORM">19.1.63</a>) can be
used. The function itself or a copy of the provided function object is
returned: see the example below, in which an extra argument list is added to
the <code >for_each</code> call, which argument is eventually also passed to the
function given to <code >for_each</code>. Within <code >for_each</code> the return value of the
function that is passed to it is ignored. The <code >for_each</code> generic algorithm
looks a lot like the range-based for loop, but different from the range-based
for-loop the <code >for_each</code> algoritm can also be used with sub-ranges and with
reverse-iterators.
        </ul>
        <li> Example:
        <pre>
    #include &lt;algorithm&gt;
    #include &lt;string&gt;
    #include &lt;cstring&gt;
    #include &lt;iostream&gt;
    #include &lt;cctype&gt;
    using namespace std;

    void lowerCase(char &amp;c)                     // `c' *is* modified
    {
        c = tolower(static_cast&lt;unsigned char&gt;(c));
    }
    void capitalizedOutput(string const &amp;str)   // `str' is *not* modified
    {
        char    *tmp = strcpy(new char[str.size() + 1], str.c_str());

        for_each(tmp + 1, tmp + str.size(), lowerCase);

        tmp[0] = toupper(*tmp);
        cout &lt;&lt; tmp &lt;&lt; " ";
        delete tmp;
    };
    int main()
    {
        string sarr[] =
            {
                "alpha", "BRAVO", "charley", "DELTA",  "echo",
                "FOXTROT", "golf", "HOTEL"
            };
        string *last = sarr + sizeof(sarr) / sizeof(string);

        for_each(sarr, last, capitalizedOutput)("that's all, folks");
        cout &lt;&lt; '\n';
    }
    /*
    Displays:

    Alpha Bravo Charley Delta Echo Foxtrot Golf Hotel That's all, folks
    */
</pre>
        <li> Here is another example using a function object:
        <pre>
    #include &lt;algorithm&gt;
    #include &lt;string&gt;
    #include &lt;iostream&gt;
    #include &lt;cctype&gt;
    using namespace std;

    void lowerCase(char &amp;c)
    {
        c = tolower(static_cast&lt;unsigned char&gt;(c));
    }
    class Show
    {
        int d_count;

        public:
            Show()
            :
                d_count(0)
            {}
            void operator()(std::string &amp;str)
            {
                std::for_each(str.begin(), str.end(), lowerCase);
                str[0] = toupper(str[0]);   // assuming str is not empty
                std::cout &lt;&lt; ++d_count &lt;&lt; " " &lt;&lt; str &lt;&lt; "; ";
            }
            int count() const
            {
                return d_count;
            }
    };
    int main()
    {
        string sarr[] =
            {
                "alpha", "BRAVO", "charley", "DELTA", "echo",
                "FOXTROT", "golf", "HOTEL"
            };
        string *last = sarr + sizeof(sarr) / sizeof(string);

        cout &lt;&lt; for_each(sarr, last, Show{}).count() &lt;&lt; '\n';
    }
    /*
    Displays (all on one line):

    1 Alpha; 2 Bravo; 3 Charley; 4 Delta; 5 Echo; 6 Foxtrot;
                                              7 Golf; 8 Hotel; 8
    */
</pre>
    </ul>
    The example also shows that the <code >for_each</code> algorithm may be used with
functions defining <code >const</code> and non-<code >const</code> parameters. Also, see section
<a href="cplusplus19.html#TRANSFORM">19.1.63</a> for differences between the <code >for_each</code> and <code >transform</code>
generic algorithms.
<p>
The <code >for_each</code> algorithm cannot directly be used (i.e., by passing
<code >*this</code> as the function object argument) inside a member function to modify
its own object as the <code >for_each</code> algorithm first creates its own copy of the
passed function object. A <a name="an2297"></a><em >lambda function</em> or a <em >wrapper class</em> whose
constructor accepts a pointer or reference to the current object and possibly
to one of its member functions solves this problem.
<p>
<a name="GEN"></a><a name="l402"></a>
<h3 >19.1.19: generate</h3>
        <a name="an2298"></a>
    <ul>
        <li> Header file: <code >&lt;algorithm&gt;</code>
        <li> Function prototype:
        <ul>
            <li><code >void generate(ForwardIterator first,
                ForwardIterator last, Generator generator);</code>
        </ul>
        <li> Description:
        <ul>
            <li> All elements implied by the iterator range <code >[first,
last)</code> are initialized by the return value of <code >generator</code>, which can be a
function or function object. <code >Generator::operator()</code> does not receive
any arguments. The example uses a well-known fact from algebra: in order to
obtain the square of <code >n + 1</code>, add <code >1 + 2 * n</code> to <code >n * n</code>.
        </ul>
        <li> Example:
        <pre>
    #include &lt;algorithm&gt;
    #include &lt;vector&gt;
    #include &lt;iterator&gt;
    #include &lt;iostream&gt;
    using namespace std;

    class NaturalSquares
    {
        size_t d_newsqr;
        size_t d_last;

        public:
            NaturalSquares(): d_newsqr(0), d_last(0)
            {}
            size_t operator()()
            {                   // using: (a + 1)^2 == a^2 + 2*a + 1
                return d_newsqr += (d_last++ &lt;&lt; 1) + 1;
            }
    };
    int main()
    {
        vector&lt;size_t&gt; uv(10);

        generate(uv.begin(), uv.end(), NaturalSquares{});

        copy(uv.begin(), uv.end(), ostream_iterator&lt;int&gt;{ cout, " " });
        cout &lt;&lt; '\n';
    }
    // Displays:   1 4 9 16 25 36 49 64 81 100
</pre>
    </ul>
<p>
<a name="GENN"></a><a name="l403"></a>
<h3 >19.1.20: generate_n</h3>
        <a name="an2299"></a>
    <ul>
        <li> Header file: <code >&lt;algorithm&gt;</code>
        <li> Function prototypes:
        <ul>
            <li><code >void generate_n(ForwardIterator first, Size n,
                Generator generator);</code>
        </ul>
        <li> Description:
        <ul>
            <li> <code >n</code> elements starting at the element pointed to by
iterator <code >first</code> are initialized by the return value of <code >generator</code>,
which can be a function or function object.
        </ul>
        <li> Example:
        <pre>
    #include &lt;algorithm&gt;
    #include &lt;vector&gt;
    #include &lt;iterator&gt;
    #include &lt;iostream&gt;
    using namespace std;

    class NaturalSquares
    {
        size_t d_newsqr;
        size_t d_last;

        public:
            NaturalSquares(): d_newsqr(0), d_last(0)
            {}
            size_t operator()()
            {                           // using: (a + 1)^2 == a^2 + 2*a + 1
                return d_newsqr += (d_last++ &lt;&lt; 1) + 1;
            }
    };
    int main()
    {
        vector&lt;size_t&gt; uv(10);

        generate_n(uv.begin(), 5, NaturalSquares{});

        copy(uv.begin(), uv.end(), ostream_iterator&lt;int&gt;{ cout, " " });
        cout &lt;&lt; '\n';
    }
    // Displays:    1 4 9 16 25 0 0 0 0 0
</pre>
    </ul>
<p>
<a name="INCLUDES"></a><a name="l404"></a>
<h3 >19.1.21: includes</h3>
        <a name="an2300"></a>
    <ul>
        <li> Header file: <code >&lt;algorithm&gt;</code>
        <li> Function prototypes:
        <ul>
            <li><code >bool includes(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, InputIterator2 last2);</code>
            <li><code >bool includes(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, InputIterator2 last2, Compare comp);</code>
        </ul>
        <li> Description:
        <ul>
            <li> The first prototype: both sequences of elements implied by
the ranges <code >[first1, last1)</code> and <code >[first2, last2)</code> should have been
sorted using the <code >operator&lt;</code> of the data type to which the iterators
point. The function returns <code >true</code> if every element in the second sequence
<code >[first2, last2)</code> is contained in the first sequence <code >[first1,
last1)</code> (the second range is a subset of the first range).
            <li> The second prototype: both sequences of elements implied by
the ranges <code >[first1, last1)</code> and <code >[first2, last2)</code> should have been
sorted using the <code >comp</code> function object. The function returns <code >true</code> if
every element in the second sequence <code >[first2, last2)</code> is contained in
the first sequence <code >[first1, last1)</code> (the second range is a subset of
the first range).
        </ul>
        <li> Example:
        <pre>
    #include &lt;algorithm&gt;
    #include &lt;string&gt;
    #include &lt;cstring&gt;
    #include &lt;iostream&gt;
    using namespace std;

    class CaseString
    {
        public:
            bool operator()(string const &amp;first,
                            string const &amp;second) const
            {
                return !strcasecmp(first.c_str(), second.c_str());
            }
    };
    int main()
    {
        string first1[] =
            {
                "alpha", "bravo", "charley", "delta",  "echo",
                "foxtrot", "golf", "hotel"
            };
        string first2[] =
            {
                "Alpha", "bravo", "Charley", "delta",  "Echo",
                "foxtrot", "Golf", "hotel"
            };
        string second[] =
            {
                "charley", "foxtrot", "hotel"
            };
        size_t n = sizeof(first1) / sizeof(string);

        cout &lt;&lt; "The elements of `second' are " &lt;&lt;
            (includes(first1, first1 + n, second, second + 3) ? "" : "not")
            &lt;&lt; " contained in the first sequence:\n"
               "second is a subset of first1\n";

        cout &lt;&lt; "The elements of `first1' are " &lt;&lt;
            (includes(second, second + 3, first1, first1 + n) ? "" : "not")
            &lt;&lt; " contained in the second sequence\n";

        cout &lt;&lt; "The elements of `second' are " &lt;&lt;
            (includes(first2, first2 + n, second, second + 3) ? "" : "not")
            &lt;&lt; " contained in the first2 sequence\n";

        cout &lt;&lt; "Using case-insensitive comparison,\n"
            "the elements of `second' are "
            &lt;&lt;
            (includes(first2, first2 + n, second, second + 3, CaseString{}) ?
                "" : "not")
            &lt;&lt; " contained in the first2 sequence\n";
    }
    /*
        Displays:
            The elements of `second' are  contained in the first sequence:
            second is a subset of first1
            The elements of `first1' are not contained in the second sequence
            The elements of `second' are not contained in the first2 sequence
            Using case-insensitive comparison,
            the elements of `second' are  contained in the first2 sequence
    */
</pre>
    </ul>
<p>
<a name="INNERPROD"></a><a name="l405"></a>
<h3 >19.1.22: inner_product</h3>
        <a name="an2301"></a>
    <ul>
        <li> Header file: <code >&lt;numeric&gt;</code>
        <li> Function prototypes:
        <ul>
            <li><code >Type inner_product(InputIterator1 first1,
                InputIterator1 last1, InputIterator2 first2, Type init);</code>
            <li><code >Type inner_product(InputIterator1 first1,
                InputIterator1 last1, InputIterator2 first2, Type init,
                BinaryOperator1 op1, BinaryOperator2 op2);</code>
        </ul>
        <li> Description:
        <ul>
            <li> The first prototype: the sum of all pairwise products of the
elements implied by the range <code >[first1, last1)</code> and the same number of
elements starting at the element pointed to by <code >first2</code> are added to
<code >init</code>, and this sum is returned. The function uses the <code >operator+</code> and
<code >operator*</code> of the data type to which the iterators point.
            <li> The second prototype: binary operator <code >op1</code> instead of the
default addition operator, and binary operator <code >op2</code> instead of the default
multiplication operator are applied to all pairwise elements implied by the
range <code >[first1, last1)</code> and the same number of elements starting at the
element pointed to by <code >first2</code>. The results of the binary operator calls are
added to <code >init</code> and <code >init</code>'s  final value is returned.
        </ul>
        <li> Example:
        <pre>
    #include &lt;numeric&gt;
    #include &lt;algorithm&gt;
    #include &lt;iterator&gt;
    #include &lt;iostream&gt;
    #include &lt;string&gt;
    using namespace std;

    class Cat
    {
        std::string  d_sep;
        public:
            Cat(string const &amp;sep)
            :
                d_sep(sep)
            {}
            string operator()
                (string const &amp;s1, string const &amp;s2) const
            {
                return s1 + d_sep + s2;
            }
    };
    int main()
    {
        size_t ia1[] = {1, 2, 3, 4, 5, 6, 7};
        size_t ia2[] = {7, 6, 5, 4, 3, 2, 1};
        size_t init = 0;

        cout &lt;&lt; "The sum of all squares in ";
        copy(ia1, ia1 + 7, ostream_iterator&lt;size_t&gt;{ cout, " " });
        cout &lt;&lt; "is " &lt;&lt;
            inner_product(ia1, ia1 + 7, ia1, init) &lt;&lt; '\n';

        cout &lt;&lt; "The sum of all cross-products in ";
        copy(ia1, ia1 + 7, ostream_iterator&lt;size_t&gt;{ cout, " " });
        cout &lt;&lt; "and ";
        copy(ia2, ia2 + 7, ostream_iterator&lt;size_t&gt;{ cout, " " });
        cout &lt;&lt; "is " &lt;&lt;
            inner_product(ia1, ia1 + 7, ia2, init) &lt;&lt; '\n';

        string names1[] = {"Frank", "Karel", "Piet"};
        string names2[] = {"Brokken", "Kubat", "Plomp"};

        cout &lt;&lt; "A list of all combined names in ";
        copy(names1, names1 + 3, ostream_iterator&lt;string&gt;{ cout, " " });
        cout &lt;&lt; "and\n";
        copy(names2, names2 + 3, ostream_iterator&lt;string&gt;{ cout, " " });
        cout &lt;&lt; "is:" &lt;&lt;
            inner_product(names1, names1 + 3, names2, string{ "\t" },
                Cat{ "\n\t"}, Cat{ " " }) &lt;&lt;
            '\n';
    }
    /*
      Displays:
        The sum of all squares in 1 2 3 4 5 6 7 is 140
        The sum of all cross-products in 1 2 3 4 5 6 7 and 7 6 5 4 3 2 1 is 84
        A list of all combined names in Frank Karel Piet and
        Brokken Kubat Plomp is:
                Frank Brokken
                Karel Kubat
                Piet Plomp
    */
</pre>
    </ul>
<p>
<a name="INMERGE"></a><a name="l406"></a>
<h3 >19.1.23: inplace_merge</h3>
        <a name="an2302"></a>
    <ul>
        <li> Header file: <code >&lt;algorithm&gt;</code>
        <li> Function prototypes:
        <ul>
            <li><code >void inplace_merge(BidirectionalIterator first,
                BidirectionalIterator middle, BidirectionalIterator last);</code>
            <li><code >void inplace_merge(BidirectionalIterator first,
                BidirectionalIterator middle, BidirectionalIterator last,
                Compare comp);</code>
        </ul>
        <li> Description:
        <ul>
            <li> The first prototype: the two (sorted) ranges <code >[first,
middle)</code> and <code >[middle, last)</code> are merged, keeping a sorted list (using the
<code >operator&lt;</code> of the data type to which the iterators point). The final
series is stored in the range <code >[first, last)</code>.
            <li> The second prototype: the two (sorted) ranges <code >[first,
middle)</code> and <code >[middle, last)</code> are merged, keeping a sorted list (using the
boolean result of the binary comparison operator <code >comp</code>). The final series
is stored in the range <code >[first, last)</code>.
        </ul>
        <li> Example:
        <pre>
    #include &lt;algorithm&gt;
    #include &lt;string&gt;
    #include &lt;cstring&gt;
    #include &lt;iterator&gt;
    #include &lt;iostream&gt;
    using namespace std;

    class CaseString
    {
        public:
            bool operator()(string const &amp;first, string const &amp;second) const
            {
                return strcasecmp(first.c_str(), second.c_str()) &lt; 0;
            }
    };
    int main()
    {
        string range[] =
            {
                "alpha", "charley", "echo", "golf",
                "bravo", "delta", "foxtrot",
            };

        inplace_merge(range, range + 4, range + 7);
        copy(range, range + 7, ostream_iterator&lt;string&gt;{ cout, " " });
        cout &lt;&lt; '\n';

        string range2[] =
            {
                "ALPHA", "CHARLEY", "DELTA", "foxtrot", "hotel",
                "bravo", "ECHO", "GOLF"
            };

        inplace_merge(range2, range2 + 5, range2 + 8, CaseString{});
        copy(range2, range2 + 8, ostream_iterator&lt;string&gt;{ cout, " " });
        cout &lt;&lt; '\n';
    }
    /*
        Displays:
            alpha bravo charley delta echo foxtrot golf
            ALPHA bravo CHARLEY DELTA ECHO foxtrot GOLF hotel
    */
</pre>
    </ul>
<p>
<a name="ITERSWAP"></a><a name="l407"></a>
<h3 >19.1.24: iter_swap</h3>
        <a name="an2303"></a>
    <ul>
        <li> Header file: <code >&lt;algorithm&gt;</code>
        <li> Function prototype:
        <ul>
            <li><code >void iter_swap(ForwardIterator1 iter1,
                ForwardIterator2 iter2);</code>
        </ul>
        <li> Description:
        <ul>
            <li> The elements pointed to by <code >iter1</code> and <code >iter2</code> are
                swapped.
        </ul>
        <li> Example:
        <pre>
    #include &lt;algorithm&gt;
    #include &lt;iterator&gt;
    #include &lt;iostream&gt;
    #include &lt;string&gt;
    using namespace std;

    int main()
    {
        string first[] = {"alpha", "bravo", "charley"};
        string second[] = {"echo", "foxtrot", "golf"};
        size_t const n = sizeof(first) / sizeof(string);

        cout &lt;&lt; "Before:\n";
        copy(first, first + n, ostream_iterator&lt;string&gt;(cout, " "));
        cout &lt;&lt; '\n';
        copy(second, second + n, ostream_iterator&lt;string&gt;(cout, " "));
        cout &lt;&lt; '\n';

        for (size_t idx = 0; idx &lt; n; ++idx)
            iter_swap(first + idx, second + idx);

        cout &lt;&lt; "After:\n";
        copy(first, first + n, ostream_iterator&lt;string&gt;(cout, " "));
        cout &lt;&lt; '\n';
        copy(second, second + n, ostream_iterator&lt;string&gt;(cout, " "));
        cout &lt;&lt; '\n';
    }
    /*
        Displays:
            Before:
            alpha bravo charley
            echo foxtrot golf
            After:
            echo foxtrot golf
            alpha bravo charley
    */
</pre>
    </ul>
<p>
<a name="LEXCOMP"></a><a name="l408"></a>
<h3 >19.1.25: lexicographical_compare</h3>
        <a name="an2304"></a>
    <ul>
        <li> Header file: <code >&lt;algorithm&gt;</code>
        <li> Function prototypes:
        <ul>
            <li><code >bool lexicographical_compare(InputIterator1 first1,
InputIterator1 last1, InputIterator2 first2, InputIterator2 last2);</code>
            <li><code >bool lexicographical_compare(InputIterator1 first1,
InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, Compare
comp);</code>
        </ul>
        <li> Description:
        <ul>
            <li> The first prototype: the corresponding pairs of elements in
the ranges pointed to by the ranges <code >[first1, last1)</code> and <code >[first2,
last2)</code> are compared. The function returns <a name="an2305"></a><code >true</code>
            <ul>
                <li> at the first element in the first range which is less
than the corresponding element in the second range (using <code >operator&lt;</code>
of the underlying data type),
                <li> if <code >last1</code> is reached, but <code >last2</code> isn't reached yet.
            </ul>
False is returned in the other cases, which indicates that the first sequence
is not lexicographically less than the second sequence. So, <a name="an2306"></a><code >false</code> is
returned:
            <ul>
                <li> at the first element in the first range which is greater
than the corresponding element in the second range (using <code >operator&lt;</code>
of the data type to which the iterators point, reversing the  operands),
                <li> if <code >last2</code> is reached, but <code >last1</code> isn't reached yet,
                <li> if <code >last1</code> and <code >last2</code> are reached.
            </ul>
            <li> The second prototype: with this function the binary
comparison operation as defined by <code >comp</code> is used instead of
<code >operator&lt;</code> of the data type to which the iterators point.
        </ul>
        <li> Example:
        <pre>
    #include &lt;algorithm&gt;
    #include &lt;iterator&gt;
    #include &lt;iostream&gt;
    #include &lt;string&gt;
    #include &lt;cstring&gt;
    using namespace std;

    class CaseString
    {
        public:
            bool operator()(string const &amp;first,
                            string const &amp;second) const
            {
                return strcasecmp(first.c_str(), second.c_str()) &lt; 0;
            }
    };
    int main()
    {
        string word1 = "hello";
        string word2 = "help";

        cout &lt;&lt; word1 &lt;&lt; " is " &lt;&lt;
            (
                lexicographical_compare(word1.begin(), word1.end(),
                                        word2.begin(), word2.end()) ?
                    "before "
                :
                    "beyond or at "
            ) &lt;&lt;
            word2 &lt;&lt; " in the alphabet\n";

        cout &lt;&lt; word1 &lt;&lt; " is " &lt;&lt;
            (
                lexicographical_compare(word1.begin(), word1.end(),
                                        word1.begin(), word1.end()) ?
                    "before "
                :
                    "beyond or at "
            ) &lt;&lt;
            word1 &lt;&lt; " in the alphabet\n";

        cout &lt;&lt; word2 &lt;&lt; " is " &lt;&lt;
            (
                lexicographical_compare(word2.begin(), word2.end(),
                                        word1.begin(), word1.end()) ?
                    "before "
                :
                    "beyond or at "
            ) &lt;&lt;
            word1 &lt;&lt; " in the alphabet\n";

        string one[] = {"alpha", "bravo", "charley"};
        string two[] = {"ALPHA", "BRAVO", "DELTA"};

        copy(one, one + 3, ostream_iterator&lt;string&gt;{ cout, " " });
        cout &lt;&lt; " is ordered " &lt;&lt;
            (
                lexicographical_compare(one, one + 3,
                                        two, two + 3, CaseString{}) ?
                    "before "
                :
                    "beyond or at "
            );
        copy(two, two + 3, ostream_iterator&lt;string&gt;{ cout, " " });
        cout &lt;&lt; "\n"
            "using case-insensitive comparisons.\n";
    }
    /*
        Displays:
            hello is before help in the alphabet
            hello is beyond or at hello in the alphabet
            help is beyond or at hello in the alphabet
            alpha bravo charley  is ordered before ALPHA BRAVO DELTA
            using case-insensitive comparisons.
    */
</pre>
    </ul>
<p>
<a name="LOWERBOUND"></a><a name="l409"></a>
<h3 >19.1.26: lower_bound</h3>
        <a name="an2307"></a>
    <ul>
        <li> Header file: <code >&lt;algorithm&gt;</code>
        <li> Function prototypes:
        <ul>
            <li><code >ForwardIterator lower_bound(ForwardIterator first,
ForwardIterator last, const Type &amp;value);</code>
            <li><code >ForwardIterator lower_bound(ForwardIterator first,
ForwardIterator last, const Type &amp;value, Compare comp);</code>
        </ul>
        <li> Description:
        <ul>
            <li> The first prototype: the sorted elements indicated by the
iterator range <code >[first, last)</code> are searched for the first element that is
not less than (i.e., greater than or equal to) <code >value</code>. The returned
iterator marks the location in the sequence where <code >value</code> can be inserted
without breaking the sorted order of the elements. The <code >operator&lt;</code> of the
data type to which the iterators point is used. If no such element is found,
<code >last</code> is returned.
            <li> The second prototype: the elements indicated by the iterator
range <code >[first, last)</code> must have been sorted using the <code >comp</code> function
(-object). Each element in the range is compared to <code >value</code> using the
<code >comp</code> function. An iterator to the first element for which the binary
predicate <code >comp</code>, applied to the elements of the range and <code >value</code>,
returns <code >false</code> is returned.  If no such element is found, <code >last</code> is
returned.
        </ul>
        <li> Example:
        <pre>
    #include &lt;algorithm&gt;
    #include &lt;iostream&gt;
    #include &lt;iterator&gt;
    #include &lt;functional&gt;
    using namespace std;

    int main()
    {
        int     ia[] = {10, 20, 30};

        cout &lt;&lt; "Sequence: ";
        copy(ia, ia + 3, ostream_iterator&lt;int&gt;(cout, " "));
        cout &lt;&lt; '\n';

        cout &lt;&lt; "15 can be inserted before " &lt;&lt;
                *lower_bound(ia, ia + 3, 15) &lt;&lt; '\n';
        cout &lt;&lt; "35 can be inserted after " &lt;&lt;
                (lower_bound(ia, ia + 3, 35) == ia + 3 ?
                                    "the last element" : "???") &lt;&lt; '\n';

        iter_swap(ia, ia + 2);

        cout &lt;&lt; "Sequence: ";
        copy(ia, ia + 3, ostream_iterator&lt;int&gt;(cout, " "));
        cout &lt;&lt; '\n';

        cout &lt;&lt; "15 can be inserted before " &lt;&lt;
                *lower_bound(ia, ia + 3, 15, greater&lt;int&gt;()) &lt;&lt; '\n';
        cout &lt;&lt; "35 can be inserted before " &lt;&lt;
                (lower_bound(ia, ia + 3, 35, greater&lt;int&gt;()) == ia ?
                                    "the first element " : "???") &lt;&lt; '\n';
    }
    /*
        Displays:
            Sequence: 10 20 30
            15 can be inserted before 20
            35 can be inserted after the last element
            Sequence: 30 20 10
            15 can be inserted before 10
            35 can be inserted before the first element
    */
</pre>
    </ul>
<p>
<a name="MAX"></a><a name="l410"></a>
<h3 >19.1.27: max</h3>
        <a name="an2308"></a>
    <ul>
        <li> Header file: <code >&lt;algorithm&gt;</code>
        <li> Function prototypes:
        <ul>
            <li><code >Type const &amp;max(Type const &amp;one, Type const &amp;two);</code>
            <li><code >Type const &amp;max(Type const &amp;one, Type const &amp;two, Comparator
                comp);</code>
        </ul>
        <li> Description:
        <ul>
            <li> The first prototype: the larger of the two elements <code >one</code>
and <code >two</code> is returned, using the <code >operator&gt;</code> of the data type to which
the iterators point to determine which element is the larger one.
            <li> The second prototype: <code >one</code> is returned if the binary
predicate <code >comp(one, two)</code> returns <code >true</code>, otherwise <code >two</code> is returned.
        </ul>
        <li> Example:
        <pre>
    #include &lt;algorithm&gt;
    #include &lt;iostream&gt;
    #include &lt;string&gt;
    #include &lt;cstring&gt;
    using namespace std;

    class CaseString
    {
        public:
            bool operator()(string const &amp;first, string const &amp;second) const
            {
                return strcasecmp(second.c_str(), first.c_str()) &gt; 0;
            }
    };
    int main()
    {
        cout &lt;&lt; "Word '" &lt;&lt; max(string("first"), string("second")) &lt;&lt;
                                    "' is lexicographically last\n";

        cout &lt;&lt; "Word '" &lt;&lt; max(string("first"), string("SECOND")) &lt;&lt;
                                    "' is lexicographically last\n";

        cout &lt;&lt; "Word '" &lt;&lt; max(string("first"), string("SECOND"),
                            CaseString{}) &lt;&lt; "' is lexicographically last\n";
    }
    /*
        Displays:
            Word 'second' is lexicographically last
            Word 'first' is lexicographically last
            Word 'SECOND' is lexicographically last
    */
</pre>
    </ul>
<p>
<a name="MAXEL"></a><a name="l411"></a>
<h3 >19.1.28: max_element</h3>
        <a name="an2309"></a>
    <ul>
        <li> Header file: <code >&lt;algorithm&gt;</code>
        <li> Function prototypes:
        <ul>
            <li><code >ForwardIterator max_element(ForwardIterator first,
ForwardIterator last);</code>
            <li><code >ForwardIterator max_element(ForwardIterator first,
ForwardIterator last, Comparator comp);</code>
        </ul>
        <li> Description:
        <ul>
            <li> The first prototype: an iterator pointing to the largest
element in the range implied by <code >[first, last)</code> is returned. The
<a name="an2310"></a><code >operator&lt;</code> of the data type to which the iterators point is used to decide
which of the elements is the largest.
            <li> The second prototype: rather than using <code >operator&lt;</code>, the
binary predicate <code >comp</code> is used to make the comparisons between the elements
implied by the iterator range <code >[first, last)</code>. The element for which
<code >comp</code> returns most often <code >true</code>, compared with other elements, is
returned.
        </ul>
        <li> Example:
        <pre>
    #include &lt;algorithm&gt;
    #include &lt;iostream&gt;
    using namespace std;

    class AbsValue
    {
        public:
            bool operator()(int first, int second) const
            {
                return abs(first) &lt; abs(second);
            }
    };
    int main()
    {
        int     ia[] = {-4, 7, -2, 10, -12};

        cout &lt;&lt; "The max. int value is " &lt;&lt; *max_element(ia, ia + 5) &lt;&lt; '\n';
        cout &lt;&lt; "The max. absolute int value is " &lt;&lt;
                *max_element(ia, ia + 5, AbsValue{}) &lt;&lt; '\n';
    }
    /*
        Displays:
            The max. int value is 10
            The max. absolute int value is -12
    */
</pre>
    </ul>
<p>
<a name="MERGE"></a><a name="l412"></a>
<h3 >19.1.29: merge</h3>
        <a name="an2311"></a>
    <ul>
        <li> Header file: <code >&lt;algorithm&gt;</code>
        <li> Function prototypes:
        <ul>
            <li><code >OutputIterator merge(InputIterator1 first1, InputIterator1
last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result);</code>
            <li><code >OutputIterator merge(InputIterator1 first1, InputIterator1
last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result,
Compare comp);</code>
        </ul>
        <li> Description:
        <ul>
            <li> The first prototype: the two (sorted) ranges <code >[first1,
last1)</code> and <code >[first2, last2)</code> are merged, keeping a sorted list (using the
<a name="an2312"></a><code >operator&lt;</code> of the data type to which the iterators point). The final
series is stored in the range starting at <code >result</code> and ending just before
the <code >OutputIterator</code> returned by the function.
            <li> The second prototype: the two (sorted) ranges <code >[first1,
last1)</code> and <code >[first2, last2)</code> are merged, keeping a sorted list (using the
boolean result of the binary comparison operator <code >comp</code>). The final series
is stored in the range starting at <code >result</code> and ending just before the
<code >OutputIterator</code> returned by the function.
        </ul>
        <li> Example:
        <pre>
    #include &lt;algorithm&gt;
    #include &lt;string&gt;
    #include &lt;cstring&gt;
    #include &lt;iterator&gt;
    #include &lt;iostream&gt;
    using namespace std;

    class CaseString
    {
        public:
            bool operator()(string const &amp;first, string const &amp;second) const
            {
                return strcasecmp(first.c_str(), second.c_str()) &lt; 0;
            }
    };
    int main()
    {
        string range1[] =
            {                                       // 5 elements
                "alpha", "bravo", "foxtrot", "hotel", "zulu"
            };
        string range2[] =
            {                                       // 4 elements
                "delta", "echo", "golf", "romeo"
            };
        string result[5 + 4];

        copy(result,
            merge(range1, range1 + 5, range2, range2 + 4, result),
            ostream_iterator&lt;string&gt;{ cout, " " });
        cout &lt;&lt; '\n';

        string range3[] =
            {
                "ALPHA", "bravo", "foxtrot", "HOTEL", "ZULU"
            };
        string range4[] =
            {
                "delta", "ECHO", "GOLF", "romeo"
            };

        copy(result,
            merge(range3, range3 + 5, range4, range4 + 4, result,
                                                            CaseString{}),
            ostream_iterator&lt;string&gt;{ cout, " " });
        cout &lt;&lt; '\n';
    }
    /*
        Displays:
            alpha bravo delta echo foxtrot golf hotel romeo zulu
            ALPHA bravo delta ECHO foxtrot GOLF HOTEL romeo ZULU
    */
</pre>
    </ul>
<p>
<a name="MIN"></a><a name="l413"></a>
<h3 >19.1.30: min</h3>
        <a name="an2313"></a>
    <ul>
        <li> Header file: <code >&lt;algorithm&gt;</code>
        <li> Function prototypes:
        <ul>
            <li><code >Type const &amp;min(Type const &amp;one, Type const &amp;two);</code>
            <li><code >Type const &amp;min(Type const &amp;one, Type const &amp;two, Comparator
                comp);</code>
        </ul>
        <li> Description:
        <ul>
            <li> The first prototype: the smaller of the two elements <code >one</code>
and <code >two</code> is returned using the <code >operator&lt;</code> of the data type to which
the iterators point to decide which of the two elements is the smaller.
            <li> The second prototype: <code >one</code> is returned if the binary
predicate <code >comp(one, two)</code> returns <code >false</code>, otherwise <code >two</code> is returned.
        </ul>
        <li> Example:
        <pre>
    #include &lt;algorithm&gt;
    #include &lt;iostream&gt;
    #include &lt;string&gt;
    #include &lt;cstring&gt;
    using namespace std;

    class CaseString
    {
        public:
            bool operator()(string const &amp;first, string const &amp;second) const
            {
                return strcasecmp(second.c_str(), first.c_str()) &gt; 0;
            }
    };
    int main()
    {
        cout &lt;&lt; "Word '" &lt;&lt; min(string{ "first" }, string{ "second" }) &lt;&lt;
                                    "' is lexicographically first\n";

        cout &lt;&lt; "Word '" &lt;&lt; min(string{ "first" }, string{ "SECOND" }) &lt;&lt;
                                    "' is lexicographically first\n";

        cout &lt;&lt; "Word '" &lt;&lt; min(string{ "first" }, string{ "SECOND" },
                            CaseString{}) &lt;&lt; "' is lexicographically first\n";
    }
    /*
        Displays:
            Word 'first' is lexicographically first
            Word 'SECOND' is lexicographically first
            Word 'first' is lexicographically first
    */
</pre>
    </ul>
<p>
<a name="MINEL"></a><a name="l414"></a>
<h3 >19.1.31: min_element</h3>
        <a name="an2314"></a>
    <ul>
        <li> Header file: <code >&lt;algorithm&gt;</code>
        <li> Function prototypes:
        <ul>
            <li><code >ForwardIterator min_element(ForwardIterator first,
                ForwardIterator last);</code>
            <li><code >ForwardIterator min_element(ForwardIterator first,
                ForwardIterator last, Comparator comp);</code>
        </ul>
        <li> Description:
        <ul>
            <li> The first prototype: an iterator pointing to the smallest
element in the range implied by the range <code >[first, last)</code> is returned
using <code >operator&lt;</code> of the data type to which the iterators point to decide
which of the elements is the smallest.
            <li> The second prototype: rather than using <code >operator&lt;</code>, the
binary predicate <code >comp</code> is used to make the comparisons between the elements
implied by the iterator range <code >[first, last)</code>. The element for which
<code >comp</code> returns <code >false</code> most often is returned.
        </ul>
        <li> Example:
        <pre>
    #include &lt;algorithm&gt;
    #include &lt;iostream&gt;
    using namespace std;

    class AbsValue
    {
        public:
            bool operator()(int first, int second) const
            {
                return abs(first) &lt; abs(second);
            }
    };
    int main()
    {
        int     ia[] = {-4, 7, -2, 10, -12};

        cout &lt;&lt; "The minimum int value is " &lt;&lt; *min_element(ia, ia + 5) &lt;&lt;
                '\n';
        cout &lt;&lt; "The minimum absolute int value is " &lt;&lt;
                *min_element(ia, ia + 5, AbsValue{}) &lt;&lt; '\n';
    }
    /*
        Displays:
            The minimum int value is -12
            The minimum absolute int value is -2
    */
</pre>
    </ul>
<p>
<a name="MISMATCH"></a><a name="l415"></a>
<h3 >19.1.32: mismatch</h3>
        <ul>
        <li> Header file: <code >&lt;algorithm&gt;</code>
        <li> Function prototypes:
        <ul>
            <li><code >pair&lt;InputIterator1, InputIterator2&gt;
                mismatch(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2);</code>
            <li><code >pair&lt;InputIterator1, InputIterator2&gt;
                mismatch(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, Compare comp);</code>
        </ul>
        <li> Description:
        <ul>
            <li> The first prototype: the two sequences of elements starting
at <code >first1</code> and <code >first2</code> are compared using the equality operator of the
data type to which the iterators point. Comparison stops if the compared
elements differ (i.e., <code >operator==</code> returns false) or <code >last1</code> is
reached. A <code >pair</code> containing iterators pointing to the final positions is
returned. The second sequence may contain more elements than the first
sequence. The behavior of the algorithm is undefined if the second sequence
contains fewer elements than the first sequence.
            <li> The second prototype: the two sequences of elements starting
at <code >first1</code> and <code >first2</code> are compared using the binary comparison
operation as defined by <code >comp</code>, instead of
<code >operator==</code>. Comparison stops if the <code >comp</code> function returns <code >false</code>
or <code >last1</code> is reached. A <code >pair</code> containing iterators pointing to the final
positions is returned. The second sequence may contain more elements than the
first sequence. The behavior of the algorithm is undefined if the second
sequence contains fewer elements than the first sequence.
        </ul>
        <li> Example:
        <pre>
    #include &lt;algorithm&gt;
    #include &lt;string&gt;
    #include &lt;cstring&gt;
    #include &lt;iostream&gt;
    #include &lt;utility&gt;
    using namespace std;

    class CaseString
    {
        public:
            bool operator()(string const &amp;first, string const &amp;second) const
            {
                return strcasecmp(first.c_str(), second.c_str()) == 0;
            }
    };
    int main()
    {
        string range1[] =
            {
                "alpha", "bravo", "foxtrot", "hotel", "zulu"
            };
        string range2[] =
            {
                "alpha", "bravo", "foxtrot", "Hotel", "zulu"
            };
        pair&lt;string *, string *&gt; pss = mismatch(range1, range1 + 5, range2);

        cout &lt;&lt; "The elements " &lt;&lt; *pss.first &lt;&lt; " and " &lt;&lt; *pss.second &lt;&lt;
                " at offset " &lt;&lt; (pss.first - range1) &lt;&lt; " differ\n";
        if
        (
            mismatch(range1, range1 + 5, range2, CaseString{}).first
            ==
            range1 + 5
        )
            cout &lt;&lt; "When compared case-insensitively they match\n";
    }
    /*
        Displays:
            The elements hotel and Hotel at offset 3 differ
            When compared case-insensitively they match
    */
</pre>
    </ul>
<p>
<a name="NEXTPERM"></a><a name="l416"></a>
<h3 >19.1.33: next_permutation</h3>
        <a name="an2315"></a>
    <ul>
        <li> Header file: <code >&lt;algorithm&gt;</code>
        <li> Function prototypes:
        <ul>
            <li><code >bool next_permutation(BidirectionalIterator first,
                BidirectionalIterator last);</code>
            <li><code >bool next_permutation(BidirectionalIterator first,
                BidirectionalIterator last, Comp comp);</code>
        </ul>
        <li> Description:
        <ul>
            <li> The first prototype: the next permutation, given the sequence
of elements in the range <code >[first, last)</code>, is determined. For example, if
the elements <code >1, 2</code> and <code >3</code> are the range for which <code >next_permutation</code>
is called, then subsequent calls of <code >next_permutation</code> reorders the
following series:
        <pre>
        1 2 3
        1 3 2
        2 1 3
        2 3 1
        3 1 2
        3 2 1
</pre>
    This example shows that the elements are reordered such that each new
permutation represents the next bigger value (132 is bigger than 123, 213 is
bigger than 132, etc.) using <a name="an2316"></a><code >operator&lt;</code> of the data type to which the
iterators point.  The value <a name="an2317"></a><code >true</code> is returned if a reordering took place,
the value <a name="an2318"></a><code >false</code> is returned if no reordering took place, which is the case
if the sequence represents the last (biggest) value. In that case, the
sequence is also sorted using <code >operator&lt;</code>.
        <li> The second prototype: the next permutation given the sequence of
elements in the range <code >[first, last)</code> is determined, using the binary
predicate <code >comp</code> to compare elements. The elements in the range are
reordered. The value <code >true</code> is returned if a reordering took place, the
value <code >false</code> is returned if no reordering took place, which is the case if
the resulting sequence would haven been ordered using the binary predicate
<code >comp</code> to compare elements.
        </ul>
    <li> Example:
        <pre>
    #include &lt;algorithm&gt;
    #include &lt;iterator&gt;
    #include &lt;iostream&gt;
    #include &lt;string&gt;
    #include &lt;cstring&gt;
    using namespace std;

    class CaseString
    {
        public:
            bool operator()(string const &amp;first, string const &amp;second) const
            {
                return strcasecmp(first.c_str(), second.c_str()) &lt; 0;
            }
    };
    int main()
    {
        string saints[] = {"Oh", "when", "the", "saints"};

        cout &lt;&lt; "All permutations of 'Oh when the saints':\n";
        cout &lt;&lt; "Sequences:\n";
        do
        {
            copy(saints, saints + 4, ostream_iterator&lt;string&gt;{ cout, " " });
            cout &lt;&lt; '\n';
        }
        while (next_permutation(saints, saints + 4, CaseString{}));

        cout &lt;&lt; "After first sorting the sequence:\n";
        sort(saints, saints + 4, CaseString{});
        cout &lt;&lt; "Sequences:\n";
        do
        {
            copy(saints, saints + 4, ostream_iterator&lt;string&gt;{ cout, " " });
            cout &lt;&lt; '\n';
        }
        while (next_permutation(saints, saints + 4, CaseString{}));
    }
    /*
        Displays (partially):
            All permutations of 'Oh when the saints':
            Sequences:
            Oh when the saints
            saints Oh the when
            saints Oh when the
            saints the Oh when
            ...
            After first sorting the sequence:
            Sequences:
            Oh saints the when
            Oh saints when the
            Oh the saints when
            Oh the when saints
            ...
    */
</pre>
    </ul>
<p>
<a name="NTHEL"></a><a name="l417"></a>
<h3 >19.1.34: nth_element</h3>
        <a name="an2319"></a>
    <ul>
        <li> Header file: <code >&lt;algorithm&gt;</code>
        <li> Function prototypes:
        <ul>
            <li><code >void nth_element(RandomAccessIterator first,
                RandomAccessIterator nth, RandomAccessIterator last);</code>
            <li><code >void nth_element(RandomAccessIterator first,
                RandomAccessIterator nth, RandomAccessIterator last, Compare
                comp);</code>
        </ul>
        <li> Description:
        <ul>
            <li> The first prototype: all elements in the range <code >[first,
last)</code> are sorted relative to the element pointed to by <code >nth</code>: all elements
in the range <code >[left, nth)</code> are smaller than the element pointed to by
<code >nth</code>, and alle elements in the range <code >[nth + 1, last)</code> are greater
than the element pointed to by <code >nth</code>. The two subsets themselves are not
sorted. The <code >operator&lt;</code> of the data type to which the iterators point is
used to compare the elements.
            <li> The second prototype: all elements in the range <code >[first,
last)</code> are sorted relative to the element pointed to by <code >nth</code>: all elements
in the range <code >[left, nth)</code> are smaller than the element pointed to by
<code >nth</code>, and alle elements in the range <code >[nth + 1, last)</code> are greater
than the element pointed to by <code >nth</code>. The two subsets themselves are not
sorted. The <code >comp</code> function object is used to compare the elements.
        </ul>
        <li> Example:
        <pre>
    #include &lt;algorithm&gt;
    #include &lt;iostream&gt;
    #include &lt;iterator&gt;
    #include &lt;functional&gt;
    using namespace std;

    int main()
    {
        int ia[] = {1, 3, 5, 7, 9, 2, 4, 6, 8, 10};

        nth_element(ia, ia + 3, ia + 10);

        cout &lt;&lt; "sorting with respect to " &lt;&lt; ia[3] &lt;&lt; '\n';
        copy(ia, ia + 10, ostream_iterator&lt;int&gt;(cout, " "));
        cout &lt;&lt; '\n';

        nth_element(ia, ia + 5, ia + 10, greater&lt;int&gt;());

        cout &lt;&lt; "sorting with respect to " &lt;&lt; ia[5] &lt;&lt; '\n';
        copy(ia, ia + 10, ostream_iterator&lt;int&gt;(cout, " "));
        cout &lt;&lt; '\n';
    }
    /*
        Displays:
            sorting with respect to 4
            1 2 3 4 9 7 5 6 8 10
            sorting with respect to 5
            10 8 7 9 6 5 3 4 2 1
    */
</pre>
    </ul>
<p>
<a name="PARTSORT"></a><a name="l418"></a>
<h3 >19.1.35: partial_sort</h3>
        <a name="an2320"></a>
    <ul>
        <li> Header file: <code >&lt;algorithm&gt;</code>
        <li> Function prototypes:
        <ul>
            <li><code >void partial_sort(RandomAccessIterator first,
RandomAccessIterator middle, RandomAccessIterator last);</code>
            <li><code >void partial_sort(RandomAccessIterator first,
RandomAccessIterator middle, RandomAccessIterator last, Compare comp);</code>
        </ul>
        <li> Description:
            <ul>
            <li> The first prototype: the
(<code >middle - first</code>) smallest elements
are sorted and stored in the range <code >[first, middle)</code> using the
<a name="an2321"></a><code >operator&lt;</code> of the data type to which the iterators point to compare
elements. The remaining elements of the series remain unsorted, and are stored
in the range <code >[middle, last)</code>.
            <li> The second prototype: the (<code >middle - first</code>) smallest
elements (according to the provided binary predicate <code >comp</code>) are sorted and
stored in the range <code >[first, middle)</code>. The remaining elements of the
series remain unsorted.
            </ul>
        <li> Example:
        <pre>
    #include &lt;algorithm&gt;
    #include &lt;iostream&gt;
    #include &lt;functional&gt;
    #include &lt;iterator&gt;
    using namespace std;

    int main()
    {
        int ia[] = {1, 3, 5, 7, 9, 2, 4, 6, 8, 10};

        partial_sort(ia, ia + 3, ia + 10);

        cout &lt;&lt; "find the 3 smallest elements:\n";
        copy(ia, ia + 10, ostream_iterator&lt;int&gt;(cout, " "));
        cout &lt;&lt; '\n';

        cout &lt;&lt; "find the 5 biggest elements:\n";
        partial_sort(ia, ia + 5, ia + 10, greater&lt;int&gt;());
        copy(ia, ia + 10, ostream_iterator&lt;int&gt;(cout, " "));
        cout &lt;&lt; '\n';
    }
    /*
        Displays:
            find the 3 smallest elements:
            1 2 3 7 9 5 4 6 8 10
            find the 5 biggest elements:
            10 9 8 7 6 1 2 3 4 5
    */
</pre>
    </ul>
<p>
<a name="PARTSORTCP"></a><a name="l419"></a>
<h3 >19.1.36: partial_sort_copy</h3>
        <a name="an2322"></a>
    <ul>
        <li> Header file: <code >&lt;algorithm&gt;</code>
        <li> Function prototypes:
        <ul>
            <li><code >void partial_sort_copy(InputIterator first, InputIterator
last, RandomAccessIterator dest_first, RandomAccessIterator dest_last);</code>
            <li><code >void partial_sort_copy(InputIterator first, InputIterator
last, RandomAccessIterator dest_first, RandomAccessIterator dest_last, Compare
comp);</code>
        </ul>
        <li> Description:
        <ul>
            <li> The first prototype: the (<code >dest_last - dest_first</code>)
smallest elements in the range
<code >[first, last)</code> are copied to the range <code >[dest_first, dest_last)</code>,
using the <a name="an2323"></a><code >operator&lt;</code> of the data type to which the iterators point to
decide which of the elements to copy.
            <li> The second prototype: the (<code >dest_last - dest_first</code>)
smallest elements in the range <code >[first, last)</code> (as decided by the binary
predicate <code >comp</code> returning <code >true</code>). The elements for which the predicate
<code >comp</code> returns <code >true</code> most often are copied to the range
<code >[dest_first, dest_last)</code>.
        </ul>
        <li> Example:
        <pre>
    #include &lt;algorithm&gt;
    #include &lt;iostream&gt;
    #include &lt;functional&gt;
    #include &lt;iterator&gt;
    using namespace std;

    int main()
    {
        int ia[] = {1, 10, 3, 8, 5, 6, 7, 4, 9, 2};
        int ia2[6];

        partial_sort_copy(ia, ia + 10, ia2, ia2 + 6);

        copy(ia, ia + 10, ostream_iterator&lt;int&gt;(cout, " "));
        cout &lt;&lt; '\n';
        cout &lt;&lt; "the 6 smallest elements: ";
        copy(ia2, ia2 + 6, ostream_iterator&lt;int&gt;(cout, " "));
        cout &lt;&lt; '\n';

        cout &lt;&lt; "the 4 smallest elements to a larger range:\n";
        partial_sort_copy(ia, ia + 4, ia2, ia2 + 6);
        copy(ia2, ia2 + 6, ostream_iterator&lt;int&gt;(cout, " "));
        cout &lt;&lt; '\n';

        cout &lt;&lt; "the 4 biggest elements to a larger range:\n";
        partial_sort_copy(ia, ia + 4, ia2, ia2 + 6, greater&lt;int&gt;());
        copy(ia2, ia2 + 6, ostream_iterator&lt;int&gt;(cout, " "));
        cout &lt;&lt; '\n';
    }
    /*
        Displays:
            1 10 3 8 5 6 7 4 9 2
            the 6 smallest elements: 1 2 3 4 5 6
            the 4 smallest elements to a larger range:
            1 3 8 10 5 6
            the 4 biggest elements to a larger range:
            10 8 3 1 5 6
    */
</pre>
    </ul>
<p>
<a name="PARTSUM"></a><a name="l420"></a>
<h3 >19.1.37: partial_sum</h3>
        <a name="an2324"></a>
    <ul>
        <li> Header file: <code >&lt;numeric&gt;</code>
        <li> Function prototypes:
        <ul>
            <li><code >OutputIterator partial_sum(InputIterator first,
InputIterator last, OutputIterator result);</code>
            <li><code >OutputIterator partial_sum(InputIterator first, InputIterator
last, OutputIterator result, BinaryOperation op);</code>
        </ul>
        <li> Description:
        <ul>
            <li> The first prototype: each element in the range
<code >[result, &lt;returned OutputIterator&gt;)</code> receives a value which is obtained
by adding the elements in the corresponding range of the range <code >[first,
last)</code>. The first element in the resulting range will be equal to the element
pointed to by <code >first</code>.
            <li> The second prototype: the value of each element in the range
<code >[result, &lt;returned OutputIterator&gt;)</code> is obtained by applying the binary
operator <code >op</code> to the previous element in the resulting range and the
corresponding element in the range <code >[first, last)</code>. The first
element in the resulting range will be equal to the element pointed to by
<code >first</code>.
        </ul>
        <li> Example:
        <pre>
    #include &lt;numeric&gt;
    #include &lt;algorithm&gt;
    #include &lt;iostream&gt;
    #include &lt;functional&gt;
    #include &lt;iterator&gt;
    using namespace std;

    int main()
    {
        int ia[] = {1, 2, 3, 4, 5};
        int ia2[5];

        copy(ia2,
            partial_sum(ia, ia + 5, ia2),
            ostream_iterator&lt;int&gt;(cout, " "));
        cout &lt;&lt; '\n';

        copy(ia2,
            partial_sum(ia, ia + 5, ia2, multiplies&lt;int&gt;()),
            ostream_iterator&lt;int&gt;(cout, " "));
        cout &lt;&lt; '\n';
    }
    /*
        Displays:
            1 3 6 10 15
            1 2 6 24 120
    */
</pre>
    </ul>
<p>
<a name="PARTIT"></a><a name="l421"></a>
<h3 >19.1.38: partition</h3>
        <a name="an2325"></a>
    <ul>
        <li> Header file: <code >&lt;algorithm&gt;</code>
        <li> Function prototype:
        <ul>
            <li><code >BidirectionalIterator partition(BidirectionalIterator
first, BidirectionalIterator last, UnaryPredicate pred);</code>
        </ul>
        <li> Description:
        <ul>
            <li> All elements in the range <code >[first, last)</code> for which the
unary predicate <code >pred</code> evaluates as <code >true</code> are placed before the elements
which evaluate as <code >false</code>. The return value points just beyond the last
element in the partitioned range for which <code >pred</code> evaluates as <code >true</code>.
        </ul>
        <li> Example:
        <pre>
    #include &lt;algorithm&gt;
    #include &lt;iostream&gt;
    #include &lt;string&gt;
    #include &lt;iterator&gt;
    using namespace std;

    class LessThan
    {
        int d_x;
        public:
            LessThan(int x)
            :
                d_x(x)
            {}
            bool operator()(int value) const
            {
                return value &lt;= d_x;
            }
    };
    int main()
    {
        int ia[] = {1, 3, 5, 7, 9, 10, 2, 8, 6, 4};
        int *split;

        split = partition(ia, ia + 10, LessThan{ ia[9] });
        cout &lt;&lt; "Last element &lt;= 4 is ia[" &lt;&lt; split - ia - 1 &lt;&lt; "]\n";

        copy(ia, ia + 10, ostream_iterator&lt;int&gt;{ cout, " " });
        cout &lt;&lt; '\n';
    }
    /*
        Displays:
            Last element &lt;= 4 is ia[3]
            1 3 4 2 9 10 7 8 6 5
    */
</pre>
    </ul>
<p>
<a name="PREVPERM"></a><a name="l422"></a>
<h3 >19.1.39: prev_permutation</h3>
        <a name="an2326"></a>
    <ul>
        <li> Header file: <code >&lt;algorithm&gt;</code>
        <li> Function prototypes:
        <ul>
            <li><code >bool prev_permutation(BidirectionalIterator first,
                BidirectionalIterator last);</code>
            <li><code >bool prev_permutation(BidirectionalIterator first,
                BidirectionalIterator last, Comp comp);</code>
        </ul>
        <li> Description:
            <ul>
            <li> The first prototype: the previous permutation given the
sequence of elements in the range <code >[first, last)</code> is determined. The
elements in the range are reordered such that the first ordering is obtained
representing a `smaller' value (see <code >next_permutation</code> (section
<a href="cplusplus19.html#NEXTPERM">19.1.33</a>) for an example involving the opposite ordering). The value
<code >true</code> is returned if a reordering took place, the value <code >false</code> is
returned if no reordering took place, which is the case if the provided
sequence was already ordered, according to the <a name="an2327"></a><code >operator&lt;</code> of the data
type to which the iterators point.
            <li> The second prototype: the previous permutation given the
sequence of elements in the range <code >[first, last)</code> is determined , using
the binary predicate <code >comp</code> to compare elements. The elements in the range
are reordered. The value <code >true</code> is returned if a reordering took place, the
value <code >false</code> is returned if no reordering took place, which is the case if
the original sequence was already ordered, using the binary predicate <code >comp</code>
to compare two elements.
            </ul>
        <li> Example:
        <pre>
    #include &lt;algorithm&gt;
    #include &lt;iostream&gt;
    #include &lt;string&gt;
    #include &lt;cstring&gt;
    #include &lt;iterator&gt;
    using namespace std;

    class CaseString
    {
        public:
            bool operator()(string const &amp;first, string const &amp;second) const
            {
                return strcasecmp(first.c_str(), second.c_str()) &lt; 0;
            }
    };
    int main()
    {
        string  saints[] = {"Oh", "when", "the", "saints"};

        cout &lt;&lt; "All previous permutations of 'Oh when the saints':\n";
        cout &lt;&lt; "Sequences:\n";
        do
        {
            copy(saints, saints + 4, ostream_iterator&lt;string&gt;{ cout, " " });
            cout &lt;&lt; '\n';
        }
        while (prev_permutation(saints, saints + 4, CaseString{}));

        cout &lt;&lt; "After first sorting the sequence:\n";
        sort(saints, saints + 4, CaseString{});
        cout &lt;&lt; "Sequences:\n";
        while (prev_permutation(saints, saints + 4, CaseString{}))
        {
            copy(saints, saints + 4, ostream_iterator&lt;string&gt;{ cout, " " });
            cout &lt;&lt; '\n';
        }
        cout &lt;&lt; "No (more) previous permutations\n";
    }
    /*
        Displays:
            All previous permutations of 'Oh when the saints':
            Sequences:
            Oh when the saints
            Oh when saints the
            Oh the when saints
            Oh the saints when
            Oh saints when the
            Oh saints the when
            After first sorting the sequence:
            Sequences:
            No (more) previous permutations
    */
</pre>
    </ul>
<p>
<a name="REMOVE"></a><a name="l423"></a>
<h3 >19.1.40: remove</h3>
        <a name="an2328"></a>
    <ul>
        <li> Header file: <code >&lt;algorithm&gt;</code>
        <li> Function prototype:
        <ul>
            <li><code >ForwardIterator remove(ForwardIterator first, ForwardIterator
last, Type const &amp;value);</code>
        </ul>
        <li> Description:
        <ul>
            <li> The elements in the range pointed to by <code >[first, last)</code>
are reordered such that all values unequal to <code >value</code> are placed at
the beginning of the range. The returned forward iterator points to the first
element that can be removed after reordering. The range <code >[returnvalue,
last)</code> is called the <a name="an2329"></a><em >leftover</em> of the algorithm. Note that the leftover may
contain elements different from <code >value</code>, but these elements can be removed
safely, as such elements are also present in the range <code >[first,
returnvalue)</code>. Such duplication is the result of the fact that the algorithm
<em >copies</em>, rather than <em >moves</em> elements into new locations.  The function
uses <code >operator==</code> of the data type to which the iterators point to
determine which elements to remove.
        </ul>
        <li> Example:
        <pre>
    #include &lt;algorithm&gt;
    #include &lt;iostream&gt;
    #include &lt;string&gt;
    #include &lt;iterator&gt;
    using namespace std;

    int main()
    {
        string words[] =
            { "kilo", "alpha", "lima", "mike", "alpha", "november", "alpha",
                "alpha", "alpha", "papa", "quebec" };
        string *removed;
        size_t const size = sizeof(words) / sizeof(string);

        cout &lt;&lt; "Removing all \"alpha\"s:\n";
        removed = remove(words, words + size, "alpha");
        copy(words, removed, ostream_iterator&lt;string&gt;(cout, " "));
        cout &lt;&lt; '\n'
             &lt;&lt; "Leftover elements are:\n";
        copy(removed, words + size, ostream_iterator&lt;string&gt;(cout, " "));
        cout &lt;&lt; '\n';
    }
    /*
        Displays:
                        Removing all "alpha"s:
                        kilo lima mike november papa quebec
                        Leftover elements are:
                        alpha alpha alpha papa quebec
    */
</pre>
    </ul>
<p>
<a name="REMOVECP"></a><a name="l424"></a>
<h3 >19.1.41: remove_copy</h3>
        <a name="an2330"></a>
    <ul>
        <li> Header file: <code >&lt;algorithm&gt;</code>
        <li> Function prototypes:
        <ul>
            <li><code >OutputIterator remove_copy(InputIterator first, InputIterator
last, OutputIterator result, Type const &amp;value);</code>
        </ul>
        <li> Description:
        <ul>
            <li> The elements in the range pointed to by <code >[first, last)</code>
not matching <code >value</code> are copied to the range <code >[result, returnvalue)</code>,
where <code >returnvalue</code> is the value returned by the function. The range
<code >[first, last)</code> is not modified.  The function uses <code >operator==</code> of the
data type to which the iterators point to determine which elements not to
copy.
        </ul>
        <li> Example:
        <pre>
    #include &lt;algorithm&gt;
    #include &lt;iostream&gt;
    #include &lt;string&gt;
    #include &lt;functional&gt;
    #include &lt;iterator&gt;
    using namespace std;

    int main()
    {
        string words[] =
            { "kilo", "alpha", "lima", "mike", "alpha", "november", "alpha",
                "oscar", "alpha", "alpha", "papa", "quebec" };
        size_t const size = sizeof(words) / sizeof(string);
        string remaining
                [
                    size -
                    count_if
                    (
                        words, words + size,
                        bind2nd(equal_to&lt;string&gt;(), string("alpha"))
                    )
                ];
        string *returnvalue =
                remove_copy(words, words + size, remaining, "alpha");

        cout &lt;&lt; "Removing all \"alpha\"s:\n";
        copy(remaining, returnvalue, ostream_iterator&lt;string&gt;(cout, " "));
        cout &lt;&lt; '\n';
    }
    /*
        Displays:
            Removing all "alpha"s:
            kilo lima mike november oscar papa quebec
    */
</pre>
    </ul>
<p>
<a name="REMOVECPIF"></a><a name="l425"></a>
<h3 >19.1.42: remove_copy_if</h3>
        <a name="an2331"></a>
    <ul>
        <li> Header file: <code >&lt;algorithm&gt;</code>
        <li> Function prototype:
        <ul>
            <li><code >OutputIterator remove_copy_if(InputIterator first,
InputIterator last, OutputIterator result, UnaryPredicate pred);</code>
        </ul>
        <li> Description:
        <ul>
            <li> The elements in the range pointed to by <code >[first, last)</code>
for which the unary predicate <code >pred</code> returns <code >true</code> are removed from the
resulting copy. All other elements are copied to the range <code >[result,
returnvalue)</code>, where <code >returnvalue</code> is the value returned by the function. The
range <code >[first, last)</code> is not modified.
        </ul>
        <li> Example:
        <pre>
    #include &lt;algorithm&gt;
    #include &lt;iostream&gt;
    #include &lt;string&gt;
    #include &lt;functional&gt;
    #include &lt;iterator&gt;
    using namespace std;

    int main()
    {
        string words[] =
            { "kilo", "alpha", "lima", "mike", "alpha", "november", "alpha",
                "oscar", "alpha", "alpha", "papa", "quebec" };
        size_t const size = sizeof(words) / sizeof(string);
        string remaining[
                            size -
                            count_if
                            (
                                words, words + size,
                                bind2nd(equal_to&lt;string&gt;(), "alpha")
                            )
                        ];
        string *returnvalue =
                    remove_copy_if
                    (
                        words, words + size, remaining,
                        bind2nd(equal_to&lt;string&gt;(), "alpha")
                    );

        cout &lt;&lt; "Removing all \"alpha\"s:\n";
        copy(remaining, returnvalue, ostream_iterator&lt;string&gt;(cout, " "));
        cout &lt;&lt; '\n';
    }
    /*
        Displays:
            Removing all "alpha"s:
            kilo lima mike november oscar papa quebec
    */
</pre>
    </ul>
<p>
<a name="REMOVEIF"></a><a name="l426"></a>
<h3 >19.1.43: remove_if</h3>
        <a name="an2332"></a>
    <ul>
        <li> Header file: <code >&lt;algorithm&gt;</code>
        <li> Function prototype:
        <ul>
            <li><code >ForwardIterator remove_if(ForwardIterator first,
ForwardIterator last, UnaryPredicate pred);</code>
        </ul>
        <li> Description:
        <ul>
            <li> The elements in the range pointed to by <code >[first, last)</code>
are reordered such that all values for which the unary predicate <code >pred</code>
evaluates as <code >false</code> are placed at the beginning of the range. The returned
forward iterator points to the first element, after reordering, for which
<code >pred</code> returns <code >true</code>. The range <code >[returnvalue, last)</code> is called the
<em >leftover</em> of the algorithm. The leftover may contain elements for which the
predicate <code >pred</code> returns <code >false</code>, but these can safely be removed, as such
elements are also present in the range <code >[first, returnvalue)</code>. Such
duplication is the result of the fact that the algorithm <em >copies</em>, rather
than <em >moves</em> elements into new locations.
        </ul>
        <li> Example:<pre>
    #include &lt;functional&gt;
    #include &lt;algorithm&gt;
    #include &lt;iostream&gt;
    #include &lt;string&gt;
    #include &lt;iterator&gt;
    using namespace std;

    int main()
    {
        string words[] =
            { "kilo", "alpha", "lima", "mike", "alpha", "november", "alpha",
                "oscar", "alpha", "alpha", "papa", "quebec" };
        size_t const size = sizeof(words) / sizeof(string);

        cout &lt;&lt; "Removing all \"alpha\"s:\n";

        string *removed = remove_if(words, words + size,
                    bind2nd(equal_to&lt;string&gt;(), string("alpha")));

        copy(words, removed, ostream_iterator&lt;string&gt;(cout, " "));
        cout &lt;&lt; '\n'
             &lt;&lt; "Trailing elements are:\n";
        copy(removed, words + size, ostream_iterator&lt;string&gt;(cout, " "));
        cout &lt;&lt; '\n';
    }
    /*
        Displays:
            Removing all "alpha"s:
            kilo lima mike november oscar papa quebec
            Trailing elements are:
            oscar alpha alpha papa quebec
    */
</pre>
    </ul>
<p>
<a name="REPLACE"></a><a name="l427"></a>
<h3 >19.1.44: replace</h3>
        <a name="an2333"></a>
    <ul>
        <li> Header file: <code >&lt;algorithm&gt;</code>
        <li> Function prototype:
        <ul>
            <li><code >ForwardIterator replace(ForwardIterator first, ForwardIterator
last, Type const &amp;oldvalue, Type const &amp;newvalue);</code>
        </ul>
        <li> Description:
        <ul>
            <li> All elements equal to <code >oldvalue</code> in the range pointed to by
<code >[first, last)</code> are replaced by a copy of <code >newvalue</code>. The algorithm
uses <code >operator==</code> of the data type to which the iterators point.
<p>
</ul>
        <li> Example:
        <pre>
    #include &lt;algorithm&gt;
    #include &lt;iostream&gt;
    #include &lt;string&gt;
    #include &lt;iterator&gt;
    using namespace std;

    int main()
    {
        string words[] =
            { "kilo", "alpha", "lima", "mike", "alpha", "november", "alpha",
                "oscar", "alpha", "alpha", "papa" };
        size_t const size = sizeof(words) / sizeof(string);

        replace(words, words + size, string("alpha"), string("ALPHA"));
        copy(words, words + size, ostream_iterator&lt;string&gt;(cout, " "));
        cout &lt;&lt; '\n';
    }
    /*
        Displays
            kilo ALPHA lima mike ALPHA november ALPHA oscar ALPHA ALPHA papa
    */
</pre>
    </ul>
<p>
<a name="REPLACECP"></a><a name="l428"></a>
<h3 >19.1.45: replace_copy</h3>
        <a name="an2334"></a>
    <ul>
        <li> Header file: <code >&lt;algorithm&gt;</code>
        <li> Function prototype:
        <ul>
            <li><code >OutputIterator replace_copy(InputIterator first, InputIterator
last, OutputIterator result, Type const &amp;oldvalue, Type const &amp;newvalue);</code>
        </ul>
        <li> Description:
        <ul>
            <li> All elements equal to <code >oldvalue</code> in the range pointed to by
<code >[first, last)</code> are replaced by a copy of <code >newvalue</code> in a new range
<code >[result, returnvalue)</code>, where <code >returnvalue</code> is the return value of the
function.  The algorithm uses <code >operator==</code> of the data type to which the
iterators point.
        </ul>
        <li> Example:
        <pre>
    #include &lt;algorithm&gt;
    #include &lt;iostream&gt;
    #include &lt;string&gt;
    #include &lt;iterator&gt;
    using namespace std;

    int main()
    {
        string words[] =
            { "kilo", "alpha", "lima", "mike", "alpha", "november", "alpha",
                "oscar", "alpha", "alpha", "papa"};
        size_t const size = sizeof(words) / sizeof(string);
        string remaining[size];

        copy
        (
            remaining,
            replace_copy(words, words + size, remaining, string("alpha"),
                                                         string("ALPHA")),
            ostream_iterator&lt;string&gt;(cout, " ")
        );
        cout &lt;&lt; '\n';
    }
    /*
        Displays:
            kilo ALPHA lima mike ALPHA november ALPHA oscar ALPHA ALPHA papa
    */
</pre>
    </ul>
<p>
<a name="REPLACECPIF"></a><a name="l429"></a>
<h3 >19.1.46: replace_copy_if</h3>
        <a name="an2335"></a>
    <ul>
        <li> Header file: <code >&lt;algorithm&gt;</code>
        <li> Function prototypes:
            <ul>
            <li><code >OutputIterator replace_copy_if(ForwardIterator first,
                ForwardIterator last, OutputIterator result, UnaryPredicate
                pred, Type const &amp;value);</code>
            </ul>
        <li> Description:
            <ul>
            <li> The elements in the range pointed to by <code >[first, last)</code>
                are copied to the range <code >[result, returnvalue)</code>, where
                <code >returnvalue</code> is the value returned by the function. The
                elements for which the unary predicate <code >pred</code> returns
                <code >true</code> are replaced by <code >value</code>. The range <code >[first,
                last)</code> is not modified.
            </ul>
        <li> Example:
        <pre>
    #include &lt;algorithm&gt;
    #include &lt;iostream&gt;
    #include &lt;string&gt;
    #include &lt;functional&gt;
    #include &lt;iterator&gt;
    using namespace std;

    int main()
    {
        string words[] =
            { "kilo", "alpha", "lima", "mike", "alpha", "november",
              "alpha", "oscar", "alpha", "alpha", "papa"};
        size_t const size = sizeof(words) / sizeof(string);
        string result[size];

        // Note: the comparisons are: "mike" &gt; word[i]
        replace_copy_if(words, words + size, result,
                        bind1st(greater&lt;string&gt;(), string("mike")),
                        string("ALPHA"));
        copy (result, result + size, ostream_iterator&lt;string&gt;(cout, " "));
        cout &lt;&lt; '\n';
    }
    /*
        Displays (all strings in words[] which are exceeded by 'mike' are
                  replaced by ALPHA):
            ALPHA ALPHA ALPHA mike ALPHA november ALPHA oscar ALPHA ALPHA papa
    */
</pre>
    </ul>
<p>
<a name="REPLACEIF"></a><a name="l430"></a>
<h3 >19.1.47: replace_if</h3>
        <a name="an2336"></a>
    <ul>
        <li> Header file: <code >&lt;algorithm&gt;</code>
        <li> Function prototype:
        <ul>
            <li><code >ForwardIterator replace_if(ForwardIterator first,
ForwardIterator last, UnaryPredicate pred, Type const &amp;value);</code>
        </ul>
        <li> Description:
        <ul>
            <li> The elements in the range pointed to by <code >[first, last)</code>
for which the unary predicate <code >pred</code> evaluates as <code >true</code>
are replaced by <code >value</code>.
        </ul>
        <code ></code> Example:<pre>
    #include &lt;algorithm&gt;
    #include &lt;iostream&gt;
    #include &lt;string&gt;
    #include &lt;functional&gt;
    #include &lt;iterator&gt;
    using namespace std;

    int main()
    {
        string words[] =
            { "kilo", "alpha", "lima", "mike", "alpha", "november", "alpha",
                "oscar", "alpha", "alpha", "papa"};
        size_t const size = sizeof(words) / sizeof(string);

        replace_if(words, words + size,
                   bind1st(equal_to&lt;string&gt;(), string("alpha")),
                   string("ALPHA"));
        copy(words, words + size, ostream_iterator&lt;string&gt;(cout, " "));
        cout &lt;&lt; '\n';
    }
    /*
        Displays:
            kilo ALPHA lima mike ALPHA november ALPHA oscar ALPHA ALPHA papa
    */
</pre>
    </ul>
<p>
<a name="REVERSE"></a><a name="l431"></a>
<h3 >19.1.48: reverse</h3>
    <a name="an2337"></a>
<ul>
    <li> Header file:
    <code >&lt;algorithm&gt;</code>
    <li> Function prototype:
    <ul>
        <li><code >void reverse(BidirectionalIterator first,
            BidirectionalIterator last);</code>
    </ul>
    <li> Description:
    <ul>
        <li> The elements in the range pointed to by <code >[first, last)</code>
            are reversed.
    </ul>
    <li> Example:
    <pre>
    #include &lt;algorithm&gt;
    #include &lt;iostream&gt;
    #include &lt;string&gt;
    using namespace std;

    int main()
    {
        string line;

        while (getline(cin, line))
        {
            reverse(line.begin(), line.end());
            cout &lt;&lt; line &lt;&lt; '\n';
        }
    }
</pre>
</ul>
<p>
<a name="REVERSECP"></a><a name="l432"></a>
<h3 >19.1.49: reverse_copy</h3>
    <a name="an2338"></a>
<ul>
    <li> Header file: <code >&lt;algorithm&gt;</code>
    <li> Function prototype:
    <ul>
        <li><code >OutputIterator reverse_copy(BidirectionalIterator first,
            BidirectionalIterator last, OutputIterator result);</code>
    </ul>
    <li> Description:
    <ul>
        <li> The elements in the range pointed to by <code >[first, last)</code>
are copied to the range <code >[result, returnvalue)</code> in reversed order. The
value <code >returnvalue</code> is the value that is returned by the function.
    </ul>
    <li> Example:
    <pre>
    #include &lt;algorithm&gt;
    #include &lt;iostream&gt;
    #include &lt;string&gt;
    using namespace std;

    int main()
    {
        string line;

        while (getline(cin, line))
        {
            size_t    size = line.size();
            char        copy[size + 1];

            cout &lt;&lt; "line: " &lt;&lt; line &lt;&lt; '\n' &lt;&lt;
                    "reversed: ";
            reverse_copy(line.begin(), line.end(), copy);
            copy[size] = 0;     // 0 is not part of the reversed
                                // line !
            cout &lt;&lt; copy &lt;&lt; '\n';
        }
    }
</pre>
</ul>
<p>
<a name="ROTATE"></a><a name="l433"></a>
<h3 >19.1.50: rotate</h3>
    <a name="an2339"></a>
    <ul>
        <li> Header file: <code >&lt;algorithm&gt;</code>
        <li> Function prototype:
        <ul>
            <li><code >void rotate(ForwardIterator first, ForwardIterator
                middle, ForwardIterator last);</code>
        </ul>
        <li> Description:
        <ul>
            <li> The elements implied by the range <code >[first, middle)</code> are
moved to the end of the container, the elements implied by the range
<code >[middle, last)</code> are moved to the beginning of the container, keeping the
order of the elements in the two subsets intact.
        </ul>
        <li> Example:
        <pre>
    #include &lt;algorithm&gt;
    #include &lt;iostream&gt;
    #include &lt;string&gt;
    #include &lt;iterator&gt;
    using namespace std;

    int main()
    {
        string words[] =
            { "kilo", "lima", "mike", "november", "oscar",
              "foxtrot", "golf", "hotel", "india", "juliet" };
        size_t const size = sizeof(words) / sizeof(string);
        size_t const midsize = size / 2;

        rotate(words, words + midsize, words + size);

        copy(words, words + size, ostream_iterator&lt;string&gt;(cout, " "));
        cout &lt;&lt; '\n';
    }
    /*
        Displays:
            foxtrot golf hotel india juliet kilo lima mike november oscar
    */
</pre>
    </ul>
<p>
<a name="ROTATECP"></a><a name="l434"></a>
<h3 >19.1.51: rotate_copy</h3>
    <a name="an2340"></a>
    <ul>
        <li> Header file: <code >&lt;algorithm&gt;</code>
        <li> Function prototypes:
        <ul>
            <li><code >OutputIterator rotate_copy(ForwardIterator first,
ForwardIterator middle, ForwardIterator last, OutputIterator result);</code>
        </ul>
        <li> Description:
        <ul>
            <li> The elements implied by the range <code >[middle, last)</code> and
then the elements implied by <code >[first, middle)</code> are copied to the
destination container having range <code >[result, returnvalue)</code>, where
<code >returnvalue</code> is the iterator returned by the function. The original order
of the elements in the two subsets is not altered.
        </ul>
        <li> Example:
        <pre>
    #include &lt;algorithm&gt;
    #include &lt;iostream&gt;
    #include &lt;string&gt;
    #include &lt;iterator&gt;
    using namespace std;

    int main()
    {
        string words[] =
           { "kilo", "lima", "mike", "november", "oscar",
              "foxtrot", "golf", "hotel", "india", "juliet" };
        size_t const size = sizeof(words) / sizeof(string);
        size_t const midsize = size / 2;
        string out[size];

        copy(out,
            rotate_copy(words, words + midsize, words + size, out),
            ostream_iterator&lt;string&gt;(cout, " "));
        cout &lt;&lt; '\n';
    }
    /*
        Displays:
            foxtrot golf hotel india juliet kilo lima mike november oscar
    */
</pre>
    </ul>
<p>
<a name="SEARCH"></a><a name="l435"></a>
<h3 >19.1.52: search</h3>
    <a name="an2341"></a>
    <ul>
        <li> Header file: <code >&lt;algorithm&gt;</code>
        <li> Function prototypes:
        <ul>
            <li><code >ForwardIterator1 search(ForwardIterator1 first1,
ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2);</code>
            <li><code >ForwardIterator1 search(ForwardIterator1 first1,
ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2,
BinaryPredicate pred);</code>
        </ul>
        <li> Description:
        <ul>
            <li> The first prototype: an iterator into the first range
<code >[first1, last1)</code> is returned where the elements in the range
<code >[first2, last2)</code> are found using <a name="an2342"></a><code >operator==</code> of the data
type to which the iterators point. If no such location exists, <code >last1</code> is
returned.
            <li> The second prototype: an iterator into the first range
<code >[first1, last1)</code> is returned where the elements in the range
<code >[first2, last2)</code> are found using the provided binary predicate <code >pred</code>
to compare the elements in the two ranges. If no such location exists,
<code >last1</code> is returned.
        </ul>
        <li> Example:
        <pre>
    #include &lt;algorithm&gt;
    #include &lt;iostream&gt;
    #include &lt;iterator&gt;
    using namespace std;

    class absInt
    {
        public:
            bool operator()(int i1, int i2) const
            {
                return abs(i1) == abs(i2);
            }
    };
    int main()
    {
        int range1[] =  {-2, -4, -6, -8, 2, 4, 6, 8};
        int range2[] =  {6, 8};

        copy
        (
            search(range1, range1 + 8, range2, range2 + 2),
            range1 + 8,
            ostream_iterator&lt;int&gt;(cout, " ")
        );
        cout &lt;&lt; '\n';

        copy
        (
            search(range1, range1 + 8, range2, range2 + 2, absInt()),
            range1 + 8,
            ostream_iterator&lt;int&gt;(cout, " ")
        );
        cout &lt;&lt; '\n';
    }
    /*
        Displays:
            6 8
            -6 -8 2 4 6 8
    */
</pre>
    </ul>
<p>
<a name="SEARCHN"></a><a name="l436"></a>
<h3 >19.1.53: search_n</h3>
    <a name="an2343"></a>
    <ul>
        <li> Header file: <code >&lt;algorithm&gt;</code>
        <li> Function prototypes:
        <ul>
            <li><code >ForwardIterator1 search_n(ForwardIterator1 first1,
ForwardIterator1 last1, Size count, Type const &amp;value);</code>
            <li><code >ForwardIterator1 search_n(ForwardIterator1 first1,
ForwardIterator1 last1, Size count, Type const &amp;value, BinaryPredicate
pred);</code>
        </ul>
        <li> Description:
        <ul>
            <li> The first prototype: an iterator into the first range
<code >[first1, last1)</code> is returned where <code >n</code> consecutive elements having
value <code >value</code> are found using <a name="an2344"></a><code >operator==</code> of the data type to which
the iterators point to compare the elements. If no such location exists,
<code >last1</code> is returned.
            <li> The second prototype: an iterator into the first range
<code >[first1, last1)</code> is returned where <code >n</code> consecutive elements having
value <code >value</code> are found using the provided binary predicate <code >pred</code> to
compare the elements. If no such location exists, <code >last1</code> is returned.
        </ul>
        <li> Example:
        <pre>
    #include &lt;algorithm&gt;
    #include &lt;iostream&gt;
    #include &lt;iterator&gt;
    using namespace std;

    bool eqInt(int i1, int i2)
    {
        return abs(i1) == abs(i2);
    }
    int main()
    {
        int range1[] =  {-2, -4, -4, -6, -8, 2, 4, 4, 6, 8};

        copy
        (
            search_n(range1, range1 + 8, 2, 4),
            range1 + 8,
            ostream_iterator&lt;int&gt;(cout, " ")
        );
        cout &lt;&lt; '\n';

        copy
        (
            search_n(range1, range1 + 8, 2, 4, eqInt),
            range1 + 8,
            ostream_iterator&lt;int&gt;(cout, " ")
        );
        cout &lt;&lt; '\n';
    }
    /*
        Displays:
            4 4
            -4 -4 -6 -8 2 4 4
    */
</pre>
    </ul>
<p>
<a name="SETDIF"></a><a name="l437"></a>
<h3 >19.1.54: set_difference</h3>
    <a name="an2345"></a>
    <ul>
        <li> Header file: <code >&lt;algorithm&gt;</code>
        <li> Function prototypes:
        <ul>
            <li><code >OutputIterator set_difference(InputIterator1 first1,
InputIterator1 last1, InputIterator2 first2, InputIterator2 last2,
OutputIterator result);</code>
            <li><code >OutputIterator set_difference(InputIterator1 first1,
InputIterator1 last1, InputIterator2 first2, InputIterator2 last2,
OutputIterator result, Compare comp);</code>
        </ul>
        <li> Description:
        <ul>
            <li> The first prototype: a sorted sequence of the elements
pointed to by the range <code >[first1, last1)</code> that are not present in the
range <code >[first2, last2)</code> is returned, starting at <code >result</code>, and ending
at the <code >OutputIterator</code> returned by the function. The elements in the two
ranges must have been sorted using <a name="an2346"></a><code >operator&lt;</code> of the data type to which
the iterators point.
            <li> The second prototype: a sorted sequence of the elements
pointed to by the range <code >[first1, last1)</code> that are not present in the
range <code >[first2, last2)</code> is returned, starting at <code >result</code>, and ending
at the <code >OutputIterator</code> returned by the function. The elements in the two
ranges must have been sorted using the <code >comp</code> function object.
        </ul>
        <li> Example:
        <pre>
    #include &lt;algorithm&gt;
    #include &lt;iostream&gt;
    #include &lt;string&gt;
    #include &lt;cstring&gt;
    #include &lt;iterator&gt;
    using namespace std;

    bool caseless(string const &amp;left, string const &amp;right)
    {
        return strcasecmp(left.c_str(), right.c_str()) &lt; 0;
    }
    int main()
    {
        string set1[] = { "kilo", "lima", "mike", "november",
                          "oscar", "papa", "quebec" };
        string set2[] = { "papa", "quebec", "romeo"};
        string result[7];
        string *returned;

        copy(result,
            set_difference(set1, set1 + 7, set2, set2 + 3, result),
            ostream_iterator&lt;string&gt;(cout, " "));
        cout &lt;&lt; '\n';

        string set3[] = { "PAPA", "QUEBEC", "ROMEO"};

        copy(result,
            set_difference(set1, set1 + 7, set3, set3 + 3, result,
            caseless),
            ostream_iterator&lt;string&gt;(cout, " "));
        cout &lt;&lt; '\n';
    }
    /*
        Displays:
            kilo lima mike november oscar
            kilo lima mike november oscar
    */
</pre>
    </ul>
<p>
<a name="SETINT"></a><a name="l438"></a>
<h3 >19.1.55: set_intersection</h3>
    <a name="an2347"></a>
    <ul>
        <li> Header file: <code >&lt;algorithm&gt;</code>
        <li> Function prototypes:
        <ul>
            <li><code >OutputIterator set_intersection(InputIterator1 first1,
InputIterator1) linebreak() tt(last1, InputIterator2 first2, InputIterator2
last2, OutputIterator result);</code>
            <li><code >OutputIterator set_intersection(InputIterator1 first1,
InputIterator1 last1, InputIterator2 first2, InputIterator2 last2,
OutputIterator result, Compare comp);</code>
        </ul>
        <li> Description:
        <ul>
            <li> The first prototype: a sorted sequence of the elements
pointed to by the range <code >[first1, last1)</code> that are also present in the
range <code >[first2, last2)</code> is returned, starting at <code >result</code>, and ending
at the <code >OutputIterator</code> returned by the function. The elements in the two
ranges must have been sorted using <a name="an2348"></a><code >operator&lt;</code> of the data type to which
the iterators point.
            <li> The second prototype: a sorted sequence of the elements
pointed to by the range <code >[first1, last1)</code> that are also present in the
range <code >[first2, last2)</code> is returned, starting at <code >result</code>, and ending
at the <code >OutputIterator</code> returned by the function. The elements in the two
ranges must have been sorted using the <code >comp</code> function object.
        </ul>
        <li> Example:
        <pre>
    #include &lt;algorithm&gt;
    #include &lt;iostream&gt;
    #include &lt;string&gt;
    #include &lt;cstring&gt;
    #include &lt;iterator&gt;
    using namespace std;

    bool caseless(string const &amp;left, string const &amp;right)
    {
        return strcasecmp(left.c_str(), right.c_str()) &lt; 0;
    }
    int main()
    {
        string set1[] = { "kilo", "lima", "mike", "november",
                          "oscar", "papa", "quebec" };
        string set2[] = { "papa", "quebec", "romeo"};
        string result[7];
        string *returned;

        copy(result,
            set_intersection(set1, set1 + 7, set2, set2 + 3, result),
            ostream_iterator&lt;string&gt;(cout, " "));
        cout &lt;&lt; '\n';

        string set3[] = { "PAPA", "QUEBEC", "ROMEO"};

        copy(result,
            set_intersection(set1, set1 + 7, set3, set3 + 3, result,
                                                             caseless),
            ostream_iterator&lt;string&gt;(cout, " "));
        cout &lt;&lt; '\n';
    }
    /*
        Displays:
            papa quebec
            papa quebec
    */
</pre>
    </ul>
<p>
<a name="SETSYM"></a><a name="l439"></a>
<h3 >19.1.56: set_symmetric_difference</h3>
    <a name="an2349"></a>
    <ul>
        <li> Header file: <code >&lt;algorithm&gt;</code>
        <li> Function prototypes:
        <ul>
            <li><code >OutputIterator set_symmetric_difference(InputIterator1
                first1, InputIterator1 last1, InputIterator2 first2,
                InputIterator2 last2, OutputIterator result);</code>
            <li><code >OutputIterator set_symmetric_difference(InputIterator1 first1,
                InputIterator1 last1, InputIterator2 first2, InputIterator2
                last2, OutputIterator result, Compare comp);</code>
        </ul>
        <li> Description:
        <ul>
            <li> The first prototype: a sorted sequence of the elements
pointed to by the range <code >[first1, last1)</code> that are not present in the
range <code >[first2, last2)</code> and those in the range <code >[first2, last2)</code>
that are not present in the range <code >[first1, last1)</code> is returned, starting
at <code >result</code>, and ending at the <code >OutputIterator</code> returned by the
function. The elements in the two ranges must have been sorted using
<a name="an2350"></a><code >operator&lt;</code> of the data type to which the iterators point.
            <li> The second prototype: a sorted sequence of the elements
pointed to by the range <code >[first1, last1)</code> that are not present in the
range <code >[first2, last2)</code> and those in the range <code >[first2, last2)</code>
that are not present in the range <code >[first1, last1)</code> is returned, starting
at <code >result</code>, and ending at the <code >OutputIterator</code> returned by the
function. The elements in the two ranges must have been sorted using the
<code >comp</code> function object.
        </ul>
        <li> Example:
        <pre>
    #include &lt;algorithm&gt;
    #include &lt;iostream&gt;
    #include &lt;string&gt;
    #include &lt;cstring&gt;
    #include &lt;iterator&gt;
    using namespace std;

    bool caseless(string const &amp;left, string const &amp;right)
    {
        return strcasecmp(left.c_str(), right.c_str()) &lt; 0;
    }
    int main()
    {
        string set1[] = { "kilo", "lima", "mike", "november",
                          "oscar", "papa", "quebec" };
        string set2[] = { "papa", "quebec", "romeo"};
        string result[7];

        copy(result,
            set_symmetric_difference(set1, set1 + 7, set2, set2 + 3,
                                                           result),
            ostream_iterator&lt;string&gt;(cout, " "));
        cout &lt;&lt; '\n';

        string set3[] = { "PAPA", "QUEBEC", "ROMEO"};

        copy(result,
            set_symmetric_difference(set1, set1 + 7, set3, set3 + 3,
                                                     result, caseless),
            ostream_iterator&lt;string&gt;(cout, " "));
        cout &lt;&lt; '\n';
    }
    /*
        Displays:
            kilo lima mike november oscar romeo
            kilo lima mike november oscar ROMEO
    */
</pre>
    </ul>
<p>
<a name="SETUNI"></a><a name="l440"></a>
<h3 >19.1.57: set_union</h3>
    <a name="an2351"></a>
    <ul>
        <li> Header file: <code >&lt;algorithm&gt;</code>
        <li> Function prototypes:
        <ul>
            <li><code >OutputIterator set_union(InputIterator1 first1, InputIterator1
last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result);</code>
            <li><code >OutputIterator set_union(InputIterator1 first1, InputIterator1
last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result,
Compare comp);</code>
        </ul>
        <li> Description:
        <ul>
            <li> The first prototype: a sorted sequence of the elements that
are present in either the range <code >[first1, last1)</code> or the range
<code >[first2, last2)</code> or in both ranges is returned, starting at <code >result</code>,
and ending at the <code >OutputIterator</code> returned by the function. The elements in
the two ranges must have been sorted using <a name="an2352"></a><code >operator&lt;</code> of the data type to
which the iterators point. Note that in the final range each element appears
only once.
            <li> The second prototype: a sorted sequence of the elements that
are present in either the range <code >[first1, last1)</code> or the range
<code >[first2, last2)</code> or in both ranges is returned, starting at <code >result</code>,
and ending at the <code >OutputIterator</code> returned by the function. The elements in
the two ranges must have been sorted using <code >comp</code> function object. Note that
in the final range each element appears only once.
        </ul>
        <li> Example:
        <pre>
    #include &lt;algorithm&gt;
    #include &lt;iostream&gt;
    #include &lt;string&gt;
    #include &lt;cstring&gt;
    #include &lt;iterator&gt;
    using namespace std;

    bool caseless(string const &amp;left, string const &amp;right)
    {
        return strcasecmp(left.c_str(), right.c_str()) &lt; 0;
    }
    int main()
    {
        string set1[] = { "kilo", "lima", "mike", "november",
                          "oscar", "papa", "quebec" };
        string set2[] = { "papa", "quebec", "romeo"};
        string result[8];

        copy(result,
            set_union(set1, set1 + 7, set2, set2 + 3, result),
            ostream_iterator&lt;string&gt;(cout, " "));
        cout &lt;&lt; '\n';

        string set3[] = { "PAPA", "QUEBEC", "ROMEO"};

        copy(result,
            set_union(set1, set1 + 7, set3, set3 + 3, result, caseless),
            ostream_iterator&lt;string&gt;(cout, " "));
        cout &lt;&lt; '\n';
    }
    /*
        Displays:
            kilo lima mike november oscar papa quebec romeo
            kilo lima mike november oscar papa quebec ROMEO
    */
</pre>
    </ul>
<p>
<a name="SORT"></a><a name="l441"></a>
<h3 >19.1.58: sort</h3>
    <a name="an2353"></a>
    <ul>
        <li> Header file: <code >&lt;algorithm&gt;</code>
        <li> Function prototypes:
        <ul>
            <li><code >void sort(RandomAccessIterator first,
                RandomAccessIterator last);</code>
            <li><code >void sort(RandomAccessIterator first,
                RandomAccessIterator last, Compare comp);</code>
        </ul>
        <li> Description:
        <ul>
           <li> The first prototype: the elements in the range <code >[first,
last)</code> are sorted in ascending order using <a name="an2354"></a><code >operator&lt;</code> of the data type to
which the iterators point.
            <li> The second prototype: the elements in the range
<code >[first, last)</code> are sorted in ascending order using the <code >comp</code>
function object to compare the elements. The binary predicate <code >comp</code>
should return <code >true</code> if its first argument should be placed earlier in the
sorted sequence than its second argument.
        </ul>
        <li> Example:
        <pre>
    #include &lt;algorithm&gt;
    #include &lt;iostream&gt;
    #include &lt;string&gt;
    #include &lt;functional&gt;
    #include &lt;iterator&gt;
    using namespace std;

    int main()
    {
        string words[] = {"november", "kilo", "mike", "lima",
                          "oscar", "quebec", "papa"};

        sort(words, words + 7);
        copy(words, words + 7, ostream_iterator&lt;string&gt;(cout, " "));
        cout &lt;&lt; '\n';

        sort(words, words + 7, greater&lt;string&gt;());
        copy(words, words + 7, ostream_iterator&lt;string&gt;(cout, " "));
        cout &lt;&lt; '\n';
    }
    /*
        Displays:
            kilo lima mike november oscar papa quebec
            quebec papa oscar november mike lima kilo
    */
</pre>
    </ul>
<p>
<a name="STABPART"></a><a name="l442"></a>
<h3 >19.1.59: stable_partition</h3>
    <a name="an2355"></a>
    <ul>
        <li> Header file: <code >&lt;algorithm&gt;</code>
        <li> Function prototype:
        <ul>
            <li><code >BidirectionalIterator stable_partition(BidirectionalIterator
first, BidirectionalIterator last, UnaryPredicate pred);</code>
        </ul>
        <li> Description:
        <ul>
            <li> All elements in the range <code >[first, last)</code> for which the
unary predicate <code >pred</code> evaluates as <code >true</code> are placed before the elements
which evaluate as <code >false</code>. Apart from this reordering, the relative order of
all elements for which the predicate evaluates to <code >false</code> and the relative
order of all elements for which the predicate evaluates to <code >true</code> is kept.
The return value points just beyond the last element in the
partitioned range for which <code >pred</code> evaluates as <code >true</code>.
        </ul>
        <li> Example:
        <pre>
    #include &lt;algorithm&gt;
    #include &lt;iostream&gt;
    #include &lt;string&gt;
    #include &lt;functional&gt;
    #include &lt;iterator&gt;
    using namespace std;

    int main()
    {
        int org[] = {1, 3, 5, 7, 9, 10, 2, 8, 6, 4};
        int ia[10];
        int *split;

        copy(org, org + 10, ia);
        split = partition(ia, ia + 10, bind2nd(less_equal&lt;int&gt;(), ia[9]));
        cout &lt;&lt; "Last element &lt;= 4 is ia[" &lt;&lt; split - ia - 1 &lt;&lt; "]\n";

        copy(ia, ia + 10, ostream_iterator&lt;int&gt;(cout, " "));
        cout &lt;&lt; '\n';

        copy(org, org + 10, ia);
        split = stable_partition(ia, ia + 10,
                                    bind2nd(less_equal&lt;int&gt;(), ia[9]));
        cout &lt;&lt; "Last element &lt;= 4 is ia[" &lt;&lt; split - ia - 1 &lt;&lt; "]\n";

        copy(ia, ia + 10, ostream_iterator&lt;int&gt;(cout, " "));
        cout &lt;&lt; '\n';
    }
    /*
        Displays:
            Last element &lt;= 4 is ia[3]
            1 3 4 2 9 10 7 8 6 5
            Last element &lt;= 4 is ia[3]
            1 3 2 4 5 7 9 10 8 6
    */
</pre>
    </ul>
<p>
<a name="STABSORT"></a><a name="l443"></a>
<h3 >19.1.60: stable_sort</h3>
    <a name="an2356"></a>
    <ul>
        <li> Header file: <code >&lt;algorithm&gt;</code>
        <li> Function prototypes:
        <ul>
            <li><code >void stable_sort(RandomAccessIterator first,
                RandomAccessIterator last);</code>
            <li><code >void stable_sort(RandomAccessIterator first,
                RandomAccessIterator last, Compare comp);</code>
        </ul>
        <li> Description:
        <ul>
           <li> The first prototype: the elements in the range <code >[first,
last)</code> are stable-sorted in ascending order using <a name="an2357"></a><code >operator&lt;</code> of the data
type to which the iterators point: the relative order of equal elements is
kept.
            <li> The second prototype: the elements in the range
<code >[first, last)</code> are stable-sorted in ascending order using the <code >comp</code>
binary predicate to compare the elements. This predicate should return
<code >true</code> if its first argument should be placed before its second argument in
the sorted set of element.
        </ul>
        <li> Example (annotated below):
        <pre>
    #include &lt;algorithm&gt;
    #include &lt;iostream&gt;
    #include &lt;string&gt;
    #include &lt;vector&gt;
    #include &lt;iterator&gt;
    using namespace std;

    struct Pss: public pair&lt;string, string&gt;                         // 1
    {
        Pss(string const &amp;s1, string const &amp;s2)
        :
            pair&lt;string, string&gt;(s1, s2)
        {}
    };
    ostream &amp;operator&lt;&lt;(ostream &amp;out, Pss const &amp;p)                 // 2
    {
        return out &lt;&lt; "    " &lt;&lt; p.first &lt;&lt; " " &lt;&lt; p.second &lt;&lt; '\n';
    }
    class Sortby
    {
        string Pss::*d_field;
        public:
            Sortby(string Pss::*field)                              // 3
            :
                d_field(field)
            {}
            bool operator()(Pss const &amp;p1, Pss const &amp;p2) const     // 4
            {
                return p1.*d_field &lt; p2.*d_field;
            }
    };
    int main()
    {
        vector&lt;Pss&gt; namecity {                                      // 5
                Pss("Hampson",   "Godalming"),
                Pss("Moran",     "Eugene"),
                Pss("Goldberg",  "Eugene"),
                Pss("Moran",     "Godalming"),
                Pss("Goldberg",  "Chicago"),
                Pss("Hampson",   "Eugene")
        };

        sort(namecity.begin(), namecity.end(), Sortby{ &amp;Pss::first });// 6

        cout &lt;&lt; "sorted by names:\n";
        copy(namecity.begin(), namecity.end(),
                                            ostream_iterator&lt;Pss&gt;{ cout });

                                                                    // 7
        stable_sort(namecity.begin(), namecity.end(),
                                            Sortby{ &amp;Pss::second });

        cout &lt;&lt; "sorted by names within sorted cities:\n";
        copy(namecity.begin(), namecity.end(),
                                            ostream_iterator&lt;Pss&gt;{ cout });
    }
    /*
        Displays:
            sorted by names:
                Goldberg Eugene
                Goldberg Chicago
                Hampson Godalming
                Hampson Eugene
                Moran Eugene
                Moran Godalming
            sorted by names within sorted cities:
                Goldberg Chicago
                Goldberg Eugene
                Hampson Eugene
                Moran Eugene
                Hampson Godalming
                Moran Godalming
    */
</pre>
    </ul>
    Note that the example implements a solution to an often occurring problem:
how to <a name="an2358"></a> sort using multiple hierarchal
criteria. The example deserves some additional attention:
    <ul>
    <li> First, at <code >// 1</code> a <a name="an2359"></a>wrapper struct <code >Pss</code> is created around
<code >std::pair&lt;std::string, std::string&gt;</code>. The intent here is to define a type
that is a wrapper around a class that is defined in the <code >std</code> namespace for
which no insertion operation has been defined. This struct design conflicts
with the principles outlined in section <a href="cplusplus14.html#INHERITWHY">14.7</a>. However, inheritance
is defensible here as the intention is not to add `missing features' and as
<code >pair</code> itself is in essence just <a href="cplusplus09.html#POD">Plain Old Data</a>.
    <li> Next (<code >// 2</code>), <code >operator</code>&lt;&lt; is overloaded for <code >Pss</code> objects.
Although the compiler wouldn't have complained if this operator had been
defined in the <code >std</code> namespace for the <code >pair&lt;string, string&gt;</code> type, this
would also have been bad style as the
    <a name="an2360"></a><a name="an2361"></a> <code >std</code>
namespace is <em >off limits</em> to ordinary programs. By defining a wrapper type
around <code >pair&lt;string, string&gt;</code> bad style can be prevented.
    <li> Then (<code >// 3</code>), a class <code >Sortby</code> is defined, allowing us to
construct an anonymous object receiving a pointer to one of the
<code >Pss</code> data members that are used for sorting. In this case, as both members
are <code >string</code> objects, its constructor can easily be defined. It expects
a pointer to a <code >string</code> member of the class <code >Pss</code>.
    <li> <code >Sortby</code>'s <code >operator()</code> member (<code >// 4</code>) receives two references
to <code >Pss</code> objects and uses its pointer to member to compare the appropriate
fields of the <code >Pss</code> objects.
    <li> In <code >main</code> some data is stored in a <code >vector</code> (<code >// 5</code>).
    <li> Then (<code >// 6</code>) the first sort takes place. The least important
criterion must be sorted first and for this a simple <code >sort</code> suffices. Since
we want the names to be sorted within cities, the names represent the least
important criterion, so we sort by names: <code >Sortby(&amp;Pss::first)</code>.
    <li> The next important criterion, the cities, are sorted next (<code >//
7</code>). Since the relative ordering of the <em >names</em> are not altered anymore by
<code >stable_sort</code>, the ties that are observed when cities are sorted are solved
in such a way that the existing relative ordering is not broken. So, we end up
getting Goldberg in Eugene before Hampson in Eugene, before Moran in
Eugene. To sort by cities, we use another anonymous <code >Sortby</code> object:
<code >Sortby(&amp;Pss::second)</code>.
    </ul>
<p>
<a name="SWAP"></a><a name="l444"></a>
<h3 >19.1.61: swap</h3>
    <a name="an2362"></a>
<ul>
    <li> Header file: <code >&lt;algorithm&gt;</code>
    <li> Function prototype:
    <ul>
        <li><code >void swap(Type &amp;object1, Type &amp;object2);</code>
    </ul>
    <li> Description:
    <ul>
        <li> The elements <code >object1</code> and <code >object2</code> exchange their values.
    They do so by either cyclic copy assignment or cyclic move assignment (if
    available).
    </ul>
    <li> Example:
    <pre>
    #include &lt;algorithm&gt;
    #include &lt;iostream&gt;
    #include &lt;string&gt;
    #include &lt;iterator&gt;
    using namespace std;

    int main()
    {
        string first[] = {"alpha", "bravo", "charley"};
        string second[] = {"echo", "foxtrot", "golf"};
        size_t const n = sizeof(first) / sizeof(string);

        cout &lt;&lt; "Before:\n";
        copy(first, first + n, ostream_iterator&lt;string&gt;(cout, " "));
        cout &lt;&lt; '\n';
        copy(second, second + n, ostream_iterator&lt;string&gt;(cout, " "));
        cout &lt;&lt; '\n';

        for (size_t idx = 0; idx &lt; n; ++idx)
            swap(first[idx], second[idx]);

        cout &lt;&lt; "After:\n";
        copy(first, first + n, ostream_iterator&lt;string&gt;(cout, " "));
        cout &lt;&lt; '\n';
        copy(second, second + n, ostream_iterator&lt;string&gt;(cout, " "));
        cout &lt;&lt; '\n';
    }
    /*
        Displays:
            Before:
            alpha bravo charley
            echo foxtrot golf
            After:
            echo foxtrot golf
            alpha bravo charley
    */
</pre>
</ul>
<p>
<a name="SWAPRAN"></a><a name="l445"></a>
<h3 >19.1.62: swap_ranges</h3>
    <a name="an2363"></a>
<ul>
    <li> Header file: <code >&lt;algorithm&gt;</code>
    <li> Function prototype:
    <ul>
        <li><code >ForwardIterator2 swap_ranges(ForwardIterator1 first1,
            ForwardIterator1 last1, ForwardIterator2 result);</code>
    </ul>
    <li> Description:
    <ul>
        <li> The elements in the range pointed to by <code >[first1, last1)</code>
are swapped with the elements in the range <code >[result, returnvalue)</code>, where
<code >returnvalue</code> is the value returned by the function. The two ranges must be
disjoint.
    </ul>
    <li> Example:
    <pre>
    #include &lt;algorithm&gt;
    #include &lt;iostream&gt;
    #include &lt;string&gt;
    #include &lt;iterator&gt;
    using namespace std;

    int main()
    {
        string first[] = {"alpha", "bravo", "charley"};
        string second[] = {"echo", "foxtrot", "golf"};
        size_t const n = sizeof(first) / sizeof(string);

        cout &lt;&lt; "Before:\n";
        copy(first, first + n, ostream_iterator&lt;string&gt;(cout, " "));
        cout &lt;&lt; '\n';
        copy(second, second + n, ostream_iterator&lt;string&gt;(cout, " "));
        cout &lt;&lt; '\n';

        swap_ranges(first, first + n, second);

        cout &lt;&lt; "After:\n";
        copy(first, first + n, ostream_iterator&lt;string&gt;(cout, " "));
        cout &lt;&lt; '\n';
        copy(second, second + n, ostream_iterator&lt;string&gt;(cout, " "));
        cout &lt;&lt; '\n';
    }
    /*
        Displays:
            Before:
            alpha bravo charley
            echo foxtrot golf
            After:
            echo foxtrot golf
            alpha bravo charley
    */
</pre>
</ul>
<p>
<a name="TRANSFORM"></a><a name="l446"></a>
<h3 >19.1.63: transform</h3>
    <a name="an2364"></a>
    <ul>
        <li> Header file: <code >&lt;algorithm&gt;</code>
        <li> Function prototypes:
        <ul>
            <li><code >OutputIterator transform(InputIterator first, InputIterator
last, OutputIterator result, UnaryOperator op);</code>
            <li><code >OutputIterator transform(InputIterator1 first1, InputIterator1
last1, InputIterator2 first2, OutputIterator result, BinaryOperator op);</code>
        </ul>
        <li> Description:
        <ul>
            <li> The first prototype: the unary operator <code >op</code> is applied to
each of the elements in the range <code >[first, last)</code>, and the resulting
values are stored in the range starting at <code >result</code>. The return value points
just beyond the last generated element.
            <li> The second prototype: the binary operator <code >op</code> is applied
to each of the elements in the range <code >[first1, last1)</code> and the
corresponding element in the second range starting at <code >first2</code>. The
resulting values are stored in the range starting at <code >result</code>. The return
value points just beyond the last generated element.
        </ul>
        <li> Example:
        <pre>
    #include &lt;functional&gt;
    #include &lt;vector&gt;
    #include &lt;algorithm&gt;
    #include &lt;iostream&gt;
    #include &lt;string&gt;
    #include &lt;cctype&gt;
    #include &lt;iterator&gt;
    using namespace std;

    string caps(string const &amp;src)
    {
        string tmp;
        tmp.resize(src.length());

        transform(src.begin(), src.end(), tmp.begin(), ::toupper);
        return tmp;
    }
    int main()
    {
        string words[] = {"alpha", "bravo", "charley"};

        copy(words, transform(words, words + 3, words, caps),
                                ostream_iterator&lt;string&gt;(cout, " "));
        cout &lt;&lt; '\n';

        int         values[] = {1, 2, 3, 4, 5};
        vector&lt;int&gt; squares;

        transform(values, values + 5, values,
                                back_inserter(squares), multiplies&lt;int&gt;());

        copy(squares.begin(), squares.end(),
                                ostream_iterator&lt;int&gt;(cout, " "));
        cout &lt;&lt; '\n';
    }
    /*
        Displays:
            ALPHA BRAVO CHARLEY
            1 4 9 16 25
    */
</pre>
    </ul>
    the following differences between the <code >for_each</code> (section
<a href="cplusplus19.html#FOREACH">19.1.18</a>) and <code >transform</code> generic algorithms should be noted:
    <a name="an2365"></a><a name="an2366"></a>
    <ul>
        <li> With <code >transform</code> the <em >return value</em> of the function
object's <code >operator()</code> member is used; the argument that is passed to the
<code >operator()</code> member itself is not changed.
        <li> With <code >for_each</code> the function object's <code >operator()</code>
receives a reference to an argument, which itself may be changed by the
function object's <code >operator()</code>.
    </ul>
    Also note that the range-based for loop can often be used instead of the
<code >transform</code> generic algorithm. However, but different from the
range-based for-loop the <code >transform</code> algoritm can also be used width
sub-ranges and with reverse-iterators.
<p>
<a name="UNIQUE"></a><a name="l447"></a>
<h3 >19.1.64: unique</h3>
    <a name="an2367"></a>
    <ul>
        <li> Header file: <code >&lt;algorithm&gt;</code>
        <li> Function prototypes:
        <ul>
            <li><code >ForwardIterator unique(ForwardIterator first,
ForwardIterator last);</code>
            <li><code >ForwardIterator unique(ForwardIterator first,
ForwardIterator last, BinaryPredicate pred);</code>
        </ul>
        <li> Description:
        <ul>
            <li> The first prototype: using <a name="an2368"></a><code >operator==</code> of the data type to
which the iterators point, all but the first of consecutively equal elements
in the range pointed to by <code >[first, last)</code> are relocated to the end of
the range. The returned forward iterator marks the beginning of the
<a name="an2369"></a><em >leftover</em>. All elements in the range <code >[first, return-value)</code> are
unique, all elements in the range <code >[return-value, last)</code> are equal to
elements in the range <code >[first, return-value)</code>.
            <li> The second prototype: all but the first of consecutive
elements in the range pointed to by <code >[first, last)</code> for which the binary
predicate <code >pred</code> (expecting two arguments of the data type to which the
iterators point) returns <code >true</code>, are relocated to the end of the range. The
returned forward iterator marks the beginning of the <a name="an2370"></a><em >leftover</em>. For all
pairs of elements in the range <code >[first, return-value)</code> <code >pred</code> returns
<code >false</code> (i.e., they are <em >unique</em>), while <code >pred</code> returns <code >true</code> for a
combination of, as its first operand, an element in the range
    <code >[return-value, last)</code> and, as its second operand, an element in the
range <code >[first, return-value)</code>.
            </ul>
        <li> Example:
        <pre>
    #include &lt;algorithm&gt;
    #include &lt;iostream&gt;
    #include &lt;string&gt;
    #include &lt;cstring&gt;
    #include &lt;iterator&gt;
    using namespace std;

    bool casestring(string const &amp;first, string const &amp;second)
    {
        return strcasecmp(first.c_str(), second.c_str()) == 0;
    }
    int main()
    {
        string words[] = {"alpha", "alpha", "Alpha", "papa", "quebec" };
        size_t const size = sizeof(words) / sizeof(string);

        string *removed = unique(words, words + size);
        copy(words, removed, ostream_iterator&lt;string&gt;(cout, " "));
        cout &lt;&lt; '\n'
             &lt;&lt; "Trailing elements are:\n";
        copy(removed, words + size, ostream_iterator&lt;string&gt;(cout, " "));
        cout &lt;&lt; '\n';

        removed = unique(words, words + size, casestring);
        copy(words, removed, ostream_iterator&lt;string&gt;(cout, " "));
        cout &lt;&lt; '\n'
             &lt;&lt; "Trailing elements are:\n";
        copy(removed, words + size, ostream_iterator&lt;string&gt;(cout, " "));
        cout &lt;&lt; '\n';
    }
    /*
        Displays:
            alpha Alpha papa quebec
            Trailing elements are:
            quebec
            alpha papa quebec
            Trailing elements are:
            quebec quebec
    */
</pre>
    </ul>
<p>
<a name="UNIQUECP"></a><a name="l448"></a>
<h3 >19.1.65: unique_copy</h3>
    <a name="an2371"></a>
    <ul>
        <li> Header file: <code >&lt;algorithm&gt;</code>
        <li> Function prototypes:
        <ul>
            <li><code >OutputIterator unique_copy(InputIterator first,
InputIterator last, OutputIterator result);</code>
            <li><code >OutputIterator unique_copy(InputIterator first,
InputIterator last, OutputIterator result, BinaryPredicate pred);</code>
        </ul>
        <li> Description:
        <ul>
            <li> The first prototype: the elements in the range <code >[first,
last)</code> are copied to the resulting container, starting at <code >result</code>.
Consecutively equal elements (using <a name="an2372"></a><code >operator==</code> of the data type to which
the iterators point) are copied only once (keeping the first of a series of
equal elements). The returned output iterator points
just beyond the last copied element.
            <li> The second prototype: the elements in the range
<code >[first, last)</code> are copied to the resulting container, starting at
<code >result</code>.  Consecutive elements in the range pointed to by <code >[first,
last)</code> for which the binary predicate <code >pred</code> returns <code >true</code> are copied only
once (keeping the first of a series of equal elements). The returned output
iterator points just beyond the last copied element.
        </ul>
        <li> Example:
        <pre>
    #include &lt;algorithm&gt;
    #include &lt;iostream&gt;
    #include &lt;string&gt;
    #include &lt;vector&gt;
    #include &lt;iterator&gt;
    #include &lt;cstring&gt;
    using namespace std;

    bool casestring(string const &amp;first, string const &amp;second)
    {
        return strcasecmp(first.c_str(), second.c_str()) == 0;
    }
    int main()
    {
        string words[] = {"oscar", "Alpha", "alpha", "alpha",
                                                        "papa", "quebec" };
        size_t const size = sizeof(words) / sizeof(string);
        vector&lt;string&gt; remaining;

        unique_copy(words, words + size, back_inserter(remaining));

        copy(remaining.begin(), remaining.end(),
                ostream_iterator&lt;string&gt;(cout, " "));
        cout &lt;&lt; '\n';

        vector&lt;string&gt; remaining2;

        unique_copy(words, words + size,
                                back_inserter(remaining2), casestring);

        copy(remaining2.begin(), remaining2.end(),
                ostream_iterator&lt;string&gt;(cout, " "));
        cout &lt;&lt; '\n';
    }
    /*
        Displays:
            oscar Alpha alpha papa quebec
            oscar Alpha papa quebec
    */
</pre>
    </ul>
<p>
<a name="UPPERBOUND"></a><a name="l449"></a>
<h3 >19.1.66: upper_bound</h3>
    <a name="an2373"></a>
    <ul>
        <li> Header file: <code >&lt;algorithm&gt;</code>
        <li> Function prototypes:
        <ul>
            <li><code >ForwardIterator upper_bound(ForwardIterator first,
ForwardIterator last, Type const &amp;value);</code>
            <li><code >ForwardIterator upper_bound(ForwardIterator first,
ForwardIterator last, Type const &amp;value, Compare comp);</code>
        </ul>
        <li> Description:
        <ul>
            <li> The first prototype: the sorted elements (using ascending
sort) stored in the iterator range <code >[first, last)</code> are searched for the
first element that is greater than <code >value</code>. The returned iterator marks the
first location in the sequence where <code >value</code> can be inserted without
breaking the sorted order of the elements using <a name="an2374"></a><code >operator&lt;</code> of the data type
to which the iterators point. If no such element is found, <code >last</code> is
returned.
            <li> The second prototype: the elements implied by the iterator
range <code >[first, last)</code> must have been sorted using the <code >comp</code> function
or function object. Each element in the range is compared to <code >value</code> using
the <code >comp</code> function. An iterator to the first element for which the binary
predicate <code >comp</code>, applied to the elements of the range and <code >value</code>,
returns <code >true</code> is returned.  If no such element is found, <code >last</code> is
returned.
        </ul>
        <li> Example:
        <pre>
    #include &lt;algorithm&gt;
    #include &lt;iostream&gt;
    #include &lt;functional&gt;
    #include &lt;iterator&gt;
    using namespace std;

    int main()
    {
        int         ia[] = {10, 15, 15, 20, 30};
        size_t    n = sizeof(ia) / sizeof(int);

        cout &lt;&lt; "Sequence: ";
        copy(ia, ia + n, ostream_iterator&lt;int&gt;(cout, " "));
        cout &lt;&lt; '\n';

        cout &lt;&lt; "15 can be inserted before " &lt;&lt;
                *upper_bound(ia, ia + n, 15) &lt;&lt; '\n';
        cout &lt;&lt; "35 can be inserted after " &lt;&lt;
                (upper_bound(ia, ia + n, 35) == ia + n ?
                                    "the last element" : "???") &lt;&lt; '\n';

        sort(ia, ia + n, greater&lt;int&gt;());

        cout &lt;&lt; "Sequence: ";
        copy(ia, ia + n, ostream_iterator&lt;int&gt;(cout, " "));
        cout &lt;&lt; '\n';

        cout &lt;&lt; "15 can be inserted before " &lt;&lt;
                *upper_bound(ia, ia + n, 15, greater&lt;int&gt;()) &lt;&lt; '\n';
        cout &lt;&lt; "35 can be inserted before " &lt;&lt;
                (upper_bound(ia, ia + n, 35, greater&lt;int&gt;()) == ia ?
                                    "the first element " : "???") &lt;&lt; '\n';
    }
    /*
        Displays:
            Sequence: 10 15 15 20 30
            15 can be inserted before 20
            35 can be inserted after the last element
            Sequence: 30 20 15 15 10
            15 can be inserted before 10
            35 can be inserted before the first element
    */
</pre>
    </ul>
<p>
<a name="l450"></a>
<h3 >19.1.67: Heap algorithms</h3>
    A <a name="an2375"></a>heap is a kind of <a name="an2376"></a>binary tree which can be represented by an array. In
the standard heap, the key of an element is not smaller than the key of its
children. This kind of heap is called a <em >max heap</em>.  A tree in which
numbers are keys could be organized as shown in figure <a href="cplusplus19.html#heaptree">22</a>.
    <p><a name="heaptree"></a><figure >
<img src="stl/heap.gif" >
<figcaption >Figure 22: A binary tree representation of a heap</figcaption>
</figure></p>

    Such a tree may also be organized in an array:
        <pre>
        12, 11, 10, 8, 9, 7, 6, 1, 2, 4, 3, 5
</pre>
    In the following description, keep two pointers into this array in mind:
a  pointer <code >node</code> indicates the location of the next node of the tree, a
pointer <code >child</code> points to the next element which is a child of the <code >node</code>
pointer. Initially, <code >node</code> points to the first element, and <code >child</code> points
to the second element.
    <ul>
    <li><code >*node++ (== 12)</code>. 12 is the top node. its children are <code >*child++</code>
(11) and <code >*child++</code> (10), both less than 12.
    <li> The next node (<code >*node++ (== 11)</code>), in turn, has <code >*child++</code> (8)
and <code >*child++</code> (9) as its children.
    <li> The next node (<code >*node++ (== 10)</code>) has <code >*child++</code> (7)
and <code >*child++</code> (6) as its children.
    <li> The next node (<code >*node++ (== 8)</code>) has <code >*child++</code> (1)
and <code >*child++</code> (2) as its children.
    <li> Then, node (<code >*node++ (== 9)</code>) has children <code >*child++</code> (4)
and <code >*child++</code> (3).
    <li> Finally (as far as children are concerned) (<code >*node++ (== 7)</code>) has
one child <code >*child++</code> (5)
    </ul>
    Since <code >child</code> now points beyond the array, the remaining nodes have no
children. So, nodes 6, 1, 2, 4, 3 and 5 don't have children.
<p>
Note that the left and right branches are not ordered: 8 is less than 9, but 7
is larger than 6.
<p>
A heap is created by traversing a binary tree level-wise, starting from the
top node. The top node is 12, at the zeroth level. At the first level we find
11 and 10. At the second level 8, 9, 7 and 6 are found, etc.
<p>
Heaps can be constructed in containers supporting random access. So, a list is
not an appropriate data structure for a heap. Heaps can be constructed from an
(unsorted) array (using <a href="cplusplus19.html#MAKEHEAP"><code >make_heap</code></a>). The top-element can
be pruned from a heap, followed by reordering the heap (using
<a href="cplusplus19.html#POPHEAP"><code >pop_heap</code></a>), a new element can be added to the heap,
followed by reordering the heap (using <a href="cplusplus19.html#PUSHHEAP"><code >push_heap</code></a>), and
the elements in a heap can be sorted (using <a href="cplusplus19.html#SORTHEAP"><code >sort_heap</code></a>,
which, of course, invalidates the heap).
<p>
<a name="MAKEHEAP"></a><a name="l451"></a>
<h4>19.1.67.1: The `make_heap' function</h4>
        <a name="an2377"></a>
    <ul>
        <li> Header file: <code >&lt;algorithm&gt;</code>
        <li> Function prototypes:
        <ul>
            <li><code >void make_heap(RandomAccessIterator first,
RandomAccessIterator last);</code>
            <li><code >void make_heap(RandomAccessIterator first,
RandomAccessIterator last, Compare comp);</code>
        </ul>
        <li> Description:
        <ul>
            <li> The first prototype: the elements in the range <code >[first,
last)</code> are reordered to form a <a name="an2378"></a>max-heap using <a name="an2379"></a><code >operator&lt;</code> of the data
type to which the iterators point.
            <li> The second prototype: the elements in the range <code >[first,
last)</code> are reordered to form a max-heap using the binary comparison function
object <code >comp</code> to compare elements.
        </ul>
        
        <li> Follow this link for a small <a href="cplusplus19.html#HEAPDEMO">example</a> of a program
using <code >make_heap</code>.
    </ul>
<p>
<a name="POPHEAP"></a><a name="l452"></a>
<h4>19.1.67.2: The `pop_heap' function</h4>
        <a name="an2380"></a>
    <ul>
        <li> Header file: <code >&lt;algorithm&gt;</code>
        <li> Function prototypes:
        <ul>
            <li><code >void pop_heap(RandomAccessIterator first,
RandomAccessIterator last);</code>
            <li><code >void pop_heap(RandomAccessIterator first,
RandomAccessIterator last, Compare comp);</code>
        </ul>
        <li> Description:
        <ul>
            <li> The first prototype: the first element in the range
<code >[first, last)</code> is moved to <code >last - 1</code>. Then, the elements in the range
<code >[first, last - 1)</code> are reordered to form a max-heap using the
<code >operator&lt;</code> of the data type to which the iterators point.
            <li> The second prototype: the first element in the range
<code >[first, last)</code> is moved to <code >last - 1</code>. Then, the elements in the range
<code >[first, last - 1)</code> are reordered to form a max-heap using the binary
comparison function object <code >comp</code> to compare elements.
        </ul>
        
        <li> Follow this link for a small <a href="cplusplus19.html#HEAPDEMO">example</a> of a program
using <code >pop_heap</code>.
    </ul>
<p>
<a name="PUSHHEAP"></a><a name="l453"></a>
<h4>19.1.67.3: The `push_heap' function</h4>
        <a name="an2381"></a>
    <ul>
        <li> Header file: <code >&lt;algorithm&gt;</code>
        <li> Function prototypes:
        <ul>
            <li><code >void push_heap(RandomAccessIterator first,
RandomAccessIterator last);</code>
            <li><code >void push_heap(RandomAccessIterator first,
RandomAccessIterator last, Compare comp);</code>
        </ul>
        <li> Description:
        <ul>
            <li> The first prototype: assuming that the range <code >[first,
last - 1)</code> contains a valid heap, and the element at <code >last - 1</code> contains an
element to be added to the heap, the elements in the range <code >[first, last
- 1)</code> are reordered to form a max-heap using the <code >operator&lt;</code> of the data
type to which the iterators point.
            <li> The second prototype: assuming that the range <code >[first,
last - 1)</code> contains a valid heap, and the element at <code >last - 1</code> contains an
element to be added to the heap, the elements in the range <code >[first, last
- 1)</code> are reordered to form a max-heap using the binary comparison function
object <code >comp</code> to compare elements.
        </ul>
        
        <li> Follow this link for a small <a href="cplusplus19.html#HEAPDEMO">example</a> of a program
using <code >push_heap</code>.
    </ul>
<p>
<a name="SORTHEAP"></a><a name="l454"></a>
<h4>19.1.67.4: The `sort_heap' function</h4>
        <a name="an2382"></a>
    <ul>
        <li> Header file: <code >&lt;algorithm&gt;</code>
        <li> Function prototypes:
        <ul>
            <li><code >void sort_heap(RandomAccessIterator first,
RandomAccessIterator last);</code>
            <li><code >void sort_heap(RandomAccessIterator first,
RandomAccessIterator last, Compare comp);</code>
        </ul>
        <li> Description:
        <ul>
            <li> The first prototype: assuming the elements in the range
<code >[first, last)</code> form a valid max-heap, the elements in the range
<code >[first, last)</code> are sorted using <a name="an2383"></a><code >operator&lt;</code> of the data type to
which the iterators point.
            <li> The second prototype: assuming the elements in the range
<code >[first, last)</code> form a valid heap, the elements in the range
<code >[first, last)</code> are sorted using the binary comparison function
object <code >comp</code> to compare elements.
        </ul>
        
        <li> Follow this link for a small <a href="cplusplus19.html#HEAPDEMO">example</a> of a program
using <code >sort_heap</code>.
    </ul>
<p>
<a name="HEAPDEMO"></a><a name="l455"></a>
<h4>19.1.67.5: An example using the heap functions</h4>
        Here is an example showing the various generic algorithms manipulating heaps:
        <pre>
    #include &lt;algorithm&gt;
    #include &lt;iostream&gt;
    #include &lt;functional&gt;
    #include &lt;iterator&gt;
    using namespace std;

    void show(int *ia, char const *header)
    {
        cout &lt;&lt; header &lt;&lt; ":\n";
        copy(ia, ia + 20, ostream_iterator&lt;int&gt;(cout, " "));
        cout &lt;&lt; '\n';
    }
    int main()
    {
        int ia[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
                    11, 12, 13, 14, 15, 16, 17, 18, 19, 20};

        make_heap(ia, ia + 20);
        show(ia, "The values 1-20 in a max-heap");

        pop_heap(ia, ia + 20);
        show(ia, "Removing the first element (now at the end)");

        push_heap(ia, ia + 20);
        show(ia, "Adding 20 (at the end) to the heap again");

        sort_heap(ia, ia + 20);
        show(ia, "Sorting the elements in the heap");


        make_heap(ia, ia + 20, greater&lt;int&gt;());
        show(ia, "The values 1-20 in a heap, using &gt; (and beyond too)");

        pop_heap(ia, ia + 20, greater&lt;int&gt;());
        show(ia, "Removing the first element (now at the end)");

        push_heap(ia, ia + 20, greater&lt;int&gt;());
        show(ia, "Re-adding the removed element");

        sort_heap(ia, ia + 20, greater&lt;int&gt;());
        show(ia, "Sorting the elements in the heap");
    }
    /*
        Displays:
            The values 1-20 in a max-heap:
            20 19 15 18 11 13 14 17 9 10 2 12 6 3 7 16 8 4 1 5
            Removing the first element (now at the end):
            19 18 15 17 11 13 14 16 9 10 2 12 6 3 7 5 8 4 1 20
            Adding 20 (at the end) to the heap again:
            20 19 15 17 18 13 14 16 9 11 2 12 6 3 7 5 8 4 1 10
            Sorting the elements in the heap:
            1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
            The values 1-20 in a heap, using &gt; (and beyond too):
            1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
            Removing the first element (now at the end):
            2 4 3 8 5 6 7 16 9 10 11 12 13 14 15 20 17 18 19 1
            Re-adding the removed element:
            1 2 3 8 4 6 7 16 9 5 11 12 13 14 15 20 17 18 19 10
            Sorting the elements in the heap:
            20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1
    */
</pre>
<p>
<a name="MEMFUNADAPT"></a><a name="l456"></a>
<h2 >19.2: STL: More function adaptors</h2>
Before using the function adaptors presented in these (sub)sections the
<a name="an2384"></a><code >&lt;functional&gt;</code> header file must be included.
<p>
Member function adaptors are part of the Standard Template Library (STL). They
are most useful in combination with the <em >generic algorithms</em>, which is why
they are discussed in this chapter instead of the previous chapter which was
devoted to the STL.
<p>
The member function adaptors defined in the STL allow us to call
(parameterless) member functions of class objects as though they were
non-member functions and to compose unary or binary argument functions into
single function objects so that they can jointly be used with generic
algorithms.
<p>
In the next section calling member functions as non-member functions is
discussed; adaptable functions are covered thereafter.
<p>
<a name="ADAPTABLEFUN"></a><a name="l457"></a>
<h3 >19.2.1: Adaptable functions</h3>
    Within the context of the STL an <em >adaptable function</em> is a function object
defining
    <ul>
    <li><a name="an2385"></a><code >argument_type</code> as a synonym of the type of its unary function
operator's argument, and
    <li><a name="an2386"></a><code >first_argument_type</code> and <a name="an2387"></a><code >second_argument_type</code> as
synonyms of the types of its binary function operator's arguments
    </ul>
and defining <a name="an2388"></a><code >result_type</code> as the type of the return value of its function
call operator.
<p>
The STL defines <a name="an2389"></a><code >pointer_to_unary_function</code> and
<a name="an2390"></a><code >pointer_to_binary_function</code> as adaptors accepting pointers to,
respectively, unary and binary functions, converting them into adaptable
functions.  
<p>
When <code >ptr_fun</code> is provided with a unary function it uses
<code >pointer_to_unary_function</code> to create an <em >adaptable unary function</em> and it
uses <code >pointer_to_binary_function</code> when provided with a binary function to
create an <em >adaptable binary function</em>.
<p>
Note, however, that these adaptors, as well as <code >ptr_fun</code> are deprecated in
the upcoming <a name="an2391"></a>C++17 standard, as their use can easily be replaced by lambda
expressions.
<p>
Here is an example showing the use of <code >ptr_fun</code>, creating an adaptable
binary function. In <code >main</code>, the word to search for is extracted from the
standard input stream as well as additional words that are stored in a vector
of <code >string</code> objects. If the target word is found the program displays the
word following the target word in the vector of <code >string</code> objects. Searching
is performed case insensitively, for which the <code >POSIX</code> function
<a name="an2392"></a><code >strcasecmp</code> is used. Following the use of <code >ptr_fun</code> an equivalent
statement using a lambda expression is shown:
        <pre>
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;functional&gt;
#include &lt;cstring&gt;
#include &lt;string&gt;
#include &lt;iterator&gt;
#include &lt;iostream&gt;

using namespace std;

inline int stringcasecmp(string lhs, string rhs)
{
    return strcasecmp(lhs.c_str(), rhs.c_str());
}

int main()
{
    string target;
    cin &gt;&gt; target;

    vector&lt;string&gt; v1;
    copy(istream_iterator&lt;string&gt;(cin), istream_iterator&lt;string&gt;(),
        back_inserter(v1));

    auto pos = find_if(                         // deprecated in C++17
                    v1.begin(), v1.end(),
                    not1( bind2nd(ptr_fun(stringcasecmp), target) )
               );

                                                // preferred alternative:
    auto pos = find_if(v1.begin(), v1.end(),    // use a lambda expression
            [&amp;](auto const &amp;str)
            {
                return not stringcasecmp(str, target);

            }
        );

    if ( pos != v1.end())
       cout &lt;&lt;   "The search for `" &lt;&lt; target &lt;&lt; "' was successful.\n"
                 "The next string is: `" &lt;&lt; pos[1] &lt;&lt; "'.\n";
}

    // on input:
    //  VERY   I have existed for years, but very little has changed
    // the program displays:
    //  The search for `VERY' was successful.
    //  The next string is: `little'.
</pre>
<p>
The observant reader may have noticed that this is not a very efficient
program. The function <code >stringcasecmp</code> defines value type parameters forcing
the construction of copies of the arguments passed to <code >stringcasecmp</code> every
time it is called. But after changing the parameter definitions into
        <pre>
    inline int stringcasecmp(string const &amp;lhs, string const &amp;rhs)
</pre>
    the compiler generates an error message like:
        <pre>
In instantiation of 'std::binder2nd&lt;std::pointer_to_binary_function&lt;
        const std::string&amp;, const std::string&amp;, int&gt; &gt;':

    typename _Operation::result_type std::binder2nd&lt;_Operation&gt;::operator()(
            typename _Operation::first_argument_type&amp;) const
cannot be overloaded with:
    typename _Operation::result_type std::binder2nd&lt;_Operation&gt;::operator()(
            const typename _Operation::first_argument_type&amp;) const
</pre>
    The second <code >find_if</code> statement, however, compiles flawlessly after
changing <code >stringcasecmp's</code> value parameters into <code >const &amp;</code> parameters,
which is an additional reason for preferring the use of the lambda expression
in this example.
<p>

<hr>
<ul>
    <li> <a href="cplusplus.html">Table of Contents</a>
    <li> <a href="cplusplus18.html">Previous Chapter</a>
    <li> <a href="cplusplus20.html">Next Chapter</a>
</ul>
<hr>
</body>
</html>
