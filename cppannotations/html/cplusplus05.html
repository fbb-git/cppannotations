<!DOCTYPE html><html><head>
<meta charset="UTF-8">
<title> C++ Annotations Version 10.6.0 </title>
<link rel="stylesheet" type="text/css" href="cplusplus.css"><style type="text/css">
    figure {text-align: center;}
    img {vertical-align: center;}
</style>
<link rel="stylesheet" type="text/css" href="cplusplus.css"></head>
<body >
<hr>
<ul>
    <li> <a href="cplusplus.html">Table of Contents</a>
    <li> <a href="cplusplus04.html">Previous Chapter</a>
    <li> <a href="cplusplus06.html">Next Chapter</a>
</ul>
<hr>
<a name="String"></a><a name="l73"></a>
<h1 >Chapter 5: The `string' Data Type</h1>
<strong >C++</strong> offers many solutions for common problems. Most of these facilities
are part of the <em >Standard Template Library</em> or they are implemented as
<em >generic algorithms</em> (see chapter <a href="cplusplus19.html#GENERIC">19</a>).
<p>
Among the facilities <strong >C++</strong> programmers have developed over and over again
are those manipulating chunks of text, commonly called <em >strings</em>. The <strong >C</strong>
programming language offers rudimentary string support. <strong >C</strong>'s <a name="an294"></a><em >NTBS</em> is
the foundation upon which an enormous amount of code has been
built&nbsp;(An <em >NTBS</em> (null-terminated byte string, also <a name="an295"></a><em >NTB string</em>)
is a character sequence whose highest-addressed element with defined content
has the value zero (the terminating null character); no other character in the
sequence has the value zero.).
<p>
To process text <strong >C++</strong> offers a <a name="an296"></a><code >std::string</code> type. In <strong >C++</strong>
the traditional <strong >C</strong> library functions manipulating NTB strings are
deprecated in favor of using <code >string</code> objects. Many problems in <strong >C</strong>
programs are caused by buffer overruns, boundary errors and allocation
problems that can be traced back to improperly using these traditional <strong >C</strong>
string library functions. Many of these problems can be prevented using
<strong >C++</strong> string objects.
<p>
Actually, <code >string</code> objects are <em >class type</em> variables, and in that sense
they are comparable to stream objects like <code >cin</code> and <code >cout</code>. In this
section the use of <code >string</code> type objects is covered. The focus is on their
definition and their use. When using <code >string</code> objects the
    <a name="an297"></a><em >member function</em> <em >syntax</em> is commonly used:
    <pre>
        stringVariable.operation(argumentList)
</pre>
    For example, if <code >string1</code> and <code >string2</code> are variables of type
<code >std::string</code>, then
    <pre>
        string1.compare(string2)
</pre>
 can be used to compare both strings.
<p>
In addition to the common member functions the <code >string</code> class also offers a
wide variety of <em >operators</em>, like the assignment (<code >=</code>) and the comparison
operator (<code >==</code>). Operators often result in code that is easy to understand
and their use is generally preferred over the use of member functions offering
comparable functionality. E.g., rather than writing
        <pre>
    if (string1.compare(string2) == 0)
</pre>
    the following is generally preferred:
        <pre>
    if (string1 == string2)
</pre>
<p>
To define and use <code >string</code>-type objects, sources must include the header
file <a name="an298"></a><code >&lt;string&gt;</code>. To merely <a name="an299"></a> <em >declare</em> the string type
the header <a name="an300"></a>iosfwd can be included.
<p>
In addition to <code >std::string</code>, the header file <code >string</code> defines the
following string types:
    <ul>
    <li><a name="an301"></a><code >std::wstring</code>, a string type consisting of <code >wchar_t</code> characters;
    <li><a name="an302"></a><code >std::u16string</code>, a string type consisting of <code >char16_t</code> characters;
    <li><a name="an303"></a><code >std::u32string</code>, a string type consisting of <code >char32_t</code> characters.
    </ul>
<p>
<a name="l74"></a>
<h2 >5.1: Operations on strings</h2>
Some of the operations that can be performed on strings return indices within
the strings. Whenever such an operation fails to find an appropriate index,
the <em >value</em> <a name="an304"></a><code >string::npos</code> is returned. This value is a symbolic
value of type <a name="an305"></a><a name="an306"></a><code >string::size_type</code>, which is (for all practical
purposes) an (<code >unsigned</code>) <code >int</code>.
<p>
All <code >string</code> members accepting <code >string</code> objects as arguments also accept
<code >char const *</code> (NTBS) arguments. The same usually holds true
for operators accepting <code >string</code> objects.
<p>
Some <code >string</code>-members use <em >iterators</em>. Iterators are formally introduced
in section <a href="cplusplus18.html#ITERATORS">18.2</a>. Member functions using iterators are listed in
the next section (<a href="cplusplus05.html#STRINGOVERVIEW">5.2</a>), but the iterator concept itself
is not further covered by this chapter.
<p>
Strings support a large variety of members and operators. A short overview
listing their capabilities is provided in this section, with subsequent
sections offering a detailed discussion. The bottom line: <strong >C++</strong> strings are
extremely versatile and there is hardly a reason for falling back on the <strong >C</strong>
library to process text. <strong >C++</strong> strings handle all the required memory
management and thus memory related problems, which is the #1 source of
problems in <strong >C</strong> programs, can be prevented when <strong >C++</strong> strings are
used. Strings do come at a price, though. The class's extensive capabilities
have also turned it into a beast. It's hard to learn and master all its
features and in the end you'll find that not all that you expected is actually
there. For example, <code >std::string</code> doesn't offer case-insensitive
comparisons. But in the end it isn't even as simple as that. It <em >is</em> there,
but it is somewhat hidden and at this point in the <strong >C++</strong> Annotations it's too
early to study into that hidden corner yet. Instead, realize that <strong >C</strong>'s
standard library <em >does</em> offer useful functions that can be used as long as
we're aware of their limitations and are able to avoid their traps. So for
now, to perform a traditional <a name="an307"></a>case-insensitive comparison of the contents
of two <code >std::string</code> objects <code >str1</code> and <code >str2</code> the following will do:
    <a name="an308"></a>
        <pre>
    strcasecmp(str1.c_str(), str2.c_str());
</pre>
<p>
Strings support the following functionality:
    <ul>
    <li><code >initialization</code>:<blockquote >when string objects are defined they are always properly
initialized. In other words, they are always in a <a name="an309"></a>valid state. Strings may
be initialized empty or already existing text can be used to initialize
strings.</blockquote>
    <li><code >assignment</code>:<blockquote >strings may be given new values. New values may be assigned using
member functions (like <code >assign</code>) but a plain assignment operator (i.e.,
<code >=</code>)may also be used. Furthermore, assignment <em >to</em> a character buffer is
also supported.</blockquote>
    <li><code >conversions</code>:<blockquote >the partial or complete contents of string objects may be interpreted
as <strong >C</strong> strings but the string's contents may also be processed as a series
of raw binary bytes, not necessarily terminating in a 0-valued
character. Furthermore, in many situations plain characters and <strong >C</strong> strings
may be used where <code >std::string</code>s are accepted as well.</blockquote>
    <li><code >breakdown</code>:<blockquote >the individual characters stored in a string can be accessed
using the familiar index operator (<code >[]</code>) allowing us to either access or
modify information in the middle of a string.</blockquote>
    <li><code >comparisons</code>:<blockquote >strings may be compared to other strings (NTB strings) using the
familiar logical comparison operators <code >==, !=, &lt;, &lt;=, &gt;</code> and <code >&gt;=</code>. There
are also member functions available offering a more fine-grained comparison.</blockquote>
    <li><code >modification</code>:<blockquote >the contents of strings may be modified in many ways. Operators are
available to add information to string objects, to insert information in
the middle of string objects, or to replace or erase (parts of) a
string's contents.</blockquote>
    <li><code >swapping</code>:<blockquote >the string's swapping capability allows us in principle to exchange
the contents of two string objects without a byte-by-byte copying
operation of the string's contents.</blockquote>
    <li><code >searching</code>:<blockquote >the locations of characters, sets of characters, or series of
characters may be searched for from any position within the string object
and either searching in a forward or backward direction.</blockquote>
    <li><code >housekeeping</code>:<blockquote >several housekeeping facilities are offered: the string's length,
or its  empty-state may be interrogated. But string objects may also be
resized.</blockquote>
    <li><code >stream I/O</code>:<blockquote >strings may be extracted from or inserted into streams. In addition
to plain string extraction a line of a text file may be read without running
the risk of a buffer overrun. Since extraction and insertion operations are
stream based the I/O facilities are <em >device independent</em>.</blockquote>
    </ul>
<p>
<a name="STRINGOVERVIEW"></a><a name="l75"></a>
<h2 >5.2: A std::string reference</h2>
In this section the string members and string-related operations are
referenced. The subsections cover, respectively the string's initializers,
iterators, operators, and member functions. The following terminology is used
throughout this section:
    <ul>
    <li> <code >object</code> is always a <code >string</code>-object;
    <li> <code >argument</code> is a <code >string const &amp;</code> or a <code >char const *</code> unless
indicated otherwise.  The contents of an <code >argument</code> never is modified by the
operation processing the <code >argument</code>;
    <li> <code >opos</code> refers to an offset into an <code >object</code> string;
    <li> <code >apos</code> refers to an offset into an <code >argument</code>;
    <li> <code >on</code> represents a number of characters in an <code >object</code> (starting
at <code >opos</code>);
    <li> <code >an</code> represents a number of characters in an <code >argument</code> (starting
at <code >apos</code>).
    </ul>
<p>
Both <code >opos</code> and <code >apos</code> must refer to existing offsets, or an exception
(cf. chapter <a href="cplusplus10.html#EXCEPTIONS">10</a>) is generated. In contrast, <code >an</code> and <code >on</code> may
exceed the number of available characters, in which case only the available
characters are considered.
<p>
Many members declare default values for <code >on, an</code> and <code >apos</code>. Some members
declare default values for <code >opos</code>. Default offset values are 0, the default
values of <code >on</code> and <code >an</code> is <code >string::npos</code>, which can be interpreted as
`the required number of characters to reach the end of the string'.
<p>
With members starting their operations at the end of the string object's
contents proceeding backwards, the default value of <code >opos</code> is the index of
the object's <em >last</em> character, with <code >on</code> by default equal to <code >opos + 1</code>,
representing the length of the substring <em >ending</em> at <code >opos</code>.
<p>
In the overview of member functions presented below it may be assumed that all
these parameters accept default values unless indicated otherwise.  Of course,
the default argument values cannot be used if a function requires additional
arguments beyond the ones otherwise accepting default values.
<p>
Some members have overloaded versions expecting an initial argument of type
<code >char const *</code>. But even if that is not the case the first argument can
<em >always</em> be of type <code >char const *</code> where a parameter of <code >std::string</code> is
defined.
<p>
Several member functions accept <em >iterators</em>. Section <a href="cplusplus18.html#ITERATORS">18.2</a> covers
the technical aspects of <em >iterators</em>, but these may be ignored at this point
without loss of continuity.  Like <code >apos</code> and <code >opos</code>, iterators must refer
to existing positions and/or to an existing range of characters within the
string object's contents.
<p>
All <code >string</code>-member functions computing indices return the
predefined constant <code >string::npos</code> on failure.
<p>
The the <a name="an310"></a><code >s</code> <a name="an311"></a>literal suffix to indicate that a <code >std::string</code> constant is
intended when a string literal (like <code >"hello world"</code>) is used. It can be
used after declaring <code >using namespace std</code> or, more specific, after
declaring 
        <a name="an312"></a><a name="an313"></a>
    <code >using namespace std::literals::string_literals</code>. 
<p>
When string literals are used when explicitly defining or using
<code >std::string</code> objects the <code >s</code>-suffix is hardly ever required, but it may
come in handy when using the <code >auto</code> keyword. E.g., <code >auto str = "hello
world"s</code> defines <code >std::string str</code>, whereas it would have been a <code >char
const *</code> if the literal suffix had been omitted.
<p>
<a name="l76"></a>
<h3 >5.2.1: Initializers</h3>
    After defining string objects they are guaranteed to be in a valid
state. At <em >definition time</em>  string objects may be initialized in one of the
following ways:
    The following <code >string</code> constructors <a name="an314"></a> are
available:
    <ul>
    <li><code >string object</code>:<blockquote >initializes <code >object</code> to an empty string.  When defining a
<code >string</code> this way no argument list may be specified;</blockquote>
    <li><code >string object(string::size_type count, char ch)</code>:<blockquote >initializes <code >object</code> with <code >count</code> characters <code >ch</code>;</blockquote>
    <li><code >string object(string const &amp;argument)</code>:<blockquote >initializes <code >object</code> with <code >argument</code>;</blockquote>
    <li><code >string object(std::string const &amp;argument, string::size_type
            apos, string::size_type an)</code>:<blockquote >initializes <code >object</code> with <code >argument</code>'s contents starting at index
position <code >apos</code>, using at most <code >an</code> of <code >argument</code>'s characters;</blockquote>
    <li><code >string object(InputIterator begin, InputIterator end)</code>:<blockquote >initializes <code >object</code> with the characters in the range of characters
defined by the two <code >InputIterators</code>.</blockquote>
    </ul>
<p>
<a name="l77"></a>
<h3 >5.2.2: Iterators</h3>
            See section <a href="cplusplus18.html#ITERATORS">18.2</a> for details about <em >iterators</em>. As a quick
introduction to iterators: an iterator acts like a pointer, and pointers can
often be used in situations where iterators are requested. Iterators usually
come in pairs, defining a range of entities. The begin-iterator points to the
first entity, the end-iterator points just beyond the last entity of the
range. Their difference is equal to the number of entities in the
iterator-range.
<p>
Iterators play an important role in the context of <em >generic algorithms</em>
(cf. chapter <a href="cplusplus19.html#GENERIC">19</a>). The class <code >std::string</code> defines the following
<a name="an315"></a><em >iterator types</em>:
    <ul>
    <li><code >string::iterator</code> and <code >string::const_iterator</code>:
        <blockquote >these iterators are <a name="an316"></a><em >forward iterators</em>. The
<code >const_iterator</code> is returned by <code >string const</code> objects, the plain
<code >iterator</code> is returned by non-const string objects. Characters referred to
by <code >iterators</code> may be modified;</blockquote>
    <li><code >string::reverse_iterator</code> and <code >string::reverse_const_iterator</code>:
        <blockquote >these iterators are also <a name="an317"></a><em >forward iterators</em> but when
<em >incrementing</em> the iterator the <em >previous</em> character in the string object
is reached. Other than that they are comparable to, respectively,
<code >string::iterator</code> and <code >string::const_iterator</code>.</blockquote>
    </ul>
<p>
<a name="l78"></a>
<h3 >5.2.3: Operators</h3>
    String objects may be manipulated by member functions but also by
operators. Using operators often results in more natural-looking code. In
cases where operators are available having equivalent functionality as member
function the operator is practically always preferred.
<p>
The following operators are available for <code >string</code> objects (in the examples
`object' and `argument' refer to existing <code >std::string</code> objects).
    <ul>
    <li> plain assignment:
    <blockquote >a character, <strong >C</strong> or <strong >C++</strong> string may be assigned to a <code >string</code>
object. The assignment operator returns its left-hand side operand. Example:
    <pre>
object =  argument;
object = "C string";
object = 'x';
object = 120;       // same as object = 'x'
</pre>
    </blockquote>
    <li> addition:
    <blockquote >the arithmetic additive assignment operator and the addition
operator add text to a <code >string</code> object. The compound assignment operator
returns its left-hand side operand, the addition operator returns its result
in a temporary string object. When using the addition operator either the
left-hand side operand or the right-hand side operand must be a
<code >std::string</code> object. The other operand may be a char, a <strong >C</strong> string or a
<strong >C++</strong> string. Example:
    <pre>
object += argument;
object += "hello";
object += 'x';      // integral expressions are OK

argument + otherArgument;   // two std::string objects
argument + "hello";         // using + at least one
"hello" + argument;         // std::string is required
argument + 'a';             // integral expressions are OK
'a' + argument;
</pre>
    </blockquote>
    <li> index operator:
    <blockquote >The index operator may be used to retrieve <code >object</code>'s
individual characters, or to assign new values to individual characters of a
non-const string object. There is no range-checking (use the <code >at()</code> member
function for that). This operator returns a <code >char &amp;</code> or <code >char const &amp;</code>.
Example:
    <pre>
object[3] = argument[5];
</pre>
    </blockquote>
    <li> logical operators:
    <blockquote >the logical comparison operators may be applied to two string
objects or to a string object and a <strong >C</strong> string to compare their
contents. These operators return a <code >bool</code> value.
The <code >==, !=, &gt;, &gt;=, &lt;,</code> and <code >&lt;=</code> operators are available. The ordering
operators perform a lexicographical comparison of their contents
using the ASCII character collating sequence. Example:
    <pre>
object == object;           // true
object != (object + 'x');   // true
object &lt;= (object + 'x');   // true
</pre>
    </blockquote>
    <li> stream related operators:
    <blockquote >the insertion-operator (cf. section <a href="cplusplus03.html#CoutCinCerr">3.1.4</a>) may be used to
insert a <code >string</code> object into an <code >ostream</code>, the extraction-operator may be
used to extract a string object from an <code >istream</code>. The extraction operator
by default first ignores all white space characters and then extracts all
consecutively non-blank characters from an <code >istream</code>. Instead of a string a
character array may be extracted as well, but the advantage of using a string
object should be clear: the destination string object is automatically resized
to the required number of characters. Example:
    <pre>
cin &gt;&gt; object;
cout &lt;&lt; object;
</pre>
    </blockquote>
    </ul>
<p>
<a name="STRINGMEMBERS"></a><a name="l79"></a>
<h3 >5.2.4: Member functions</h3>
    The <code >std::string</code> class offers many member function as well as additional
non-member functions that should be considered part of the string class.
All these functions are listed below in alphabetic order.
<p>
The symbolic value <code >string::npos</code> is defined by the string class. It
represents `index-not-found' when returned by member functions returning
string offset positions. Example: when calling `<code >object.find('x')</code>' (see
below) on a string object not containing the character <code >'x'</code>, <code >npos</code>
is returned, as the requested position does not exist.
<p>
The final 0-byte used in <strong >C</strong> strings to indicate the end of an NTBS is
<em >not</em> considered part of a <strong >C++</strong> string, and so the member function will
return <code >npos</code>, rather than <code >length()</code> when looking for 0 in a string
object containing the characters of a <strong >C</strong> string.
<p>
Here are the standard functions that operate on objects of the class
string. When a parameter of <code >size_t</code> is mentioned it may be interpreted as a
parameter of type <code >string::size_type</code>, but without defining a default
argument value. The type <code >size_type</code> should be read as
<code >string::size_type</code>. With <code >size_type</code> the default argument values
mentioned in section <a href="cplusplus05.html#STRINGOVERVIEW">5.2</a> apply. All quoted functions are
member functions of the class <code >std::string</code>, except where indicated
otherwise.
    <ul>
    <li><a name="an318"></a><code >char &amp;at(size_t opos)</code>:<blockquote >a reference to the character at the indicated position is
        returned. When called with <code >string const</code> objects a <code >char const &amp;</code>
        is returned. The member function performs range-checking, raising an
        exception (that by default aborts the program) if an invalid index is
        passed.</blockquote>
    <li><a name="an319"></a><code >string &amp;append(InputIterator begin, InputIterator end)</code>:<blockquote >the characters in the range defined by <code >begin</code> and <code >end</code> are
        appended to the current string object.</blockquote>
    <li><code >string &amp;append(string const &amp;argument, size_type apos,
        size_type an)</code>:<blockquote ><code >argument</code> (or a substring) is appended to the current string
        object.</blockquote>
    <li><code >string &amp;append(char const *argument, size_type an)</code>:<blockquote >the first <code >an</code> characters of <code >argument</code> are appended to the
        string object.</blockquote>
    <li><code >string &amp;append(size_type n, char ch)</code>:<blockquote ><code >n</code> characters <code >ch</code> are appended to the current string object.</blockquote>
    <li><a name="an320"></a><code >string &amp;assign(string const &amp;argument, size_type
        apos, size_type an)</code>:<blockquote ><code >argument</code> (or a substring) is assigned to the string object.
        If <code >argument</code> is of type <code >char const *</code> and one additional
        argument is provided the second argument is interpreted as a value
        initializing <code >an</code>, using 0 to initialize <code >apos</code>.</blockquote>
    <li><code >string &amp;assign(size_type n, char ch)</code>:<blockquote ><code >n</code> characters <code >ch</code> are assigned to the current string object.</blockquote>
    <li><a name="an321"></a><code >char &amp;back()</code>:<blockquote >returns a reference to the last <code >char</code> stored inside the string
        object. The result is undefined for empty strings.</blockquote>
    <li><a name="an322"></a><code >string::iterator begin()</code>:<blockquote >an iterator referring to the first character of the current string
        object is returned. With <code >const</code> string objects a <code >const_iterator</code>
        is returned.</blockquote>
    <li><a name="an323"></a><code >size_type capacity() const</code>:<blockquote >the number of characters that can currently be stored in the string
        object without needing to resize it is returned.</blockquote>
    <li><a name="an324"></a><code >string::const_iterator cbegin()</code>:<blockquote >a <code >const_iterator</code> referring to the first character of the current
        string object is returned.</blockquote>
    <li><a name="an325"></a><code >string::const_iterator cend()</code>:<blockquote >a <code >const_iterator</code> referring to the end of the current
        string object is returned.</blockquote>
    <li><a name="an326"></a><code >int compare(string const &amp;argument) const</code>:<blockquote >the text stored in the current string object and the text stored in
        <code >argument</code> is compared using a lexicographical comparison using the
        ASCII character collating sequence. zero is returned if the two
        strings have identical contents, a negative value is returned if the
        text in the current object should be ordered <em >before</em> the text in
        <code >argument</code>; a positive value is returned if the text in the current
        object should be ordered <em >beyond</em> the text in <code >argument</code>.</blockquote>
    <li><code >int compare(size_t opos, size_t on, string const &amp;argument) const</code>:<blockquote >a substring of the text stored in the current string object is
        compared to the text stored in <code >argument</code>. At most <code >on</code> characters
        starting at offset <code >opos</code> are compared to the text in <code >argument</code>.</blockquote>
    <li><code >int compare(size_t opos, size_t on, string const &amp;argument,
            size_type apos, size_type an)</code>:<blockquote >a substring of the text stored in the current string object is
        compared to a substring of the text stored in <code >argument</code>. At most
        <code >on</code> characters of the current string object, starting at offset
        <code >opos</code>, are compared to at most <code >an</code> characters of <code >argument</code>,
        starting at offset <code >apos</code>. In this case <code >argument</code> <em >must</em> be a
        string object.</blockquote>
    <li><code >int compare(size_t opos, size_t on, char const *argument, size_t an)</code>:<blockquote >a substring of the text stored in the current string object is
        compared to a substring of the text stored in <code >argument</code>. At most
        <code >on</code> characters of the current string object starting at offset
        <code >opos</code> are compared to at most <code >an</code> characters of
        <code >argument</code>. <code >Argument</code> must have at least <code >an</code> characters. The
        characters may have arbitrary values: 0-valued characters have no
        special meanings.</blockquote>
    <li><a name="an327"></a><code >size_t copy(char *argument, size_t on, size_type opos) const</code>:<blockquote >the contents of the current string object are (partially) copied into
        <code >argument</code>. The actual number of characters copied is returned.  The
        second argument, specifying the number of characters to copy, from the
        current string object is required. No 0-valued character is appended
        to the copied string but can be appended to the copied text using an
        idiom like the following: 
       <pre>
    argument[object.copy(argument, string::npos)] = 0;
</pre>
       Of course, the programmer should make sure that <code >argument</code>'s size is
        large enough to accomodate the additional 0-byte.</blockquote>
    <li><a name="an328"></a><code >string::const_reverse_iterator crbegin()</code>:<blockquote >a <code >const_reverse_iterator</code> referring to the last character of the
        current string object is returned.</blockquote>
    <li><a name="an329"></a><code >string::const_reverse_iterator crend()</code>:<blockquote >a <code >const_reverse_iterator</code> referring to the begin of the current
        string object is returned.</blockquote>
    <li><a name="an330"></a><code >char const *c_str() const</code>:<blockquote >the contents of the current string object as an NTBS.</blockquote>
    <li><a name="an331"></a><code >char const *data() const</code>:<blockquote >the raw contents of the current string object are returned. Since this
        member does not return an NTBS (as
        <code >c_str</code> does), it can be used to retrieve any kind of information
        stored inside the current string object including, e.g., series of
        0-bytes:
       <pre>
    string s(2, 0);
    cout &lt;&lt; static_cast&lt;int&gt;(s.data()[1]) &lt;&lt; '\n';
</pre>
        </blockquote>
    <li><a name="an332"></a><code >bool empty() const</code>:<blockquote ><code >true</code> is returned if the current string object contains no data.</blockquote>
    <li><a name="an333"></a><code >string::iterator end()</code>:<blockquote >an iterator referring to the position just beyond the last character
        of the current string object is returned. With <code >const</code> string
        objects a <code >const_iterator</code> is returned.</blockquote>
    <li><a name="an334"></a><code >string &amp;erase(size_type opos, size_type on)</code>:<blockquote >a (sub)string of the information stored in the current string object
        is erased.</blockquote>
    <li><code >string::iterator erase(string::iterator begin, string::iterator end)</code>:<blockquote >the parameter <code >end</code> is optional. If omitted the value returned by
        the current object's <code >end</code> member is used. The characters defined by
        the <code >begin</code> and <code >end</code> iterators are erased. The iterator <code >begin</code>
        is returned, which is then referring to the position immediately
        following the last erased character.</blockquote>
    <li><a name="an335"></a><code >size_t find(string const &amp;argument, size_type opos) const</code>:<blockquote >the first index in the current string object where <code >argument</code> is
        found is returned.</blockquote>
    <li><code >size_t find(char const *argument, size_type opos, size_type an) const</code>:<blockquote >the first index in the current string object where <code >argument</code> is
        found is returned. When all three arguments are specified the first
        argument <em >must</em> be a <code >char const *</code>.</blockquote>
    <li><code >size_t find(char ch, size_type opos) const</code>:<blockquote >the first index in the current string object where <code >ch</code> is found is
        returned.</blockquote>
    <li><a name="an336"></a><code >size_t find_first_of(string const &amp;argument,
                                               size_type opos) const</code>:<blockquote >the first index in the current string object where any character in
        <code >argument</code> is found is returned.</blockquote>
    <li><code >size_type find_first_of(char const *argument, size_type opos,
        size_type an) const</code>:<blockquote >the first index in the current string object where any character in
        <code >argument</code> is found is returned. If <code >opos</code> is provided it refers
        to the first index in the current string object where the search for
        <code >argument</code> should start. If omitted, the string object is scanned
        completely.  If <code >an</code> is provided it indicates the number of
        characters of the <code >char const *</code> argument that should be used in the
        search. It defines a substring starting at the beginning of
        <code >argument</code>. If omitted, all of <code >argument</code>'s characters are used.</blockquote>
    <li><code >size_type find_first_of(char ch, size_type opos)</code>:<blockquote >the first index in the current string object where character <code >ch</code> is
        found is returned.</blockquote>
    <li><code >size_t find_first_not_of(char ch, size_type opos) const</code>:<blockquote >the first index in the current string object where another
        character than <code >ch</code> is found is returned.</blockquote>
    <li><a name="an337"></a><code >size_t find_last_of(string const &amp;argument,
                                               size_type opos) const</code>:<blockquote >the last index in the current string object where any character in
        <code >argument</code> is found is returned.</blockquote>
    <li><code >size_type find_last_of(char const *argument, size_type opos,
            size_type an) const</code>:<blockquote >the last index in the current string object where any character in
        <code >argument</code> is found is returned. If <code >opos</code> is provided it refers
        to the last index in the current string object where the search for
        <code >argument</code> should start. If omitted, the string object is scanned
        completely.  If <code >an</code> is provided it indicates the number of
        characters of the <code >char const *</code> argument that should be used in the
        search. It defines a substring starting at the beginning of
        <code >argument</code>. If omitted, all of <code >argument</code>'s characters are used.</blockquote>
    <li><code >size_type find_last_of(char ch, size_type opos)</code>:<blockquote >the last index in the current string object where character <code >ch</code> is
        found is returned.</blockquote>
    <li><a name="an338"></a><code >size_t find_last_not_of(string const &amp;argument,
                                                size_type opos) const</code>:<blockquote >the last index in the current string object where any character <em >not</em>
        appearing in <code >argument</code> is found is returned.</blockquote>
    <li><a name="an339"></a><code >char &amp;front()</code>:<blockquote >returns a reference to the first <code >char</code> stored inside the string
        object. The result is undefined for empty strings.</blockquote>
    <li><a name="an340"></a><code >allocator_type get_allocator()</code>:<blockquote >returns the allocator of the class <code >std::string</code></blockquote>
    <li><a name="an341"></a><code >istream &amp;std::getline(istream &amp;istr, string &amp;object,
            char delimiter = '\n')</code>:<blockquote >Note: this is <em >not</em> a member function of the class <code >string</code>.<br/>
       A line of text is read from <code >istr</code>. All characters until
        <code >delimiter</code> (or the end of the stream, whichever comes first) are
        read from <code >istr</code> and are stored in <code >object</code>. If the delimiter is
        encountered it is removed from the stream, but is not stored in
        <code >line</code>.<br/>
       If the delimiter is not found, <code >istr.eof</code> returns <code >true</code> (see
        section <a href="cplusplus06.html#IOSTATES">6.3.1</a>). Since streams may be interpreted as <code >bool</code>
        values (cf. section <a href="cplusplus06.html#IOSTATES">6.3.1</a>) a commonly encountered idiom to
        read all lines from a stream successively into a string object
        <code >line</code> looks like this:
       <pre>
    while (getline(istr, line))
        process(line);
</pre>
       The contents of the last line, whether or not it was terminated
        by a delimiter, is eventually also assigned to <code >object</code>.</blockquote>
    <li><a name="an342"></a><code >string &amp;insert(size_t opos, string const &amp;argument,
        size_type apos, size_type an)</code>:<blockquote >a (sub)string of <code >argument</code> is inserted into the current string
        object at the current string object's index position
        <code >opos</code>. Arguments for <code >apos</code> and <code >an</code> must either both be
        provided or they must both be omitted.</blockquote>
    <li><code >string &amp;insert(size_t opos, char const *argument,
                size_type an)</code>:<blockquote ><code >argument</code> (of type <code >char const *</code>) is inserted at index <code >opos</code>
        into the current string object.</blockquote>
    <li><code >string &amp;insert(size_t opos, size_t count, char ch)</code>:<blockquote ><code >Count</code> characters <code >ch</code> are inserted at index <code >opos</code> into the
        current string object.</blockquote>
    <li><code >string::iterator insert(string::iterator begin, char ch)</code>:<blockquote >the character <code >ch</code> is inserted at the current object's position
        referred to by <code >begin</code>. <code >Begin</code> is returned.</blockquote>
    <li><code >string::iterator insert(string::iterator begin, size_t count,
        char ch)</code>:<blockquote ><code >Count</code> characters <code >ch</code> are inserted at the current object's
        position referred to by <code >begin</code>. <code >Begin</code> is returned.</blockquote>
    <li><code >string::iterator insert(string::iterator begin, InputIterator
        abegin, InputIterator aend)</code>:<blockquote >the characters in the range defined by the <code >InputIterators abegin</code>
        and <code >aend</code> are inserted at the current object's position referred to
        by <code >begin</code>. <code >Begin</code> is returned.</blockquote>
    <li><a name="an343"></a><code >size_t length() const</code>:<blockquote >the number of characters stored in the current string object is
        returned.</blockquote>
    <li><a name="an344"></a><code >size_t max_size() const</code>:<blockquote >the maximum number of characters that can be stored in the current
        string object is returned.</blockquote>
    <li><a name="an345"></a><code >void pop_back()</code>:<blockquote >The string's last character is removed from the string object.</blockquote>
    <li><a name="an346"></a><code >void push_back(char ch)</code>:<blockquote >The character <code >ch</code> is appended to the string object.</blockquote>
    <li><a name="an347"></a><code >string::reverse_iterator rbegin()</code>:<blockquote >a reverse iterator referring to the last character of the current
        string object is returned. With <code >const</code> string objects a
        <code >reverse_const_iterator</code> is returned.</blockquote>
    <li><a name="an348"></a><code >string::iterator rend()</code>:<blockquote >a reverse iterator referring to the position just before the first
        character of the current string object is returned. With <code >const</code>
        string objects a <code >reverse_const_iterator</code> is returned.</blockquote>
    <li><a name="an349"></a><code >string &amp;replace(size_t opos, size_t on, string const
        &amp;argument, size_type apos, size_type an)</code>:<blockquote >a (sub)string of characters in <code >object</code> are replaced by the (subset
        of) characters of <code >argument</code>.  If <code >on</code> is specified as 0
        <code >argument</code> is inserted into <code >object</code> at offset <code >opos</code>.</blockquote>
    <li><code >string &amp;replace(size_t opos, size_t on, char const *argument,
        size_type an)</code>:<blockquote >a series of characters in <code >object</code> are replaced by the first <code >an</code>
        characters of <code >char const *</code> argument.</blockquote>
    <li><code >string &amp;replace(size_t opos, size_t on, size_type count, char ch)</code>:<blockquote ><code >on</code> characters of the current string object, starting at index
        position <code >opos</code>, are replaced by <code >count</code> characters <code >ch</code>.</blockquote>
    <li><code >string &amp;replace(string::iterator begin, string::iterator end,
        string const &amp;argument)</code>:<blockquote >the series of characters in the current string object defined by the
        iterators <code >begin</code> and <code >end</code> are replaced by <code >argument</code>. If
        <code >argument</code> is a <code >char const *</code>, an additional argument <code >an</code> may
        be used, specifying the number of characters of <code >argument</code> that are
        used in the replacement.</blockquote>
    <li><code >string &amp;replace(string::iterator begin, string::iterator end,
        size_type count, char ch)</code>:<blockquote >the series of characters in the current string object defined by the
        iterators <code >begin</code> and <code >end</code> are replaced by <code >count</code> characters
        having values <code >ch</code>.</blockquote>
    <li><code >string &amp;replace(string::iterator begin, string::iterator end,
        InputIterator abegin, InputIterator aend)</code>:<blockquote >the series of characters in the current string object defined by the
        iterators <code >begin</code> and <code >end</code> are replaced by the characters in the
        range defined by the <code >InputIterators abegin</code> and <code >aend</code>.</blockquote>
    <li><a name="an350"></a><code >void reserve(size_t request)</code>:<blockquote >the current string object's capacity is changed to at least
        <code >request</code>. After calling this member, <code >capacity</code>'s return value
        will be at least <code >request</code>. A request for a smaller size than the
        value returned by <code >capacity</code> is ignored. A
        <a name="an351"></a><code >std::length_error</code> exception is thrown if
        <code >request</code> exceeds the value returned by <code >max_size</code>
        (<code >std::length_error</code> is defined in the <a name="an352"></a><code >stdexcept</code>
        header). Calling <code >reserve()</code> has the effect of redefining a string's
        capacity, not of actually making available the memory to the
        program. This is illustrated by the exception thrown by the string's
        <code >at()</code> member when trying to access an element exceeding the
        string's <code >size</code> but not the string's <code >capacity</code>.</blockquote>
    <li><a name="an353"></a><code >void resize(size_t size, char ch = 0)</code>:<blockquote >the current string object is resized to
        <code >size</code> characters. If the string object is resized to a size larger
        than its current size the additional characters will be initialized to
        <code >ch</code>. If it is reduced in size the characters having the highest
        indices are chopped off.</blockquote>
    <li><a name="an354"></a><code >size_t rfind(string const &amp;argument, size_type opos) const</code>:<blockquote >the last index in the current string object where <code >argument</code> is
        found is returned. Searching proceeds from the current object's offset
        <code >opos</code> back to its beginning.</blockquote>
    <li><code >size_t rfind(char const *argument, size_type opos, size_type an) const</code>:<blockquote >the last index in the current string object where <code >argument</code> is
        found is returned.  Searching proceeds from the current object's
        offset <code >opos</code> back to its beginning.  The parameter <code >an</code> specifies
        the length of the substring of <code >argument</code> to look for, starting at
        <code >argument</code>'s beginning.</blockquote>
    <li><code >size_t rfind(char ch, size_type opos)const</code>:<blockquote >the last index in the current string object where <code >ch</code> is found
        is returned.  Searching proceeds from the current object's offset
        <code >opos</code> back to its beginning.</blockquote>
    <li><a name="an355"></a><code >void shrink_to_fit()</code>:<blockquote >optionally reduces the amount of memory allocated by a vector to its
        current size. The implementor is free to ignore or otherwise optimize
        this request. In order to guarantee a `shrink to fit' operation the
        <pre>
    string(stringObject).swap(stringObject)
</pre>
        idiom can be used.</blockquote>
    <li><a name="an356"></a><code >size_t size() const</code>:<blockquote >the number of characters stored in the current string object is
        returned. This member is a synonym of <code >length()</code>.</blockquote>
    <li><a name="an357"></a><code >string substr(size_type opos, size_type on) const</code>:<blockquote >a substring of the current string object of at most <code >on</code> characters
        starting at index <code >opos</code> is returned.</blockquote>
    <li><a name="an358"></a><code >void swap(string &amp;argument)</code>:<blockquote >the contents of the current string object are swapped with the
        contents of <code >argument</code>. For this member <code >argument</code> must be a
        string object and cannot be a <code >char const *</code>.</blockquote>
    </ul>
<p>
<a name="l80"></a>
<h3 >5.2.5: Conversion functions</h3>
    Several string conversion functions are available operating on or producing
<code >std::string</code> objects. These functions are listed below in alphabetic
order. They are not member functions, but class-less (free) functions declared
in the <code >std</code> namespace. The <a name="an359"></a><code >&lt;string&gt;</code> header file must be included
before they can be used.
<p>
<ul>
    <li><a name="an360"></a><code >float stof(std::string const &amp;str, size_t *pos = 0)</code>:<blockquote >Initial white space characters in <code >str</code> are ignored. Then the
        following sequences of characters are converted to a <code >float</code> value,
        which is returned:
       <ul>
        <li> A decimal floating point constant:
            <ul>
           <li> An optional + or - character
           <li> A series of decimal digits, possibly containing one decimal
                point character
           <li> An optional e or E character, followed by an optional - or +
            character, followed by a series  of decimal digits
            </ul>
        <li> A hexadecimal floating point constant:
           <ul>
           <li> An optional + or - character
            <li> 0x or 0X
            <li> A series of hexadecimal digits, possibly containing one
                decimal point character
           <li> An optional p or P character, followed by an optional - or +
            character, followed by a series  of decimal digits
            </ul>
        <li> An infinity expression:
           <ul>
           <li> An optional + or - character
            <li> The words <code >inf</code> or <code >infinity</code> (case insensitive words)
            </ul>
        <li> A `not a number' expression:
           <ul>
           <li> An optional + or - character
            <li> The words <code >nan</code> or <code >nan(alphanumeric character sequence)</code>
                (<code >nan</code> is a case insensitive word), resulting in a <code >NaN</code>
                floating point value
            </ul>
        </ul>
        If <code >pos != 0</code> the index of the first character in <code >str</code> which was
        not converted is returned in <code >*pos</code>.  A <code >std::invalid_argument</code>
        exception is thrown if the characters in <code >str</code> could not be
        converted to a <code >float</code>, a <code >std::out_of_range</code> exception is thrown
        if the converted value would have exceeded the range of <code >float</code>
        values.</blockquote>
    <li><a name="an361"></a><code >double stod(std::string const &amp;str, size_t *pos = 0)</code>:<blockquote >A conversion as described with <code >stof</code> is performed, but now to a
        value of type <code >double</code>.</blockquote>
    <li><a name="an362"></a><code >double stold(std::string const &amp;str, size_t *pos = 0)</code>:<blockquote >A conversion as described with <code >stof</code> is performed, but now to a
        value of type <code >long double</code>.</blockquote>
    <li><a name="an363"></a><code >int stoi(std::string const &amp;str, size_t *pos = 0,
                                                    int base = 10)</code>:<blockquote >Initial white space characters in <code >str</code> are ignored. Then all
        characters representing numeric constants of the number system whose
        <code >base</code> is specified are converted to an <code >int</code> value, which is
        returned. An optional + or - character may prefix the numeric
        characters. Values starting with 0 are automatically interpreted as
        octal values, values starting with 0x or 0X as hexadecimal
        characters. The value <code >base</code> must be between 2 and 36. If <code >pos !=
        0</code> the index of the first character in <code >str</code> which was not converted
        is returned in <code >*pos</code>. A <code >std::invalid_argument</code> exception is
        thrown if the characters in <code >str</code> could not be converted to an
        <code >int</code>, a <code >std::out_of_range</code> exception is thrown if the converted
        value would have exceeded the range of <code >int</code> values.
<p>
Here is an example of its use:
        <pre>
int value = stoi(string(" -123"));  // assigns value -123
value = stoi(string(" 123"), 0, 5); // assigns value 38
</pre>
    </blockquote>
    <li><a name="an364"></a><code >long stol(std::string const &amp;str, size_t *pos = 0, 
                                                    int base = 10)</code>:<blockquote >A conversion as described with <code >stoi</code> is performed, but now to a
        value of type <code >long</code>.</blockquote>
    <li><a name="an365"></a><code >long long stoll(std::string const &amp;str, size_t *pos = 0, 
                                                    int base = 10)</code>:<blockquote >A conversion as described with <code >stoi</code> is performed, but now to a
        value of type <code >long long</code>.</blockquote>
    <li><a name="an366"></a><code >unsigned long stoul(std::string const &amp;str, size_t *pos = 0, 
                                                    int base = 10)</code>:<blockquote >A conversion as described with <code >stoi</code> (not allowing an initial + or
        - character) is performed, but now to a value of type <code >unsigned
        long</code>.</blockquote>
    <li><a name="an367"></a><code >unsigned long long stoull(std::string const &amp;str, 
                                            size_t *pos = 0, int base = 10)</code>:<blockquote >A conversion as described with <code >stoul</code> is performed, but now to a
        value of type <code >unsigned long long</code>.</blockquote>
    <li><a name="an368"></a><code >std::string to_string(Type value)</code>:<blockquote >Type can be of the types <code >int, long, long long, unsigned, unsigned
        long, unsigned long long, float, double,</code> or <code >long double</code>. The
        value of the argument is converted to a textual representation, which
        is returned as a <code >std::string</code> value.
       </blockquote>
    <li><a name="an369"></a><code >std::string to_wstring(Type value)</code>:<blockquote >The conversion as described at <code >to_string</code> is performed, returning
        a <a name="an370"></a><code >std::wstring</code>.</blockquote>
    </ul>
<p>

<hr>
<ul>
    <li> <a href="cplusplus.html">Table of Contents</a>
    <li> <a href="cplusplus04.html">Previous Chapter</a>
    <li> <a href="cplusplus06.html">Next Chapter</a>
</ul>
<hr>
</body>
</html>
