<!DOCTYPE html><html><head>
<meta charset="UTF-8">
<title>C++ Annotations Version 10.8.0</title>
<link rel="stylesheet" type="text/css" href="cplusplus.css">
<style type="text/css">
    figure {text-align: center;}
    img {vertical-align: center;}
</style>
<link rev="made" href="mailto:Frank B. Brokken: f.b.brokken@rug.nl">
</head>
<body>
<hr/>
<h1 id="title">C++ Annotations Version 10.8.0</h1>
<h2 id="author">Frank B. Brokken</h2>

<h2 id="affiliation"><div style="text-align: center">Center of Information Technology,<br/>
        University of Groningen <br/>Nettelbosje 1,<br/>P.O. Box 11044,<br/>9700 CA Groningen <br/>The Netherlands <br/>
        Published at the University of Groningen <br/>
        ISBN 90 367 0470 7</div></h2><h2 id="date">1994 - 2017</h2>

<blockquote ><em >
    This document is intended for knowledgeable users of <strong >C</strong> (or any other
language using a <strong >C</strong>-like grammar, like <strong >Perl</strong> or <strong >Java</strong>) who would like
to know more about, or make the transition to, <strong >C++</strong>. This document is the
main textbook for Frank's <strong >C++</strong> programming courses, which are yearly
organized at the University of Groningen. The <strong >C++</strong> Annotations do not cover
all aspects of <strong >C++</strong>, though. In particular, <strong >C++</strong>'s basic grammar
is not covered when equal to <strong >C</strong>'s grammar. Any basic book on <strong >C</strong> may be
consulted to refresh that part of <strong >C++</strong>'s grammar.
<p>
If you want a <strong >hard-copy version of the C++ Annotations</strong>: printable versions
are available in zip-archives containing files in postscript, <a name="an1"></a>pdf and other
formats at
    <a name="an2"></a>
        <div style="text-align: center">
    <a target=_top href="https://github.com/fbb-git/cppannotations-zip">https://github.com/fbb-git/cppannotations-zip</a>
        </div>
    Pages of files having names starting with <code >cplusplus</code> are in A4 paper
size, pages of files having names starting with <code >cplusplusus</code> are in the US
<em >legal</em> paper size. The <strong >C++</strong> Annotations are also available as a Kindle book.
<p>
The latest version of the <strong >C++</strong> Annotations in html-format can be
browsed at:
        <div style="text-align: center">
    <a target=_top href="https://fbb-git.github.io/cppannotations/">https://fbb-git.github.io/cppannotations/</a><br/>
    and/or at<br/>
    <a target=_top href="http://www.icce.rug.nl/documents/">http://www.icce.rug.nl/documents/</a>
<p>

<blockquote >
    <em >
        Don't hesitate to send in feedback: send an e-mail if you like the
        C++ Annotations; if you think that important material was omitted;
        if you find errors or typos in the text or the code examples;
        or if you just feel like e-mailing. Send your e-mail to
        <a href="f.b.brokken@rug.nl)">Frank B. Brokken</a>.
<p>
<strong >Please</strong> state the document version you're referring to, as found in
        the title (in this document: 10.8.0) and please state chapter and
        paragraph name or number you're referring to.
<p>
All received mail is processed conscientiously, and received
        suggestions for improvements are usually processed by the
        time a new version of the Annotations is released. Except for the
        incidental case I will normally not acknowledge the receipt of
        suggestions for improvements. Please don't interpret this as me not
        appreciating your efforts.
    </em>
</blockquote>
<p>
</div>
<p>

    </em></blockquote>

<h1>Table of Contents</h1>
<dl><dt><h2><a href="cplusplus01.html#l1">Chapter 1: Overview Of The Chapters</a></h2></dt>
<dt><h2><a href="cplusplus02.html#l2">Chapter 2: Introduction</a></h2></dt>
<dd><dl>
<dt><h3><a href="cplusplus02.html#l3">2.1: What's new in the C++ Annotations</a></h3></dt>
<dt><h3><a href="cplusplus02.html#l4">2.2: C++'s history</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus02.html#l5">2.2.1: History of the C++ Annotations</a></dt>
<dt><a href="cplusplus02.html#l6">2.2.2: Compiling a C program using a C++ compiler</a></dt>
<dt><a href="cplusplus02.html#l7">2.2.3: Compiling a C++ program</a></dt>
<dd><dl>
<dt><a href="cplusplus02.html#l8">2.2.3.1: C++ under MS-Windows</a></dt>
<dt><a href="cplusplus02.html#l9">2.2.3.2: Compiling a C++ source text</a></dt>
</dl></dd>
</dl></dd>
<dt><h3><a href="cplusplus02.html#l10">2.3: C++: advantages and claims</a></h3></dt>
<dt><h3><a href="cplusplus02.html#l11">2.4: What is Object-Oriented Programming?</a></h3></dt>
<dt><h3><a href="cplusplus02.html#l12">2.5: Differences between C and C++</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus02.html#l13">2.5.1: The function `main'</a></dt>
<dt><a href="cplusplus02.html#l14">2.5.2: End-of-line comment</a></dt>
<dt><a href="cplusplus02.html#l15">2.5.3: Strict type checking</a></dt>
<dt><a href="cplusplus02.html#l16">2.5.4: Function Overloading</a></dt>
<dt><a href="cplusplus02.html#l17">2.5.5: Default function arguments</a></dt>
<dt><a href="cplusplus02.html#l18">2.5.6: NULL-pointers vs. 0-pointers and nullptr</a></dt>
<dt><a href="cplusplus02.html#l19">2.5.7: The `void' parameter list</a></dt>
<dt><a href="cplusplus02.html#l20">2.5.8: The `#define __cplusplus'</a></dt>
<dt><a href="cplusplus02.html#l21">2.5.9: Using standard C functions</a></dt>
<dt><a href="cplusplus02.html#l22">2.5.10: Header files for both C and C++</a></dt>
<dt><a href="cplusplus02.html#l23">2.5.11: Defining local variables</a></dt>
<dt><a href="cplusplus02.html#l24">2.5.12: The keyword `typedef'</a></dt>
<dt><a href="cplusplus02.html#l25">2.5.13: Functions as part of a struct</a></dt>
<dt><a href="cplusplus02.html#l26">2.5.14: Features introduced at the C++17 standard</a></dt>
</dl></dd>
</dl></dd>
<dt><h2><a href="cplusplus03.html#l27">Chapter 3: A First Impression Of C++</a></h2></dt>
<dd><dl>
<dt><h3><a href="cplusplus03.html#l28">3.1: Notable differences with C</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus03.html#l29">3.1.1: Using the keyword `const'</a></dt>
<dt><a href="cplusplus03.html#l30">3.1.2: Namespaces</a></dt>
<dt><a href="cplusplus03.html#l31">3.1.3: The scope resolution operator ::</a></dt>
<dt><a href="cplusplus03.html#l32">3.1.4: `cout', `cin', and `cerr'</a></dt>
</dl></dd>
<dt><h3><a href="cplusplus03.html#l33">3.2: Functions as part of structs</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus03.html#l34">3.2.1: Data hiding: public, private and class</a></dt>
<dt><a href="cplusplus03.html#l35">3.2.2: Structs in C vs. structs in C++</a></dt>
</dl></dd>
<dt><h3><a href="cplusplus03.html#l36">3.3: Several additions to C's grammar</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus03.html#l37">3.3.1: References</a></dt>
<dt><a href="cplusplus03.html#l38">3.3.2: Rvalue References</a></dt>
<dt><a href="cplusplus03.html#l39">3.3.3: Lvalues, rvalues and more</a></dt>
<dt><a href="cplusplus03.html#l40">3.3.4: Strongly typed enumerations</a></dt>
<dt><a href="cplusplus03.html#l41">3.3.5: Initializer lists</a></dt>
<dt><a href="cplusplus03.html#l42">3.3.6: Type inference using `auto'</a></dt>
<dd><dl>
<dt><a href="cplusplus03.html#l43">3.3.6.1: Structured binding declarations (C++17)</a></dt>
</dl></dd>
<dt><a href="cplusplus03.html#l44">3.3.7: Defining types and `using' declarations</a></dt>
<dt><a href="cplusplus03.html#l45">3.3.8: Range-based for-loops</a></dt>
<dt><a href="cplusplus03.html#l46">3.3.9: Raw String Literals</a></dt>
<dt><a href="cplusplus03.html#l47">3.3.10: Binary constants</a></dt>
<dt><a href="cplusplus03.html#l48">3.3.11: Selection statements with initializers (C++17)</a></dt>
<dt><a href="cplusplus03.html#l49">3.3.12: Attributes</a></dt>
</dl></dd>
<dt><h3><a href="cplusplus03.html#l50">3.4: New language-defined data types</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus03.html#l51">3.4.1: The data type `bool'</a></dt>
<dt><a href="cplusplus03.html#l52">3.4.2: The data type `wchar_t'</a></dt>
<dt><a href="cplusplus03.html#l53">3.4.3: Unicode encoding</a></dt>
<dt><a href="cplusplus03.html#l54">3.4.4: The data type `long long int'</a></dt>
<dt><a href="cplusplus03.html#l55">3.4.5: The data type `size_t'</a></dt>
<dt><a href="cplusplus03.html#l56">3.4.6: Digit separators</a></dt>
</dl></dd>
<dt><h3><a href="cplusplus03.html#l57">3.5: A new syntax for casts</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus03.html#l58">3.5.1: The `static_cast'-operator</a></dt>
<dt><a href="cplusplus03.html#l59">3.5.2: The `const_cast'-operator</a></dt>
<dt><a href="cplusplus03.html#l60">3.5.3: The `reinterpret_cast'-operator</a></dt>
<dt><a href="cplusplus03.html#l61">3.5.4: The `dynamic_cast'-operator</a></dt>
<dt><a href="cplusplus03.html#l62">3.5.5: Casting 'shared_ptr' objects</a></dt>
</dl></dd>
<dt><h3><a href="cplusplus03.html#l63">3.6: Keywords and reserved names in C++</a></h3></dt>
</dl></dd>
<dt><h2><a href="cplusplus04.html#l64">Chapter 4: Namespaces</a></h2></dt>
<dd><dl>
<dt><h3><a href="cplusplus04.html#l65">4.1: Namespaces</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus04.html#l66">4.1.1: Defining namespaces</a></dt>
<dd><dl>
<dt><a href="cplusplus04.html#l67">4.1.1.1: Declaring entities in namespaces</a></dt>
<dt><a href="cplusplus04.html#l68">4.1.1.2: A closed namespace</a></dt>
</dl></dd>
<dt><a href="cplusplus04.html#l69">4.1.2: Referring to entities</a></dt>
<dd><dl>
<dt><a href="cplusplus04.html#l70">4.1.2.1: The `using' directive</a></dt>
<dt><a href="cplusplus04.html#l71">4.1.2.2: `Koenig lookup'</a></dt>
</dl></dd>
<dt><a href="cplusplus04.html#l72">4.1.3: The standard namespace</a></dt>
<dt><a href="cplusplus04.html#l73">4.1.4: Nesting namespaces and namespace aliasing</a></dt>
<dd><dl>
<dt><a href="cplusplus04.html#l74">4.1.4.1: Defining entities outside of their namespaces</a></dt>
</dl></dd>
</dl></dd>
</dl></dd>
<dt><h2><a href="cplusplus05.html#l75">Chapter 5: The `string' Data Type</a></h2></dt>
<dd><dl>
<dt><h3><a href="cplusplus05.html#l76">5.1: Operations on strings</a></h3></dt>
<dt><h3><a href="cplusplus05.html#l77">5.2: A std::string reference</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus05.html#l78">5.2.1: Initializers</a></dt>
<dt><a href="cplusplus05.html#l79">5.2.2: Iterators</a></dt>
<dt><a href="cplusplus05.html#l80">5.2.3: Operators</a></dt>
<dt><a href="cplusplus05.html#l81">5.2.4: Member functions</a></dt>
<dt><a href="cplusplus05.html#l82">5.2.5: Conversion functions</a></dt>
</dl></dd>
</dl></dd>
<dt><h2><a href="cplusplus06.html#l83">Chapter 6: The IO-stream Library</a></h2></dt>
<dd><dl>
<dt><h3><a href="cplusplus06.html#l84">6.1: Special header files</a></h3></dt>
<dt><h3><a href="cplusplus06.html#l85">6.2: The foundation: the class `ios_base'</a></h3></dt>
<dt><h3><a href="cplusplus06.html#l86">6.3: Interfacing `streambuf' objects: the class `ios'</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus06.html#l87">6.3.1: Condition states</a></dt>
<dt><a href="cplusplus06.html#l88">6.3.2: Formatting output and input</a></dt>
<dd><dl>
<dt><a href="cplusplus06.html#l89">6.3.2.1: Format modifying member functions</a></dt>
<dt><a href="cplusplus06.html#l90">6.3.2.2: Formatting flags</a></dt>
</dl></dd>
</dl></dd>
<dt><h3><a href="cplusplus06.html#l91">6.4: Output</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus06.html#l92">6.4.1: Basic output: the class `ostream'</a></dt>
<dd><dl>
<dt><a href="cplusplus06.html#l93">6.4.1.1: Writing to `ostream' objects</a></dt>
<dt><a href="cplusplus06.html#l94">6.4.1.2: `ostream' positioning</a></dt>
<dt><a href="cplusplus06.html#l95">6.4.1.3: `ostream' flushing</a></dt>
</dl></dd>
<dt><a href="cplusplus06.html#l96">6.4.2: Output to files: the class `ofstream'</a></dt>
<dd><dl>
<dt><a href="cplusplus06.html#l97">6.4.2.1: Modes for opening stream objects</a></dt>
</dl></dd>
<dt><a href="cplusplus06.html#l98">6.4.3: Output to memory: the class `ostringstream'</a></dt>
</dl></dd>
<dt><h3><a href="cplusplus06.html#l99">6.5: Input</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus06.html#l100">6.5.1: Basic input: the class `istream'</a></dt>
<dd><dl>
<dt><a href="cplusplus06.html#l101">6.5.1.1: Reading from `istream' objects</a></dt>
<dt><a href="cplusplus06.html#l102">6.5.1.2: `istream' positioning</a></dt>
</dl></dd>
<dt><a href="cplusplus06.html#l103">6.5.2: Input from files: the class `ifstream'</a></dt>
<dt><a href="cplusplus06.html#l104">6.5.3: Input from memory: the class `istringstream'</a></dt>
<dt><a href="cplusplus06.html#l105">6.5.4: Copying streams</a></dt>
<dt><a href="cplusplus06.html#l106">6.5.5: Coupling streams</a></dt>
</dl></dd>
<dt><h3><a href="cplusplus06.html#l107">6.6: Advanced topics</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus06.html#l108">6.6.1: Moving streams</a></dt>
<dt><a href="cplusplus06.html#l109">6.6.2: Redirecting streams</a></dt>
<dt><a href="cplusplus06.html#l110">6.6.3: Reading AND Writing streams</a></dt>
</dl></dd>
</dl></dd>
<dt><h2><a href="cplusplus07.html#l111">Chapter 7: Classes</a></h2></dt>
<dd><dl>
<dt><h3><a href="cplusplus07.html#l112">7.1: The constructor</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus07.html#l113">7.1.1: A first application</a></dt>
<dt><a href="cplusplus07.html#l114">7.1.2: Constructors: with and  without arguments</a></dt>
<dd><dl>
<dt><a href="cplusplus07.html#l115">7.1.2.1: The order of construction</a></dt>
</dl></dd>
</dl></dd>
<dt><h3><a href="cplusplus07.html#l116">7.2: Ambiguity resolution</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus07.html#l117">7.2.1: Types `Data' vs. `Data()'</a></dt>
<dt><a href="cplusplus07.html#l118">7.2.2: Superfluous parentheses</a></dt>
<dt><a href="cplusplus07.html#l119">7.2.3: Existing types</a></dt>
</dl></dd>
<dt><h3><a href="cplusplus07.html#l120">7.3: Objects inside objects: composition</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus07.html#l121">7.3.1: Composition and const objects: const member initializers</a></dt>
<dt><a href="cplusplus07.html#l122">7.3.2: Composition and reference objects: reference member initializers</a></dt>
</dl></dd>
<dt><h3><a href="cplusplus07.html#l123">7.4: Data member initializers</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus07.html#l124">7.4.1: Delegating constructors</a></dt>
</dl></dd>
<dt><h3><a href="cplusplus07.html#l125">7.5: Uniform initialization</a></h3></dt>
<dt><h3><a href="cplusplus07.html#l126">7.6: Defaulted and deleted class members</a></h3></dt>
<dt><h3><a href="cplusplus07.html#l127">7.7: Const member functions and const objects</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus07.html#l128">7.7.1: Anonymous objects</a></dt>
<dd><dl>
<dt><a href="cplusplus07.html#l129">7.7.1.1: Subtleties with anonymous objects</a></dt>
</dl></dd>
</dl></dd>
<dt><h3><a href="cplusplus07.html#l130">7.8: The keyword `inline'</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus07.html#l131">7.8.1: Defining members inline</a></dt>
<dt><a href="cplusplus07.html#l132">7.8.2: When to use inline functions</a></dt>
<dd><dl>
<dt><a href="cplusplus07.html#l133">7.8.2.1: A prelude: when NOT to use inline functions</a></dt>
</dl></dd>
<dt><a href="cplusplus07.html#l134">7.8.3: Inline variables (C++17)</a></dt>
</dl></dd>
<dt><h3><a href="cplusplus07.html#l135">7.9: Local classes: classes inside functions</a></h3></dt>
<dt><h3><a href="cplusplus07.html#l136">7.10: The keyword `mutable'</a></h3></dt>
<dt><h3><a href="cplusplus07.html#l137">7.11: Header file organization</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus07.html#l138">7.11.1: Using namespaces in header files</a></dt>
</dl></dd>
<dt><h3><a href="cplusplus07.html#l139">7.12: Sizeof applied to class data members</a></h3></dt>
</dl></dd>
<dt><h2><a href="cplusplus08.html#l140">Chapter 8: Static Data And Functions</a></h2></dt>
<dd><dl>
<dt><h3><a href="cplusplus08.html#l141">8.1: Static data</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus08.html#l142">8.1.1: Private static data</a></dt>
<dt><a href="cplusplus08.html#l143">8.1.2: Public static data</a></dt>
<dt><a href="cplusplus08.html#l144">8.1.3: Initializing static const data</a></dt>
<dt><a href="cplusplus08.html#l145">8.1.4: Generalized constant expressions (constexpr)</a></dt>
<dd><dl>
<dt><a href="cplusplus08.html#l146">8.1.4.1: Constant expression data</a></dt>
</dl></dd>
</dl></dd>
<dt><h3><a href="cplusplus08.html#l147">8.2: Static member functions</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus08.html#l148">8.2.1: Calling conventions</a></dt>
</dl></dd>
</dl></dd>
<dt><h2><a href="cplusplus09.html#l149">Chapter 9: Classes And Memory Allocation</a></h2></dt>
<dd><dl>
<dt><h3><a href="cplusplus09.html#l150">9.1: Operators `new' and `delete'</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus09.html#l151">9.1.1: Allocating arrays</a></dt>
<dt><a href="cplusplus09.html#l152">9.1.2: Deleting arrays</a></dt>
<dt><a href="cplusplus09.html#l153">9.1.3: Enlarging arrays</a></dt>
<dt><a href="cplusplus09.html#l154">9.1.4: Managing `raw' memory</a></dt>
<dt><a href="cplusplus09.html#l155">9.1.5: The `placement new' operator</a></dt>
</dl></dd>
<dt><h3><a href="cplusplus09.html#l156">9.2: The destructor</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus09.html#l157">9.2.1: Object pointers revisited</a></dt>
<dt><a href="cplusplus09.html#l158">9.2.2: The function set_new_handler()</a></dt>
</dl></dd>
<dt><h3><a href="cplusplus09.html#l159">9.3: The assignment operator</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus09.html#l160">9.3.1: Overloading the assignment operator</a></dt>
<dd><dl>
<dt><a href="cplusplus09.html#l161">9.3.1.1: The member 'operator=()'</a></dt>
</dl></dd>
</dl></dd>
<dt><h3><a href="cplusplus09.html#l162">9.4: The `this' pointer</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus09.html#l163">9.4.1: Sequential assignments and this</a></dt>
</dl></dd>
<dt><h3><a href="cplusplus09.html#l164">9.5: The copy constructor: initialization vs. assignment</a></h3></dt>
<dt><h3><a href="cplusplus09.html#l165">9.6: Revising the assignment operator</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus09.html#l166">9.6.1: Swapping</a></dt>
<dd><dl>
<dt><a href="cplusplus09.html#l167">9.6.1.1: Fast swapping</a></dt>
</dl></dd>
</dl></dd>
<dt><h3><a href="cplusplus09.html#l168">9.7: Moving data</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus09.html#l169">9.7.1: The move constructor (dynamic data)</a></dt>
<dt><a href="cplusplus09.html#l170">9.7.2: The move constructor (composition)</a></dt>
<dt><a href="cplusplus09.html#l171">9.7.3: Move-assignment</a></dt>
<dt><a href="cplusplus09.html#l172">9.7.4: Revising the assignment operator (part II)</a></dt>
<dt><a href="cplusplus09.html#l173">9.7.5: Moving and the destructor</a></dt>
<dt><a href="cplusplus09.html#l174">9.7.6: Move-only classes</a></dt>
<dt><a href="cplusplus09.html#l175">9.7.7: Default move constructors and assignment operators</a></dt>
<dt><a href="cplusplus09.html#l176">9.7.8: Moving: implications for class design</a></dt>
</dl></dd>
<dt><h3><a href="cplusplus09.html#l177">9.8: Copy Elision and Return Value Optimization</a></h3></dt>
<dt><h3><a href="cplusplus09.html#l178">9.9: Plain Old Data</a></h3></dt>
<dt><h3><a href="cplusplus09.html#l179">9.10: Conclusion</a></h3></dt>
</dl></dd>
<dt><h2><a href="cplusplus10.html#l180">Chapter 10: Exceptions</a></h2></dt>
<dd><dl>
<dt><h3><a href="cplusplus10.html#l181">10.1: Exception syntax</a></h3></dt>
<dt><h3><a href="cplusplus10.html#l182">10.2: An example using exceptions</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus10.html#l183">10.2.1: Anachronisms: `setjmp' and `longjmp'</a></dt>
<dt><a href="cplusplus10.html#l184">10.2.2: Exceptions: the preferred alternative</a></dt>
</dl></dd>
<dt><h3><a href="cplusplus10.html#l185">10.3: Throwing exceptions</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus10.html#l186">10.3.1: The empty `throw' statement</a></dt>
</dl></dd>
<dt><h3><a href="cplusplus10.html#l187">10.4: The try block</a></h3></dt>
<dt><h3><a href="cplusplus10.html#l188">10.5: Catching exceptions</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus10.html#l189">10.5.1: The default catcher</a></dt>
</dl></dd>
<dt><h3><a href="cplusplus10.html#l190">10.6: Declaring (deprecated) exception throwers</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus10.html#l191">10.6.1: noexcept</a></dt>
</dl></dd>
<dt><h3><a href="cplusplus10.html#l192">10.7: Iostreams and exceptions</a></h3></dt>
<dt><h3><a href="cplusplus10.html#l193">10.8: Standard exceptions</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus10.html#l194">10.8.1: Standard exceptions: to use or not to use?</a></dt>
</dl></dd>
<dt><h3><a href="cplusplus10.html#l195">10.9: System error, error code and error category</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus10.html#l196">10.9.1: The class `std::error_code'</a></dt>
<dt><a href="cplusplus10.html#l197">10.9.2: The class `std::error_category'</a></dt>
</dl></dd>
<dt><h3><a href="cplusplus10.html#l198">10.10: Exception guarantees</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus10.html#l199">10.10.1: The basic guarantee</a></dt>
<dt><a href="cplusplus10.html#l200">10.10.2: The strong guarantee</a></dt>
<dt><a href="cplusplus10.html#l201">10.10.3: The nothrow guarantee</a></dt>
</dl></dd>
<dt><h3><a href="cplusplus10.html#l202">10.11: Function try blocks</a></h3></dt>
<dt><h3><a href="cplusplus10.html#l203">10.12: Exceptions in constructors and destructors</a></h3></dt>
</dl></dd>
<dt><h2><a href="cplusplus11.html#l204">Chapter 11: More Operator Overloading</a></h2></dt>
<dd><dl>
<dt><h3><a href="cplusplus11.html#l205">11.1: Overloading `operator[]()'</a></h3></dt>
<dt><h3><a href="cplusplus11.html#l206">11.2: Overloading the insertion and extraction operators</a></h3></dt>
<dt><h3><a href="cplusplus11.html#l207">11.3: Conversion operators</a></h3></dt>
<dt><h3><a href="cplusplus11.html#l208">11.4: The keyword `explicit'</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus11.html#l209">11.4.1: Explicit conversion operators</a></dt>
</dl></dd>
<dt><h3><a href="cplusplus11.html#l210">11.5: Overloading the increment and decrement operators</a></h3></dt>
<dt><h3><a href="cplusplus11.html#l211">11.6: Overloading binary operators</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus11.html#l212">11.6.1: Member function reference bindings (& and &&)</a></dt>
</dl></dd>
<dt><h3><a href="cplusplus11.html#l213">11.7: Overloading `operator new(size_t)'</a></h3></dt>
<dt><h3><a href="cplusplus11.html#l214">11.8: Overloading `operator delete(void *)'</a></h3></dt>
<dt><h3><a href="cplusplus11.html#l215">11.9: Operators `new[]' and `delete[]'</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus11.html#l216">11.9.1: Overloading `new[]'</a></dt>
<dt><a href="cplusplus11.html#l217">11.9.2: Overloading `delete[]'</a></dt>
<dt><a href="cplusplus11.html#l218">11.9.3: The `operator delete(void *, size_t)' family</a></dt>
<dt><a href="cplusplus11.html#l219">11.9.4: `new[]', `delete[]' and exceptions</a></dt>
</dl></dd>
<dt><h3><a href="cplusplus11.html#l220">11.10: Function Objects</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus11.html#l221">11.10.1: Constructing manipulators</a></dt>
<dd><dl>
<dt><a href="cplusplus11.html#l222">11.10.1.1: Manipulators requiring arguments</a></dt>
</dl></dd>
</dl></dd>
<dt><h3><a href="cplusplus11.html#l223">11.11: The case of [io]fstream::open()</a></h3></dt>
<dt><h3><a href="cplusplus11.html#l224">11.12: User-defined literals</a></h3></dt>
<dt><h3><a href="cplusplus11.html#l225">11.13: Overloadable operators</a></h3></dt>
</dl></dd>
<dt><h2><a href="cplusplus12.html#l226">Chapter 12: Abstract Containers</a></h2></dt>
<dd><dl>
<dt><h3><a href="cplusplus12.html#l227">12.1: Notations used in this chapter</a></h3></dt>
<dt><h3><a href="cplusplus12.html#l228">12.2: The `pair' container</a></h3></dt>
<dt><h3><a href="cplusplus12.html#l229">12.3: Allocators</a></h3></dt>
<dt><h3><a href="cplusplus12.html#l230">12.4: Available Containers</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus12.html#l231">12.4.1: The `array' container</a></dt>
<dt><a href="cplusplus12.html#l232">12.4.2: The `vector' container</a></dt>
<dt><a href="cplusplus12.html#l233">12.4.3: The `list' container</a></dt>
<dt><a href="cplusplus12.html#l234">12.4.4: The `queue' container</a></dt>
<dt><a href="cplusplus12.html#l235">12.4.5: The `priority_queue' container</a></dt>
<dt><a href="cplusplus12.html#l236">12.4.6: The `deque' container</a></dt>
<dt><a href="cplusplus12.html#l237">12.4.7: The `map' container</a></dt>
<dd><dl>
<dt><a href="cplusplus12.html#l238">12.4.7.1: The `map' constructors</a></dt>
<dt><a href="cplusplus12.html#l239">12.4.7.2: The `map' operators</a></dt>
<dt><a href="cplusplus12.html#l240">12.4.7.3: The `map' public members</a></dt>
<dt><a href="cplusplus12.html#l241">12.4.7.4: The `map': a simple example</a></dt>
</dl></dd>
<dt><a href="cplusplus12.html#l242">12.4.8: The `multimap' container</a></dt>
<dt><a href="cplusplus12.html#l243">12.4.9: The `set' container</a></dt>
<dt><a href="cplusplus12.html#l244">12.4.10: The `multiset' container</a></dt>
<dt><a href="cplusplus12.html#l245">12.4.11: The `stack' container</a></dt>
<dt><a href="cplusplus12.html#l246">12.4.12: The `unordered_map' container (`hash table')</a></dt>
<dd><dl>
<dt><a href="cplusplus12.html#l247">12.4.12.1: The `unordered_map' constructors</a></dt>
<dt><a href="cplusplus12.html#l248">12.4.12.2: The `unordered_map' public members</a></dt>
<dt><a href="cplusplus12.html#l249">12.4.12.3: The `unordered_multimap' container</a></dt>
</dl></dd>
<dt><a href="cplusplus12.html#l250">12.4.13: The `unordered_set' container</a></dt>
<dd><dl>
<dt><a href="cplusplus12.html#l251">12.4.13.1: The `unordered_multiset' container</a></dt>
</dl></dd>
<dt><a href="cplusplus12.html#l252">12.4.14: Heterogeneous lookup</a></dt>
</dl></dd>
<dt><h3><a href="cplusplus12.html#l253">12.5: The `complex' container</a></h3></dt>
<dt><h3><a href="cplusplus12.html#l254">12.6: Unrestricted Unions</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus12.html#l255">12.6.1: Implementing the destructor</a></dt>
<dt><a href="cplusplus12.html#l256">12.6.2: Embedding an unrestricted union in a surrounding class</a></dt>
<dt><a href="cplusplus12.html#l257">12.6.3: Destroying an embedded unrestricted union</a></dt>
<dt><a href="cplusplus12.html#l258">12.6.4: Copy and move constructors</a></dt>
<dt><a href="cplusplus12.html#l259">12.6.5: Assignment</a></dt>
</dl></dd>
</dl></dd>
<dt><h2><a href="cplusplus13.html#l260">Chapter 13: Inheritance</a></h2></dt>
<dd><dl>
<dt><h3><a href="cplusplus13.html#l261">13.1: Related types</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus13.html#l262">13.1.1: Inheritance depth: desirable?</a></dt>
</dl></dd>
<dt><h3><a href="cplusplus13.html#l263">13.2: Access rights: public, private, protected</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus13.html#l264">13.2.1: Public, protected and private derivation</a></dt>
<dt><a href="cplusplus13.html#l265">13.2.2: Promoting access rights</a></dt>
</dl></dd>
<dt><h3><a href="cplusplus13.html#l266">13.3: The constructor of a derived class</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus13.html#l267">13.3.1: Move construction</a></dt>
<dt><a href="cplusplus13.html#l268">13.3.2: Move assignment</a></dt>
<dt><a href="cplusplus13.html#l269">13.3.3: Inheriting constructors</a></dt>
</dl></dd>
<dt><h3><a href="cplusplus13.html#l270">13.4: The destructor of a derived class</a></h3></dt>
<dt><h3><a href="cplusplus13.html#l271">13.5: Redefining member functions</a></h3></dt>
<dt><h3><a href="cplusplus13.html#l272">13.6: Multiple inheritance</a></h3></dt>
<dt><h3><a href="cplusplus13.html#l273">13.7: Conversions between base classes and derived classes</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus13.html#l274">13.7.1: Conversions with object assignments</a></dt>
<dt><a href="cplusplus13.html#l275">13.7.2: Conversions with pointer assignments</a></dt>
</dl></dd>
<dt><h3><a href="cplusplus13.html#l276">13.8: Using non-default constructors with new[]</a></h3></dt>
</dl></dd>
<dt><h2><a href="cplusplus14.html#l277">Chapter 14: Polymorphism</a></h2></dt>
<dd><dl>
<dt><h3><a href="cplusplus14.html#l278">14.1: Virtual functions</a></h3></dt>
<dt><h3><a href="cplusplus14.html#l279">14.2: Virtual destructors</a></h3></dt>
<dt><h3><a href="cplusplus14.html#l280">14.3: Pure virtual functions</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus14.html#l281">14.3.1: Implementing pure virtual functions</a></dt>
</dl></dd>
<dt><h3><a href="cplusplus14.html#l282">14.4: Explicit virtual overrides</a></h3></dt>
<dt><h3><a href="cplusplus14.html#l283">14.5: Virtual functions and multiple inheritance</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus14.html#l284">14.5.1: Ambiguity in multiple inheritance</a></dt>
<dt><a href="cplusplus14.html#l285">14.5.2: Virtual base classes</a></dt>
<dt><a href="cplusplus14.html#l286">14.5.3: When virtual derivation is not appropriate</a></dt>
</dl></dd>
<dt><h3><a href="cplusplus14.html#l287">14.6: Run-time type identification</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus14.html#l288">14.6.1: The dynamic_cast operator</a></dt>
<dt><a href="cplusplus14.html#l289">14.6.2: The `typeid' operator</a></dt>
</dl></dd>
<dt><h3><a href="cplusplus14.html#l290">14.7: Inheritance: when to use to achieve what?</a></h3></dt>
<dt><h3><a href="cplusplus14.html#l291">14.8: The `streambuf' class</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus14.html#l292">14.8.1: Protected `streambuf' members</a></dt>
<dd><dl>
<dt><a href="cplusplus14.html#l293">14.8.1.1: Protected members for input operations</a></dt>
<dt><a href="cplusplus14.html#l294">14.8.1.2: Protected members for output operations</a></dt>
<dt><a href="cplusplus14.html#l295">14.8.1.3: Protected members for buffer manipulation</a></dt>
<dt><a href="cplusplus14.html#l296">14.8.1.4: Deriving classes from `streambuf'</a></dt>
</dl></dd>
<dt><a href="cplusplus14.html#l297">14.8.2: The class `filebuf'</a></dt>
<dt><a href="cplusplus14.html#l298">14.8.3: Safely interfacing streams to another std::streambuf</a></dt>
</dl></dd>
<dt><h3><a href="cplusplus14.html#l299">14.9: A polymorphic exception class</a></h3></dt>
<dt><h3><a href="cplusplus14.html#l300">14.10: How polymorphism is implemented</a></h3></dt>
<dt><h3><a href="cplusplus14.html#l301">14.11: Undefined reference to vtable ...</a></h3></dt>
<dt><h3><a href="cplusplus14.html#l302">14.12: Virtual constructors</a></h3></dt>
</dl></dd>
<dt><h2><a href="cplusplus15.html#l303">Chapter 15: Friends</a></h2></dt>
<dd><dl>
<dt><h3><a href="cplusplus15.html#l304">15.1: Friend functions</a></h3></dt>
<dt><h3><a href="cplusplus15.html#l305">15.2: Extended friend declarations</a></h3></dt>
</dl></dd>
<dt><h2><a href="cplusplus16.html#l306">Chapter 16: Classes Having Pointers To Members</a></h2></dt>
<dd><dl>
<dt><h3><a href="cplusplus16.html#l307">16.1: Pointers to members: an example</a></h3></dt>
<dt><h3><a href="cplusplus16.html#l308">16.2: Defining  pointers to members</a></h3></dt>
<dt><h3><a href="cplusplus16.html#l309">16.3: Using pointers to members</a></h3></dt>
<dt><h3><a href="cplusplus16.html#l310">16.4: Pointers to static members</a></h3></dt>
<dt><h3><a href="cplusplus16.html#l311">16.5: Pointer sizes</a></h3></dt>
</dl></dd>
<dt><h2><a href="cplusplus17.html#l312">Chapter 17: Nested Classes</a></h2></dt>
<dd><dl>
<dt><h3><a href="cplusplus17.html#l313">17.1: Defining nested class members</a></h3></dt>
<dt><h3><a href="cplusplus17.html#l314">17.2: Declaring nested classes</a></h3></dt>
<dt><h3><a href="cplusplus17.html#l315">17.3: Accessing private members in nested classes</a></h3></dt>
<dt><h3><a href="cplusplus17.html#l316">17.4: Nesting enumerations</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus17.html#l317">17.4.1: Empty enumerations</a></dt>
</dl></dd>
<dt><h3><a href="cplusplus17.html#l318">17.5: Revisiting virtual constructors</a></h3></dt>
</dl></dd>
<dt><h2><a href="cplusplus18.html#l319">Chapter 18: The Standard Template Library</a></h2></dt>
<dd><dl>
<dt><h3><a href="cplusplus18.html#l320">18.1: Predefined function objects</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus18.html#l321">18.1.1: Arithmetic function objects</a></dt>
<dt><a href="cplusplus18.html#l322">18.1.2: Relational function objects</a></dt>
<dt><a href="cplusplus18.html#l323">18.1.3: Logical function objects</a></dt>
</dl></dd>
<dt><h3><a href="cplusplus18.html#l324">18.2: Iterators</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus18.html#l325">18.2.1: std::distance</a></dt>
<dt><a href="cplusplus18.html#l326">18.2.2: Insert iterators</a></dt>
<dt><a href="cplusplus18.html#l327">18.2.3: Iterators for `istream' objects</a></dt>
<dd><dl>
<dt><a href="cplusplus18.html#l328">18.2.3.1: Iterators for `istreambuf' objects</a></dt>
</dl></dd>
<dt><a href="cplusplus18.html#l329">18.2.4: Iterators for `ostream' objects</a></dt>
<dd><dl>
<dt><a href="cplusplus18.html#l330">18.2.4.1: Iterators for `ostreambuf' objects</a></dt>
</dl></dd>
</dl></dd>
<dt><h3><a href="cplusplus18.html#l331">18.3: The class 'unique_ptr'</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus18.html#l332">18.3.1: Defining `unique_ptr' objects</a></dt>
<dt><a href="cplusplus18.html#l333">18.3.2: Creating a plain `unique_ptr'</a></dt>
<dt><a href="cplusplus18.html#l334">18.3.3: Moving  another `unique_ptr'</a></dt>
<dt><a href="cplusplus18.html#l335">18.3.4: Pointing to a newly allocated object</a></dt>
<dt><a href="cplusplus18.html#l336">18.3.5: Operators and members</a></dt>
<dt><a href="cplusplus18.html#l337">18.3.6: Using `unique_ptr' objects for arrays</a></dt>
</dl></dd>
<dt><h3><a href="cplusplus18.html#l338">18.4: The class `shared_ptr'</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus18.html#l339">18.4.1: Defining `shared_ptr' objects</a></dt>
<dt><a href="cplusplus18.html#l340">18.4.2: Creating a plain `shared_ptr'</a></dt>
<dt><a href="cplusplus18.html#l341">18.4.3: Pointing to a newly allocated object</a></dt>
<dt><a href="cplusplus18.html#l342">18.4.4: Operators and members</a></dt>
<dt><a href="cplusplus18.html#l343">18.4.5: Casting shared pointers</a></dt>
<dt><a href="cplusplus18.html#l344">18.4.6: Using `shared_ptr' objects for arrays</a></dt>
</dl></dd>
<dt><h3><a href="cplusplus18.html#l345">18.5: Smart smart pointer construction: `make_shared' and `make_unique'</a></h3></dt>
<dt><h3><a href="cplusplus18.html#l346">18.6: Classes having pointer data members</a></h3></dt>
<dt><h3><a href="cplusplus18.html#l347">18.7: Lambda expressions</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus18.html#l348">18.7.1: Lambda expressions: syntax</a></dt>
<dt><a href="cplusplus18.html#l349">18.7.2: Using lambda expressions</a></dt>
<dt><a href="cplusplus18.html#l350">18.7.3: Generic lambda expressions</a></dt>
</dl></dd>
<dt><h3><a href="cplusplus18.html#l351">18.8: Regular Expressions</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus18.html#l352">18.8.1: The regular expression mini language</a></dt>
<dd><dl>
<dt><a href="cplusplus18.html#l353">18.8.1.1: Character classes</a></dt>
</dl></dd>
<dt><a href="cplusplus18.html#l354">18.8.2: Defining regular expressions: std::regex</a></dt>
<dt><a href="cplusplus18.html#l355">18.8.3: Retrieving matches: std::match_results</a></dt>
<dt><a href="cplusplus18.html#l356">18.8.4: Regular expression matching functions</a></dt>
<dd><dl>
<dt><a href="cplusplus18.html#l357">18.8.4.1: The std::regex_constants::match_flag_type flags</a></dt>
<dt><a href="cplusplus18.html#l358">18.8.4.2: Matching full texts: std::regex_match</a></dt>
<dt><a href="cplusplus18.html#l359">18.8.4.3: Partially matching text: std::regex_search</a></dt>
<dt><a href="cplusplus18.html#l360">18.8.4.4: The member std::match:_results::format</a></dt>
<dt><a href="cplusplus18.html#l361">18.8.4.5: Modifying target strings: std::regex_replace</a></dt>
</dl></dd>
</dl></dd>
<dt><h3><a href="cplusplus18.html#l362">18.9: Randomization and Statistical Distributions</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus18.html#l363">18.9.1: Random Number Generators</a></dt>
<dt><a href="cplusplus18.html#l364">18.9.2: Statistical distributions</a></dt>
<dd><dl>
<dt><a href="cplusplus18.html#l365">18.9.2.1: Bernoulli distribution</a></dt>
<dt><a href="cplusplus18.html#l366">18.9.2.2: Binomial distribution</a></dt>
<dt><a href="cplusplus18.html#l367">18.9.2.3: Cauchy distribution</a></dt>
<dt><a href="cplusplus18.html#l368">18.9.2.4: Chi-squared distribution</a></dt>
<dt><a href="cplusplus18.html#l369">18.9.2.5: Extreme value distribution</a></dt>
<dt><a href="cplusplus18.html#l370">18.9.2.6: Exponential distribution</a></dt>
<dt><a href="cplusplus18.html#l371">18.9.2.7: Fisher F distribution</a></dt>
<dt><a href="cplusplus18.html#l372">18.9.2.8: Gamma distribution</a></dt>
<dt><a href="cplusplus18.html#l373">18.9.2.9: Geometric distribution</a></dt>
<dt><a href="cplusplus18.html#l374">18.9.2.10: Log-normal distribution</a></dt>
<dt><a href="cplusplus18.html#l375">18.9.2.11: Normal distribution</a></dt>
<dt><a href="cplusplus18.html#l376">18.9.2.12: Negative binomial distribution</a></dt>
<dt><a href="cplusplus18.html#l377">18.9.2.13: Poisson distribution</a></dt>
<dt><a href="cplusplus18.html#l378">18.9.2.14: Student t distribution</a></dt>
<dt><a href="cplusplus18.html#l379">18.9.2.15: Uniform int distribution</a></dt>
<dt><a href="cplusplus18.html#l380">18.9.2.16: Uniform real distribution</a></dt>
<dt><a href="cplusplus18.html#l381">18.9.2.17: Weibull distribution</a></dt>
</dl></dd>
</dl></dd>
</dl></dd>
<dt><h2><a href="cplusplus19.html#l382">Chapter 19: The STL Generic Algorithms</a></h2></dt>
<dd><dl>
<dt><h3><a href="cplusplus19.html#l383">19.1: The Generic Algorithms</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus19.html#l384">19.1.1: accumulate</a></dt>
<dt><a href="cplusplus19.html#l385">19.1.2: adjacent_difference</a></dt>
<dt><a href="cplusplus19.html#l386">19.1.3: adjacent_find</a></dt>
<dt><a href="cplusplus19.html#l387">19.1.4: binary_search</a></dt>
<dt><a href="cplusplus19.html#l388">19.1.5: copy</a></dt>
<dt><a href="cplusplus19.html#l389">19.1.6: copy_backward</a></dt>
<dt><a href="cplusplus19.html#l390">19.1.7: count</a></dt>
<dt><a href="cplusplus19.html#l391">19.1.8: count_if</a></dt>
<dt><a href="cplusplus19.html#l392">19.1.9: equal</a></dt>
<dt><a href="cplusplus19.html#l393">19.1.10: equal_range</a></dt>
<dt><a href="cplusplus19.html#l394">19.1.11: exchange</a></dt>
<dt><a href="cplusplus19.html#l395">19.1.12: fill</a></dt>
<dt><a href="cplusplus19.html#l396">19.1.13: fill_n</a></dt>
<dt><a href="cplusplus19.html#l397">19.1.14: find</a></dt>
<dt><a href="cplusplus19.html#l398">19.1.15: find_end</a></dt>
<dt><a href="cplusplus19.html#l399">19.1.16: find_first_of</a></dt>
<dt><a href="cplusplus19.html#l400">19.1.17: find_if</a></dt>
<dt><a href="cplusplus19.html#l401">19.1.18: for_each</a></dt>
<dt><a href="cplusplus19.html#l402">19.1.19: generate</a></dt>
<dt><a href="cplusplus19.html#l403">19.1.20: generate_n</a></dt>
<dt><a href="cplusplus19.html#l404">19.1.21: includes</a></dt>
<dt><a href="cplusplus19.html#l405">19.1.22: inner_product</a></dt>
<dt><a href="cplusplus19.html#l406">19.1.23: inplace_merge</a></dt>
<dt><a href="cplusplus19.html#l407">19.1.24: iter_swap</a></dt>
<dt><a href="cplusplus19.html#l408">19.1.25: lexicographical_compare</a></dt>
<dt><a href="cplusplus19.html#l409">19.1.26: lower_bound</a></dt>
<dt><a href="cplusplus19.html#l410">19.1.27: max</a></dt>
<dt><a href="cplusplus19.html#l411">19.1.28: max_element</a></dt>
<dt><a href="cplusplus19.html#l412">19.1.29: merge</a></dt>
<dt><a href="cplusplus19.html#l413">19.1.30: min</a></dt>
<dt><a href="cplusplus19.html#l414">19.1.31: min_element</a></dt>
<dt><a href="cplusplus19.html#l415">19.1.32: mismatch</a></dt>
<dt><a href="cplusplus19.html#l416">19.1.33: next_permutation</a></dt>
<dt><a href="cplusplus19.html#l417">19.1.34: nth_element</a></dt>
<dt><a href="cplusplus19.html#l418">19.1.35: partial_sort</a></dt>
<dt><a href="cplusplus19.html#l419">19.1.36: partial_sort_copy</a></dt>
<dt><a href="cplusplus19.html#l420">19.1.37: partial_sum</a></dt>
<dt><a href="cplusplus19.html#l421">19.1.38: partition</a></dt>
<dt><a href="cplusplus19.html#l422">19.1.39: prev_permutation</a></dt>
<dt><a href="cplusplus19.html#l423">19.1.40: remove</a></dt>
<dt><a href="cplusplus19.html#l424">19.1.41: remove_copy</a></dt>
<dt><a href="cplusplus19.html#l425">19.1.42: remove_copy_if</a></dt>
<dt><a href="cplusplus19.html#l426">19.1.43: remove_if</a></dt>
<dt><a href="cplusplus19.html#l427">19.1.44: replace</a></dt>
<dt><a href="cplusplus19.html#l428">19.1.45: replace_copy</a></dt>
<dt><a href="cplusplus19.html#l429">19.1.46: replace_copy_if</a></dt>
<dt><a href="cplusplus19.html#l430">19.1.47: replace_if</a></dt>
<dt><a href="cplusplus19.html#l431">19.1.48: reverse</a></dt>
<dt><a href="cplusplus19.html#l432">19.1.49: reverse_copy</a></dt>
<dt><a href="cplusplus19.html#l433">19.1.50: rotate</a></dt>
<dt><a href="cplusplus19.html#l434">19.1.51: rotate_copy</a></dt>
<dt><a href="cplusplus19.html#l435">19.1.52: search</a></dt>
<dt><a href="cplusplus19.html#l436">19.1.53: search_n</a></dt>
<dt><a href="cplusplus19.html#l437">19.1.54: set_difference</a></dt>
<dt><a href="cplusplus19.html#l438">19.1.55: set_intersection</a></dt>
<dt><a href="cplusplus19.html#l439">19.1.56: set_symmetric_difference</a></dt>
<dt><a href="cplusplus19.html#l440">19.1.57: set_union</a></dt>
<dt><a href="cplusplus19.html#l441">19.1.58: sort</a></dt>
<dt><a href="cplusplus19.html#l442">19.1.59: stable_partition</a></dt>
<dt><a href="cplusplus19.html#l443">19.1.60: stable_sort</a></dt>
<dt><a href="cplusplus19.html#l444">19.1.61: swap</a></dt>
<dt><a href="cplusplus19.html#l445">19.1.62: swap_ranges</a></dt>
<dt><a href="cplusplus19.html#l446">19.1.63: transform</a></dt>
<dt><a href="cplusplus19.html#l447">19.1.64: unique</a></dt>
<dt><a href="cplusplus19.html#l448">19.1.65: unique_copy</a></dt>
<dt><a href="cplusplus19.html#l449">19.1.66: upper_bound</a></dt>
<dt><a href="cplusplus19.html#l450">19.1.67: Heap algorithms</a></dt>
<dd><dl>
<dt><a href="cplusplus19.html#l451">19.1.67.1: The `make_heap' function</a></dt>
<dt><a href="cplusplus19.html#l452">19.1.67.2: The `pop_heap' function</a></dt>
<dt><a href="cplusplus19.html#l453">19.1.67.3: The `push_heap' function</a></dt>
<dt><a href="cplusplus19.html#l454">19.1.67.4: The `sort_heap' function</a></dt>
<dt><a href="cplusplus19.html#l455">19.1.67.5: An example using the heap functions</a></dt>
</dl></dd>
</dl></dd>
<dt><h3><a href="cplusplus19.html#l456">19.2: STL: More function adaptors</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus19.html#l457">19.2.1: Adaptable functions</a></dt>
</dl></dd>
</dl></dd>
<dt><h2><a href="cplusplus20.html#l458">Chapter 20: Multi Threading</a></h2></dt>
<dd><dl>
<dt><h3><a href="cplusplus20.html#l459">20.1: Handling time (absolute and relative)</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus20.html#l460">20.1.1: Units: the class std::ratio</a></dt>
<dt><a href="cplusplus20.html#l461">20.1.2: Amounts of time: std::chrono::duration</a></dt>
<dt><a href="cplusplus20.html#l462">20.1.3: Clocks measuring time</a></dt>
<dt><a href="cplusplus20.html#l463">20.1.4: Points in time: std::chrono::time_point</a></dt>
<dt><a href="cplusplus20.html#l464">20.1.5: Converting time to text</a></dt>
<dd><dl>
<dt><a href="cplusplus20.html#l465">20.1.5.1: std::put_time format specifiers</a></dt>
</dl></dd>
</dl></dd>
<dt><h3><a href="cplusplus20.html#l466">20.2: Multi Threading</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus20.html#l467">20.2.1: The namespace std::this_thread</a></dt>
<dt><a href="cplusplus20.html#l468">20.2.2: The class std::thread</a></dt>
<dd><dl>
<dt><a href="cplusplus20.html#l469">20.2.2.1: Static data and threads: std::thread_local</a></dt>
<dt><a href="cplusplus20.html#l470">20.2.2.2: Exceptions and join()</a></dt>
</dl></dd>
</dl></dd>
<dt><h3><a href="cplusplus20.html#l471">20.3: Synchronization (mutexes)</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus20.html#l472">20.3.1: Initialization in multi-threaded programs</a></dt>
<dt><a href="cplusplus20.html#l473">20.3.2: Shared mutexes</a></dt>
</dl></dd>
<dt><h3><a href="cplusplus20.html#l474">20.4: Locks and lock handling</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus20.html#l475">20.4.1: Deadlocks</a></dt>
<dt><a href="cplusplus20.html#l476">20.4.2: Shared locks</a></dt>
</dl></dd>
<dt><h3><a href="cplusplus20.html#l477">20.5: Event handling (condition variables)</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus20.html#l478">20.5.1: The class std::condition_variable</a></dt>
<dt><a href="cplusplus20.html#l479">20.5.2: The class std::condition_variable_any</a></dt>
<dt><a href="cplusplus20.html#l480">20.5.3: An example using condition variables</a></dt>
</dl></dd>
<dt><h3><a href="cplusplus20.html#l481">20.6: Atomic actions: mutexes not required</a></h3></dt>
<dt><h3><a href="cplusplus20.html#l482">20.7: An example: threaded quicksort</a></h3></dt>
<dt><h3><a href="cplusplus20.html#l483">20.8: Shared States</a></h3></dt>
<dt><h3><a href="cplusplus20.html#l484">20.9: Asynchronous return objects: std::future</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus20.html#l485">20.9.1: The std::future_error exception and the std::future_errc enum</a></dt>
</dl></dd>
<dt><h3><a href="cplusplus20.html#l486">20.10: Shared asynchronous return objects: std::shared_future</a></h3></dt>
<dt><h3><a href="cplusplus20.html#l487">20.11: Starting a new thread: std::async</a></h3></dt>
<dt><h3><a href="cplusplus20.html#l488">20.12: Preparing a task for execution: std::packaged_task</a></h3></dt>
<dt><h3><a href="cplusplus20.html#l489">20.13: The class `std::promise'</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus20.html#l490">20.13.1: Exception propagation: std::exception_ptr</a></dt>
</dl></dd>
<dt><h3><a href="cplusplus20.html#l491">20.14: An example: multi-threaded compilations</a></h3></dt>
</dl></dd>
<dt><h2><a href="cplusplus21.html#l492">Chapter 21: Function and Variable Templates</a></h2></dt>
<dd><dl>
<dt><h3><a href="cplusplus21.html#l493">21.1: Defining function templates</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus21.html#l494">21.1.1: Considerations regarding template parameters</a></dt>
<dt><a href="cplusplus21.html#l495">21.1.2: Auto and decltype</a></dt>
<dt><a href="cplusplus21.html#l496">21.1.3: Late-specified return type</a></dt>
</dl></dd>
<dt><h3><a href="cplusplus21.html#l497">21.2: Passing arguments by reference (reference wrappers)</a></h3></dt>
<dt><h3><a href="cplusplus21.html#l498">21.3: Using local and unnamed types as template arguments</a></h3></dt>
<dt><h3><a href="cplusplus21.html#l499">21.4: Template parameter deduction</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus21.html#l500">21.4.1: Lvalue transformations</a></dt>
<dt><a href="cplusplus21.html#l501">21.4.2: Qualification transformations</a></dt>
<dt><a href="cplusplus21.html#l502">21.4.3: Transformation to a base class</a></dt>
<dt><a href="cplusplus21.html#l503">21.4.4: The template parameter deduction algorithm</a></dt>
<dt><a href="cplusplus21.html#l504">21.4.5: Template type contractions</a></dt>
</dl></dd>
<dt><h3><a href="cplusplus21.html#l505">21.5: Declaring function templates</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus21.html#l506">21.5.1: Instantiation declarations</a></dt>
</dl></dd>
<dt><h3><a href="cplusplus21.html#l507">21.6: Instantiating function templates</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus21.html#l508">21.6.1: Instantiations: no `code bloat'</a></dt>
</dl></dd>
<dt><h3><a href="cplusplus21.html#l509">21.7: Using explicit template types</a></h3></dt>
<dt><h3><a href="cplusplus21.html#l510">21.8: Overloading function templates</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus21.html#l511">21.8.1: An example using overloaded function templates</a></dt>
<dt><a href="cplusplus21.html#l512">21.8.2: Ambiguities when overloading function templates</a></dt>
<dt><a href="cplusplus21.html#l513">21.8.3: Declaring overloaded function templates</a></dt>
</dl></dd>
<dt><h3><a href="cplusplus21.html#l514">21.9: Specializing templates for deviating types</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus21.html#l515">21.9.1: Avoiding too many specializations</a></dt>
<dt><a href="cplusplus21.html#l516">21.9.2: Declaring specializations</a></dt>
<dt><a href="cplusplus21.html#l517">21.9.3: Complications when using the insertion operator</a></dt>
</dl></dd>
<dt><h3><a href="cplusplus21.html#l518">21.10: Static assertions</a></h3></dt>
<dt><h3><a href="cplusplus21.html#l519">21.11: Numeric limits</a></h3></dt>
<dt><h3><a href="cplusplus21.html#l520">21.12: Polymorphous wrappers for function objects</a></h3></dt>
<dt><h3><a href="cplusplus21.html#l521">21.13: Compiling template definitions and instantiations</a></h3></dt>
<dt><h3><a href="cplusplus21.html#l522">21.14: The function selection mechanism</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus21.html#l523">21.14.1: Determining the template type parameters</a></dt>
</dl></dd>
<dt><h3><a href="cplusplus21.html#l524">21.15: SFINAE: Substitution Failure Is Not An Error</a></h3></dt>
<dt><h3><a href="cplusplus21.html#l525">21.16: C++17: Conditional function definitions using `if constexpr'</a></h3></dt>
<dt><h3><a href="cplusplus21.html#l526">21.17: Summary of the template declaration syntax</a></h3></dt>
<dt><h3><a href="cplusplus21.html#l527">21.18: Variables as templates (template variables)</a></h3></dt>
</dl></dd>
<dt><h2><a href="cplusplus22.html#l528">Chapter 22: Class Templates</a></h2></dt>
<dd><dl>
<dd><dl>
<dt><a href="cplusplus22.html#l529">22.0.1: Template Argument Deduction (C++17)</a></dt>
<dd><dl>
<dt><a href="cplusplus22.html#l530">22.0.1.1: Simple Definitions</a></dt>
<dt><a href="cplusplus22.html#l531">22.0.1.2: Explicit Conversions</a></dt>
</dl></dd>
</dl></dd>
<dt><h3><a href="cplusplus22.html#l532">22.1: Defining class templates</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus22.html#l533">22.1.1: Constructing the circular queue: CirQue</a></dt>
<dt><a href="cplusplus22.html#l534">22.1.2: Non-type parameters</a></dt>
<dt><a href="cplusplus22.html#l535">22.1.3: Member templates</a></dt>
<dt><a href="cplusplus22.html#l536">22.1.4: CirQue's constructors and member functions</a></dt>
<dt><a href="cplusplus22.html#l537">22.1.5: Using CirQue objects</a></dt>
<dt><a href="cplusplus22.html#l538">22.1.6: Default class template parameters</a></dt>
<dt><a href="cplusplus22.html#l539">22.1.7: Declaring class templates</a></dt>
<dt><a href="cplusplus22.html#l540">22.1.8: Preventing template instantiations</a></dt>
</dl></dd>
<dt><h3><a href="cplusplus22.html#l541">22.2: Static data members</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus22.html#l542">22.2.1: Extended use of the keyword `typename'</a></dt>
</dl></dd>
<dt><h3><a href="cplusplus22.html#l543">22.3: Specializing class templates for deviating types</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus22.html#l544">22.3.1: Example of a class specialization</a></dt>
</dl></dd>
<dt><h3><a href="cplusplus22.html#l545">22.4: Partial specializations</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus22.html#l546">22.4.1: Intermezzo: some simple matrix algebraic concepts</a></dt>
<dt><a href="cplusplus22.html#l547">22.4.2: The Matrix class template</a></dt>
<dt><a href="cplusplus22.html#l548">22.4.3: The MatrixRow partial specialization</a></dt>
<dt><a href="cplusplus22.html#l549">22.4.4: The MatrixColumn partial specialization</a></dt>
<dt><a href="cplusplus22.html#l550">22.4.5: The 1x1 matrix: avoid ambiguity</a></dt>
</dl></dd>
<dt><h3><a href="cplusplus22.html#l551">22.5: Variadic templates</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus22.html#l552">22.5.1: Defining and using variadic templates</a></dt>
<dt><a href="cplusplus22.html#l553">22.5.2: Perfect forwarding</a></dt>
<dt><a href="cplusplus22.html#l554">22.5.3: The unpack operator</a></dt>
<dt><a href="cplusplus22.html#l555">22.5.4: Non-type variadic templates</a></dt>
<dt><a href="cplusplus22.html#l556">22.5.5: A bare bones `not_fn' negator</a></dt>
<dt><a href="cplusplus22.html#l557">22.5.6: Folding expressions</a></dt>
</dl></dd>
<dt><h3><a href="cplusplus22.html#l558">22.6: Tuples</a></h3></dt>
<dt><h3><a href="cplusplus22.html#l559">22.7: Computing the return type of function objects</a></h3></dt>
<dt><h3><a href="cplusplus22.html#l560">22.8: Instantiating class templates</a></h3></dt>
<dt><h3><a href="cplusplus22.html#l561">22.9: Processing class templates and instantiations</a></h3></dt>
<dt><h3><a href="cplusplus22.html#l562">22.10: Declaring friends</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus22.html#l563">22.10.1: Non-templates used as friends in templates</a></dt>
<dt><a href="cplusplus22.html#l564">22.10.2: Templates instantiated for specific types as friends</a></dt>
<dt><a href="cplusplus22.html#l565">22.10.3: Unbound templates as friends</a></dt>
<dt><a href="cplusplus22.html#l566">22.10.4: Extended friend declarations</a></dt>
</dl></dd>
<dt><h3><a href="cplusplus22.html#l567">22.11: Class template derivation</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus22.html#l568">22.11.1: Deriving ordinary classes from class templates</a></dt>
<dt><a href="cplusplus22.html#l569">22.11.2: Deriving class templates from class templates</a></dt>
<dt><a href="cplusplus22.html#l570">22.11.3: Deriving class templates from ordinary classes</a></dt>
</dl></dd>
<dt><h3><a href="cplusplus22.html#l571">22.12: Static Polymorphism</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus22.html#l572">22.12.1: An example of static polymorphism</a></dt>
<dt><a href="cplusplus22.html#l573">22.12.2: Converting dynamic polymorphic classes to static             polymorphic classes</a></dt>
<dt><a href="cplusplus22.html#l574">22.12.3: Using static polymorphism to avoid reimplementations</a></dt>
</dl></dd>
<dt><h3><a href="cplusplus22.html#l575">22.13: Class templates and nesting</a></h3></dt>
<dt><h3><a href="cplusplus22.html#l576">22.14: Constructing iterators</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus22.html#l577">22.14.1: Implementing a `RandomAccessIterator'</a></dt>
<dt><a href="cplusplus22.html#l578">22.14.2: Implementing a `reverse_iterator'</a></dt>
</dl></dd>
</dl></dd>
<dt><h2><a href="cplusplus23.html#l579">Chapter 23: Advanced Template Use</a></h2></dt>
<dd><dl>
<dt><h3><a href="cplusplus23.html#l580">23.1: Subtleties</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus23.html#l581">23.1.1: Returning types nested under class templates</a></dt>
<dt><a href="cplusplus23.html#l582">23.1.2: Type resolution for base class members</a></dt>
<dt><a href="cplusplus23.html#l583">23.1.3: ::template, .template and ->template</a></dt>
</dl></dd>
<dt><h3><a href="cplusplus23.html#l584">23.2: Template Meta Programming</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus23.html#l585">23.2.1: Values according to templates</a></dt>
<dd><dl>
<dt><a href="cplusplus23.html#l586">23.2.1.1: Converting integral types to types</a></dt>
</dl></dd>
<dt><a href="cplusplus23.html#l587">23.2.2: Selecting alternatives using templates</a></dt>
<dd><dl>
<dt><a href="cplusplus23.html#l588">23.2.2.1: Defining overloading members</a></dt>
<dt><a href="cplusplus23.html#l589">23.2.2.2: Class structure as a function of template parameters</a></dt>
<dt><a href="cplusplus23.html#l590">23.2.2.3: An illustrative example</a></dt>
</dl></dd>
<dt><a href="cplusplus23.html#l591">23.2.3: Templates: Iterations by Recursion</a></dt>
</dl></dd>
<dt><h3><a href="cplusplus23.html#l592">23.3: User-defined literals</a></h3></dt>
<dt><h3><a href="cplusplus23.html#l593">23.4: Template template parameters</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus23.html#l594">23.4.1: Policy classes - I</a></dt>
<dt><a href="cplusplus23.html#l595">23.4.2: Policy classes - II: template template parameters</a></dt>
<dd><dl>
<dt><a href="cplusplus23.html#l596">23.4.2.1: The destructor of Policy classes</a></dt>
</dl></dd>
<dt><a href="cplusplus23.html#l597">23.4.3: Structure by Policy</a></dt>
</dl></dd>
<dt><h3><a href="cplusplus23.html#l598">23.5: Alias Templates</a></h3></dt>
<dt><h3><a href="cplusplus23.html#l599">23.6: Trait classes</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus23.html#l600">23.6.1: Distinguishing class from non-class types</a></dt>
<dt><a href="cplusplus23.html#l601">23.6.2: Available type traits</a></dt>
</dl></dd>
<dt><h3><a href="cplusplus23.html#l602">23.7: Using `noexcept' when offering the `strong guarantee'</a></h3></dt>
<dt><h3><a href="cplusplus23.html#l603">23.8: More conversions to class types</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus23.html#l604">23.8.1: Types to types</a></dt>
<dt><a href="cplusplus23.html#l605">23.8.2: An empty type</a></dt>
<dt><a href="cplusplus23.html#l606">23.8.3: Type convertibility</a></dt>
<dd><dl>
<dt><a href="cplusplus23.html#l607">23.8.3.1: Determining inheritance</a></dt>
</dl></dd>
</dl></dd>
<dt><h3><a href="cplusplus23.html#l608">23.9: Template TypeList processing</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus23.html#l609">23.9.1: The length of a TypeList</a></dt>
<dt><a href="cplusplus23.html#l610">23.9.2: Searching a TypeList</a></dt>
<dt><a href="cplusplus23.html#l611">23.9.3: Selecting from a TypeList</a></dt>
<dt><a href="cplusplus23.html#l612">23.9.4: Prefixing/Appending to a TypeList</a></dt>
<dt><a href="cplusplus23.html#l613">23.9.5: Erasing from a TypeList</a></dt>
<dd><dl>
<dt><a href="cplusplus23.html#l614">23.9.5.1: Erasing the first occurrence</a></dt>
<dt><a href="cplusplus23.html#l615">23.9.5.2: Erasing a type by its index</a></dt>
<dt><a href="cplusplus23.html#l616">23.9.5.3: Erasing all occurrences of a type</a></dt>
<dt><a href="cplusplus23.html#l617">23.9.5.4: Erasing duplicates</a></dt>
</dl></dd>
</dl></dd>
<dt><h3><a href="cplusplus23.html#l618">23.10: Using a TypeList</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus23.html#l619">23.10.1: The Wrap and Multi class templates</a></dt>
<dt><a href="cplusplus23.html#l620">23.10.2: The MultiBase class template</a></dt>
<dt><a href="cplusplus23.html#l621">23.10.3: Support templates</a></dt>
<dt><a href="cplusplus23.html#l622">23.10.4: Using Multi</a></dt>
</dl></dd>
<dt><h3><a href="cplusplus23.html#l623">23.11: Expression Templates</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus23.html#l624">23.11.1: Designing an Expression Template</a></dt>
<dt><a href="cplusplus23.html#l625">23.11.2: Implementing an Expression Template</a></dt>
<dt><a href="cplusplus23.html#l626">23.11.3: The BasicType trait class and ordering classes</a></dt>
</dl></dd>
</dl></dd>
<dt><h2><a href="cplusplus24.html#l627">Chapter 24: Concrete Examples</a></h2></dt>
<dd><dl>
<dt><h3><a href="cplusplus24.html#l628">24.1: Using file descriptors with `streambuf' classes</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus24.html#l629">24.1.1: Classes for output operations</a></dt>
<dt><a href="cplusplus24.html#l630">24.1.2: Classes for input operations</a></dt>
<dd><dl>
<dt><a href="cplusplus24.html#l631">24.1.2.1: Using a one-character buffer</a></dt>
<dt><a href="cplusplus24.html#l632">24.1.2.2: Using an n-character buffer</a></dt>
<dt><a href="cplusplus24.html#l633">24.1.2.3: Seeking positions in `streambuf' objects</a></dt>
<dt><a href="cplusplus24.html#l634">24.1.2.4: Multiple `unget' calls in `streambuf' objects</a></dt>
</dl></dd>
<dt><a href="cplusplus24.html#l635">24.1.3: Fixed-sized field extraction from istream objects</a></dt>
<dd><dl>
<dt><a href="cplusplus24.html#l636">24.1.3.1: Member functions and example</a></dt>
</dl></dd>
</dl></dd>
<dt><h3><a href="cplusplus24.html#l637">24.2: The `fork' system call</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus24.html#l638">24.2.1: A basic Fork class</a></dt>
<dt><a href="cplusplus24.html#l639">24.2.2: Parents and Children</a></dt>
<dt><a href="cplusplus24.html#l640">24.2.3: Redirection revisited</a></dt>
<dt><a href="cplusplus24.html#l641">24.2.4: The `Daemon' program</a></dt>
<dt><a href="cplusplus24.html#l642">24.2.5: The class `Pipe'</a></dt>
<dt><a href="cplusplus24.html#l643">24.2.6: The class `ParentSlurp'</a></dt>
<dt><a href="cplusplus24.html#l644">24.2.7: Communicating with multiple children</a></dt>
<dd><dl>
<dt><a href="cplusplus24.html#l645">24.2.7.1: The class `Selector': interface</a></dt>
<dt><a href="cplusplus24.html#l646">24.2.7.2: The class `Selector': implementation</a></dt>
<dt><a href="cplusplus24.html#l647">24.2.7.3: The class `Monitor': interface</a></dt>
<dt><a href="cplusplus24.html#l648">24.2.7.4: The class `Monitor': s_handler</a></dt>
<dt><a href="cplusplus24.html#l649">24.2.7.5: The class `Monitor': the member `run'</a></dt>
<dt><a href="cplusplus24.html#l650">24.2.7.6: The class `Monitor': example</a></dt>
<dt><a href="cplusplus24.html#l651">24.2.7.7: The class `Child'</a></dt>
</dl></dd>
</dl></dd>
<dt><h3><a href="cplusplus24.html#l652">24.3: Adding binary operators to classes</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus24.html#l653">24.3.1: Merely using operators</a></dt>
<dd><dl>
<dt><a href="cplusplus24.html#l654">24.3.1.1: To namespace or not to namespace?</a></dt>
</dl></dd>
<dt><a href="cplusplus24.html#l655">24.3.2: The CRTP and defining operator function templates</a></dt>
<dt><a href="cplusplus24.html#l656">24.3.3: Insertion and extraction</a></dt>
</dl></dd>
<dt><h3><a href="cplusplus24.html#l657">24.4: Range-based for-loops and pointer-ranges</a></h3></dt>
<dt><h3><a href="cplusplus24.html#l658">24.5: Distinguishing lvalues from rvalues with operator[]()</a></h3></dt>
<dt><h3><a href="cplusplus24.html#l659">24.6: Implementing a `reverse_iterator'</a></h3></dt>
<dt><h3><a href="cplusplus24.html#l660">24.7: Using `bisonc++' and `flexc++'</a></h3></dt>
<dd><dl>
<dt><a href="cplusplus24.html#l661">24.7.1: Using `flexc++' to create a scanner</a></dt>
<dd><dl>
<dt><a href="cplusplus24.html#l662">24.7.1.1: The derived class `Scanner'</a></dt>
<dt><a href="cplusplus24.html#l663">24.7.1.2: The lexical scanner specification file</a></dt>
<dt><a href="cplusplus24.html#l664">24.7.1.3: Implementing `Scanner'</a></dt>
<dt><a href="cplusplus24.html#l665">24.7.1.4: Using a `Scanner' object</a></dt>
<dt><a href="cplusplus24.html#l666">24.7.1.5: Building the program</a></dt>
</dl></dd>
<dt><a href="cplusplus24.html#l667">24.7.2: Using `bisonc++' and `flexc++'</a></dt>
<dd><dl>
<dt><a href="cplusplus24.html#l668">24.7.2.1: The `bisonc++' specification file</a></dt>
<dt><a href="cplusplus24.html#l669">24.7.2.2: The `flexc++' specification file</a></dt>
<dt><a href="cplusplus24.html#l670">24.7.2.3: Building the program</a></dt>
</dl></dd></dl></dd></dl></dd></dl>

<p><hr/><p>
<p>

</body>
</html>
