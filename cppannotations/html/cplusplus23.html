<!DOCTYPE html><html><head>
<meta charset="UTF-8">
<title> C++ Annotations Version 10.9.2 </title>
<link rel="stylesheet" type="text/css" href="cplusplus.css"><style type="text/css">
    figure {text-align: center;}
    img {vertical-align: center;}
    .XXfc {margin-left:auto;margin-right:auto;}
    .XXtc {text-align: center;}
    .XXtl {text-align: left;}
    .XXtr {text-align: right;}
    .XXvt {vertical-align: top;}
    .XXvb {vertical-align: bottom;}
</style>
<link rel="stylesheet" type="text/css" href="cplusplus.css"></head>
<body >
<hr>
<ul>
    <li> <a href="cplusplus.html">Table of Contents</a>
    <li> <a href="cplusplus22.html">Previous Chapter</a>
    <li> <a href="cplusplus24.html">Next Chapter</a>
</ul>
<hr>
<a name="ADVANCEDTEMPL"></a><a name="l588"></a>
<h1 >Chapter 23: Advanced Template Use</h1>

The main purpose of templates is to provide a generic definition of classes
and functions that may then be tailored to specific types.
<p>
But templates allow us to do more than that. If not for compiler
implementation limitations, templates could be used to program, at
compile-time, just about anything we use computers for. This remarkable feat,
offered by no other current-day computer language, stems from the fact that
templates allow us to do three things at compile-time:
    <ul>
    <li> Templates allow us to do integer arithmetic (and to save computed
values symbolically);
    <li> Templates allow us to make compile-time decisions;
    <li> Templates allow us to do things repeatedly.
    </ul>
<p>
Of course, asking the compiler to compute, e.g., prime numbers, is one
thing. But it's a completely different thing to do so in an award winning
way. Don't expect speed records to be broken when the compiler performs
complex calculations for us. But that's all beside the point. In the end we
<em >can</em> ask the compiler to compute virtually anything using <strong >C++</strong>'s
template language, including prime numbers....
<p>
In this chapter these remarkable features of templates are
discussed. Following a short overview of subtleties related to templates the
main characteristics of <a name="an3053"></a>template meta programming are introduced.
<p>
In addition to template type and template non-type parameters there is a third
kind of template parameter, the
    <a name="an3054"></a><em >template template parameter</em>. This kind of template parameter is
introduced shortly, laying the groundwork for the discussion of <em >trait
classes</em> and <em >policy classes</em>.
<p>
This chapter ends with the discussion of several additional and interesting
applications of templates: adapting compiler error messages, conversions to
class types and an elaborate example discussing compile-time list processing.
<p>
Much of the inspiration for this chapter came from two highly recommended
books: Andrei Alexandrescu's 2001 book
    <a name="an3055"></a><strong >Modern C++ design</strong> (Addison-Wesley) and Nicolai
Josutis and David Vandevoorde's 2003 book
    <a name="an3056"></a><a name="an3057"></a><strong >Templates</strong> (Addison-Wesley).
<p>
<a name="SUBTLE"></a><a name="l589"></a>
<h2 >23.1: Subtleties</h2>
    In section <a href="cplusplus22.html#DISTINGUISH">22.2.1</a> a special application of the keyword <a name="an3058"></a><code >typename</code>
was discussed. There we learned that it is not only used to define a name for
a (complex) type, but also to distinguish types defined by class templates
from members defined by class templates.  In this section two more
applications of <code >typename</code> are introduced:
    <ul>
    <li> In section <a href="cplusplus23.html#RETURNNESTED">23.1.1</a> we apply <code >typename</code> to situations
where types nested in templates are returned from member functions of class
templates;
    <li> in section <a href="cplusplus23.html#TYPERES">23.1.2</a> we cover the problem of how to refer to base
class templates from derived class templates.
    </ul>
    In addition to the special applications of <code >typename</code> section
<a href="cplusplus23.html#DOTTEMP">23.1.3</a> introduces some new syntax that is related to the extended use of
the keyword <code >typename</code>: <code >::template, .template</code> and <code >-&gt;template</code> are
used to inform the compiler that a name used inside a template is itself a
class template.
<p>
<a name="RETURNNESTED"></a><a name="l590"></a>
<h3 >23.1.1: Returning types nested under class templates</h3>
    In the following example a nested class, not depending on a template
parameter, is defined inside a class template. The class template member
<code >nested</code> returns an object of this nested class. The example uses a
(deprecated) in-class member implementation. The reason for this shortly
becomes clear.
        <pre>
    template &lt;typename T&gt;
    class Outer
    {
        public:
            class Nested
            {};
            Nested nested() const
            {
                return Nested{};
            }
    };
</pre>
    The above example compiles flawlessly. Inside the class <code >Outer</code> there is
no ambiguity with respect to the meaning of <code >nested</code>'s return type.
<p>
However, following good practices inline and template members should be
implemented below their class interfaces (see section <a href="cplusplus07.html#DEFINLINE">7.8.1</a>). So we
remove the implementation from the interface and put it below the interface:
        <pre>
    template &lt;typename T&gt;
    class Outer
    {
        public:
            class Nested
            {};

            Nested nested() const;
    };

    template &lt;typename T&gt;
    Outer&lt;T&gt;::Nested Outer&lt;T&gt;::nested() const
    {
        return Nested{};
    }
</pre>
 Suddenly the compiler refuses to compile the <code >nested</code> member. Fortunately,
it also suggests a solution in its error message:
    <pre>
    error: need `typename' before `Outer&lt;T&gt;::Nested' because 
           `Outer&lt;T&gt;' is a dependent scope
     Outer&lt;T&gt;::Nested Outer&lt;T&gt;::nested() const
     ~~~~~~~~
</pre>
    Now that the implementation has been moved out of the interface the return
type (i.e., <code >Outer&lt;T&gt;::Nested</code>) refers to a type defined by <code >Outer&lt;T&gt;</code>
rather than to a member of <code >Outer&lt;T&gt;</code>, and so <code >typename</code> must once again
be used. 
<p>
A general rule for using <code >typename</code> can be formulated: the keyword
<code >typename</code> must be used whenever a type is referred to that is a <em >subtype</em>
of a type that itself depends on a template type parameter.
        <a name="an3059"></a>
        <a name="an3060"></a>
    When using the inline implementation no such dependency is used as the
function's return type is simply <code >Nested</code>. When implementing the function
outside of the class interface (which should be considered `good practice')
then a specification of the class defining <code >Nested</code> must be provided for the
function's return type. So it becomes <code >Outer&lt;T&gt;::Nested</code> which clearly is a
type depending on a template type parameter.
<p>
Like before, writing <code >typename</code> in front of <code >Outer&lt;T&gt;::Nested</code> removes
the compilation error. Thus, the correct implementation of the function
<code >nested</code> becomes:
        <pre>
    template &lt;typename T&gt;
    typename Outer&lt;T&gt;::Nested Outer&lt;T&gt;::nested() const
    {
        return Nested();
    }
</pre>
<p>
<a name="TYPERES"></a><a name="l591"></a>
<h3 >23.1.2: Type resolution for base class members</h3>
    Below we see two class templates. <code >Base</code> and <code >Derived</code>, <code >Base</code> being
<code >Derived</code>'s base class:
        <pre>
    #include &lt;iostream&gt;

    template &lt;typename T&gt;
    class Base
    {
        public:
            void member();
    };
    template &lt;typename T&gt;
    void Base&lt;T&gt;::member()
    {
        std::cout &lt;&lt; "This is Base&lt;T&gt;::member()\n";
    }
    template &lt;typename T&gt;
    class Derived: public Base&lt;T&gt;
    {
        public:
            Derived();
    };
    template &lt;typename T&gt;
    Derived&lt;T&gt;::Derived()
    {
        member();
    }
</pre>
    This example won't compile, and the compiler tells us something like:
        <a name="an3061"></a>
        <pre>
    error: there are no arguments to 'member' that depend on a template
           parameter, so a declaration of 'member' must be available
</pre>
    This error causes some confusion as ordinary (non-template) base classes
readily make their public and protected members available to classes that are
derived from them. This is no different for class templates, but only if the
compiler can figure out what we mean. In the above example the compiler
<em >can't</em> as it doesn't know for what type <code >T</code> the member function
<code >member</code> must be initialized when called from <code >Derived&lt;T&gt;::Derived</code>.
<p>
To appreciate why this is true, consider the situation where we have
defined a specialization:
        <pre>
    template &lt;&gt;
    Base&lt;int&gt;::member()
    {
        std::cout &lt;&lt; "This is the int-specialization\n";
    }
</pre>
    Since the compiler, when <code >Derived&lt;SomeType&gt;::Derived</code> is called, does
not know whether a specialization of <code >member</code> is in effect, it can't
decide (when compiling <code >Derived&lt;T&gt;::Derived</code>) for what type to instantiate
<code >member</code>. It can't decide this when compiling <code >Derived&lt;T&gt;::Derived</code> as
<code >member</code>'s call in <code >Derived::Derived</code> doesn't require a template type
parameter.
<p>
In cases like these, where no template type parameter is available to
determine which type to use, the compiler must be told that it should postpone
its decision about the template type parameter to use (and therefore about the
particular (here: <code >member</code>) function to call)
    <a name="an3062"></a>
until instantiation time.
<p>
This may be implemented in two ways: either by using <code >this</code> or by
explicitly mentioning the base class, instantiated for the derived class's
template type(s). When <code >this</code> is used the compiler is informed that we're
referring to the type <code >T</code> for which the template was instantiated. Any
confusion about which member function to use (the derived class or base class
member) is resolved in favor of the derived class member. Alternatively, the
base or derived class can explicitly be mentioned (using <code >Base&lt;T&gt;</code> or
<code >Derived&lt;T&gt;</code>) as shown in the next example. Note that with the <code >int</code>
template type the <code >int</code> specialization is used.
        <pre>
    #include &lt;iostream&gt;

    template &lt;typename T&gt;
    class Base
    {
        public:
            void member();
    };
    template &lt;typename T&gt;
    void Base&lt;T&gt;::member()
    {
        std::cout &lt;&lt; "This is Base&lt;T&gt;::member()\n";
    }
    template &lt;&gt;
    void Base&lt;int&gt;::member()
    {
        std::cout &lt;&lt; "This is the int-specialization\n";
    }
    template &lt;typename T&gt;
    class Derived: public Base&lt;T&gt;
    {
        public:
            Derived();
            virtual void member();
    };
    template &lt;typename T&gt;
    void Derived&lt;T&gt;::member()
    {
        std::cout &lt;&lt; "This is Derived&lt;T&gt;::member()\n";
    }
    template &lt;typename T&gt;
    Derived&lt;T&gt;::Derived()
    {
        this-&gt;member();         // Using `this' implies using the
                                // type for which T was instantiated
        Derived&lt;T&gt;::member();   // Same: calls the Derived member
        Base&lt;T&gt;::member();      // Same: calls the Base member
        std::cout &lt;&lt; "Derived&lt;T&gt;::Derived() completed\n";
    }

    int main()
    {
        Derived&lt;double&gt; d;
        Derived&lt;int&gt; i;
    }

    /*
        Generated output:
    This is Derived&lt;T&gt;::member()
    This is Derived&lt;T&gt;::member()
    This is Base&lt;T&gt;::member()
    Derived&lt;T&gt;::Derived() completed
    This is Derived&lt;T&gt;::member()
    This is Derived&lt;T&gt;::member()
    This is the int-specialization
    Derived&lt;T&gt;::Derived() completed
    */
</pre>
    The above example also illustrates the use of virtual member templates
(although virtual member templates aren't often used). In the example <code >Base</code>
declares a <code >virtual void member</code> and <code >Derived</code> defines its overriding
function <code >member</code>. In that case <code >this-&gt;member()</code> in <code >Derived::Derived</code>
calls, due to <code >member</code>'s virtual nature, <code >Derived::member</code>. The statement
<code >Base&lt;T&gt;::member()</code>, however, always calls <code >Base</code>'s <code >member</code> function
and can be used to
    <a name="an3063"></a> bypass dynamic polymorphism.
<p>
<a name="DOTTEMP"></a><a name="l592"></a>
<h3 >23.1.3: ::template, .template and -&gt;template</h3>
    In general, the compiler is able to determine the true nature of a name. As
discussed, this is not always the case and sometimes we have to advise the
compiler. The <code >typename</code> keyword may often be used for that purpose.
<p>
But <code >typename</code> cannot always come to the rescue. While parsing a source the
compiler receives a series of <em >tokens</em>, representing meaningful units of
text encountered in the program's source. A token could represent, e.g., an
identifier or a number. Other tokens represent operators, like <code >=, +</code> or
<code >&lt;</code>. It is precisely the last token that may cause problems as it may have
very different meanings. The correct meaning cannot always be determined from
the context in which the compiler encounters <code >&lt;</code>. In some situations the
compiler <em >does</em> know that <code >&lt;</code> does not represent the <em >less than</em>
operator, as when a template parameter list follows the keyword <code >template</code>,
e.g.,
        <pre>
    template &lt;typename T, int N&gt;
</pre>
    Clearly, in this case <code >&lt;</code> does not represent a `less than' operator.
<p>
The special meaning of <code >&lt;</code> when it is preceded by <code >template</code> forms the
basis for the syntactic constructs discussed in this section.
<p>
Assume the following class has been defined:
        <pre>
    template &lt;typename Type&gt;
    class Outer
    {
        public:
            template &lt;typename InType&gt;
            class Inner
            {
                public:
                    template &lt;typename X&gt;
                    void nested();
            };
    };
</pre>
    The class template <code >Outer</code> defines a nested class template
<code >Inner</code>. <code >Inner</code> in turn defines a template member function.
<p>
Next a class template <code >Usage</code> is defined, offering a member function
<code >caller</code> expecting an object of the above <code >Inner</code> type.  An initial setup
for <code >Usage</code> looks like this:
        <pre>
    template &lt;typename T1, typename T2&gt;
    class Usage
    {
        public:
            void caller(Outer&lt;T1&gt;::Inner&lt;T2&gt; &amp;obj);
       ...
    };
</pre>
    The compiler won't accept this as it interprets <code >Outer&lt;T1&gt;::Inner</code> as a
class type. But there is no class <code >Outer&lt;T1&gt;::Inner</code>. Here the compiler
generates an error like:
        <pre>
    error: 'class Outer&lt;T1&gt;::Inner' is not a type
</pre>
    To inform the compiler that <code >Inner</code>
 <a name="an3064"></a>
 <a name="an3065"></a>
    itself is a template, using the template type parameter <code >&lt;T2&gt;</code>, the
<a name="an3066"></a><code >::template</code> construction is required. It tells the compiler that the next
<code >&lt;</code> should not be interpreted as a `less than' token, but rather as a
template type argument. So, the declaration is modified to:
        <pre>
    void caller(Outer&lt;T1&gt;::template Inner&lt;T2&gt; &amp;obj);
</pre>
    This still doesn't get us where we want to be: after all <code >Inner&lt;T2&gt;</code> is
a type, nested under a class template, depending on a template type
parameter. In fact, the original <code >Outer&lt;T1&gt;::Inner&lt;T2&gt; &amp;obj</code> declaration
results in a series of error messages, one of them looking like this:
        <pre>
    error: expected type-name before '&amp;' token
</pre>
    As is often the case this error message nicely indicates what should be
done to get it right: add <code >typename</code>:
        <pre>
    void caller(typename Outer&lt;T1&gt;::template Inner&lt;T2&gt; &amp;obj);
</pre>
<p>
Of course, <code >caller</code> itself is not only just declared, it must also be
implemented. Assume that its implementation should call <code >Inner</code>'s member
<code >nested</code>, instantiated for yet another type <code >X</code>. The class template
<code >Usage</code> should therefore receive a third template type parameter, called
<code >T3</code>. Assume it has been defined. To implement <code >caller</code>, we write:
        <pre>
    void caller(typename Outer&lt;T1&gt;::template Inner&lt;T2&gt; &amp;obj)
    {
        obj.nested&lt;T3&gt;();
    }
</pre>
   Once again we run into a problem. In the function's body the compiler once
again interprets <code >&lt;</code> as `less than', seeing a logical expression having as
its right-hand side a primary expression instead of a function call specifying
a template type <code >T3</code>.
<p>
To tell the compiler that is should interpret <code >&lt;T3&gt;</code> as a type to
instantiate, the <code >template</code> keyword must once again be used. This
time it is used in the context of the member selection operator.  We write
<a name="an3067"></a><code >.template</code> to inform the compiler that what follows is not a `less than'
operator, but rather a type specification. The function's final implementation
becomes:
        <pre>
    void caller(typename Outer&lt;T1&gt;::template Inner&lt;T2&gt; &amp;obj)
    {
        obj.template nested&lt;T3&gt;();
    }
</pre>
<p>
Instead of defining value or reference parameters functions may also
define pointer parameters. Had <code >obj</code> been defined as a pointer parameter the
implementation would have had to use the <code >-&gt;template</code> construction, rather
than the <code >.template</code> construction. E.g.,
        <pre>
    void caller(typename Outer&lt;T1&gt;::template Inner&lt;T2&gt; *ptr)
    {
        ptr-&gt;template nested&lt;T3&gt;();
    }
</pre>
<p>
As we've seen class templates can be derived from base class templates. The
base class template can declare a <a name="an3068"></a>static member template, which is
available to a class that is derived from this base class. Such a base class
might look like this:
        <pre>
    template &lt;typename Type&gt;
    struct Base
    {
        template &lt;typename Tp&gt;
        static void fun();
    };
</pre>
<p>
Normally, when a base class defines a static member we can just call that
member by prefixing its name by its class name. E.g.,
        <pre>
    int main()
    {
        Base&lt;int&gt;::fun&lt;double&gt;();
    }
</pre>
    This also works fine if a class <code >Derived</code> is derived from <code >Base</code>,
instantiated for a specific type:
        <pre>
    struct Der: public Base&lt;int&gt;
    {
        static void call()
        {
            Base&lt;int&gt;::fun&lt;int&gt;();      // OK
            fun&lt;int&gt;();                 // also OK
        };
    };
</pre>
    However, when the derived class itself is a class template this way to
call <code >fun</code> does not compile anymore, as it interprets <code >Base&lt;Type&gt;::fun</code> in
<code >Base&lt;Type&gt;::fun&lt;int&gt;</code> as a type, to be instantiated for <code >int</code>. This
interpretation can be overruled by us by indicating that <code >fun</code> itself is a
template. For this the <code >::template</code> prefix is used:
        <pre>
    template &lt;typename Type&gt;
    struct Der: public Base&lt;Type&gt;
    {
        //template &lt;typename Tp&gt;    // 'call' may be a member template
        //static                    // 'call' may be a static member
        void call()
        {
            // fun&lt;int&gt;();                      // won't compile
            // Base&lt;Type&gt;::fun&lt;int&gt;();          // won't compile
            Base&lt;Type&gt;::template fun&lt;int&gt;();    // OK
            Base&lt;Type&gt;::template fun&lt;Tp&gt;();     // OK if call is a 
                                                //    member template
        };
    };
</pre>
<p>
<a name="l593"></a>
<h2 >23.2: Template Meta Programming</h2>
<p>
<a name="l594"></a>
<h3 >23.2.1: Values according to templates</h3>
    In <a name="an3069"></a>template programming values are preferably represented by <code >enum</code>
values. Enums are preferred over, e.g., <code >int const</code> values since enums never
require any linkage. They are pure symbolic values with no memory
representation whatsoever.
<p>
Consider the situation where a programmer must use a cast, say a
<a name="an3070"></a><code >reinterpret_cast</code>. A problem with a <code >reinterpret_cast</code> is that it is the
ultimate way to turn off all compiler checks. All bets are off, and we can
write extreme but absolutely pointless <code >reinterpret_cast</code> statements, like
        <pre>
    int intVar = 12;
    ostream &amp;ostr = reinterpret_cast&lt;ostream &amp;&gt;(intVar);
</pre>
<p>
Wouldn't it be nice if the compiler would warn us against such oddities by
generating an error message?
<p>
If that's what we'd like the compiler to do, there must be some way to
distinguish madness from weirdness. Let's assume we agree on the following
distinction: reinterpret casts are never acceptable if the target type
represents a larger type than the expression (source) type, since that would
immediately result in exceeding the amount of memory that's actually available
to the target type. For this reason it's clearly silly to
<code >reinterpret_cast&lt;double *&gt;(&amp;intVar)</code>, but <code >reinterpret_cast&lt;char
*&gt;(&amp;intVar)</code> could be defensible.
<p>
The intent is now to create a new kind of cast, let's call it
<a name="an3071"></a><code >reinterpret_to_smaller_cast</code>. It should only be allowed to perform a
<code >reinterpret_to_smaller_cast</code> if the target type occupies less memory than
the source type (note that this exactly the opposite reasoning as used by
Alexandrescu <a name="an3072"></a>  (2001), section 2.1).
<p>
To start, we construct the following template:
        <pre>
    template&lt;typename Target, typename Source&gt;
    Target &amp;reinterpret_to_smaller_cast(Source &amp;source)
    {
        // determine whether Target is smaller than source
        return reinterpret_cast&lt;Target &amp;&gt;(source);
    }
</pre>
<p>
At the comment an enum-definition is inserted defining a symbol having a
suggestive name.  A compile-time error results if the required condition is
not met and the error message displays the name of the symbol. A division by
zero is clearly not allowed, and noting that a <code >false</code> value represents a
zero value, the condition could be:
        <pre>
    1 / (sizeof(Target) &lt;= sizeof(Source));
</pre>
    The interesting part is that this condition doesn't result in any code at
all. The enum's value is a plain value that's computed by the compiler while
evaluating the expression:
        <pre>
    template&lt;typename Target, typename Source&gt;
    Target &amp;reinterpret_to_smaller_cast(Source &amp;source)
    {
        enum
        {
            the_Target_size_exceeds_the_Source_size =
                1 / (sizeof(Target) &lt;= sizeof(Source))
        };
        return reinterpret_cast&lt;Target &amp;&gt;(source);
    }
</pre>
    When <code >reinterpret_to_smaller_cast</code> is used to cast from <code >int</code> to
<code >double</code> an error is produced by the compiler, like this:
        <pre>
    error: enumerator value for 'the_Target_size_exceeds_the_Source_size'
        is not an integer constant
</pre>
    whereas no error is reported if, e.g.,
<code >reinterpret_to_smaller_cast&lt;int&gt;(doubleVar)</code> is requested with
<code >doubleVar</code> defined as a <code >double</code>.
<p>
In the above example an <code >enum</code> was used to compute (at compile-time) a
value that is illegal if an assumption is not met. The creative part is
finding an appropriate expression.
<p>
Enum values are well suited for these situations as they do not consume
any memory and their evaluation does not produce any executable code. They can
be used to accumulate values too: the resulting enum value then contains a
final value, computed by the compiler rather than by executable code as the
next sections illustrate. In general, programs shouldn't do run-time what they
can do
        <a name="an3073"></a>
    at compile-time and performing complex calculations resulting in constant
values is a clear example of this principle.
<p>
<a name="INTTYPE"></a><a name="l595"></a>
<h4>23.2.1.1: Converting integral types to types</h4>
        Another use of values buried inside templates is to `templatize' simple scalar
<code >int</code> values. This is useful in situations where a scalar value (often a
<code >bool</code> value) is available to select a specialization but a type is required
to base the selection on. This situation is shortly encountered (section
<a href="cplusplus23.html#ALTERNATIVES">23.2.2</a>).
<p>
Templatizing
        <a name="an3074"></a>
    integral values is based on the fact that a
        <a name="an3075"></a>
    class template together with its template arguments defines a type. E.g.,
<code >vector&lt;int&gt;</code> and <code >vector&lt;double&gt;</code> are different types.
<p>
Turning integral values into templates is easily done. Define a template (it
does not have to have any contents at all) and store the integral value in an
<code >enum</code>:
        <pre>
    template &lt;int x&gt;
    struct IntType
    {
        enum { value = x };
    };
</pre>
    As <code >IntType</code> does not have any members the `<code >class IntType</code>' can be
defined as `<code >struct IntType</code>', saving us from having to type <code >public:</code>.
<p>
Defining the <code >enum</code> value `<code >value</code>' allows us to retrieve the value
used at the instantiation at no cost in storage. Enum values are neither
variables nor data members and thus have no address. They are mere values.
<p>
It's easy to use the <code >struct IntType</code>. An anonymous or named
object can be defined by specifying a value for its <code >int</code> non-type
parameter. Example:
        <pre>
    int main()
    {
        IntType&lt;1&gt; it;
        cout &lt;&lt; "IntType&lt;1&gt; objects have value: " &lt;&lt; it.value &lt;&lt; "\n" &lt;&lt;
                "IntType&lt;2&gt; objects are of a different type "
                        "and have values " &lt;&lt; IntType&lt;2&gt;().value &lt;&lt; '\n';
    }
</pre>
    Actually, neither the named object nor the anonymous object is
    <a name="an3076"></a>
required. As the <code >enum</code> is defined as a plain value, associated with the
<code >struct IntType</code> we merely have to specify the specific <code >int</code> for which
the <code >struct IntType</code> is defined to retrieve its `<code >value</code>', like this:
        <pre>
    int main()
    {
        cout &lt;&lt; "IntType&lt;100&gt;, no object, defines `value': " &lt;&lt;
                IntType&lt;100&gt;::value &lt;&lt; "\n";
    }
</pre>
<p>
<a name="ALTERNATIVES"></a><a name="l596"></a>
<h3 >23.2.2: Selecting alternatives using templates</h3>
    An essential characteristic of programming languages is that they allow the
conditional execution of code. For this <strong >C++</strong> offers the <code >if</code> and
<code >switch</code> statements. If we want to be able to `program the compiler'
this feature must also be offered by templates.
<p>
Like templates storing values templates making choices do not require any code
to be executed at run-time. The selection is purely made by the compiler, at
compile-time. The essence of template meta programming is that we are <em >not</em>
using or relying on any executable code.  The result of a template meta
program often is executable code, but that code is a function of decisions
merely made by the compiler.
<p>
Template (member) functions are only instantiated when they are actually
used. Consequently we can define specializations of functions that are
mutually exclusive. Thus it is possible to define a specialization that can be
compiled in situation one, but not in situation two and to define another
specialization that can be compiled in situation two, but not in situation
one. Using specializations code can be generated that is tailored to the
demands of a particular situation.
<p>
A feature like this cannot be implemented in run-time executable code. For
example, when designing a generic storage class the software engineer may
intend to store <em >value class</em> type objects as well as objects of
<em >polymorphic class</em> types in the final storage class. Thus the software
engineer may conclude that the storage class should contain pointers to
objects, rather than the objects themselves. The initial implementation
attempt could look like this:
        <pre>
    template &lt;typename Type&gt;
    void Storage::add(Type const &amp;obj)
    {
        d_data.push_back(
            d_ispolymorphic ?
                obj.clone()
            :
                new Type{obj}
        );
    }
</pre>
    The intent is to use the <code >clone</code> member function of the class <code >Type</code>
if <code >Type</code> is a polymorphic class and the standard copy constructor if
<code >Type</code> is a value class.
<p>
Unfortunately, this scheme usually fails as value classes do not define
<code >clone</code> member functions and polymorphic base classes should <em >delete</em>
their copy constructors (cf. section <a href="cplusplus07.html#DEFAULTED">7.6</a>). It doesn't matter to the
compiler that <code >clone</code> is never called for value classes and that the copy
constructor is only available in value classes and not in polymorphic
classes. It merely has some code to compile, and can't do that because of
missing members. It's as simple as that.
<p>
<a name="l597"></a>
<h4>23.2.2.1: Defining overloading members</h4>
            Template meta programming comes to the rescue. Knowing that class template
member functions are only instantiated when used, our plan is to design
overloaded <code >add</code> member functions of which only one is going to be called
(and thus instantiated). Our selection will be based on an additional (in
addition to <code >Type</code> itself) template non-type parameter that indicates
whether we'll use <code >Storage</code> for polymorphic or non-polymorphic classes. Our
class <code >Storage</code> starts like this:
        <pre>
    template &lt;typename Type, bool isPolymorphic&gt;
    class Storage
</pre>
    Initially two <em >overloaded</em> versions of our <code >add</code> member are defined:
one used with <code >Storage</code> objects storing polymorphic objects (using <code >true</code>
as its template non-type argument) and one storing value
class objects (using <code >false</code> as its template non-type argument).
<p>
Unfortunately we run into a small problem: functions cannot be overloaded
by their argument <em >values</em> but only by their argument <em >types</em>. But the
small problem may be solved. Realizing that types are defined by the
combination of template names and their template arguments we may convert the
values <code >true</code> and <code >false</code> into types using the knowledge from section
<a href="cplusplus23.html#INTTYPE">23.2.1.1</a> about how to convert integral values to types.
<p>
We'll provide one (private) <code >add</code> member with an <code >IntType&lt;true&gt;</code> parameter
(implementing the polymorphic class) and another (private) <code >add</code> member with
an <code >IntType&lt;false&gt;</code> parameter (implementing the non-polymorphic class).
<p>
In addition to these two private members a third (public) member <code >add</code> is
defined calling the appropriate private <code >add</code> member by providing an
<code >IntType</code> argument, constructed from <code >Storage</code>'s template non-type
parameter.
<p>
Here are the implementations of the three <code >add</code> members:
        <pre>
    // declared in Storage's private section:

    template &lt;typename Type, bool isPolymorphic&gt;
    void Storage&lt;Type, isPolymorphic&gt;::add(Type const &amp;obj, IntType&lt;true&gt;)
    {
        d_data.push_back(obj.clone());
    }

    template &lt;typename Type, bool isPolymorphic&gt;
    void Storage&lt;Type, isPolymorphic&gt;::add(Type const &amp;obj, IntType&lt;false&gt;)
    {
        d_data.push_back(new Type(obj));
    }

    // declared in Storage's public section:

    template &lt;typename Type, bool isPolymorphic&gt;
    void Storage&lt;Type, isPolymorphic&gt;::add(Type const &amp;obj)
    {
        add(obj, IntType&lt;isPolymorphic&gt;());
    }
</pre>
    The appropriate <code >add</code> member is instantiated and called because a
primitive value can be converted to a type. Each of the possible template
non-type values is thus used to define an overloaded class template member
function.
<p>
Since class template members are only instantiated when used only one of
the overloaded private <code >add</code> members is instantiated. Since the other one is
never called (and thus never instantiated) compilation errors are prevented.
<p>
<a name="IFELSE"></a><a name="l598"></a>
<h4>23.2.2.2: Class structure as a function of template parameters</h4>
            Some software engineers have reservations when thinking about the
<code >Storage</code> class that uses pointers to store copies of value class
objects. Their argument is that value class objects can very well be stored by
value, rather than by pointer. They'd rather store value class objects by
value and polymorphic class objects by pointer.
<p>
Such distinctions  frequently occur in template meta programming and
the following <code >struct IfElse</code>
        <a name="an3077"></a>
        <a name="an3078"></a>
    may be used to obtain one of two types, depending on a <code >bool</code> selector
value.
<p>
First define the <em >generic form</em> of the template:
        <pre>
    template&lt;bool selector, typename FirstType, typename SecondType&gt;
    struct IfElse
    {
        typedef FirstType type;
    };
</pre>
    Then define a partial specialization. The specialization represents
a specific selector value (e.g., <code >false</code>) and leaves the remaining types
open to further specification:
        <pre>
    template&lt;typename FirstType, typename SecondType&gt;
    struct IfElse&lt;false, FirstType, SecondType&gt;
    {
        typedef SecondType type;
    };
</pre>
    The former (generic) definition associates <code >FirstType</code> with the
<code >IfElse::type</code> type definition, the latter definition (partially specialized
for the logical value <code >false</code>) associates <code >SecondType</code> with the
<code >IfElse::type</code> type definition.
<p>
The <code >IfElse</code> template allows us to define class templates whose data
organization is conditional to the template's parameters.
    <a name="an3079"></a>
 Using <code >IfElse</code> the <code >Storage</code> class may define
<em >pointers</em> to store copies of polymorphic class type objects and <em >values</em>
to store value class type objects:
        <pre>
    template &lt;typename Type, bool isPolymorphic&gt;
    class Storage
    {
        typedef typename IfElse&lt;isPolymorphic, Type *, Type&gt;::type
                DataType;

        std::vector&lt;DataType&gt; d_data;

        private:
            void add(Type const &amp;obj, IntType&lt;true&gt;);
            void add(Type const &amp;obj, IntType&lt;false&gt;);
        public:
            void add(Type const &amp;obj);
    }

    template &lt;typename Type, bool isPolymorphic&gt;
    void Storage&lt;Type, isPolymorphic&gt;::add(Type const &amp;obj, IntType&lt;true&gt;)
    {
        d_data.push_back(obj.clone());
    }

    template &lt;typename Type, bool isPolymorphic&gt;
    void Storage&lt;Type, isPolymorphic&gt;::add(Type const &amp;obj, IntType&lt;false&gt;)
    {
        d_data.push_back(obj);
    }

    template &lt;typename Type, bool isPolymorphic&gt;
    void Storage&lt;Type, isPolymorphic&gt;::add(Type const &amp;obj)
    {
        add(obj, IntType&lt;isPolymorphic&gt;());
    }
</pre>
    The above example uses <code >IfElse</code>'s <code >type</code>, defined by <code >IfElse</code> as
either <code >FirstType</code> or <code >SecondType</code>. <code >IfElse</code>'s <code >type</code> defines the
actual data type to use for <code >Storage</code>'s <code >vector</code> data type.
<p>
The remarkable result in this example is that the <em >data organization</em> of
the <code >Storage</code> class now depends on its template arguments. Since the
<code >isPolymorphic == true</code> situation uses different data types than the
<code >isPolymorphic == false</code> situation, the overloaded private <code >add</code> members
can utilize this difference immediately. E.g., <code >add(Type const &amp;obj,
IntType&lt;false&gt;)</code> uses direct copy construction to store a copy of <code >obj</code>
in <code >d_vector</code>.
<p>
It is also possible to make a selection from multiple types as <code >IfElse</code>
structs can be nested. Realize that using <code >IfElse</code> never has any effect on
the size or execution time of the final executable program. The final program
simply contains the appropriate type, conditional to the type that's
eventually selected.
<p>
<a name="l599"></a>
<h4>23.2.2.3: An illustrative example</h4>
            The next example, defining <code >MapType</code> as a map having plain types or
pointers for either its key or value types, illustrates this approach:
        <pre>
    template &lt;typename Key, typename Value, int selector&gt;
    class Storage
    {
        typedef typename IfElse&lt;
                    selector == 1,              // if selector == 1:
                    map&lt;Key, Value&gt;,            // use map&lt;Key, Value&gt;

                    typename IfElse&lt;
                        selector == 2,          // if selector == 2:
                        map&lt;Key, Value *&gt;,      // use map&lt;Key, Value *&gt;

                        typename IfElse&lt;
                            selector == 3,      // if selector == 3:
                            map&lt;Key *, Value&gt;,  // use map&lt;Key *, Value&gt;
                                                // otherwise:
                            map&lt;Key *, Value *&gt; // use map&lt;Key *, Value *&gt;

                        &gt;::type
                    &gt;::type
                &gt;::type
                MapType;

        MapType d_map;

        public:
            void add(Key const &amp;key, Value const &amp;value);
        private:
            void add(Key const &amp;key, Value const &amp;value, IntType&lt;1&gt;);
           ...
    };
    template &lt;typename Key, typename Value, int selector&gt;
    inline void Storage&lt;selector, Key, Value&gt;::add(Key const &amp;key,
                                                   Value const &amp;value)
    {
        add(key, value, IntType&lt;selector&gt;());
    }
</pre>
    The principle used in the above examples is: if class templates may use
data types that depend on template non-type parameters, an <code >IfElse</code> struct
can be used to select the appropriate data types. Knowledge about the various
data types may also be used to define overloaded member functions. The
implementations of these overloaded members may then be optimized to the
various data types. In programs only one of these alternate functions (the one
that is optimized to the actually used data types) will then be instantiated.
<p>
The private <code >add</code> functions define the same parameters as the public
<code >add</code> wrapper function, but add a specific <code >IntType</code> type, allowing the
compiler to select the appropriate overloaded version based on the template's
non-type selector parameter.
<p>
<a name="l600"></a>
<h3 >23.2.3: Templates: Iterations by Recursion</h3>
        As there are no variables in template meta programming, there is no
template equivalent to a <code >for</code> or <code >while</code> statement. However, iterations
can always be rewritten as recursions.  Recursions <em >are</em> supported
by templates and so iterations can always be implemented as (tail) recursions.
        <a name="an3080"></a>
<p>
To implement iterations by (tail) recursion do as follows:
    <ul>
    <li> define a specialization implementing the end-condition;
    <li> define all other steps using recursion.
    <li> store intermediate values as <code >enum</code> values.
    </ul>
    The compiler selects a more specialized template implementation over a
more generic one. By the time the compiler reaches the end-condition the
recursion stops since the specialization does not use recursion.
<p>
Most readers are probably familiar with the recursive implementation of
the mathematical `<em >factorial</em>' operator, commonly represented by the
exclamation mark (<code >!</code>): <code >n</code> factorial (so: <code >n!</code>) returns the successive
products <code >n * (n - 1) * (n - 2) * ... * 1</code>, representing the number of ways
<code >n</code> objects can be permuted. Interestingly, the factorial operator is itself
usually defined by a <em >recursive</em> definition:
        <pre>
    n! = (n == 0) ?
            1
        :
            n * (n - 1)!
</pre>
    To compute <code >n!</code> from a template, a template <code >Factorial</code> can be defined
using an <code >int n</code> template non-type parameter. A specialization is defined
for the case <code >n == 0</code>. The generic implementation uses recursion according
to the factorial definition. Furthermore, the <code >Factorial</code> template defines
an <code >enum</code> value `<code >value</code>' containing its factorial value. Here is the
generic definition:
        <pre>
    template &lt;int n&gt;
    struct Factorial
    {
        enum { value = n * Factorial&lt;n - 1&gt;::value };
    };
</pre>
    Note how the expression assigning a value to `<code >value</code>' uses constant
values that can be determined by the compiler. The value n is provided, and
<code >Factorial&lt;n - 1&gt;</code> is computed using <em >template meta
programming</em>. <code >Factorial&lt;n-1&gt;</code> in turn results in value that can be
determined by the compiler (<em >viz.</em>
<code >Factorial&lt;n-1&gt;::value</code>). <code >Factorial&lt;n-1&gt;::value</code> represents the <code >value</code>
defined by the <em >type</em> <code >Factorial&lt;n - 1&gt;</code>. It is <em >not</em> the value returned
by an <em >object</em> of that type. There are no objects here but merely values
defined by types.
<p>
The recursion ends in  a specialization. The compiler selects the
specialization (provided for the terminating value 0) instead of  the generic
implementation whenever possible. Here is the specialization's implementation:
        <pre>
    template &lt;&gt;
    struct Factorial&lt;0&gt;
    {
        enum { value = 1 };
    };
</pre>
    The <code >Factorial</code> template can be used to determine, compile time, the
number of permutations of a fixed number of objects. E.g.,
        <pre>
    int main()
    {
        cout &lt;&lt; "The number of permutations of 5 objects = " &lt;&lt;
                Factorial&lt;5&gt;::value &lt;&lt; "\n";
    }
</pre>
    Once again, <code >Factorial&lt;5&gt;::value</code> is <em >not</em> evaluated at run-time, but
at compile-time. The run-time equivalent of the above <code >cout</code> statement is,
therefore:
        <pre>
    int main()
    {
        cout &lt;&lt; "The number of permutations of 5 objects = " &lt;&lt;
                120 &lt;&lt; "\n";
    }
</pre>
<p>
<a name="UDL"></a><a name="l601"></a>
<h2 >23.3: User-defined literals</h2>
In addition to the literal operators discussed in section <a href="cplusplus11.html#UDLITERALS">11.13</a> 
<strong >C++</strong> also offers a function template literal operator, matching the
prototype
        <pre>
    template &lt;char ...Chars&gt;
    Type operator "" _identifier()
</pre>
    This variadic non-type parameter function template defines no parameters,
but merely a variadic non-type parameter list.
<p>
Its argument must be an int constant, as is also expected by the literal
operator defining an <code >unsigned long long int</code> parameter. All the characters
of the int constant are passed as individual <code >char</code> non-type template
arguments to the literal operator.
<p>
For example, if <code >_NM2km</code> is a literal operator function template, it can
be called as <code >80_NM2km</code>. The function template is then actually called as
<code >_NM2km&lt;'8', '0'&gt;()</code>. If this function template merely uses template meta
programming techniques and only processes integral data then its actions can
be performed completely at compile-time. To illustrate this, let's assume
<code >NM2km</code> only processes and returns unsigned values.
<p>
The function template <code >_NM2km</code> can forward its argument to a class template,
defining an enum constant <code >value</code>, and that performs the required
computations. Here is the implementation of the variadic literal operator
function template <code >_NM2km</code>:
            <pre>
    template &lt;char ... Chars&gt;
    size_t constexpr operator "" _NM2km()
    {
        return static_cast&lt;size_t&gt;(             // forward Chars to NM2km
                NM2km&lt;0, Chars ...&gt;::value * 1.852);
    }
</pre>
    The class template <code >NM2km</code> defines three non-type parameters: <code >acc</code>
accumulates the value, <code >c</code> is the first character of the variadic non-type
parameters, while <code >...Chars</code> represents the remaining non-type parameters,
contained in a non-type parameter pack. Since <code >c</code> is, at each recursive
call, the next character from the original non-type parameter pack, the value
so far multiplied by 10 plus the value of the next character is passed as the
next accumulated value to its recursive call, together with the remaining
elements of the parameter pack, represented by <code >Chars ...</code>:
            <pre>
    template &lt;size_t acc, char c, char  ...Chars&gt;
    struct NM2km
    {
        enum
        {
            value = NM2km&lt;10 * acc + c - '0', Chars ...&gt;::value
        };
    };
</pre>
    Eventually, the parameter pack is empty. For this case a partial
specialization of <code >NM2km</code> is available:
        <pre>
    template &lt;size_t acc, char c&gt;   // empty parameter pack
    struct NM2km&lt;acc, c&gt;
    {
        enum
        {
            value = 10 * acc + c - '0'
        };
    };
</pre>
<p>
This works fine, but of course not in cases where binary, octal, or
hexadecimal values must also be interpreted. In that case we must first
determine whether the first character(s) indicate a special number
system. This can be determined by the class template <code >NM2kmBase</code>, that is
now called from the <code >_NM2km</code> literal operator:
            <pre>
    template &lt;char ... Chars&gt;
    size_t constexpr operator "" _NM2km()
    {
        return static_cast&lt;size_t&gt;(         // forward Chars to NM2kmBase
                NM2kmBase&lt;Chars ...&gt;::value * 1.852);
    }
</pre>
    The <code >NM2kmBase</code> class template normally assumes the decimal number
system, passing base value 10 and initial sum 0 to <code >NM2km</code>. The <code >NM2km</code>
class template is provided with an additional (first) non-type parameter
representing the base value of the number system to use. Here is
<code >NM2kmBase</code>:
        <pre>
    template &lt;char ...Chars&gt;
    struct NM2kmBase
    {
        enum
        {
            value = NM2km&lt;10, 0, Chars ...&gt;::value
        };
    };
</pre>
    Partial specializations handle the different number systems, by inspecting
the first (one or two) characters:
        <pre>
    template &lt;char ...Chars&gt;
    struct NM2kmBase&lt;'0', Chars ...&gt;        // "0..."
    {
        enum
        {                                   // octal value: base 8
            value = NM2km&lt;8, 0, Chars ...&gt;::value
        };
    };

    template &lt;char ...Chars&gt;
    struct NM2kmBase&lt;'0', 'b', Chars ...&gt;   // "0b..."
    {
        enum
        {                                   // binary value: base 2
            value = NM2km&lt;2, 0, Chars ...&gt;::value
        };
    };

    template &lt;char  ...Chars&gt;
    struct NM2kmBase&lt;'0', 'x', Chars ...&gt;   // "0x..."
    {
        enum
        {                                   // hex value: base 16
            value = NM2km&lt;16, 0, Chars ...&gt;::value
        };
    };
</pre>
<p>
<code >NM2km</code> is implemented as before, albeit that it can now handle
various number systems. The conversion from character to numeric value is left
to a small support function template, <code >cVal</code>:
        <pre>
    template &lt;char c&gt;
    int constexpr cVal()
    {
        return '0' &lt;= c &lt;= '9' ? c - '0' : 10 + c - 'a';
    }

    template &lt;size_t base, size_t acc, char c, char  ...Chars&gt;
    struct NM2km
    {
        enum
        {
            value = NM2km&lt;base, base * acc + cVal&lt;c&gt;(),
                                        Chars ...&gt;::value
        };
    };

    template &lt;size_t base, size_t acc, char c&gt;
    struct NM2km&lt;base, acc, c&gt;
    {
        enum { value = base * acc + cVal&lt;c&gt;() };
    };
</pre>
<p>
<a name="TEMPTEMPPAR"></a><a name="l602"></a>
<h2 >23.4: Template template parameters</h2>
Consider the following situation: a software engineer is asked to design a
storage class <code >Storage</code>. Data stored in <code >Storage</code> objects may either make
and store copies of the data or store the data as received. <code >Storage</code>
objects may also either use a vector or a linked list as its underlying
storage medium. How should the engineer tackle this request? Should four
different <code >Storage</code> classes be designed?
<p>
The engineer's first reaction could be to develop an all-in <code >Storage</code> class.
It could have two data members, a list and a vector, and its constructor could
be provided with maybe an enum value indicating whether the data itself or new
copies should be stored. The enum value can be used to initialize a series of
pointers to member functions performing the requested tasks (e.g., using a
vector to store the data or a list to store copies).
<p>
Complex, but doable. Then the engineer is asked to modify the class: in the
case of new copies a custom-made allocation scheme should be used rather than
the standard <code >new</code> operator.  He's also asked to allow the use of yet
another type of container, in addition to the vector and the list that were
already part of the design. Maybe a <code >deque</code> would be preferred or maybe even
a <code >stack</code>.
<p>
It's clear that the approach aiming at implementing all functionality and all
possible combinations in one class doesn't scale. The class <code >Storage</code> soon
becomes a monolithic giant which is hard to understand, maintain, test, and
deploy.
<p>
One of the reasons why the big, all-encompassing class is hard to deploy and
understand is that a well-designed class should
        <a name="an3081"></a>
    <em >enforce constraints</em>: the design of the class should, by itself,
disallow certain operations, violations of which should be detected by the
compiler, rather than by a program that might terminate in a fatal error.
<p>
Think about the above request. If the class offers both an interface to access
the vector data storage <em >and</em> an interface to access the list data storage,
then it's likely that the class offers an overloaded <a name="an3082"></a><code >operator[]</code> member
to access elements in the vector. This member, however, will be syntactically
present, but semantically invalid when the <em >list</em> data storage is selected,
which doesn't support <code >operator[]</code>.
<p>
Sooner or later, <em >users</em> of the monolithic all-encompassing class
<code >Storage</code> will fall into the trap of using <code >operator[]</code> even though
they've selected the list as the underlying data storage. The compiler won't
be able to detect the error, which only appears once the program is
running, confusing its users.
<p>
The question remains: how should the engineer proceed, when confronted with
the above questions? It's time to introduce <a name="an3083"></a> <em >policies</em>.
<p>
<a name="l603"></a>
<h3 >23.4.1: Policy classes - I</h3>
    A <a name="an3084"></a><em >policy</em> defines (in some contexts: prescribes) a particular kind of
behavior. In <strong >C++</strong> a
    <a name="an3085"></a>
 <em >policy class</em> defines a certain part of the class interface. It may also
define inner types, member functions, and data members.
<p>
In the previous section the problem of creating a class that might use any of
a series of allocation schemes was introduced. These allocation schemes all
depend on the actual data type to use, and so the `template reflex' should
kick in.
<p>
Allocation schemes should probably be defined as template classes, applying
the appropriate allocation procedures to the data type at hand. When such
allocation schemes are used by the familiar STL containers (like
<code >std::vector, std::stack</code>, etc.), then such home-made allocation schemes
should probably be derived from <code >std::allocator</code><a name="an3086"></a>, to provide
for the requirements made by these containers. The class template
<code >std::allocator</code> is declared by the <a name="an3087"></a><code >&lt;memory&gt;</code> header file and the three
allocation schemes developed here were all derived from <code >std::allocator</code>.
<p>
Using in-class implementations for brevity the following allocation classes
could be defined:
    <ul>
    <li> No special allocation takes place, <code >Data</code> is used `as is':
    <pre>
template &lt;typename Data&gt;
class PlainAlloc: public std::allocator&lt;Data&gt;
{
    template&lt;typename IData&gt;
    friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;out,
                                    PlainAlloc&lt;IData&gt; const &amp;alloc);
    Data d_data;

    public:
        PlainAlloc()
        {}
        PlainAlloc(Data const &amp;data)
        :
            d_data(data)
        {}
        PlainAlloc(PlainAlloc&lt;Data&gt; const &amp;other)
        :
            d_data(other.d_data)
        {}
};
</pre>
    <li> The second allocation scheme uses the standard <code >new</code> operator to
allocate a new copy of the data:
    <pre>
template &lt;typename Data&gt;
class NewAlloc: public std::allocator&lt;Data&gt;
{
    template&lt;typename IData&gt;
    friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;out,
                                    NewAlloc&lt;IData&gt; const &amp;alloc);
    Data *d_data;

    public:
        NewAlloc()
        :
            d_data(0)
        {}
        NewAlloc(Data const &amp;data)
        :
            d_data(new Data(data))
        {}
        NewAlloc(NewAlloc&lt;Data&gt; const &amp;other)
        :
            d_data(new Data(*other.d_data))
        {}
        ~NewAlloc()
        {
            delete d_data;
        }
};
</pre>
    <li> The third allocation scheme uses the <a name="an3088"></a>placement new operator (see
        section <a href="cplusplus09.html#PLACEMENT">9.1.5</a>), requesting memory from a
        common pool (the implementation of the member <code >request</code>,
        obtaining the required amount of memory, is left as an exercise to the
        reader):
    <pre>
template&lt;typename Data&gt;
class PlacementAlloc: public std::allocator&lt;Data&gt;
{
    template&lt;typename IData&gt;
    friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;out,
                                    PlacementAlloc&lt;IData&gt; const &amp;alloc);
    Data *d_data;

    static char s_commonPool[];
    static char *s_free;

    public:
        PlacementAlloc()
        :
            d_data(0)
        {}
        PlacementAlloc(Data const &amp;data)
        :
            d_data(new(request()) Data(data))
        {}
        PlacementAlloc(PlacementAlloc&lt;Data&gt; const &amp;other)
        :
            d_data(new(request()) Data(*other.d_data))
        {}
        ~PlacementAlloc()
        {
            d_data-&gt;~Data();
        }
    private:
        static char *request();
};
</pre>
    </ul>
    The above three classes define <em >policies</em> that may be selected by the
user of the class <code >Storage</code> introduced in the previous section. In addition
to these classes, additional allocation schemes could be implemented by the
user as well.
<p>
To apply the proper allocation scheme to the class <code >Storage</code>,
<code >Storage</code> should be designed as a class template itself. The class also
needs a template type parameter allowing users to specify the data type.
<p>
The data type to be used by a particular allocation scheme could of course
be specified when specifying the allocation scheme to use. The class
<code >Storage</code> would then have two template type parameters, one for the data
type, one for the allocation scheme:
        <pre>
    template &lt;typename Data, typename Scheme&gt;
    class Storage ...
</pre>
<p>
To use the class <code >Storage</code> we would then write, e.g.:
        <pre>
    Storage&lt;string, NewAlloc&lt;string&gt;&gt; storage;
</pre>
    Using <code >Storage</code> this way is fairly complex and potentially error-prone,
as it requires the user to specify the data type twice. Instead, the
allocation scheme should be specified using a new type of template parameter,
not requiring the user to specify the data type required by the allocation
scheme. This new kind of template parameter (in addition to the well-known
<em >template type parameter</em> and <em >template non-type parameter</em>) is called the
 <a name="an3089"></a><em >template template parameter</em>.
<p>
Starting with the C++14 standard the keyword <em >class</em> 
        <a name="an3090"></a> 
    in the syntactical form of template template parameters (<code >template
&lt;parameter specifications&gt; class Name</code>) is no longer required. From that
standard onward, the keyword <code >typename</code> can also be used (e.g., <code >template
&lt;parameter specifications&gt; typename Name</code>).
<p>
<a name="l604"></a>
<h3 >23.4.2: Policy classes - II: template template parameters</h3>
    Template <a name="an3091"></a> template parameters allow us to
specify a <em >class template</em> as a template parameter. By specifying a class
template, it is possible to add a certain kind of behavior (called a
<a name="an3092"></a><em >policy</em>) to an existing class template.
<p>
To specify an allocation <em >policy</em>, rather than an allocation <code >type</code>
for the class <code >Storage</code> we rephrase its class template header:
definition starts as follows:
        <pre>
    template &lt;typename Data, template &lt;typename&gt; class Policy&gt;
    class Storage...
</pre>
    The second template parameter is new. It is a <em >template template
parameter</em>. It has the following elements:
    <ul>
    <li> The keyword <code >template</code>, starting the template template parameter;
    <li> The keyword <code >template</code> is followed (between angle brackets) by a
        list of template parameters that must be specified for the template
        template parameter. These parameters <em >may</em> be given names, but names
        are usually omitted as those names cannot be used in subsequent
        template definitions. On the other hand, providing formal names may
        help the reader of the template to understand the kind of templates
        that must be specified with the template template parameter.
    <li> Template template parameters must match, in numbers and types (i.e.,
        template type parameters, template non-type parameters, template
        template parameters) the template parameters that must be specified
        for the policy. This can be tricky, as some templates use default
        parameters that are hardly ever changed (like the allocation schemes
        for containers). Programmers may not immediately realize that these
        defaults exist and be confused when the compiler rejects such
        templates when trying to pass them as template template parameters for
        which these additional (default) parameters weren't
        specified. However, language offers a solution for this
        problem in the form of <em >alias templates</em>, introduced in section
        <a href="cplusplus23.html#ALIASES">23.5</a>.
    <li> Following the bracketed list the keyword <a name="an3093"></a><code >class</code> or <code >typename</code> 
        <em >must</em> be specified. 
    <li> All parameters may be provided with default arguments. This is shown
        in the next example of a hypothetical class template:
        <pre>
template &lt;
    template &lt;
        typename = std::string,
        int = 12,
        template &lt;typename = int&gt; class Inner = std::vector
    &gt;
    class Policy
&gt;
class Demo
{
   ...
};
</pre>
       Here, the class template <code >Demo</code> expects a template template parameter
        named <code >Policy</code>, expecting three template parameters: a template type
        parameter (by default <code >std::string</code>); a template non-type parameter
        (by default having value 12); and <code >Policy</code> itself expects a template
        template parameter, called <code >Inner</code>, by default using an <code >int</code> as
        its template type parameter.
       </ul>
    Policy classes are often an integral part of the class under
consideration. Because of this they are often deployed as base classes. In the
example the class <code >Policy</code> could be used as a base class of the class
<code >Storage</code>.
<p>
The policy operates on the class <code >Storage</code>'s data type. Therefore the
policy is informed about that data type as well. Our class <code >Storage</code> now
begins like this:
        <pre>
    template &lt;typename Data, template &lt;typename&gt; class Policy&gt;
    class Storage: public Policy&lt;Data&gt;
</pre>
    This automatically allows us to use <code >Policy</code>'s members when implementing
the members of the class <code >Storage</code>.
<p>
Our home-made allocation classes do not really provide us with many useful
members. Except for the extraction operator they offer no immediate access to
the data. This can easily be repaired by adding more members. E.g., the class
<code >NewAlloc</code> could be augmented with operators allowing access to and
modification of stored data:
            <pre>
        operator Data &amp;()   // optionally add a `const' member too
        {
            return *d_data;
        }
        NewAlloc &amp;operator=(Data const &amp;data)
        {
            *d_data = data;
        }
</pre>
    The other allocation classes could be given comparable members.
<p>
Let's use the allocation schemes in some real code. The next
example shows how <code >Storage</code> can be defined using some data type and an
allocation scheme. We start out again with a class <code >Storage</code>:
        <pre>
    template &lt;typename Data, template &lt;typename&gt; class Allocate&gt;
    class Storage: public std::vector&lt;Data, Allocate&lt;Data&gt;&gt;
    {};
</pre>
    That's all we have to do. Note that <code >std::vector</code> formally has two
template parameters. The first one is the vector's data type, which is always
specified; the second one is the allocator used by the vector. Usually the
allocator is left unspecified (in which case the default STL allocator is
used), but here it is mentioned explicitly, allowing us to pass our own
allocation policy to <code >Storage</code>.
<p>
All required functionality is inherited from the <code >vector</code> base class, while
the policy is `factored into the equation' using a template template
parameter. Here's an example showing how this is done:
        <pre>
    Storage&lt;std::string, NewAlloc&gt; storage;

    copy(istream_iterator&lt;std::string&gt;(cin), istream_iterator&lt;std::string&gt;(),
            back_inserter(storage));

    cout &lt;&lt; "Element index 1 is " &lt;&lt; storage[1] &lt;&lt; '\n';
    storage[1] = "hello";

    copy(storage.begin(), storage.end(),
         ostream_iterator&lt;NewAlloc&lt;std::string&gt; &gt;(cout, "\n"));
</pre>
   Since <code >Storage</code> objects are also <code >std::vector</code> objects the STL <code >copy</code>
function can be used in combination with the <em >back_inserter</em> iterator to add
some data to the <code >storage</code> object. Its elements can be accessed and modified
using the index operator. Then <code >NewAlloc&lt;std::string&gt;</code> objects are inserted
into <code >cout</code> (also using the <code >copy</code> function).
<p>
Interestingly, this is not the end of the story. Remember that our
intention was to create a class allowing us to specify the <em >storage type</em> as
well. What if we don't want to use a <code >vector</code>, but instead would like to use
a <code >list</code>?
<p>
It's easy to change <code >Storage</code>'s setup so that a completely different
storage type can be used on request, like a <code >deque</code>. To implement this, the
storage class is parameterized as well, using yet another template template
parameter:
        <pre>
    template &lt;typename Data, template &lt;typename&gt; class AllocationPolicy,
              template &lt;typename, typename&gt; class Container = std::vector&gt;
    class Storage: public Container&lt;Data, AllocationPolicy&lt;Data&gt;&gt;
    {};
</pre>
    The earlier example using a <code >Storage</code> object can be used again without
requiring any modifications at all (except for the above redefinition). It
clearly can't be used with a <code >list</code> container, as the <code >list</code> lacks
<code >operator[]</code>. Trying to do so is immediately recognized by the compiler,
producing an error if an attempt is made to use <code >operator[]</code> on, e.g., a
    <code >list</code>.&nbsp;(A complete example showing the definition of the
allocation classes and the class <code >Storage</code> as well as its use is provided in
the <strong >C++</strong> Annotations's distribution in the file
<code >yo/advancedtemplates/examples/storage.cc</code>.) A <code >list</code> container, however
can still be specified as the container to use. In that case a <code >Storage</code> is
implemented as a <code >list</code>, offering <code >list</code>'s interface, rather than
<code >vector</code>'s interface, to its users.
<p>
<a name="l605"></a>
<h4>23.4.2.1: The destructor of Policy classes</h4>
        In the previous section policy classes were used as base classes of template
classes. This resulted in the interesting observation that a policy class
may serve as a <em >base class</em>
        <a name="an3094"></a>
    of a derived class.
    As a policy class may act as a base class, a pointer or reference to such
a policy class can be used to point or refer to the derived class using the
policy.
<p>
This situation, although legal, should be avoided for various reasons:
        <a name="an3095"></a>
    <ul>
    <li> Destruction of a derived class object using the base class's
destructor requires the implementation of a virtual destructor;
    <li> A virtual destructor introduces overhead to a class that normally has
no data members, but merely defines behavior: suddenly a <a name="an3096"></a><code >vtable</code> is
required as well as a data member pointing to the vtable;
    <li> Virtual member functions somewhat reduce the efficiency of code;
virtual member functions use <a name="an3097"></a><em >dynamic polymorphism</em>, which in principle is
undoing the advantages of <a name="an3098"></a><em >static polymorphism</em> as offered by templates;
    <li> Virtual member functions in templates may result in <a name="an3099"></a><em >code bloat</em>:
once an instantiation of a class's member is required, the class's vtable and
<em >all</em> its virtual members must be implemented too.
    </ul>
    To avoid these drawbacks, it is good practice to <em >prevent</em> the use of
references or pointers to policy classes to refer or point to derived
class objects. This is accomplished by providing policy classes with
        <a name="an3100"></a>
    <em >non-virtual protected destructors</em>. With a non-virtual destructor there
is no performance penalty and since its destructor is protected users cannot
refer to classes derived from the policy class using a pointer or reference to
the policy class.
<p>
<a name="l606"></a>
<h3 >23.4.3: Structure by Policy</h3>
    Policy classes usually define behavior, not structure. Policy classes
        <a name="an3101"></a>
 are normally used to parameterize some aspect of the behavior of classes that
are derived from them. However, different policies may require different data
members. These data members may also be defined by the policy classes. Policy
classes may therefore be used to define both behavior and structure.
<p>
By providing a well-defined interface a class derived from a policy class may
define member specializations using the different structures of policy classes
to their advantage. For example, a plain pointer-based policy class could
offer its functionality by resorting to <strong >C</strong>-style <a name="an3102"></a>pointer juggling,
whereas a <code >vector</code>-based policy class could use the vector's members
directly.
<p>
In this example a generic class template <code >Size</code> could be designed
expecting a container-like policy using features commonly found in
containers, defining the data (and hence the structure) of the container
specified in the policy. E.g.:
        <pre>
    template &lt;typename Data, template &lt;typename&gt; class Container&gt;
    struct Size: public Container&lt;Data&gt;
    {
        size_t size()
        {                           // relies on the container's `size()'
                                    // note: can't use `this-&gt;size()'
            return Container&lt;Data&gt;::size();
        }
    };
</pre>
    A specialization can now be defined for a much simpler storage class
using, e.g., plain pointers (the implementation capitalizes on <code >first</code> and
<code >second</code>, data members of <code >std::pair</code>.  Cf. the example at the end of this
section):
        <pre>
    template &lt;typename Data&gt;
    struct Size&lt;Data, Plain&gt;: public Plain&lt;Data&gt;
    {
        size_t size()
        {                           // relies on pointer data members
            return this-&gt;second - this-&gt;first;
        }
    };
</pre>
    Depending on the intentions of the template's author other members could
be implemented as well.
<p>
To simplify the real use of the above templates, a generic wrapper class
can be constructed: it uses the <code >Size</code> template matching the actually used
storage type (e.g., a <code >std::vector</code> or some plain storage class) to define
its structure:
        <pre>
    template &lt;typename Data, template &lt;typename&gt; class Store&gt;
    class Wrapper: public Size&lt;Data, Store&gt;
    {};
</pre>
<p>
The above classes could now be used as follows (<em >en passant</em> showing an
extremely basic <code >Plain</code> class):
        <pre>
    #include &lt;iostream&gt;
    #include &lt;vector&gt;

    template &lt;typename Data&gt;
    struct Plain: public std::pair&lt;Data *, Data *&gt;
    {};

    int main()
    {
        Wrapper&lt;int, std::vector&gt; wiv;
        std::cout &lt;&lt; wiv.size() &lt;&lt; "\n";

        Wrapper&lt;int, Plain&gt; wis;
        std::cout &lt;&lt; wis.size() &lt;&lt; "\n";
    }
</pre>
    The <code >wiv</code> object now defines vector-data, the <code >wis</code> object merely
defines a <code >std::pair</code> object's data members.
<p>
<a name="ALIASES"></a><a name="l607"></a>
<h2 >23.5: Alias Templates</h2>
In addition to function and class templates, <strong >C++</strong> also uses templates to
define an alias for a set of types. This is called an
    <a name="an3103"></a><em >alias template</em>. Alias templates can be specialized. The name of an
alias template is a type name.
<p>
Alias templates can be used as arguments to template template
parameters. This allows us to avoid the `unexpected default parameters' you
may encounter when using template template parameters.  E.g., defining a
template specifying a <code >template &lt;typename&gt; class Container</code> is fine, but it
is impossible to specify a container like <code >vector</code> or <code >set</code> as template
template argument, as <code >vector</code> and <code >set</code> containers also define a second
template parameter, specifying their allocation policy.
<p>
Alias templates are defined like <code >using</code> declarations, specifying an alias
for an existing (maybe partially or fully specialized) template type. In the
following example <code >Vector</code> is defined as an alias for <code >vector</code>:
        <pre>
    template &lt;typename Type&gt;
    using Vector = std::vector&lt;Type&gt;;

    Vector&lt;int&gt; vi;             // same as std::vector&lt;int&gt;
    std::vector&lt;int&gt; vi2(vi);   // copy construction: OK
</pre>
    So, what's the point of doing this?
    Looking at the <code >vector</code> container, we see that it defines two, rather
than one, template parameters, the second parameter being the allocation
policy <code >_Alloc</code>, by default set to <code >std::allocator&lt;_Tp&gt;</code>:
        <pre>
    template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt; &gt;
    class vector: ...
</pre>
    Now define a class template <code >Generic</code> defining a template template
parameter:
        <pre>
    template &lt;typename Type, template &lt;typename&gt; class Container&gt;
    class Generic: public Container&lt;Type&gt;
    {
        ...
    };
</pre>
    Most likely, <code >Generic</code> offers members made available by the container
that is actually used to create the <code >Generic</code> object, and adds to those some
members of it own. However, a simple container like <code >std::vector</code> cannot be
used, as <code >std::vector</code> doesn't match a <code >template &lt;typename&gt; class
Container&gt;</code> parameter; it requires a <code >template &lt;typename, typename&gt; class
Container&gt;</code> template template parameter.
<p>
The <code >Vector</code> alias template, however, <em >is</em> defined as a template
having one template type parameter, and it uses the vector's default
allocator. Consequently, passing a <code >Vector</code> to <code >Generic</code> works fine:
        <pre>
    Generic&lt;int, Vector&gt; giv;       // OK
    Generic&lt;int, std::vector&gt; err;  // won't compile: 2nd argument mismatch
</pre>
<p>
With the aid of a small alias template it is also possible to use a
completely different kind of container, like a <code >map</code>, with <code >Generic</code>:
        <pre>
    template &lt;typename Type&gt;
    using MapString = std::map&lt;Type, std::string&gt;;

    Generic&lt;int, MapString&gt; gim;    // uses map&lt;int, string&gt;
</pre>
<p>
<a name="TRAIT"></a><a name="l608"></a>
<h2 >23.6: Trait classes</h2>
Scattered over the <code >std</code> namespace
    <a name="an3104"></a><a name="an3105"></a>
    <em >trait classes</em> are found. E.g., most <strong >C++</strong> programmers have seen
the compiler mentioning `<code >std::char_traits&lt;char&gt;</code>' when performing an
illegal operation on <code >std::string</code> objects, as in <code >std::string s(1)</code>.
<p>
Trait classes are used to make compile-time decisions about types. Trait
classes allow us to apply the proper code to the proper data type, be it a
pointer, a reference, or a plain value, all this maybe in combination with
<code >const</code>. The particular type of data to use can be inferred from the actual
type that is specified (or implied) when the template is used. This can be
fully automated, not requiring the template writer to make any decision.
<p>
Trait classes allow us to develop a <code >template &lt;typename Type1, typename
Type2, ...&gt;</code> without the need to specify many specializations covering all
combinations of, e.g., values, (const) pointers, or (const) references, which
would soon result in an unmaintainable exponential explosion of template
specializations (e.g., allowing these five different types for each template
parameter already results in 25 combinations when two template type parameters
are used: each must be covered by potentially different specializations).
<p>
Having available a trait class, the actual type can be inferred compile
time, allowing the compiler to deduce whether or not the actual type is a
pointer, a pointer to a member, or a const pointer, and to make comparable
deductions in case the actual type is, e.g., an lvalue or rvalue reference
type. This in turn allows us to write templates that define types like
    <a name="an3106"></a>
 <a name="an3107"></a><code >argument_type</code>, <a name="an3108"></a><code >first_argument_type</code>, <a name="an3109"></a><code >second_argument_type</code> and
<a name="an3110"></a><code >result_type</code>, which are required by several generic algorithms (e.g.,
<a href="cplusplus19.html#COUNTIF">count_if()</a>).
<p>
A trait class usually performs no behavior. I.e., it has no constructor
and no members that can be called. Instead, it defines a series of types and
<code >enum</code> values that have certain values depending on the actual type that is
passed to the trait class template.  The compiler uses one of a set of
available specializations to select the one appropriate for an actual template
type parameter.
<p>
The point of departure when defining a trait template is a plain
vanilla <code >struct</code>, defining the characteristics of a plain value type like
an <code >int</code>.  This sets the stage for specific specializations, modifying the
characteristics for any other type that could be specified for the template.
<p>
To make matters concrete, assume the intent is to create a trait class
<code >BasicTraits</code> telling us whether a type is a plain value type, a pointer
type, an lvalue reference type or an rvalue reference type (all of which may
or may not be <code >const</code> types).
<p>
Whatever the actually provided type, we want to be able to determine the
`plain' type (i.e., the type without any modifiers, pointers or references),
the `pointer type' and the `reference type', allowing us to define in all
cases, e.g., an rvalue reference to its built-in type, even though we passed a
const pointer to that type.
<p>
Our point of departure, as mentioned, is a plain <code >struct</code> defining the
required parameter. Maybe something like this:
        <pre>
        template &lt;typename T&gt;
        struct Basic
        {
            typedef T Type;
            enum
            {
                isPointer = false,
                isConst = false,
                isRef = false,
                isRRef = false
            };
        };
</pre>
<p>
Although some conclusions can be drawn by combining various <code >enum</code>
values (e.g., a plain type is not a pointer or a reference or an rvalue
reference or a const), it is good practice to provide a full implementation of
trait classes, not requiring its users to construct these logical expressions
themselves. Therefore, the basic decisions in a trait class are usually made
by a
        <a name="an3111"></a><a name="an3112"></a>nested trait class,
    leaving the task of creating appropriate logical expressions to a
surrounding trait class.
<p>
So, the <code >struct Basic</code> defines the generic form of our inner trait
class. Specializations handle specific details. E.g., a pointer type is
recognized by the following specialization:
        <pre>
        template &lt;typename T&gt;
        struct Basic&lt;T *&gt;
        {
            typedef T Type;
            enum
            {
                isPointer = true,
                isConst = false,
                isRef = false,
                isRRef = false
            };
        };
</pre>
<p>
whereas a pointer to a const type is matched with the next specialization:
        <pre>
        template &lt;typename T&gt;
        struct Basic&lt;T const *&gt;
        {
            typedef T Type;
            enum
            {
                isPointer = true,
                isConst = true,
                isRef = false,
                isRRef = false
            };
        };
</pre>
<p>
Several other specializations should be defined: e.g., recognizing
<code >const</code> value types or (rvalue) reference types. Eventually all these
specializations are implemented as nested <code >struct</code>s of an outer class
<code >BasicTraits</code>, offering the public traits class interface. The outline of
the outer trait class is:
        <pre>
    template &lt;typename TypeParam&gt;
    class BasicTraits
    {
        // Define specializations of the template `Base' here

        public:
            BasicTraits(BasicTraits const &amp;other) = delete;

            typedef typename Basic&lt;TypeParam&gt;::Type ValueType;
            typedef ValueType *PtrType;
            typedef ValueType &amp;RefType;
            typedef ValueType &amp;&amp;RvalueRefType;

            enum
            {
                isPointerType = Basic&lt;TypeParam&gt;::isPointer,
                isReferenceType = Basic&lt;TypeParam&gt;::isRef,
                isRvalueReferenceType = Basic&lt;TypeParam&gt;::isRRef,
                isConst = Basic&lt;TypeParam&gt;::isConst,
                isPlainType = not (isPointerType or isReferenceType or
                                   isRvalueReferenceType or isConst)
            };
    };
</pre>
    The trait class's public interface explicitly deletes its copy
constructor. As it therefore defines no constructor at all and as it has no
static members it does not offer any run-time executable code.
All the trait class's facilities must therefore be used compile time.
<p>
A trait class template can be used to obtain the proper type, irrespective
of the template type argument provided. It can also be used to select
a proper specialization that depends on, e.g., the <code >const</code>-ness of a
template type. Example:
        <pre>
     cout &lt;&lt;
      "int: plain type? "     &lt;&lt; BasicTraits&lt;int&gt;::isPlainType &lt;&lt; "\n"
      "int: ptr? "            &lt;&lt; BasicTraits&lt;int&gt;::isPointerType &lt;&lt; "\n"
      "int: const? "          &lt;&lt; BasicTraits&lt;int&gt;::isConst &lt;&lt; "\n"
      "int *: ptr? "          &lt;&lt; BasicTraits&lt;int *&gt;::isPointerType &lt;&lt; "\n"
      "int const *: ptr? "    &lt;&lt; BasicTraits&lt;int const *&gt;::isPointerType &lt;&lt;
                                                                      "\n"
      "int const: const? "    &lt;&lt; BasicTraits&lt;int const&gt;::isConst &lt;&lt; "\n"
      "int: reference? "      &lt;&lt; BasicTraits&lt;int&gt;::isReferenceType &lt;&lt; "\n"
      "int &amp;: reference? "    &lt;&lt; BasicTraits&lt;int &amp;&gt;::isReferenceType &lt;&lt; "\n"
      "int const &amp;: ref ? "   &lt;&lt; BasicTraits&lt;int const &amp;&gt;::isReferenceType &lt;&lt;
                                                                        "\n"
      "int const &amp;: const ? " &lt;&lt; BasicTraits&lt;int const &amp;&gt;::isConst &lt;&lt; "\n"
      "int &amp;&amp;: r-reference? " &lt;&lt; BasicTraits&lt;int &amp;&amp;&gt;::isRvalueReferenceType &lt;&lt;
                                                                        "\n"
      "int &amp;&amp;: const? " &lt;&lt; BasicTraits&lt;int &amp;&amp;&gt;::isConst &lt;&lt; "\n"
      "int const &amp;&amp;: r-ref ? "&lt;&lt; BasicTraits&lt;int const &amp;&amp;&gt;::
                                                isRvalueReferenceType &lt;&lt; "\n"
      "int const &amp;&amp;: const ? "&lt;&lt; BasicTraits&lt;int const &amp;&amp;&gt;::isConst &lt;&lt; "\n"
        "\n";

     BasicTraits&lt;int *&gt;::ValueType           value = 12;
     BasicTraits&lt;int const *&gt;::RvalueRefType rvalue = int(10);
     BasicTraits&lt;int const &amp;&amp;&gt;::PtrType      ptr = new int(14);
     cout &lt;&lt; value &lt;&lt; ' ' &lt;&lt; rvalue &lt;&lt; ' ' &lt;&lt; *ptr &lt;&lt; '\n';
</pre>
<p>
<a name="CLASSORNOT"></a><a name="l609"></a>
<h3 >23.6.1: Distinguishing class from non-class types</h3>
    In the previous section the <code >BasicTraits</code> trait class was developed. Using
specialized versions of a nested <code >struct Type</code> modifiers, pointers,
references and values could be distinguished.
<p>
Knowing whether a type is a class type or not (e.g., the type represents a
primitive type) could also be a useful bit of knowledge to a template
developer. The class template developer might want to define a
specialization when the template's type parameter represents a class
type (maybe using some member function that should be available)
and another specialization for non-class types.
<p>
This section addresses the question how a trait class can distinguish class
        <a name="an3113"></a>
    types from non-class types.
<p>
In order to distinguish classes from non-class types a distinguishing feature
that can be used at compile-time must be found. It may take some thinking to
find such a distinguishing characteristic, but a good candidate eventually is
found in the <a name="an3114"></a>pointer to members syntactic construct. Pointers to members
are only available for classes. Using the pointer to member construct as the
distinguishing characteristic, a specialization can be developed that uses the
pointer to member if available. Another specialization (or the generic
template) does something else if the pointer to member construction is not
available.
<p>
How can we distinguish a pointer to a member from `a generic situation',
not being a pointer to a member? Fortunately, such a distinction is
possible. A function template specialization can be defined having a parameter
which is a pointer to a member function. The generic function template
then accepts any other argument. The compiler <em >selects</em> the former
(specialized) function when the provided type is a class type as class types
<em >may</em> support a pointer to a member. The interesting verb here is `<em >may</em>':
the class does not <em >have</em> to define a pointer to member.
<p>
Furthermore, the compiler does not actually <em >call</em> any function: we're
talking compile-time here. All the compiler does is to <em >select</em> the
appropriate function by evaluating a constant expression.
<p>
So, our intended function template now looks like this:
        <pre>
    template &lt;typename ClassType&gt;
    static `some returntype'  fun(void (ClassType::*)());
</pre>
    The function's return type (`<code >(some returntype)</code>') will be defined
shortly. Let's first have a closer look at the function's parameter.  The
function's parameter defines a pointer to a member returning <code >void</code>. Such a
function does <em >not</em> have to exist for the concrete class-type that's
specified when the function is used.  In fact, <em >no</em> implementation is
provided. The function <code >fun</code> is only declared as a <em >static</em> member in the
trait class. It's not implemented and no trait class object is required to
call it. What, then, is its use?
<p>
To answer the question we now have a look at the generic function
template that should be used when the template's argument is <em >not</em> a class
type. The language offers a `worst case' parameter in its
        <a name="an3115"></a>
    <a name="an3116"></a><em >ellipsis</em> parameter list. The ellipsis is a final resort the compiler
may turn to if everything else fails. The generic function template specifies
a plain ellipsis in its parameter list:
        <pre>
    template &lt;typename NonClassType&gt;
    static `some returntype' fun(...);
</pre>
    It would be an error to define the generic alternative as a function
expecting an <code >int</code>. The compiler, when confronted with alternatives,
favors the simplest, most specified alternative over a more complex, generic
one. So, when providing <code >fun</code> with an argument it selects <code >int</code>
whenever possible and it won't select <code >fun(void (ClassType::*)())</code>. When
given the choice between <code >fun(void (ClassType::*)())</code> and <code >fun(...)</code> it
selects the former unless it can't do that.
<p>
The question now becomes: what argument can be used for both a pointer to
a member and for the ellipsis? Actually, there is such a `one size fits all'
argument: 0. The value 0 can be passed as argument value to functions defining
an ellipsis parameter and to functions defining a pointers-to-member
parameter.
<p>
But 0 does not specify a particular class. Therefore, <code >fun</code> must specify
an explicit template argument, appearing in our code as <code >fun&lt;Type&gt;(0)</code>, with
<code >Type</code> being the template type parameter of the trait class.
<p>
Now for the return type. The function's return type cannot be a simple
value (like <code >true</code> or <code >false</code>). Our eventual intent is to provide the
trait class with an enum telling us whether the trait class's template
argument represents a class type or not. That enum becomes something like
this:
        <pre>
    enum { isClass = some class/non-class distinguishing expression } ;
</pre>
    The distinguishing expression cannot be
        <pre>
    enum { isClass = fun&lt;Type&gt;(0) } ;
</pre>
    as <code >fun&lt;Type&gt;(0)</code> is not a constant expression and enum values <em >must</em>
        <a name="an3117"></a>
 be defined by constant expressions so they can be determined at compile-time.
<p>
To determine <code >isClass</code>'s value we must find an expression allowing for
compile-time discriminations between <code >fun&lt;Type&gt;(...)</code>  and <code >fun&lt;Type&gt;(void
(Type::*)())</code>.
<p>
In situations like these the <a name="an3118"></a><code >sizeof</code> operator often is our tool of
choice as it is evaluated at compile-time. By defining different sized return
types for the two <code >fun</code> declarations we are able to distinguish (at
compile-time) which of the two <code >fun</code> alternatives is selected by the
compiler.
<p>
The <code >char</code> type is by definition a type having size 1. By defining
another type containing two consecutive <code >char</code> values a larger type is
obtained. A <code >char [2]</code> is of course not a type, but a <code >char[2]</code> can be
defined as a data member of a struct, and a struct <em >does</em> define a
type. That struct then has a size exceeding 1. E.g.,
        <pre>
    struct Char2
    {
        char data[2];
    };
</pre>
    <code >Char2</code> can be defined as a nested type of our traits class. The
two <code >fun</code> function template declarations become:
        <pre>
    template &lt;typename ClassType&gt;
    static Char2 fun(void (ClassType::*)());

    template &lt;typename NonClassType&gt;
    static char fun(...);
</pre>
    Since <code >sizeof</code> expressions are evaluated at compile-time we can now
determine <code >isClass</code>'s value:
        <pre>
    enum { isClass = sizeof(fun&lt;Type&gt;(0)) == sizeof(Char2) };
</pre>
    This expression has several interesting implications:
    <ul>
    <li> no <code >fun</code> function template is ever instantiated;
    <li> the compiler considers <code >Type</code> and selects
<code >fun</code>'s function template specialization if <code >Type</code> is a class type and the
generic function template if not;
    <li> From the selected function it determines the return type and thus the
return type's size;
    <li> Resulting in the proper evaluation of <code >isClass</code>.
    </ul>
    Without requiring any instantiation the trait class can now provide an
answer to the question whether a template type argument represents a class
type or not. Marvelous!
<p>
<a name="TYPETRAITS"></a><a name="l610"></a>
<h3 >23.6.2: Available type traits</h3>
    <strong >C++</strong> offers many facilities to identify and modifiy
characteristics of types. Before using these facilities the <a name="an3119"></a><code >&lt;type_traits&gt;</code>
header file must be included.
<p>
All facilities offered by <code >type_traits</code> are defined in the <code >std</code>
namespace (omitted from the examples given below), allowing programmers to
determine various characteristics of types and values.
<p>
In the description of available type traits the following concepts are
encountered: 
    <ul>
    <li> <a name="an3120"></a><em >arithmetic type</em>:
       any integral or floating point type;
<p>
<li> <a name="an3121"></a><em >class type</em>:
       not a union type, without non-static data members, without virtual
        members, without virtual or non-empty base classes;
<p>
<li> <a name="an3122"></a><em >compound type</em>:
      <ul>
       <li> arrays of objects of a given type;
       <li> functions, which have parameters of a given type returning
        <code >void</code> or objects;
       <li> pointers to <code >void</code>, to objects, to functions, or to 
        non-static class members;
       <li> references to objects or functions;
       <li> class, union or enumeration types;
       </ul>
<p>
<li> <a name="an3123"></a><em >fundamental type</em>:
       a built-in type;
<p>
<li> <a name="an3124"></a><em >integral type</em>:
       all types whose values represent integral numbers, as well as <code >bool</code>
        and all built-in types representing (possibly unicode) characters;
<p>
<li> <a name="an3125"></a><em >literal type</em>:
       a literal type is a scalar type; a trivial class type; or an array of
        literal type elements;
<p>
<li> <a name="an3126"></a><em >is_nothrow_... type trait</em>:
       a type trait to determine whether its template argument supports the
        specified non-throwing member. Such type traits return <code >false</code>
        unless <code >noexcept(true)</code> is used at the function's declaration. E.g.,
       <pre>
    struct NoThrow
    {
        NoThrow &amp;operator=(SomeType const &amp;rhs) noexept(true);
    };
</pre>
<p>
<li> <a name="an3127"></a><em >trivial type</em>:
       trivial types are scalar types, trivial class types, arrays of such
        types and cv-qualified versions of these types;
<p>
<li> <a name="an3128"></a><em >trivial class type</em>: 
       a class type having a trivial copy constructor, no non-trivial move
        constructor, a trivial destructor, a trivial default constructor or at
        least one <code >constexpr</code> constructor other than the copy or move
        constructor, and only has non-static data members and base classes of
        literal types; 
<p>
<li> <a name="an3129"></a><em >trivial member function</em>: 
       trivial member functions are never declared (other than <code >default</code>) in
        their class interfaces and (for default constructors or assignment
        operators) only perform byte-by-byte actions. Here are two examples:
        <code >struct Pod</code> only has trivial members as it doesn't explicitly
        declare any member function and its data member is <em >plain old
        data</em>. <code >struct Nonpod</code> is <em >not</em> plain old data. Although it
        doesn't explictly declare any member function either, its data member
        is a <code >std::string</code>, which itself isn't plain old data as
        <code >std::string</code> has non-trivial constructors:
       <pre>
    struct Pod
    {
        int x;
    };

    struct Nonpod
    {
        std::string s;
    };
</pre>
    </ul>
<p>
When <em >type-condition</em> applies to a type, it must be a complete type,
<code >void</code>, or an array of unknown size;
<p>
The following type traits are provided:
    <ul>
    <li><code >add_const&lt;typename Type&gt;::type</code>
       <a name="an3130"></a> to add <code >const</code> to <code >Type</code>;
<p>
<li><code >add_cv&lt;typename Type&gt;::type</code>
       <a name="an3131"></a> to add <code >const volatile</code> to <code >Type</code>;
<p>
<li><code >add_lvalue_reference&lt;typename Type&gt;::type</code>
       <a name="an3132"></a> to add an lvalue reference to <code >Type</code>;
<p>
<li><code >add_pointer&lt;typename Type&gt;::type</code>
       <a name="an3133"></a> to add a pointer to <code >Type</code>;
<p>
<li><code >add_rvalue_reference&lt;typename Type&gt;::type</code>
       <a name="an3134"></a> to add an rvalue reference to <code >Type</code>;
<p>
<li><code >add_volatile&lt;typename Type&gt;::type</code>
       <a name="an3135"></a> to add <code >volatile</code> to <code >Type</code>;
    <li><code >conditional&lt;bool cond, typename TrueType, typename FalseType&gt;::type</code>
       <a name="an3136"></a> to conditionally use <code >TrueType</code> if <code >cond</code> is true,
        <code >FalseType</code> if not;
<p>
<li><code >enable_if&lt;bool cond, typename Type&gt;::type</code>
       <a name="an3137"></a> to conditionally define <code >Type</code> if <code >cond</code> is true;
<p>
<li><code >is_abstract&lt;typename Type&gt;::value</code>
       <a name="an3138"></a> to determine whether <code >Type</code> is an abstract type
        (e.g., an abstract base class) (<em >type-condition</em> applies);
<p>
<li><code >is_arithmetic&lt;typename Type&gt;::value</code>
       <a name="an3139"></a> to determine whether <code >Type</code> is an arithmetic type;
<p>
<li><code >is_array&lt;typename Type&gt;::value</code>
       <a name="an3140"></a> to determine whether <code >Type</code> is an array type;
<p>
<li><code >is_assignable&lt;typename To, typename From&gt;::value</code>
       <a name="an3141"></a> to determine whether an object of type <code >From</code> can
        be assigned to an object of type <code >To</code> (<em >type-condition</em> applies);
<p>
<li><code >is_base_of&lt;typename Base, typename Derived&gt;::value</code>
       <a name="an3142"></a> to determine whether <code >Base</code> is a base class
        of type <code >Derived</code>;
<p>
<li><code >is_class&lt;typename Type&gt;::value</code>
       <a name="an3143"></a> to determine whether <code >Type</code> is a class type;
<p>
<li><code >is_compound&lt;typename Type&gt;::value</code>
       <a name="an3144"></a> to determine whether <code >Type</code> is a compound type;
<p>
<li><code >is_const&lt;typename Type&gt;::value</code>
       <a name="an3145"></a> to determine whether <code >Type</code> is a const type;
<p>
<li><code >is_constructible&lt;typename Type, typename ...Args&gt;::value</code>
       <a name="an3146"></a> to determine whether <code >Type</code> is constructible
        from arguments in the <code >Args</code> parameter pack (<em >type-condition</em>
        applies to all types in <code >Args</code>);
<p>
<li><code >is_convertible&lt;typename From, typename To&gt;::value</code>
       <a name="an3147"></a> to determine whether a type <code >From</code> may be
        converted to a type <code >To</code> using a <code >static_cast</code>;
<p>
<li><code >is_copy_assignable&lt;typename Type&gt;::value</code>
       <a name="an3148"></a> to determine whether <code >Type</code> supports copy
        assignment (<em >type-condition</em> applies);
<p>
<li><code >is_copy_constructible&lt;typename Type&gt;::value</code>
       <a name="an3149"></a> to determine whether <code >Type</code> supports copy
        construction (<em >type-condition</em> applies);
<p>
<li><code >is_default_constructible&lt;typename Type&gt;::value</code>
       <a name="an3150"></a> to determine whether <code >Type</code> supports a
        default constructor (<em >type-condition</em> applies);
<p>
<li><code >is_destructible&lt;typename Type&gt;::value</code>
       <a name="an3151"></a> to determine whether <code >Type</code> has a non-deleted
        destructor (<em >type-condition</em> applies);
<p>
<li><code >is_empty&lt;typename Type&gt;::value</code>
       <a name="an3152"></a> to determine whether <code >Type</code> is a class type (not a union
        type), without non-static data members, virtual members, virtual or
        non-empty base classes (<em >type-condition</em> applies);
<p>
<li><code >is_enum&lt;typename Type&gt;::value</code>
       <a name="an3153"></a> to determine whether <code >Type</code> is an enum type;
<p>
<li><code >is_floating_point&lt;typename Type&gt;::value</code>
       <a name="an3154"></a> to determine whether <code >Type</code> is a floating point
        type;
<p>
<li><code >is_function&lt;typename Type&gt;::value</code>
       <a name="an3155"></a> to determine whether <code >Type</code> is a function type;
<p>
<li><code >is_fundamental&lt;typename Type&gt;::value</code>
       <a name="an3156"></a> to determine whether <code >Type</code> is a fundamental type;
<p>
<li><code >is_integral&lt;typename Type&gt;::value</code>
       <a name="an3157"></a> to determine whether <code >Type</code> is an integral type;
<p>
<li><code >is_literal_type&lt;typename Type&gt;::value</code>
       <a name="an3158"></a> to determine whether <code >Type</code> is a literal type
        (<em >type-condition</em> applies);
<p>
<li><code >is_lvalue_reference&lt;typename Type&gt;::value</code>
       <a name="an3159"></a> to determine whether <code >Type</code> is an lvalue
        reference;
<p>
<li><code >is_member_function_pointer&lt;typename Type&gt;::value</code>
       <a name="an3160"></a> to determine whether <code >Type</code> is a
        pointer to a non-static member function;
<p>
<li><code >is_member_object_pointer&lt;typename Type&gt;::value</code>
       <a name="an3161"></a> to determine whether <code >Type</code> is a pointer
        to a non-static data member;
<p>
<li><code >is_member_pointer&lt;typename Type&gt;::value</code>
       <a name="an3162"></a> to determine whether <code >Type</code> is a pointer to a
        member function;
<p>
<li><code >is_move_assignable&lt;typename Type&gt;::value</code>
       <a name="an3163"></a> to determine whether <code >Type</code> supports move
        assignment (<em >type-condition</em> applies);
<p>
<li><code >is_move_constructible&lt;typename Type&gt;::value</code>
       <a name="an3164"></a> to determine whether <code >Type</code> supports move
        construction (<em >type-condition</em> applies);
<p>
<li><code >is_nothrow_assignable&lt;typename To, typename From&gt;::value</code>
       <a name="an3165"></a> to determine whether <code >Type</code> supports an
        assignment operator not throwing exceptions (<em >type-condition</em>
        applies).
<p>
<li><code >is_nothrow_constructible&lt;typename Type, typename ...Args&gt;::value</code>
       <a name="an3166"></a> to determine whether a <code >Type</code> object can
        be constructed from arguments of types mentioned in the parameter pack
        not throwing exceptions (<em >type-condition</em> applies);
<p>
<li><code >is_nothrow_copy_assignable&lt;typename Type&gt;::value</code>
       <a name="an3167"></a> to determine whether <code >Type</code> supports a
        copy-assignment operator not throwing exceptions (<em >type-condition</em>
        applies);
<p>
<li><code >is_nothrow_copy_constructible&lt;typename Type&gt;::value</code>
       <a name="an3168"></a> to determine whether <code >Type</code>
        supports copy construction not throwing exceptions (<em >type-condition</em>
        applies);
<p>
<li><code >is_nothrow_default_constructible&lt;typename Type&gt;::value</code>
       <a name="an3169"></a> to determine whether <code >Type</code>
        supports a default constructor not throwing exceptions
        (<em >type-condition</em> applies);
<p>
<li><code >is_nothrow_destructible&lt;typename Type&gt;::value</code>
       <a name="an3170"></a> to determine whether <code >Type</code> supports a
        destructor not throwing exceptions (<em >type-condition</em> applies).
<p>
<li><code >is_nothrow_move_assignable&lt;typename Type&gt;::value</code>
       <a name="an3171"></a> to determine whether <code >Type</code> supports
        move assignment not throwing exceptions (<em >type-condition</em> applies);
<p>
<li><code >is_nothrow_move_constructible&lt;typename Type&gt;::value</code>
       <a name="an3172"></a> to determine whether <code >Type</code>
        supports a move constructor not throwing exceptions
        (<em >type-condition</em> applies);
<p>
<li><code >is_object&lt;typename Type&gt;::value</code>
       <a name="an3173"></a> to determine whether <code >Type</code> is an object (in contrast
        to scalar) type;
<p>
<li><code >is_pod&lt;typename Type&gt;::value</code>
       <a name="an3174"></a> to determine whether <code >Type</code> is <a name="an3175"></a><em >plain old data</em>
        (<em >type-condition</em> applies);
<p>
<li><code >is_pointer&lt;typename Type&gt;::value</code>
       <a name="an3176"></a> to determine whether <code >Type</code> is a pointer type;
<p>
<li><code >is_polymorphic&lt;typename Type&gt;::value</code>
       <a name="an3177"></a> to determine whether <code >Type</code> is a polymorphic type
        (<em >type-condition</em> applies);
<p>
<li><code >is_reference&lt;typename Type&gt;::value</code>
       <a name="an3178"></a> to determine whether <code >Type</code> is an (lvalue or rvalue)
        reference;
<p>
<li><code >is_rvalue_reference&lt;typename Type&gt;::value</code>
       <a name="an3179"></a> to determine whether <code >Type</code> is an rvalue
        reference;
<p>
<li><code >is_same&lt;typename First, typename Second&gt;::value</code>
       <a name="an3180"></a> to determine whether types <code >First</code> and <code >Second</code> are
        identical;
<p>
<li><code >is_scalar&lt;typename Type&gt;::value</code>
       <a name="an3181"></a> to determine whether <code >Type</code> is a scalar type (in
        contrast to an object type);
<p>
<li><code >is_signed&lt;typename Type&gt;::value</code>
       <a name="an3182"></a> to determine whether <code >Type</code> is a signed type;
<p>
<li><code >is_standard_layout&lt;typename Type&gt;::value</code>
       <a name="an3183"></a> to determine whether <code >Type</code> offers the
        standard layout (<em >type-condition</em> applies);
<p>
<li><code >is_trivial&lt;typename Type&gt;::value</code>
       <a name="an3184"></a> to determine whether <code >Type</code> is a trivial type
        (<em >type-condition</em> applies);
<p>
<li><code >is_trivially_assignable&lt;typename Dest, typename Src&gt;::value</code>
       <a name="an3185"></a> to determine whether an object or value of
        type <code >Src</code> can trivially be assigned to an object of type <code >Dest</code>
        (<em >type-condition</em> applies);
<p>
<li><code >is_trivially_constructible&lt;typename Type, typename ...Args&gt;::value</code>
       <a name="an3186"></a> to determine whether <code >Type</code> is
        trivially constructible from arguments in the <code >Args</code> parameter pack
        (<em >type-condition</em> applies to all types in <code >Args</code>);
<p>
<li><code >is_trivially_copy_assignable&lt;typename Type&gt;::value</code>
       <a name="an3187"></a> to determine whether <code >Type</code> supports
        a trivial assignment operator (<em >type-condition</em> applies);
<p>
<li><code >is_trivially_copy_constructible&lt;typename Type&gt;::value</code>
       <a name="an3188"></a> to determine whether <code >Type</code> is
        trivially copy-constructible (<em >type-condition</em> applies);
<p>
<li><code >is_trivially_copyable&lt;typename Type&gt;::value</code>
       <a name="an3189"></a> to determine whether <code >Type</code> is trivially
        copyable (<em >type-condition</em> applies);
<p>
<li><code >is_trivially_default_constructible&lt;typename Type&gt;::value</code>
       <a name="an3190"></a> to determine whether <code >Type</code>
        supports a trivial default constructor (<em >type-condition</em> applies);
<p>
<li><code >is_trivially_default_destructible&lt;typename Type&gt;::value</code>
       <a name="an3191"></a> to determine whether <code >Type</code>
        supports a trivial default destructor (<em >type-condition</em> applies);
<p>
<li><code >is_trivially_move_assignable&lt;typename Type&gt;::value</code>
       <a name="an3192"></a> to determine whether <code >Type</code> supports
        a trivial assignment operator (<em >type-condition</em> applies);
<p>
<li><code >is_trivially_move_constructible&lt;typename Type&gt;::value</code>
       <a name="an3193"></a> to determine whether <code >Type</code> is
        trivially move-constructible (<em >type-condition</em> applies);
<p>
<li><code >is_union&lt;typename Type&gt;::value</code>
       <a name="an3194"></a> to determine whether <code >Type</code> is a union type;
<p>
<li><code >is_unsigned&lt;typename Type&gt;::value</code>
       <a name="an3195"></a> to determine whether <code >Type</code> is an unsigned type;
<p>
<li><code >is_void&lt;typename Type&gt;::value</code>
       <a name="an3196"></a> to determine whether <code >Type</code> is <code >void</code>;
<p>
<li><code >is_volatile&lt;typename Type&gt;::value</code>
       <a name="an3197"></a> to determine whether <code >Type</code> is a <code >volatile</code>
        qualified type;
<p>
<li><code >make_signed&lt;typename Type&gt;::type</code>
       <a name="an3198"></a> to construct a signed type;
<p>
<li><code >make_unsigned&lt;typename Type&gt;::type</code>
       <a name="an3199"></a> to construct an unsigned type;
<p>
<li><code >remove_all_extents&lt;typename Type&gt;::type</code>
       <a name="an3200"></a> if <code >Type</code> is a (possibly multidimensional)
        array of <code >ElementType</code> values or objects then <code >typedef type</code>
        equals <code >ElementType</code>;
<p>
<li><code >remove_const&lt;typename Type&gt;::type</code>
       <a name="an3201"></a> to remove <code >const</code> from <code >Type</code>;
<p>
<li><code >remove_cv&lt;typename Type&gt;::type</code>
       <a name="an3202"></a> to remove <code >const</code> and/or <code >volatile</code> from <code >Type</code>;
<p>
<li><code >remove_extent&lt;typename Type&gt;::type</code>
       <a name="an3203"></a> if <code >Type</code> is an array of <code >ElementType</code> values or
        objects then <code >typedef type</code> equals <code >ElementType</code>. With
        multi-dimensional arrays <code >ElementType</code> is the type of the array from
        which its first array dimension has been removed;
<p>
<li><code >remove_pointer&lt;typename Type&gt;::type</code>
       <a name="an3204"></a> to remove a pointer from <code >Type</code>;
<p>
<li><code >remove_reference&lt;typename Type&gt;::type</code>
       <a name="an3205"></a> to remove a reference from <code >Type</code>;
<p>
<li><code >remove_volatile&lt;typename Type&gt;::type</code>
       <a name="an3206"></a> to remove <code >volatile</code> from <code >Type</code>;
<p>
</ul>
<p>
<a name="ERRCODEENUM"></a><a name="l611"></a>
<h3 >23.6.3: Deriving classes from std::error_code</h3>
    In section <a href="cplusplus10.html#ERRORCODEEXC">10.9.1</a> the class <code >std::error_code</code> was introduced. One
of its constructors accepts an <a name="an3207"></a><code >ErrorCodeEnum</code>. Enums we
define ourselves may be `promoted' to <code >ErrorCodeEnums</code>, allowing their use
by <code >error_code</code> and comparable classes. 
<p>
Standard error code values (like the <code >errno</code> values), or the values defined
by <code >enum class Errc</code> are used by low-level system functions like
<strong >stat</strong>(2), but they may not be suited for errors encountered by your own
functions or classes. For example, when designing an interactive calculator,
several errors may be encountered that are related to the way expressions are
entered by the user. For those situations you might want to develop your own
<code >ErrorCodeEnum</code>. At the same time, the organization of the classes involved
in using <code >system_error</code> exceptions is complex, and the situation is further
complicated when different developers use their own self-defined enumerations
and classes. For example, it is enticing to list error conditions in an enum,
but such an enum is hard to maintain if your program links to a library in
which another developer has defined a separate enumeration. If you also 
want to use the newly available error conditions then it's less attractive to
update your implementation so that that's possible. 
<p>
The approach developed in this and the next section results in more flexible
(although still complex...) code. First two <code >ErrorCodeEnums</code> are developed:
they are the starting points when defining related error values. That these
values are related is then further developed by defining matching classes,
that are derived from the class <code >error_category</code> (see section
<a href="cplusplus14.html#ERRCAT">14.9</a>). Error conditions are used to associate error values with generic
causes of errors. Since error conditions may previously have been defined
(maybe by different developers) it is an interesting puzzle by itself to
figure out how multiple error conditions can flexibly be combined in one
program. This puzzle is solved by defining a class <code >ErrorCondition</code> that is
able to manage all error conditions.
<p>
The example used below focuses on the construction of a flight simulator. When
using the flight simulator itself several errors may be encountered (e.g., a
navigation beacon is out of range). Inside the cockpit, the system offers a
calculator, and here too specific errors may emerge: a non-existing function
may be requested, or parentheses of complex expressions might not
match. Whereas the former error is a specific calculator related error, the
latter is an error that's associated with bad user input, and thus three broad
categories of errors (i.e., error conditions) are distinguished: simulator-,
calculator-, and user-errors.
<p>
<ul>
<li> Our first step consists of defining our own error enumerations: one
    related to the calculator and one related to the simulator:
<p>
<pre>
enum class CalculatorError
{
    // no 0, since that's by convention implies no error
    //  values do not have to be consecutive
    NoLvalue = 1,           // lhs of assignment is lvalue
    TypeError,              // incorrect expression type
    RangeError,             // e.g. sqrt(-1)
    ArityError,             // too few, too many arguments to a function
    UnknownFunction,        // function not defined
    MissingParentheses,     // ( and ) don't match
};
</pre>
<p>
<pre>
enum class SimulatorError
{
    // no 0
    //  values do not have to be consecutive
    EngineFailure = 1,      // engine malfunction
    ComFailure,             // the radio communication failed
    RangeError,             // outside the range of a navigation system
    UnknownFunction,        // auto pilot function not available
    // ...                  // etc.
};
</pre>
<p>
The class <code >std::error_code</code> is designed so that two pieces of
    information (the error value and its category) become available. The
    (int) error code through the member <code >value()</code>, the error category
    through its member <code >category()</code>.
<p>
<li> Second, our intention is to let <code >error_code</code> accept
    <code >CalculatorError</code> and <code >SimulatorError</code> values using its
    <code >error_code(ErrorCodeEnum)</code> constructor as this allows us to
    retrieve error values and categories, using our own error code
    enumerations. 
<p>
To achieve that the trait class <a name="an3208"></a><code >is_error_code_enum's</code> static member
    <code >value</code> must return <code >true</code> when provided with a
    value from our own error enumeration. This trait class.  Interestingly,
    defining the specializations of <code >std::is_error_code_enum</code> requires us to
    add code to the <code >std</code> namespace. Normally this is not allowed, but in
    this case it is. The <strong >C++</strong> standard states:
<p>
<blockquote >20.5.4.2.1 Namespace std
<p>
The behavior of a C++ program is undefined if it adds declarations or
        definitions to namespace std or to a namespace within namespace std
        unless otherwise specified.
<p>
A program may add a template specialization for any standard library
        template to namespace std only if the declaration depends on a
        user-defined type and the specialization meets the standard library
        requirements for the original template and is not explicitly
        prohibited.  
    </blockquote> 
   Here is the specialization for <code >CalculatorError</code>; the one for
    <code >SimulatorError</code> is defined analogously:
<p>
<pre>
namespace std
{
    template &lt;&gt;
    struct is_error_code_enum&lt;CalculatorError&gt;: public true_type
    {};
}
</pre>
<p>
This completes the definition of our own error enumerations, which are
    now `promoted' to <code >ErrorCodeEnums</code>.
<p>
<li> Third, one of the constructors of <code >error_code</code> objects expects, in
    addition to an error value (an <code >int</code>) an <code >error_category</code>
    reference. Although the member template constructor merely requires an
    <code >ErrorCodeEnum</code> value, in fact it also needs an <code >error_category</code>
    object. That constructor normally casts the <code >ErrorCodeEnum</code> value to an
    <code >int</code>, and constructs the <code >error_code</code> by also specifying a fitting
    <code >error_category</code>. Therefore, a class matching the <code >ErrorCodeEnum</code> is
    usually derived from <code >error_category</code>. Deriving a class from
    <code >error_category</code> is covered in the next section.
</ul>
<p>
<a name="l612"></a>
<h3 >23.6.4: Deriving classes from std::error_category</h3> 
    The <code >ErrorCodeEnums</code> developed in the previous section are the starting
points for two more classes, derived from the class <code >error_category</code> (see
section <a href="cplusplus14.html#ERRCAT">14.9</a>). 
<p>
Classes derived from <code >error_category</code> are designed as singleton classes, and
merely have to implement their own <code >name, message</code> and an <code >equivalent</code>
function.
<p>
Associated with errors defined by <code >ErrorCodeEnums</code> are two textual items
(NTBSs): a verbal description of the error, and the name of the <em >error
condition</em> to which the enum value belongs. E.g., with
<code >CalculatorError:::MissingParentheses</code> the description <code >"parentheses don't
match"</code> and the error condition name <code >"InputCond"</code> could be matched. Those
associations are collected in a class template <code >CatMap</code>, derived from
<code >std::unordered_map</code>. <code >CatMap</code>'s design is a rather straightforward,
offering a constructor accepting an <code >std::initializer_list</code>:
<p>
<pre>
    template &lt;class Enum&gt;
    class CatMap: public std::unordered_map&lt;
                                Enum,
                                std::tuple&lt;char const *, char const *&gt;
                        &gt;       //         description   condition name
    {
        typedef std::tuple&lt;char const *, char const *&gt; Tuple;
        typedef std::unordered_map&lt;Enum, Tuple&gt; Map;
    
        public:
            CatMap(std::initializer_list&lt;typename Map::value_type&gt; const &amp;list);
    };
    
    template &lt;class Enum&gt;
    CatMap&lt;Enum&gt;::CatMap(
                    std::initializer_list&lt;typename Map::value_type&gt; const &amp;list)
    :
        Map{ list }
    {}
</pre>
<p>
As <code >ErrorCodeEnum</code>-values may have been randomly assigned (not using 0)
<code >CapMap</code> objects offers fast access to the errors' descriptions and
condition names. Note that <code >CatMap</code> objects provide error conditions by
name: by the time the category class is designed the (eventually?) available
error conditions are at least known by name, and so they can be referred to by
their names. Actually defining error conditions is covered in the next
section.
<p>
When deriving a class from <code >error_category</code> a member <code >message(int ev)</code>
<em >must</em> be defined, overriding the <code >error_category's message</code>, returning
the descriptions matching error enum value <code >ev</code>. As associations between
enum values and descriptions are defined in a <code >CatMap</code> object, the
implementations of <code >message</code> members can simply use <code >CatMap</code>
objects. 
<p>
Message handling itself can therefore be factorized in a class template
<code >CategoryBase</code>. <code >CategoryBase</code> objects are instantiated with an
<code >ErrorCodeEnum</code> type (<code >Enum</code>), and contain a <code >static CatMap&lt;Enum&gt; const
s_errors</code> object as well as a <code >message(int ev, char const *noEnumValue)
const</code> member, returning the description matching <code >ev</code> or the error message
<code >noEnumValue</code> if <code >ev</code> does not represent a defined enum value. Here is its
implementation:
<p>
<pre>
    template &lt;class Enum&gt;
    std::string CategoryBase&lt;Enum&gt;::message(int ev, char const *noEnumValue) const
    {
        auto iter = s_errors.find(static_cast&lt;Enum&gt;(ev));
    
        return iter == s_errors.end() ? noEnumValue : std::get&lt;0&gt;(iter-&gt;second);
    }
</pre>
<p>
But that isn't all that <code >CategoryBase</code> can accomplish: since it contains
<code >s_errors</code>, the associations between error enum values and category
conditions are also available. Error category classes also define members
<code >bool equivalent(std::error_code const &amp;ec, int condNr)</code>. These members are
called from the equally named <code >ErrorCondition</code> member to verify that a
provided error code is indeed associated with error condition number
<code >condNr</code>. Given the availability of <code >CatMap s_errors</code>, and a facility in
the class <code >ErrorCondition</code> for retrieving the condition's name given its
number, error categories' <code >equivalent</code> implementations are identical,
except for the actually used error code enumeration. But as that enumeration
is provided as a template argument to <code >CategoryBase</code> a member function
<code >equivalent</code> can be defined performing the required test. The implementation
simply locates the error enum's value stored in an <code >error_code</code> in
<code >s_errors</code>, and compares the stored error condition's name to the name
provided by the (singleton) <code >error_condition</code> object, given the condition's
number. Here is its implementation:
<p>
<pre>
    template &lt;class Enum&gt;
    bool CategoryBase&lt;Enum&gt;::equivalent(std::error_code const &amp;ec, int condNr)
                                                                    const noexcept
    {
        auto iter = s_errors.find(static_cast&lt;Enum&gt;(ec.value()));
    
        return  iter != s_errors.end()
                and
                std::get&lt;1&gt;(iter-&gt;second) == ErrorCondition::instance()[condNr];
    }
</pre>
<p>
In addition, to allow single inheritance to be used when deriving classes from
<code >std::error_category</code> the class <code >CategoryBase</code> itself is derived from
<code >std::error_category</code>.
<p>
So, by deriving classes from <code >CategoryBase</code> we obtain a
<code >CatMap</code>; a function returning error descriptions; an implementation of
<code >equivalent</code> that can be used by all classes derived from
<code >std::error_category</code>; and, finally, a class that itself also is an
<code >error_category</code> class. Here is the interface of <code >CategoryBase</code>:
<p>
<pre>
    template &lt;class Enum&gt;
    class CategoryBase: public std::error_category
    {
        public:
            bool equivalent(std::error_code const &amp;ec, int condNr) const noexcept
                                                                        override;
    
        protected:
            static CatMap&lt;Enum&gt; const s_errors;
    
            std::string message(int ev, char const *noEnumValue) const;
    };
</pre>
<p>
Now we're ready for defining our own error category classes. To define a
category class we take the following steps:
<p>
<ul> 
    <li> First the class's interface is developed. As <code >CategoryBase</code> is
        available, such an interface is easily developed: it's derived from
        <code >CategoryBase</code>. Being a singleton, its (default) constructor is
        private and a static member <code >instance</code> returns a reference to the
        class's sole object. In addition it declares <code >name</code> and <code >message</code>
        (<code >equivalent</code> is provided by <code >CategoryBase</code>). Here is
        <code >CalculatorCategory's</code> class interface:
<p>
<pre>
class CalculatorCategory: public CategoryBase&lt;CalculatorError&gt;
{
    static CalculatorCategory *s_instance;

    public:
        static CalculatorCategory &amp;instance();

        char const *name() const noexcept override;
        std::string message(int ce) const override;

    private:
        CalculatorCategory() = default;
};
</pre>
<p>
The member <code >instance</code> returns a reference to the singleton object,
        initializing it the first time it is called:
<p>
<pre>
CalculatorCategory &amp;CalculatorCategory::instance()
{
    if (s_instance == 0)
        s_instance = new CalculatorCategory;

    return *s_instance;
}
</pre>
<p>
<li> The member <code >name</code> simply returns a short string naming the category
        (<code >"calculator"</code> for the calculator category).
<p>
<li> The member <code >message's</code> implementation also is extremely simple,
        thanks to <code >CategoryBase::member</code>: it merely returns what's returned by
        that latter member:
<p>
<pre>
std::string CalculatorCategory::message(int ev) const
{
    return CategoryBase&lt;CalculatorError&gt;::message(
                    ev, "CalculatorError not recognized");
}
</pre>
<p>
<li> The associations between error code enum values, descriptions and
        error condition names are defined when initializing the <code >CatMap</code>
        unordered map. Since that map is a data member of the error category's
        base class it can be initialized when defining the category
        class. Here is the initialization for <code >CalculatorCategory</code>:
<p>
<pre>
template &lt;&gt;
CatMap&lt;CalculatorError&gt; const CategoryBase&lt;CalculatorError&gt;::s_errors =
{
    { CalculatorError::NoLvalue,
            {"lhs of assignment is not a variable", "UnavailCond" } },
    { CalculatorError::TypeError,
            {"type of expression incorrect",        "UnavailCond" } },
    { CalculatorError::RangeError,
            {"argument value not allowed",          "UnavailCond" } },
    { CalculatorError::ArityError,
                {"incorrect number of arguments",   "UnavailCond" } },
    { CalculatorError::UnknownFunction,
            {"function not defined",                "UnavailCond" } },
    { CalculatorError::MissingParentheses,
            {"parentheses don't match",             "InputCond"   } },
};
</pre>
<p>
<li> We're now in position to actually create <code >error_code</code> objects from
        <code >CalculatorError</code> enum values. For this we define the free function
        <code >make_error_code(CalculatorError ce)</code>:
<p>
<pre>
std::error_code make_error_code(CalculatorError ce)
{
    return { static_cast&lt;int&gt;(ce), CalculatorCategory::instance() };
}
</pre>
<p>
</ul>
<p>
Now that a <code >CalculatorError</code> value can be converted to an
<code >std::error_code</code> we can use it in our programs. Here is a little demo
program illustrating its use:
<p>
<pre>
    #include &lt;iostream&gt;
    #include &lt;system_error&gt;

    #include "../calculatorerror/calculatorerror.h"
    #include "../calculatorcategory/calculatorcategory.h"

    int main()
    try
    {
        std::error_code ec = CalculatorError::ArityError;
        std::cout &lt;&lt; ec &lt;&lt; ' ' &lt;&lt; ec.message() &lt;&lt; '\n';
        throw std::system_error{ ec, "For demonstration purposes" };
    }
    catch (std::system_error &amp;se)
    {
        std::cout &lt;&lt; se.what() &lt;&lt; ":\n"
                    "    " &lt;&lt; se.code() &lt;&lt; '\n';
    }

    /*
    Outputs:
        calculator:4 incorrect number of arguments
        For demonstration purposes: incorrect number of arguments:
            calculator:4
    */
</pre>
<p>
In the next section defining and using error conditions is covered in detail.
<p>
<a name="ERRCONDITION"></a><a name="l613"></a>
<h3 >23.6.5: Deriving classes from std::error_condition</h3>
    So our flight simulator program uses two <code >ErrorCodeEnums</code>: one covering
errors that are related to the simulator itself, and one covering errors
related to its on-board calculator. If we're using facilities provided by
libraries then several more enums might also be available that we could use in
our simulator. E.g., there could be a data base of airport approach charts,
defining an <code >ApproachChartError</code> enum, and the simulator's GPS might come
with its own <code >GPSError</code> enum.
<p>
Errors can usually be categorized. In our simulator we might recognize user
input errors, unavailable requests, system failures, etc..
<p>
<a name="an3209"></a><em >Error_conditions</em> allow us to categorize
<code >ErrorCodeEnums</code> errors without having to use <code >if</code>-statements to test for
specific enum values. Error conditions <em >could</em> be (and often <em >are</em>)
implemented like error categories: an enumeration is defined, which is then
`upgraded' to a <code >std::error_condition</code>.
<p>
The disadvantage of using enumerations across independent developers is that
enumerations are difficult to apply, combine, and extend: a library might
define an <code >InputError</code> condition but another library might do so as well;
different enums might be available, but how do we prevent those enums from
using identical values?
<p>
Such problems can usually be prevented by avoiding fixed enum values, and
instead use verbal labels denoting error conditions. So rather than specifying
        <pre>
    enum class ErrorCondition
    {
        InputCond,
        UnavailCond,
        SystemCond
    };
</pre>
    textual labels like <code >"InputCond", "UnavailCond",</code> and <code >"SystemCond"</code>
could be used. Instead of defining a fixed-size <code >ErrorConditionEnum</code> a
singleton class <code >ErrorCondition</code> is used, providing and encapsulating such
an enumeration, at the same time guaranteeing the uniqueness of error
conditions which are identified by textual labels.
<p>
The class <code >ConditionCategory</code> implements the requirements imposed by the
class <code >std::error_condition</code>, tailored to the error conditions managed by
the class <code >ErrorCondition</code>. Also designed as a singleton,
<code >ConditionCategory</code> contains a vector whose elements hold names and
descriptions of the various error conditions. In addition to the familiar
members <code >name, message</code> and <code >equivalent</code> it offers a member
<code >addCondition</code>. That latter function is used by <code >ErrorCondition</code> to add
new error conditions to the current set. Here is its interface:
        <pre>
    class ConditionCategory: public std::error_category
    {
        static ConditionCategory *s_instance;
    
        typedef std::tuple&lt;
                    std::string,                // 0: condition name
                    char const *                // 1: descr.
                &gt; Info;
    
        std::vector&lt;Info&gt; d_conditionInfo;
    
        public:
            static ConditionCategory &amp;instance();
    
            char const *name() const noexcept override;
            std::string message(int ev) const override;
            bool equivalent(std::error_code const &amp;code,
                            int condition) const noexcept override;
    
                                            // returns condition idx-th name
            std::string const &amp;operator[](size_t idx) const;
            void addCondition(char const *name, char const *description);
            size_t size() const;
    
        private:
            ConditionCategory();
    };
</pre>
<p>
The members <code >name</code> and <code >message</code> have trivial implementations.  The member
<code >equivalent</code> receives an <code >error_code</code> object and an error condition enum
value (as an <code >int</code>). The function must return <code >true</code> if its
<code >error_code</code> is associated with the received error condition enum
value. <code >Equivalent</code> itself doesn't perform those checks. Rather, it
retrieves the <code >error_code's error_category</code> and uses that object's
<code >equivalent</code> function to perform the test:
        <pre>
    bool ConditionCategory::equivalent(std::error_code const &amp;ec, int condNr )
                                                                const noexcept
    {
        return ec.category().equivalent(ec, condNr);
    }
</pre>
<p>
Next we look at the class <code >ErrorCondition</code>. It contains a
<code >ConditionCategory</code> object (i.e., <em >the</em> <code >ConditionCategory</code> object), and
a <code >unsorted_map</code>, mapping condition names to their indices in the
<code >ConditionCategory's</code> vector. Other than that it's a rather plain class,
offering members to retrieve the enum values of the various error conditions,
and returning conditions' names given their numbers. Error condition enum
values are simply defined as their indices in the <code >ConditionCategory's</code>
vector, statically cast to the enum <code >ErrorCondition::Enum</code>.
<p>
<code >Enum</code> by itself is defined as a mere enumeration name, promoted to an
<code >ErrorConditionEnum</code> by the <code >std::is_error_condition_enum</code> trait class
specialization (comparable to what the <code >is_error_code_enum</code> trait class
accomplished for our enums like <code >CalculatorError</code>). Here is the
<code >is_error_condition_enum</code> trait class specialization, followed by
<code >ErrorCondition's</code> class interface:
    <pre>
    namespace std
    {
        template &lt;&gt;
        struct is_error_condition_enum&lt;ErrorCondition::Enum&gt;: public true_type
        {};
    }
</pre>
<p>
<pre>
    class ErrorCondition
    {
        static ErrorCondition *s_instance;
    
        ConditionCategory &amp;d_ec;
    
        typedef std::unordered_map&lt;std::string, size_t&gt; ConditionMap;
        ConditionMap d_condition;
    
        public:
            enum Enum           // enum returning values of error conditions,
            {};
    
            static ErrorCondition &amp;instance();
    
                                // name: name used for the error_condition
            void addCondition(char const *name, char const *description);
    
            Enum operator()(char const *condName) const;    // enum given the
                                                            // condition's name
    
            std::string const &amp;operator[](size_t nr) const; // condition name
                                                            // given its nr
        private:
            ErrorCondition(); // singleton, see instance.cc
    
    };
</pre>
<p>
Error conditions objects themselves are returned by a function
<code >make_error_condition</code>, expecting an <code >ErrorConditionEnum</code> value as its
argument, and internally using an <code >std::error_category</code> that is associated
with the various error condition enum values, much like <code >CalculatorCategory</code>
was associated with the <code >CalculatorError</code> enumeration. Since
<code >ConditionCategory</code> is a singleton, it can directly pass that singleton
object to the <code >std::error_condition</code> object:
<p>
<pre>
    std::error_condition make_error_condition(ErrorCondition::Enum ec)
    {
        return { static_cast&lt;int&gt;(ec), ConditionCategory::instance() };
    }
</pre>
<p>
A demo program illustrating some of the facilities of the <code >error_code,
error_category, error_condition</code> and related classes concludes this
section. The complete implementation of the program is provided in the
<strong >C++</strong> Annotations' source archive in the directory
<code >yo/advancedtemplates/examples/errocde</code>. 
<p>
<pre>
    int main()
    try
    {
        ErrorCondition &amp;errorCond  = ErrorCondition::instance();
    
        std::cerr &lt;&lt; CalculatorCategory::instance().name() &lt;&lt; '\n' &lt;&lt;
                     SimulatorCategory::instance().name() &lt;&lt; '\n';
    
        errorCond.addCondition("InputCond",   "error in user request");
        errorCond.addCondition("UnavailCond", "function not available");
        errorCond.addCondition("SystemCond",  "system failure");
    
            // ec is an actual error code, belonging to some error enum
            // the assert checks whether the specified error code belongs to
            // the specified error condition
    
    //                    // also OK: ErrorCondition::Enum{};
    //    std::error_condition cond = errorCond("InputCond");
    
        std::error_code ec = CalculatorError::TypeError;
    
        std::cerr &lt;&lt; "Enum value of UnavailCond = " &lt;&lt;
                                errorCond("UnavailCond") &lt;&lt; '\n';
        assert(ec != ErrorCondition::Enum{});
        assert(ec == errorCond("UnavailCond"));
        assert(ec != errorCond("SystemCond"));
    
        ec = CalculatorError::MissingParentheses;
        assert(ec == errorCond("InputCond"));
    
        ec = CalculatorError::ArityError;
        std::cout &lt;&lt; ec &lt;&lt; ' ' &lt;&lt; ec.message() &lt;&lt; '\n';
        throw std::system_error{ ec, "For demonstration purposes" };
    }
    catch (std::system_error const &amp;se)
    {
        std::cout &lt;&lt; "System Error: " &lt;&lt; se.what() &lt;&lt; ":\n"
                     "    " &lt;&lt; se.code() &lt;&lt; '\n';
    }
    /*
        Produced output:
    
        calculator
        simulator
        Enum value of UnavailCond = 2
        calculator:4 incorrect number of arguments
        System Error: For demonstration purposes: incorrect number of arguments:
            calculator:4
    */
</pre>
<p>
<a name="NOEXCEPT"></a><a name="l614"></a>
<h2 >23.7: Using `noexcept' when offering the `strong guarantee'</h2>
When throwing exceptions while trying to achieve the strong guarantee a
function's actions are usually split in two parts
    <ul>
    <li> First, usually on a temporary object, all operations that may throw
are performed (which doesn't affect the target object)
    <li> Then, the target object is modified using operations that offer the
<em >nothrow</em> guarantee.
    </ul>
<p>
The actions in the first step might be made <em >move aware</em> by using
<code >std::move</code> (e.g., to assign the source's values to a (possibly temporary)
destination). However, using <code >std::move</code> can easily affect the source (e.g.,
when extending the source's memory, moving the existing data to its new
locations), which breaks the first step's assumption, as the target object is
now modified. 
<p>
In this case (and generally) the move operation should not be allowed to throw
exceptions. This, in turn, implies that it is difficult to write code which
must offer a non-throwing moving constructor, if it uses (external) 
data types over which the moving constructor has no control. E.g.,
        <pre>
    template &lt;typename Type&gt;
    class MyClass
    {
        Type d_f;
        public:
            MyClass() = default;
            MyClass(MyClass &amp;&amp;tmp)
            :
                d_f(move(tmp.d_f))
            {}
    };
</pre>
    Here, <code >MyClass</code>'s author has no control over the design of <code >Type</code>. If
<code >Foreign</code> merely has a (possibly throwing) copy constructor, then the
following code breaks the no-throw assumption underlying move constructors:
        <pre>
    MyClass&lt;Foreign&gt; s2{ move(MyClass&lt;Foreign&gt;()) };
</pre>
<p>
If templates are able to detect whether <code >Type</code> has non-throwing move
constructors then their implementations may be optimized by
calling these move constructors (already modifying their targets in the first
part of code offering the strong guarantee) in situations where otherwise the
non-modifying, but more expensive copy constructor has to be used.
<p>
The <a name="an3210"></a><code >noexcept</code> keyword was introduced to allow such templates to perform
such optimizations. As with <code >throw</code> lists, checking for <code >noexcept</code> is
a run-time check, but the consequence of violating a <code >noexept</code> declaration
are more serious than violating a <code >throw</code> list: violating <code >noexcept</code>
results in calling <code >std::terminate</code>, terminating the program, possibly
without unwinding the stack. In the context of the previous example, the
following code is flawlessly accepted by the compiler, demonstrating that
there is no compile-time checking of <code >noexcept</code>:
        <pre>
    class Foreign
    {
        public:
            Foreign() = default;
            Foreign(Foreign const &amp;other) noexcept
            {
                throw 1;
            }
    };
</pre>
    However, when this class's copy constructor is called, execution aborts
with the following message:
        <pre>
    terminate called after throwing an instance of 'int'
    Abort
</pre>
<p>
Keep in mind that the current purpose of <code >noexcept</code> is to allow templates to
optimize their code by using move operations where the code must also be able
to offer the string exception guarantee. Since <code >noexcept</code> also offers the
conditional <code >noexcept(condition)</code> syntax (with <code >noexcept(true)</code> and
<code >noexcept</code> having identical semantics), <code >noexcept</code> can be made
conditional to the `noexcepting' nature of template types. Note that this is
not possible with <code >throw</code> lists. 
<p>
The following <a name="an3211"></a> rules of thumb by be used to decide whether or
not to use <code >noexcept</code> in your code:
    <ul>
    <li> General rule: don't use <code >noexcept</code> (this is identical to the advise
        given for <code >throw</code> lists);
    <li> Default implementations of constructors, copy- and move-assignment
        operators and destructors are provided with <code >noexcept(true)</code> if the
        compiler can deduct that composing types also offer
        <code >noexcept(true)</code>, allowing template optimizations using move
        operations where possible.
    <li> Functions provided with <code >noexcept</code> declarations may <em >still</em> throw
        exceptions (see the example given above). In the end <code >noexcept</code>
        merely means that if such a function throws an exception
        <code >std::terminate</code> rather than <code >std::unexpected</code> is called. 
    <li> Functions previously provided with an empty throw list (<code >throw()</code>)
        should now be provided with <code >noexcept(true)</code>.
    <li> <code >noexcept</code> specifications are required when using the following std
        traits (declared in the <a name="an3212"></a><code >&lt;type_traits&gt;</code> header file):
        <ul>
        <li><a name="an3213"></a><code >is_nothrow_constructible</code>
        <li><a name="an3214"></a><code >is_nothrow_default_constructible</code>
        <li><a name="an3215"></a><code >is_nothrow_move_constructible</code>
        <li><a name="an3216"></a><code >is_nothrow_copy_constructible</code>
        <li><a name="an3217"></a><code >is_nothrow_assignable</code>
        <li><a name="an3218"></a><code >is_nothrow_move_assignable</code>
        <li><a name="an3219"></a><code >is_nothrow_copy_assignable</code>
        <li><a name="an3220"></a><code >is_nothrow_destructible</code>
        </ul>
        These type traits provide the member constant <code >value</code> which is
        <code >true</code> if the class (and possibly its argument type list) matches
        the characteristic after which the trait was named. E.g., if
        <code >MyClass(string const &amp;) noexcept</code> is a constructor, then
        <pre>
    std::is_nothrow_constructible&lt;MyClass, string&gt;::value
</pre>
        equals <code >true</code>. For the named members (like
        <code >is_nothrow_move_constructible</code>) parameter types do not have to be
        specified, as they are implied. E.g.,
        <pre>
    std::is_nothrow_move_constructible&lt;MyClass&gt;::value
</pre>
        returns <code >true</code> if the move constructor has the <code >noexcept</code>
        modifier. 
    </ul>
<p>
<a name="l615"></a>
<h2 >23.8: More conversions to class types</h2>
<p>
<a name="l616"></a>
<h3 >23.8.1: Types to types</h3>
    Although <em >class</em> templates may be partially specialized, <em >function</em>
templates may not. At times this is annoying. Assume a function template is
available implementing a certain unary operator that could be used with the
<code >transform</code> generic algorithm (cf. section <a href="cplusplus19.html#TRANSFORM">19.1.63</a>):
        <pre>
    template &lt;typename Return, typename Argument&gt;
    Return chop(Argument const &amp;arg)
    {
        return Return{ arg };
    }
</pre>
    Furthermore assume that if <code >Return</code> is <code >std::string</code> then the above
implementation should not be used. Instead, with <code >std::string</code> a second
argument <code >1</code> should always be provided. If <code >Argument</code> is a <strong >C++</strong> string,
this would allow us to, e.g., return a copy of <code >arg</code> from which its first
character has been chopped off.
<p>
Since <code >chop</code> is a function, it is not possible to define a partial
specialization like this:
        <pre>
    template &lt;typename Argument&gt;        // This won't compile!
    std::string chop&lt;std::string, Argument&gt;(Argument const &amp;arg)
    {
        return std::string{ arg, 1 };
    }
</pre>
    Although a function template cannot be partially specialized it <em >is</em>
possible to use overloading, defining a second,  dummy, <code >string</code> parameter:
        <pre>
    template &lt;typename Argument&gt;
    std::string chop(Argument const &amp;arg, std::string)
    {
        return std::string{ arg, 1 };
    }
</pre>
<p>
Instead of providing a <code >string</code> dummy argument the functions <em >could</em>
use the <code >IntType</code> template (cf. section <a href="cplusplus23.html#INTTYPE">23.2.1.1</a>) to select the proper
overloaded version. E.g., <code >IntType&lt;0&gt;</code> could be defined as the type of the
second argument of the first overloaded <code >chop</code> function, and <code >IntType&lt;1&gt;</code>
could be used for the second overloaded function. From the point of view of
program efficiency this is an attractive option, as the provided <code >IntType</code>
objects are extremely lightweight. <code >IntType</code> objects contain no data at
all. But there's also an obvious disadvantage as there is no intuitively clear
association between the <code >int</code> value used and the intended type.
<p>
Instead of defining arbitrary <code >IntType</code> types it is more attractive to
use another lightweight solution, using an automatic type-to-type
association. The <code >struct TypeType</code> is a lightweight type wrapper, much like
<code >IntType</code>. Here is its definition:
        <pre>
    template &lt;typename T&gt;
    struct TypeType
    {
        typedef T Type;
    };
</pre>
    <code >TypeType</code> is also a lightweight type as it doesn't have any data fields
either. <code >TypeType</code> allows us to use a natural type association for
<code >chop</code>'s second argument. E.g, the overloaded functions can now be defined
as follows:
        <pre>
    template &lt;typename Return, typename Argument&gt;
    Return chop(Argument const &amp;arg, TypeType&lt;Argument&gt; )
    {
        return Return{ arg };
    }

    template &lt;typename Argument&gt;
    std::string chop(Argument const &amp;arg, TypeType&lt;std::string&gt; )
    {
        return std::string{ arg, 1 };
    }
</pre>
    Using the above implementations any type can be specified for
<code >Result</code>. If it happens to be a <code >std::string</code> the appropriate overloaded
version is automatically selected. The following additional overload of the
function <code >chop</code> capitalizes on this:
        <pre>
    template &lt;typename Result&gt;
    Result chop(char const *txt)    // char const * could also be a 2nd
    {                               // template type parameter
        return chop(std::string(txt), TypeType&lt;Result&gt;{});
    }
</pre>
    Using the third <code >chop</code> function, the following statement produces the
text `<code >ello world</code>':
        <pre>
    cout &lt;&lt; chop&lt;string&gt;{ "hello world" } &lt;&lt; '\n';
</pre>
    Template functions do not support partial specializations. But they can be
overloaded. By providing overloads with dummy type-arguments that depend
on other parameters and calling these overloads from a overloaded function
that does not require the dummy type argument a situation similar to partial
specializations with class templates can often be realized.
<p>
<a name="NULLTYPE"></a><a name="l617"></a>
<h3 >23.8.2: An empty type</h3>
    At times (cf. section <a href="cplusplus23.html#TEMPLIST">23.9</a>) an empty
        <a name="an3221"></a><a name="an3222"></a><a name="an3223"></a>
    <code >struct</code> is a useful tool. It can be used as a <em >type</em> acting
analogously to the final 0-byte in NTBSs.
It can simply be defined as:
        <pre>
    struct NullType
    {};
</pre>
<p>
<a name="TYPECONV"></a><a name="l618"></a>
<h3 >23.8.3: Type convertibility</h3>
    In what situations can a type <code >T</code> be used as a `stand in' for another type
<code >U</code>? Since <strong >C++</strong> is a strongly typed language the answer is surprisingly
simple: <code >T</code>s can be used instead of <code >U</code>s if a <code >T</code> is accepted as
argument in cases where <code >U</code>s are requested.
<p>
This reasoning is behind the following class which can be used to determine
whether a type <code >T</code> can be used where a type <code >U</code> is expected. The
interesting part is that no code is actually generated or executed.  All
decisions are made by the compiler.
<p>
In the second part of this section we'll show how the code developed in
the first part can be used to detect whether a class <code >B</code> is a base class of
another class <code >D</code> (the <code >is_base_of</code> template (cf. section <a href="cplusplus23.html#TYPETRAITS">23.6.2</a>)
also provides an answer to this question). The code developed here closely
follows the example provided by Alexandrescu <a name="an3224"></a> (2001,
p. 35).
<p>
First, a function <code >test</code> is designed accepting a type <code >U</code>.
The function <code >test</code> returns a value
of the as yet unknown type <code >Convertible</code>:
        <pre>
    Convertible test(U const &amp;);
</pre>
<p>
The function <code >test</code> is never implemented. It is only declared.  If a type
<code >T</code> can be used instead of a type <code >U</code> then <code >T</code> can also be passed as
argument to the above <code >test</code> function.
<p>
On the other hand, if the alternate type <code >T</code> cannot be used where a <code >U</code> is
expected, then the compiler won't be able to use the above <code >test</code>
function. Instead, it uses an alternative function that has a lower
selection priority but that can <em >always</em> be used with <em >any</em> <code >T</code> type.
<p>
<strong >C</strong> (and <strong >C++</strong>) offer a very general parameter list, a parameter list that
is always considered acceptable. This parameter list is the familiar
  <a name="an3225"></a><em >ellipsis</em> which represents the <em >worst</em> case the compiler may
encounter.  If everything else fails, then the function defining an ellipsis
as its parameter list is selected.
<p>
Usually that's not a productive alternative, but in the current situation it
is <em >exactly</em> what is needed. When confronted with two candidate functions,
one of which defines an ellipsis parameter, the compiler selects the
function defining the ellipsis parameter only if the alternative(s) can't be
used.
<p>
Following the above reasoning an alternative function <code >test(...)</code> is
declared as well. This alternate function does not return a <code >Convertible</code>
value but a <code >NotConvertible</code> value:
        <pre>
    NotConvertible test(...);
</pre>
<p>
If <code >test</code>'s argument is of type <code >T</code> and if <code >T</code> can be converted to <code >U</code>
then <code >test</code>'s return type is <code >Convertible</code>.  Otherwise <code >NotConvertible</code>
is returned.
<p>
This situation clearly shows similarities with the situation encountered in
section <a href="cplusplus23.html#CLASSORNOT">23.6.1</a> where the value <code >isClass</code> had to be determined
compile time. Here two related problems must be solved:
    <ul>
    <li> how do we obtain a <code >T</code> argument? This is more difficult than might
be expected at first sight as it might not be possible to define a <code >T</code>. If
type <code >T</code> does not define any constructor then no <code >T</code> object can be
defined.
    <li> how can <code >Convertible</code> be distinguished from <code >NotConvertible</code>?
    </ul>
    The first problem is solved by realizing that no <code >T</code> <em >needs</em> to be
defined. After all, the intent is to decide <em >compile-time</em> whether a type is
convertible and not to define a <code >T</code> value or object. Defining objects is not
a compile-time but a <em >run-time</em> matter.
<p>
By simply <em >declaring</em> a function returning a <code >T</code> we can
tell the compiler where it should assume a <code >T</code>:
        <pre>
    T makeT();
</pre>
    This mysterious function has the magical power of enticing the compiler
into thinking that a <code >T</code> object comes out of it. However, this function
needs a small modification before it will actually suit our needs. If, for
whatever reason, <code >T</code> happens to be an array then the compiler will choke on
<code >T makeT()</code> as functions cannot return arrays. This, however, is easily
solved, as functions <em >can</em> return <em >references</em> to arrays. So the above
declaration is changed into:
        <pre>
    T const &amp;makeT();
</pre>
<p>
Next we pass a <code >T const &amp;</code> to <code >test</code>:
following code:
        <pre>
    test(makeT())
</pre>
    Now that the compiler sees <code >test</code> being called with a <code >T const &amp;</code>
argument it decides that its return value is <code >Convertible</code> if a
conversion is in fact possible. Otherwise it decides that its return value
is <code >NotConvertible</code> (as the compiler, in that case, selected <code >test(...)</code>).
<p>
The second problem, distinguishing <code >Convertible</code> from <code >NotConvertible</code>
is solved exactly the way <code >isClass</code> could be determined in section
<a href="cplusplus23.html#CLASSORNOT">23.6.1</a>, <em >viz.</em> by making their sizes different. Having done so the
following expression determines whether <code >T</code> is convertible from <code >U</code> or
not:
        <pre>
    isConvertible = sizeof(test(makeT())) == sizeof(Convertible);
</pre>
    By using <code >char</code> for <code >Convertible</code> and <code >Char2</code> (cf. section
<a href="cplusplus23.html#CLASSORNOT">23.6.1</a>) for <code >NotConvertible</code> the distinction can be made.
<p>
The above can be summarized in a class template <code >LconvertibleToR</code>,
having two template type parameters:
        <pre>
    template &lt;typename T, typename U&gt;
    class LconvertibleToR
    {
        struct Char2
        {
            char array[2];
        };
        static T const &amp;makeT();
        static char test(U const &amp;);
        static Char2 test(...);

        public:
            LconvertibleToR(LconvertibleToR const &amp;other) = delete;
            enum { yes = sizeof(test(makeT())) == sizeof(char) };
            enum { sameType = 0 };
    };

    template &lt;typename T&gt;
    class LconvertibleToR&lt;T, T&gt;
    {
        public:
            LconvertibleToR(LconvertibleToR const &amp;other) = delete;
            enum { yes = 1 };
            enum { sameType = 1 };
    };
</pre>
    As the class template deletes its copy constructor no object can be
created. Only its <code >enum</code> values can be interrogated. The next example writes
<code >1 0 1 0</code> when run from a <code >main</code> function:
        <pre>
    cout &lt;&lt;
        LconvertibleToR&lt;ofstream, ostream&gt;::yes &lt;&lt; " " &lt;&lt;
        LconvertibleToR&lt;ostream, ofstream&gt;::yes &lt;&lt; " " &lt;&lt;
        LconvertibleToR&lt;int, double&gt;::yes &lt;&lt; " " &lt;&lt;
        LconvertibleToR&lt;int, string&gt;::yes &lt;&lt;
        "\n";
</pre>
<p>
<a name="l619"></a>
<h4>23.8.3.1: Determining inheritance</h4>
        Now that it is possible to determine type convertibility, it's easy to
determine whether a type <code >Base</code> is a (public) base class of a type
<code >Derived</code>.
<p>
Inheritance is determined by inspecting convertibility of (const)
pointers. <code >Derived const *</code> can be converted to <code >Base const *</code> if
    <ul>
    <li> both types are identical;
    <li> <code >Base</code> is a public and unambiguous base class of <code >Derived</code>;
    <li> and (usually not intended) if <code >Base</code> is void.
    </ul>
    Assuming the last conversion isn't used inheritance can be determined
using the following trait class <code >LBaseRDerived</code>. <code >LBaseRDerived</code> provides
an enum <code >yes</code> which is 1 if the left type is a base class of the right type
and both types are different:
    <pre>
    template &lt;typename Base, typename Derived&gt;
    struct LBaseRDerived
    {
        LBaseRDerived(LBaseRDerived const &amp;) = delete;
        enum {
            yes =
                LconvertibleToR&lt;Derived const *, Base const *&gt;::yes &amp;&amp;
                not LconvertibleToR&lt;Base const *, void const *&gt;::sameType
        };
    };
</pre>
<p>
If code should not consider a class to be its own base class, then the
trait class <code >LBaseRtrulyDerived</code> can be used to perform a  strict test. This
trait class adds a test for type-equality:
    <pre>
    template &lt;typename Base, typename Derived&gt;
    struct LBaseRtrulyDerived
    {
        LBaseRtrulyDerived(LBaseRtrulyDerived const &amp;) = delete;
        enum {
            yes =
                LBaseRDerived&lt;Base, Derived&gt;::yes &amp;&amp;
                not LconvertibleToR&lt;Base const *, Derived const *&gt;::sameType
        };
    };
</pre>
    Example: the next statement displays <code >1: 0, 2: 1, 3: 0, 4: 1, 5: 0</code>
when executed from a <code >main</code> function:
    <pre>
    cout &lt;&lt; "\n" &lt;&lt;
        "1: " &lt;&lt; LBaseRDerived&lt;ofstream, ostream&gt;::yes &lt;&lt; ",  " &lt;&lt;
        "2: " &lt;&lt; LBaseRDerived&lt;ostream, ofstream&gt;::yes &lt;&lt; ",  " &lt;&lt;
        "3: " &lt;&lt; LBaseRDerived&lt;void, ofstream&gt;::yes &lt;&lt; ",  " &lt;&lt;
        "4: " &lt;&lt; LBaseRDerived&lt;ostream, ostream&gt;::yes &lt;&lt; ",  " &lt;&lt;
        "5: " &lt;&lt; LBaseRtrulyDerived&lt;ostream, ostream&gt;::yes &lt;&lt;
        "\n";
</pre>
<p>
<a name="TEMPLIST"></a><a name="l620"></a>
<h2 >23.9: Template TypeList processing</h2>
    This section serves two purposes. It illustrates capabilities of the various
template meta-programming techniques, which can be used as a source of
inspiration when developing your own templates; and it offers a concrete
example, illustrating some of the power offered by these techniques.
<p>
This section itself was inspired by Andrei Alexandrescu's (2001) book
        <a name="an3226"></a>
    <strong >Modern C++ design</strong>. It diverts from Alexandrescu's book in its use of
variadic templates which were not yet available when he wrote his book. Even
so, the algorithms used by Alexandrescu are still useful when using variadic
templates.
<p>
<strong >C++</strong> offers the <a href="cplusplus22.html#TUPLES">tuple</a> to store and retrieve
values of multiple types. Here the focus is merely on processing types.  A
simple struct <code >TypeList</code> is going to be used as our working horse for the
upcoming subsections. Here is its definition:
        <pre>
    template &lt;typename ...Types&gt;
    struct TypeList
    {
        TypeList(TypeList const &amp;) = delete;
        enum { size = sizeof ...(Types) };
    };
</pre>
    A typelist allows us to store any number of types. Here is an example
storing the three types <code >char, short, int</code> in a <code >TypeList</code>:
        <pre>
    TypeList&lt;char, short, int&gt;
</pre>
<p>
<a name="l621"></a>
<h3 >23.9.1: The length of a TypeList</h3>
    As the number of types in a parameter pack may be obtained using the <code >sizeof</code>
operator (cf. section <a href="cplusplus22.html#VARIADIC">22.5</a>) it is easy to obtain the number of types
that were specified with a certain <code >TypeList</code>. For example, the following
statement displays the value 3:
        <pre>
    std::cout &lt;&lt; TypeList&lt;int, char, bool&gt;::size &lt;&lt; '\n';
</pre>
<p>
However, it's illustrative to see how the number of types specified with a
<code >TypeList</code> could be determined if <code >sizeof</code> hadn't been available.
<p>
To obtain the number of types that were specified with a <code >TypeList</code>
the following algorithm is used:
    <ul>
    <li> If the <code >TypeList</code> contains no types, its size equals zero;
    <li> If the <code >TypeList</code> contains types, its size equals 1 plus the number
        of types that follow its  first type.
    </ul>
    The algorithm uses recursion to define the length of a <code >TypeList</code>. In
executable <strong >C++</strong> recursion could also be used in comparable situations. For
example recursion can be used to determine the length of an NTBS:
        <pre>
    size_t c_length(char const *cp)
    {
        return *cp == 0 ? 0 : 1 + c_length(cp + 1);
    }
</pre>
    While <strong >C++</strong> functions usually use iteration rather than recursion,
iteration is not available to template meta programming algorithms. In
template meta programming repetition <em >must</em> be implemented using
recursion. Furthermore, while <strong >C++</strong> run-time code may use conditions to
decide whether or not to start the next recursion template meta programming
cannot do so. Template meta programming algorithms must resort to (partial)
specializations. The specializations are used to select alternatives.
<p>
The number of types that are specified in a <code >TypeList</code> can be computed
using the following alternate implementation of <code >TypeList</code>, using a generic
<code >struct</code> declaration and two specialization for the empty and non-empty
<code >TypeList</code> (cf. the above description of the algorithm):
        <pre>
    template &lt;typename ...Types&gt;
    struct TypeList;

    template &lt;typename Head, typename ...Tail&gt;
    struct TypeList&lt;Head, Tail...&gt;
    {
        enum { size = 1 + TypeList&lt;Tail...&gt;::size };
    };
    template &lt;&gt;
    struct TypeList&lt;&gt;
    {
        enum { size = 0 };
    };
</pre>
<p>
<a name="SEARCHTYPE"></a><a name="l622"></a>
<h3 >23.9.2: Searching a TypeList</h3>
    To determine whether a particular type (called <em >SearchType</em> below) is
present in a given <code >TypeList</code>, an algorithm is used that either defines
`index' as -1 (if SearchType is not an element of the <code >TypeList</code> ) or it
defines `index' as the index of the first occurrence of SearchType in
the <code >TypeList</code>. The following algorithm is used:
    <ul>
    <li> If the <code >TypeList</code> is empty, `index' is -1;
    <li> If the <code >TypeList</code>'s first element equals   SearchType, `index' is 0;
    <li> Otherwise  `index' is:
        <ul>
        <li> -1 if searching for SearchType in <code >TypeList</code>'s tail results in
            `index' == -1;
        <li> Otherwise (SearchType was found in <code >TypeList</code>'s tail) index is
            set to 1 + the index obtained when searching for SearchType in the
            <code >TypeList</code>'s tail.
        </ul>
    </ul>
    The algorithm is implemented using a variadic template struct
<code >ListSearch</code> expecting a parameter pack:
        <pre>
    template &lt;typename ...Types&gt;
    struct ListSearch
    {
        ListSearch(ListSearch const &amp;) = delete;
    };
</pre>
    Specializations handle the alternatives mentioned with the algorithm:
    <ul>
    <li> If <code >TypeList</code> is empty, `index' is -1:
        <pre>
    template &lt;typename SearchType&gt;
    struct ListSearch&lt;SearchType, TypeList&lt;&gt;&gt;
    {
        ListSearch(ListSearch const &amp;) = delete;
        enum { index = -1 };
    };
</pre>
<p>
<li> If <code >TypeList</code>'s head  equals SearchType, `index'
        is 0. Note that <code >SearchType</code> is explicitly mentioned as the
            <code >TypeList</code>'s first element:
        <pre>
    template &lt;typename SearchType, typename ...Tail&gt;
    struct ListSearch&lt;SearchType, TypeList&lt;SearchType, Tail...&gt;&gt;
    {
        ListSearch(ListSearch const &amp;) = delete;
        enum { index = 0 };
    };
</pre>
<p>
<li> Otherwise a search is performed on the <code >TypeList</code>'s tail. The index
            value returned by this search is stored in a <code >tmp</code> enum value,
            which is then used to determine index's value.
        <pre>
    template &lt;typename SearchType, typename Head, typename ...Tail&gt;
    struct ListSearch&lt;SearchType, TypeList&lt;Head, Tail...&gt; &gt;
    {
        ListSearch(ListSearch const &amp;) = delete;
        enum {tmp = ListSearch&lt;SearchType, TypeList&lt;Tail...&gt;&gt;::index};
        enum {index = tmp == -1 ? -1 : 1 + tmp};
    };
</pre>
    </ul>
    Here is an example showing  how <code >ListSearch</code> can be used:
        <pre>
    std::cout &lt;&lt;
        ListSearch&lt;char, TypeList&lt;int, char, bool&gt;&gt;::index &lt;&lt; "\n" &lt;&lt;
        ListSearch&lt;float, TypeList&lt;int, char, bool&gt;&gt;::index &lt;&lt; "\n";
</pre>
<p>
<a name="ATINDEX"></a><a name="l623"></a>
<h3 >23.9.3: Selecting from a TypeList</h3>
    The inverse operation of determining the index of a certain type in a
<code >TypeList</code> is retrieving the type given its index. This inverse operation is
the topic of this section.
<p>
The algorithm is implemented using a struct <code >TypeAt</code>. <code >TypeAt</code> uses a
<code >typedef</code> to define the type matching a given index. But the index might be
out of bounds. In that case we have several options:
    <ul>
    <li> Use a <a href="cplusplus21.html#STATICASSERT">static_assert</a> to stop the compilation. This
is an appropriate action if the index should simply not be out of bounds;
    <li> Define a local type (e.g., <code >Null</code>) that should not be used as a
type in the <code >TypeList</code>. This type is going to be returned when the index is
out of bounds. Using this local type as one of the types in a <code >TypeList</code> is
considered an error as its would conflict with the special meaning of <code >Null</code>
as the type returned at an invalid index.<br/>
    To prevent <code >Null</code> from being returned by <code >TypeAt</code> a <code >static_assert</code>
is used to catch the <code >Null</code> type when it is encountered while evaluating
<code >TypeAt</code>;
    <li> The struct <code >TypeAt</code> may define an enum value <code >validIndex</code> set to
<code >true</code> if the index was valid and set to <code >false</code> if not.
    </ul>
    The first alternative is implemented below. The other alternatives are not
difficult to implement and are left as exercises for the reader. Here's how
<code >TypeAt</code> works:
    <ul>
    <li> The foundation consists of a variadic template struct <code >TypeAt</code>,
        expecting an index and a <code >TypeList</code>:
            <pre>
    template &lt;size_t index, typename Typelist&gt;
    struct TypeAt;
</pre>
<p>
<li> If the typelist is empty a <code >static_assert</code> ends the compilation
            <pre>
    template &lt;size_t index&gt;
    struct TypeAt&lt;index, TypeList&lt;&gt;&gt;
    {
        static_assert(index &lt; 0, "TypeAt index out of bounds");
        typedef TypeAt Type;
    };
</pre>
<p>
<li> If the search index equals 0, define <code >Type</code> as the first type in
        the <code >TypeList</code>:
            <pre>
    template &lt;typename Head, typename ...Tail&gt;
    struct TypeAt&lt;0, TypeList&lt;Head, Tail...&gt;&gt;
    {
        typedef Head Type;
    };
</pre>
<p>
<li> Otherwise, <code >Type</code> is defined as <code >Type</code> defined by <code >TypeAt&lt;index
        - 1&gt;</code> operating on the <code >TypeList</code>'s tail:
            <pre>
    template &lt;size_t index, typename Head, typename ...Tail&gt;
    struct TypeAt&lt;index, TypeList&lt;Head, Tail...&gt;&gt;
    {
        typedef typename TypeAt&lt;index - 1, TypeList&lt;Tail...&gt;&gt;::Type Type;
    };
</pre>
    </ul>
    Here is how <code >typeAt</code> can be used. Uncommenting the first variable
definition causes a <code >TypeAt index out of bounds</code> compilation error:
        <pre>
    typedef TypeList&lt;int, char, bool&gt; list3;

//    TypeAt&lt;3, list3&gt;::Type invalid;
    TypeAt&lt;0, list3&gt;::Type intVariable = 13;
    TypeAt&lt;2, list3&gt;::Type boolVariable = true;

    cout &lt;&lt; "The size of the first type is " &lt;&lt;
                sizeof(TypeAt&lt;0, list3&gt;::Type) &lt;&lt; ", "
            "the size of the third type is " &lt;&lt;
                sizeof(TypeAt&lt;2, list3&gt;::Type) &lt;&lt; "\n";

    if (typeid(TypeAt&lt;1, list3&gt;::Type) == typeid(char))
        cout &lt;&lt; "The typelist's 2nd type is char\n";

    if (typeid(TypeAt&lt;2, list3&gt;::Type) != typeid(char))
        cout &lt;&lt; "The typelist's 3nd type is not char\n";
</pre>
<p>
<a name="l624"></a>
<h3 >23.9.4: Prefixing/Appending to a TypeList</h3>
    Prepending or appending a type to a <code >TypeList</code> is easy and doesn't require
recursive template meta programs. Two variadic template structs <code >Append</code> and
<code >Prefix</code> and two specializations are all it takes.
<p>
Here are the declarations of the two variadic template structs:
            <pre>
    template &lt;typename ...Types&gt;
    struct Append;

    template &lt;typename ...Types&gt;
    struct Prefix;
</pre>
<p>
To append or prefix a new type to a typelist, specializations expect a
typelist and a type to add. Then, they simply define a new <code >TypeList</code> also
including the new type. The <code >Append</code> specialization shows that a template
pack does not have to be used as the first argument when defining another
variadic template type:
        <pre>
    template &lt;typename NewType, typename ...Types&gt;
    struct Append&lt;TypeList&lt;Types...&gt;, NewType&gt;
    {
        typedef TypeList&lt;Types..., NewType&gt; List;
    };

    template &lt;typename NewType, typename ...Types&gt;
    struct Prefix&lt;NewType, TypeList&lt;Types...&gt;&gt;
    {
        typedef TypeList&lt;NewType, Types...&gt; List;
    };
</pre>
<p>
<a name="l625"></a>
<h3 >23.9.5: Erasing from a TypeList</h3>
    It is also possible to erase types from a <code >TypeList</code>. Again, there are
several possibilities, each resulting in a different algorithm.
    <ul>
    <li> The type to erase is specified, and the first
occurrence of that type is removed from the <code >TypeList</code>;
    <li> The index of the type to erase is specified, and the type at that
index position  is erased from the <code >TypeList</code>;
    <li> The type to erase is specified, and all
occurrences of that type are removed from the <code >TypeList</code>.
    <li> As a variant of erasure: we may want to erase all multiply
occurring types in a <code >TypeList</code>, keeping each type only once.
    </ul>
    Doubtlessly there are other ways of erasing types from a
<code >TypeList</code>. Which ones are eventually  implemented depends of course on
the circumstances. As template meta programming is very powerful most if not
all algorithms can probably be implemented. As an illustration of how to erase
types from a <code >TypeList</code> the above-mentioned algorithms are now developed in
the upcoming subsections.
<p>
<a name="l626"></a>
<h4>23.9.5.1: Erasing the first occurrence</h4>
        To erase the first occurrence of a specified <code >EraseType</code> from a <code >TypeList</code>
a recursive algorithm is used once again. The template meta program uses a
generic <code >Erase</code> struct and several specializations. The specializations
define a type <code >List</code> containing the resulting <code >TypeList</code> after the
erasure. Here is the algorithm:
    <ul>
    <li> The foundation of the algorithm consists of a struct template
<code >Erase</code> expecting the type to erase and a <code >TypeList</code>:
            <pre>
    template &lt;typename EraseType, typename TypeList&gt;
    struct Erase;
</pre>
    <li> If the typelist is empty, there's nothing to erase, and an empty
        <code >TypeList</code> results:
            <pre>
    template &lt;typename EraseType&gt;
    struct Erase&lt;EraseType, TypeList&lt;&gt;&gt;
    {
        typedef TypeList&lt;&gt; List;
    };
</pre>
    <li> If the <code >TypeList</code>'s head matches the type to erase, then <code >List</code>
        becomes a <code >TypeList</code> containing the original <code >TypeList</code>'s tail
        types:
            <pre>
    template &lt;typename EraseType, typename ...Tail&gt;
    struct Erase&lt;EraseType, TypeList&lt;EraseType, Tail...&gt;&gt;
    {
        typedef TypeList&lt;Tail...&gt; List;
    };
</pre>
    <li> In all other cases the erase operation is applied to the
        <code >TypeList</code>'s tail. This results in a <code >TypeList</code> to which the
        orginal <code >TypeList</code>'s head must be prefixed. The <code >TypeList</code>
        returned by the prefix operation is then returned as <code >Erase::List</code>:
            <pre>
    template &lt;typename EraseType, typename Head, typename ...Tail&gt;
    struct Erase&lt;EraseType, TypeList&lt;Head, Tail...&gt;&gt;
    {
        typedef typename
            Prefix&lt;Head,
                typename Erase&lt;EraseType, TypeList&lt;Tail...&gt;&gt;::List
            &gt;::List List;
    };
</pre>
    </ul>
    Here is a statement showing how <code >Erase</code> can be used:
            <pre>
    cout &lt;&lt;
            Erase&lt;int, TypeList&lt;char, double, int&gt;&gt;::List::size &lt;&lt; '\n' &lt;&lt;
            Erase&lt;char, TypeList&lt;int&gt;&gt;::List::size &lt;&lt; '\n' &lt;&lt;
            Erase&lt;int, TypeList&lt;int&gt;&gt;::List::size &lt;&lt; '\n' &lt;&lt;
            Erase&lt;int, TypeList&lt;&gt;&gt;::List::size &lt;&lt; "\n";
</pre>
<p>
<a name="l627"></a>
<h4>23.9.5.2: Erasing a type by its index</h4>
        To erase a type from a <code >TypeList</code> by its index we again use a
recursive template meta program. <code >EraseIdx</code> expects a <code >size_t</code> index value
and a <code >TypeList</code> from which its <code >idx</code><sup >th</sup> (0-based) type must be
erased. <code >EraseIdx</code> defines the type <code >List</code> containing the resulting
<code >TypeList</code>. Here is the algorithm:
    <ul>
    <li> The foundation of the algorithm consists of a struct template
<code >EraseIdx</code> expecting the index of the type to erase and a <code >TypeList</code>:
            <pre>
    template &lt;size_t idx, typename TypeList&gt;
    struct EraseIdx;
</pre>
    <li> If the typelist is empty, there's nothing to erase, and an empty
        <code >TypeList</code> results:
            <pre>
    template &lt;size_t idx&gt;
    struct EraseIdx&lt;idx, TypeList&lt;&gt;&gt;
    {
        typedef TypeList&lt;&gt; List;
    };
</pre>
    <li> The recursion otherwise ends once <code >idx</code> becomes 0. At that point
        the <code >TypeList</code>'s first type is ignored and <code >List</code> is initialized
        to a <code >TypeList</code> containing the types in the orginal <code >TypeList</code>'s
        tail:
            <pre>
    template &lt;typename EraseType, typename ...Tail&gt;
    struct EraseIdx&lt;0, TypeList&lt;EraseType, Tail...&gt;&gt;
    {
        typedef TypeList&lt;Tail...&gt; List;
    };
</pre>
    <li> In all other cases <code >EraseIdx</code> is applied to the <code >TypeList</code>'s
        tail, providing it with a decremented value of <code >idx</code>. To the
        resulting <code >TypeList</code> the orginal <code >TypeList</code>'s head is
        prefixed. The <code >TypeList</code> returned by the prefix operation is then
        returned as <code >EraseIdx::List</code>:
            <pre>
    template &lt;size_t idx, typename Head, typename ...Tail&gt;
    struct EraseIdx&lt;idx, TypeList&lt;Head, Tail...&gt;&gt;
    {
        typedef typename Prefix&lt;
                    Head,
                    typename EraseIdx&lt;idx - 1, TypeList&lt;Tail...&gt;&gt;::List
                &gt;::List List;
    };
</pre>
    </ul>
    Here is a statement showing how <code >EraseIdx</code> can be used:
            <pre>
    if
    (
        typeid(TypeAt&lt;2,
                EraseIdx&lt;1,
                   TypeList&lt;int, char, size_t, double, int&gt;&gt;::List
                &gt;::Type
        )
        == typeid(double)
    )
        cout &lt;&lt; "the third type is now a double\n";
</pre>
<p>
<a name="l628"></a>
<h4>23.9.5.3: Erasing all occurrences of a type</h4>
        Erasing all types <code >EraseType</code> from a <code >TypeList</code> can easily be accomplished
by applying the erasure procedure not only to the head of the <code >TypeList</code> but
also to the  <code >TypeList</code>'s tail.
<p>
Here is the algorithm, described in a slightly different order than
<code >Erase</code>'s algorithm:
    <ul>
    <li> If the <code >TypeList</code> is empty, there's nothing to erase, and an empty
        <code >TypeList</code> results. This is exactly what we do with <code >Erase</code>, so we
        can use inheritance to prevent us from having to duplicate elements of
        a template meta program:
            <pre>
    template &lt;size_t idx&gt;
    struct EraseIdx&lt;idx, TypeList&lt;&gt;&gt;
    {
        typedef TypeList&lt;&gt; List;
    };
</pre>
    <li> The foundation of the algorithm is therefore a struct template
        <code >EraseAll</code> expecting the type to erase and a <code >TypeList</code> that is
        derived from <code >Erase</code>, thus already offering the empty <code >TypeList</code>
        handling specialization:
            <pre>
    template &lt;typename EraseType, typename TypeList&gt;
    struct EraseAll: public Erase&lt;EraseType, TypeList&gt;
    {};
</pre>
    <li> If <code >TypeList</code>'s head matches <code >EraseType</code> <code >EraseAll</code> is also
        applied to the <code >TypeList</code>'s tail, thus removing all occurrences of
        <code >EraseType</code> from <code >TypeList</code>:
            <pre>
    template &lt;typename EraseType, typename ...Tail&gt;
    struct EraseAll&lt;EraseType, TypeList&lt;EraseType, Tail...&gt;&gt;
    {
        typedef typename EraseAll&lt;EraseType, TypeList&lt;Tail...&gt;&gt;::List List;
    };
</pre>
    <li> In all other cases (i.e., <code >TypeList</code>'s head does <em >not</em> match
        <code >EraseType</code>) <code >EraseAll</code> is applied to the <code >TypeList</code>'s tail.
        The returned <code >TypeList</code> consists of the original <code >TypeList</code>'s
        initial type and the types of the <code >TypeList</code> returned by the
        recursive <code >EraseAll</code> call:
            <pre>
    template &lt;typename EraseType, typename Head, typename ...Tail&gt;
    struct EraseAll&lt;EraseType, TypeList&lt;Head, Tail...&gt;&gt;
    {
        typedef typename Prefix&lt;
            Head,
            typename EraseAll&lt;EraseType, TypeList&lt;Tail...&gt;&gt;::List
        &gt;::List List;
    };
</pre>
    </ul>
    Here is a statement showing how <code >EraseAll</code> can be used:
       <pre>
    cout &lt;&lt;
        "After erasing size_t from "
            "TypeList&lt;char, int, size_t, double, size_t&gt;\n"
            "it contains " &lt;&lt;
                EraseAll&lt;size_t,
                         TypeList&lt;char, int, size_t, double, size_t&gt;
                &gt;::List::size &lt;&lt; " types\n";
</pre>
<p>
<a name="l629"></a>
<h4>23.9.5.4: Erasing duplicates</h4>
        To remove all duplicates from a <code >TypeList</code> all the <code >TypeList</code>'s first
elements must be erased from the <code >TypeList</code>'s tail, applying the procedure
recursively to the <code >TypeList</code>'s tail. The algorithm, outlined below, merely
expects a <code >TypeList</code>:
    <ul>
    <li> First, the generic <code >EraseDup</code> struct template is
declared. <code >EraseDup</code> structures define a type <code >List</code> representing the
<code >TypeList</code> that they generate. <code >EraseDup</code> calls expect a <code >TypeList</code> as
their template type parameters:
        <pre>
    template &lt;typename TypeList&gt;
    struct EraseDup;
</pre>
    <li> If the <code >TypeList</code> is empty it can be returned empty and we're done:
        <pre>
    template &lt;&gt;
    struct EraseDup&lt;TypeList&lt;&gt;&gt;
    {
        typedef TypeList&lt;&gt; List;
    };
</pre>
    <li> In all other cases
        <ul>
        <li> <code >EraseDup</code> is first applied to the original <code >TypeList</code>'s
tail. By definition this results in a <code >TypeList</code> from which all
duplicates have been removed;
        <li> The <code >TypeList</code> returned by the previous step might contain the
original <code >TypeList</code>'s initial type. If so, it is removed by applying
<code >Erase</code> on the returned <code >TypeList</code>, specifying the original <code >TypeList</code>'s
initial type as the type to remove;
        <li> The returned <code >TypeList</code> consists of the original <code >TypeList</code>'s
initial type to which the types of the <code >TypeList</code> produced by the previous
step are appended.
        </ul>
    This specialization is implemented like this:
        <pre>
    template &lt;typename Head, typename ...Tail&gt;
    struct EraseDup&lt;TypeList&lt;Head, Tail...&gt;&gt;
    {
        typedef typename EraseDup&lt;TypeList&lt;Tail...&gt;&gt;::List UniqueTail;
        typedef typename Erase&lt;Head, UniqueTail&gt;::List NewTail;

        typedef typename Prefix&lt;Head, NewTail&gt;::List List;
    };
</pre>
    </ul>
    Here is an example showing how <code >EraseDup</code> can be used:
        <pre>
    cout &lt;&lt;
        "After erasing duplicates from "
             "TypeList&lt;double, char, int, size_t, int, double, size_t&gt;\n"
        "it contains " &lt;&lt;
        EraseDup&lt;
            TypeList&lt;double, char, int, size_t, int, double, size_t&gt;
        &gt;::List::size &lt;&lt; " types\n";
</pre>
<p>
<a name="l630"></a>
<h2 >23.10: Using a TypeList</h2>
In the previous sections the definition and some of the features of typelists
were discussed. Most <strong >C++</strong> programmers consider typelists both
exciting and an intellectual challenge, honing their skills in the area of
recursive programming.
<p>
But there's more to typelist than a mere intellectual challenge. In the final
sections of this chapter the following topics are covered:
    <ul>
    <li> Creating classes from a typelist.<br/>
       Here the aim is to construct a new class consisting of instantiations
        of an existing basic template for each of the types mentioned in a
        provided typelist;
    <li> Accessing data members from the thus constructed conglomerate class
        by index, rather than name.
    </ul>
    Again, much of the material covered by these sections was inspired by
        <a name="an3227"></a>
    Alexandrescu's (2001) book.
<p>
<a name="l631"></a>
<h3 >23.10.1: The Wrap and Multi class templates</h3>
    To illustrate template meta programming concepts the template class <a name="an3228"></a><code >Multi</code>
is now developed. The class template <code >Multi</code> <em >creates</em> a new class from a
template template parameter <code >Policy</code> defining the data storage policy and a
series of types from which <code >Multi</code> is eventually derived. It does so by
passing its template parameters to its base class <code >MultiBase</code> that in turn
creates a final class inheritance tree. Since we don't know how many types are
going to be used <code >Multi</code> is defined as a variadic class template using a
template pack <code >...Types</code>.
<p>
In fact, the types that are specified with <code >Multi</code> aren't that
interesting. They primarily serve to `seed' the class <code >Policy</code>. Therefore,
rather than forwarding <code >Multi</code>'s types to <code >MultiBase</code> they are passed to
<code >Policy</code> and the sequence of <code >Policy&lt;Type&gt;</code> types is then forwarded to
<code >MultiBase</code>. <code >Multi</code>'s constructor expects initialization values for its
various <code >Policy&lt;Type&gt;</code>s which are perfectly forwarded to <code >MultiBase</code>.
<p>
The class <code >Multi</code> (implementing its constructor in-class to save some
space) shows how a
    <a name="an3229"></a>
    <a name="an3230"></a>
 template pack can be wrapped into a policy. Here is <code >Multi</code>'s definition:
    <pre>
    template &lt;template &lt;typename&gt; class Policy, typename ...Types&gt;
    struct Multi: public MultiBase&lt;0, Policy&lt;Types&gt;...&gt;
    {
        typedef TypeList&lt;Types...&gt; PlainTypes;
        typedef MultiBase&lt;0, Policy&lt;Types&gt;...&gt; Base;

        enum { size = PlainTypes::size };

        Multi(Policy&lt;Types&gt; &amp;&amp;...types)
        :
            MultiBase&lt;0, Policy&lt;Types&gt;...&gt;(
                            std::forward&lt;Policy&lt;Types&gt;&gt;(types)...)
        {}
    };
</pre>
<p>
Unfortunately, the design as described contains some flaws.
    <ul>
    <li> As the <code >Policy</code> template template parameter is defined as
<code >template &lt;typename&gt; class Policy</code> it can only accept policies expecting one
type argument. Contrary to this, <code >std::vector</code> is a template expecting two
template arguments, the second one defining the allocation scheme used by
<code >std::vector</code>. This allocation scheme is hardly ever changed, and most
applications merely define objects of types like <code >vector&lt;int&gt;,
vector&lt;string&gt;</code> etc.. Template template parameters must, however, be specified
with the correct number and types of required template parameters so
<code >vector</code> can't be specified as a policy for <code >Multi</code>. This can be solved by
    <a name="an3231"></a>
<em >wrapping</em> a more complex template in a simpler wrapper template, like so:
        <pre>
    template &lt;class Type&gt;
    struct Vector: public std::vector&lt;Type&gt;
    {
        Vector(std::initializer_list&lt;Type&gt; iniValues)
        :
            std::vector&lt;Type&gt;(iniValues)
        {}
    };
</pre>
    Now <code >Vector</code> provides <code >std::vector</code>'s second parameter using its
default template argument. Alternatively, a <em >template using declaration</em>
could be used.
    <li> If the <code >TypeList</code> contains two types like <code >int</code> and <code >double</code>
and the policy class is <code >Vector</code>, then the <code >MultiBase</code> class
eventually inherits from <code >vector&lt;int&gt;</code> and <code >vector&lt;double&gt;</code>. But if the
<code >TypeList</code> contains identical types, like two <code >int</code> type specifications
<code >MultiBase</code> would inherit from <em >two</em> <code >vector&lt;int&gt;</code> classes. Classes
cannot be derived from identical base classes as that would make it impossible
to distinguish among their members. Regarding this, Alexandrescu (2001)
    <a name="an3232"></a> writes (p.67):
    <blockquote >
   <em >There is one major source of annoyance...: you cannot use it when you
    have duplicate types in your <code >TypeList</code>.<br/>
   .... There is no easy way to solve the ambiguity, [as the eventually
    derived class/FBB] ends up inheriting [the same base class/FBB] twice.</em>
   </blockquote>
    </ul>
    There is a way around the problem of duplicate base class types. If
instead of inheriting directly from base classes these base classes are first
wrapped in unique type defining classes, then these unique classes can be used
to access the base classes using principles of inheritance. As these unique
type-defining wrapper classes are merely classes that are derived from the
`real' base classes they inherit (and thus: offer) the functionality of their
base classes. A unique type defining wrapper class can be designed after the
class <a href="cplusplus23.html#INTTYPE">IntType</a>, defined earlier.  The wrapper class we're
looking combines class derivation with the uniqueness offered by
<code >IntType</code>. The class template <code >UWrap</code> has two template parameters: one
non-type parameter <code >idx</code> and one type parameter. By ensuring that each
<code >UWrap</code> definition uses a unique <code >idx</code> value unique class types are
created. These unique class types are then used as base classes of the derived
class <code >MultiBase</code>:
    <pre>
    template &lt;size_t nr, typename Type&gt;
    struct UWrap: public Type
    {
        UWrap(Type const &amp;type)
        :
            Type(type)
        {}
    };
</pre>
    Using <code >UWrap</code> it's easy to distinguish, e.g., two <code >vector&lt;int&gt;</code>
classes: <code >UWrap&lt;0, vector&lt;int&gt;&gt;</code> could refer to the first <code >vector&lt;int&gt;</code>,
<code >UWrap&lt;1, vector&lt;int&gt;&gt;</code> to the second vector.
<p>
Uniqueness of the various <code >UWrap</code> types is assured by the class
template <code >MultiBase</code> as discussed in the next section.
<p>
It must also be possible to initialize a  <code >Multi</code> class object. Its
constructor therefore expects the initialization values for all its <code >Policy</code>
values. So if a <code >Multi</code> is defined for <code >Vector, int, string</code> then its
constructor can receive the matching initialization values. E.g.,
        <pre>
    Multi&lt;Vector, int, string&gt; mvis({1, 2, 3}, {"one", "two", "three"});
</pre>
<p>
<a name="l632"></a>
<h3 >23.10.2: The MultiBase class template</h3>
    The class template <code >MultiBase</code> is <code >Multi</code>'s base class. It
defines a class that, eventually, is derived from the list of <code >Policy</code>
types that, in turn, were created by <code >Multi</code> using any additional types that
were  passed to it.
<p>
<code >MultiBase</code> itself has no concept of a <code >Policy</code>. To <code >MultiBase</code> the
world appears to consist of a simple template pack whose types are used to
define a class from. In addition to the <code >PolicyTypes</code> template pack,
<code >MultiBase</code> also defines a <code >size_t nr</code> non-type parameter that is used to
create unique <code >UWrap</code> types. Here is <code >MultiBase</code>'s generic class
declaration:
    <pre>
    template &lt;size_t nr, typename ...PolicyTypes&gt;
    struct MultiBase;
</pre>
<p>
Two specializations handle all possible <code >MultiBase</code> invocations. One
specialization is a recursive template. This template handles the first type
of <code >MultiBase</code>'s template parameter pack and recursively uses itself to
handle the remaining types. The second specialization is invoked once the
template parameter pack is exhausted and does nothing. Here is the definition
of the latter specialization:
    <pre>
    template &lt;size_t nr&gt;
    struct MultiBase&lt;nr&gt;
    {};
</pre>
<p>
The recursively defined specialization is the interesting one. It performs
the following tasks:
    <ul>
    <li> It is derived from a unique <code >UWrap</code> type. The uniqueness is
guaranteed by using <code >MultiBase</code>'s <code >nr</code> parameter when defining
<code >UWrap</code>. In addition to <code >nr</code> the <code >UWrap</code> class receives the first type
of the template parameter pack made available to <code >MultiBase</code>;
    <li> It is also recursively derived from itself. The recursive
<code >MultiBase</code> type is defined using as its first template argument an
incremented <code >nr</code> value (thus ensuring the uniqueness of the <code >UWrap</code> types
defined by recursive <code >MultiWrap</code> types). Its second template argument is the
tail of the template parameter pack made available to <code >MultiBase</code>
    </ul>
    An illustration showing the layout of the <code >MultiBase</code> class
hierarchy is provided in figure <a href="cplusplus23.html#MultiBaseFig">29</a>.
<p>
<p><a name="MultiBaseFig"></a><figure >
<img src="advancedtemplates/multibase.gif" >
<figcaption >Figure 29: Layout of a MultiBase class hierarchy</figcaption>
</figure></p>

<p>
<code >MultiBase</code>'s constructor simply receives the initialization values that
were (originally) passed to the <code >Multi</code> object. Perfect forwarding is used
to accomplish this. <code >MultiBase</code>'s constructor passes its first parameter
value to its <code >UWrap</code> base class, also using perfect forwarding.
<code >MultiBase</code>'s recursive definition is:
        <pre>
    template &lt;size_t nr, typename PolicyT1, typename ...PolicyTypes&gt;
    struct MultiBase&lt;nr, PolicyT1, PolicyTypes...&gt; :
                                public UWrap&lt;nr, PolicyT1&gt;,
                                public MultiBase&lt;nr + 1, PolicyTypes...&gt;
    {
        typedef PolicyT1 Type;
        typedef MultiBase&lt;nr + 1, PolicyTypes...&gt; Base;

        MultiBase(PolicyT1 &amp;&amp; policyt1, PolicyTypes &amp;&amp;...policytypes)
        :
            UWrap&lt;nr, PolicyT1&gt;(std::forward&lt;PolicyT1&gt;(policyt1)),
            MultiBase&lt;nr + 1, PolicyTypes...&gt;(
                              std::forward&lt;PolicyTypes&gt;(policytypes)...)
        {}
    };
</pre>
<p>
<a name="GENSUPPORT"></a><a name="l633"></a>
<h3 >23.10.3: Support templates</h3>
    The <code >Multi</code> class template defines <code >PlainTypes</code> as the <code >TypeList</code>
holding all the types of its parameter pack. Each <code >MultiBase</code> derived from a
<code >UWrap</code> type also defines a type <code >Type</code> representing the policy type that
was used to define the <code >UWrap</code> type and a type <code >Base</code> representing the
type of its nested <code >MultiBase</code> class.
<p>
These three type definitions allow us to access the types from which the
<code >Multi</code> object was created as well as the values of those types.
<p>
The class template <code >typeAt</code>, is a pure template meta program class template
(it has no run-time executable code). It expects a <code >size_t idx</code> template
argument specifying the index of the policy type in a <code >Multi</code> type object as
well as a <code >Multi</code> class type. It defines the type <code >Type</code> as the <code >Type</code>
defined by <code >Multi</code>'s <code >MultiBase&lt;idx, ...&gt;</code> base class. Example:
        <pre>
    typeAt&lt;0, Multi&lt;Vector, int, double&gt;&gt;::Type // Type is vector&lt;int&gt;
</pre>
<p>
The class template <code >typeAt</code> defines (and uses) a nested class template
<code >PolType</code> doing all the work. <code >PolType</code>'s generic definition specifies two
template parameters: an index used to specify the index of the requested type
and a typename initialized by a <code >MultiBase</code> type argument. <code >PolType</code>'s
recursive definition recursively reduces its index non-type parameter,
passing the next base class in <code >MultiBase</code>'s inheritance tree to the
recursive call. As <code >PolType</code> eventually defines the type <code >Type</code> to be the
requested policy type the recursive definition defines its <code >Type</code> as the
type defined by the recursive call. The final (non-recursive) specialization
defines the initial policy type of the <code >MultiBase</code> type as <code >Type</code>. Here is
<code >typeAt</code>'s definition:
        <pre>
    template &lt;size_t index, typename Multi&gt;
    class typeAt
    {
        template &lt;size_t idx, typename MultiBase&gt;
        struct PolType;

        template &lt;size_t idx,
                  size_t nr, typename PolicyT1, typename ...PolicyTypes&gt;
        struct PolType&lt;idx, MultiBase&lt;nr, PolicyT1, PolicyTypes...&gt;&gt;
        {
            typedef typename PolType&lt;
                idx - 1, MultiBase&lt;nr + 1, PolicyTypes...&gt;&gt;::Type Type;
        };

        template &lt;size_t nr, typename PolicyT1, typename ...PolicyTypes&gt;
        struct PolType&lt;0, MultiBase&lt;nr, PolicyT1, PolicyTypes...&gt;&gt;
        {
            typedef PolicyT1 Type;
        };
    public:
        typeAt(typeAt const &amp;) = delete;
        typedef typename PolType&lt;index, typename Multi::Base&gt;::Type Type;
    };
</pre>
<p>
The types specified by <code >Multi</code>'s parameter pack can also be retrieved using
a second helper class template: <code >plainTypeAt</code>. Example:
        <pre>
    plainTypeAt&lt;0, Multi&lt;Vector, int, double&gt;&gt;::Type // Type is int
</pre>
    The class template <code >plainTypeAt</code> uses a comparable (but simpler)
implementation than <code >typeAt</code>. It is also a pure template meta program class
template defining a nested class template <code >At</code>. <code >At</code> is implemented like
<code >typeAt</code> but it visits the types of the original template pack that was
passed to <code >Multi</code>, and made available by <code >Multi</code> as its <code >PlainTypes</code>
type. Here is <code >plainTypeAt</code>'s definition:
        <pre>
    template &lt;size_t index, typename Multi&gt;
    class plainTypeAt
    {
        template &lt;size_t idx, typename List&gt;
        struct At;

        template &lt;size_t idx, typename Head, typename ...Tail&gt;
        struct At&lt;idx, TypeList&lt;Head, Tail...&gt;&gt;
        {
            typedef typename At&lt;idx - 1, TypeList&lt;Tail...&gt;&gt;::Type Type;
        };

        template &lt;typename Head, typename ...Tail&gt;
        struct At&lt;0, TypeList&lt;Head, Tail...&gt;&gt;
        {
            typedef Head Type;
        };

    public:
        plainTypeAt(plainTypeAt const &amp;) = delete;
        typedef typename At&lt;index, typename Multi::PlainTypes&gt;::Type Type;
    };
</pre>
<p>
Arguably the neatest support template is <code >get</code>. This is a function template
defining <code >size_t idx</code> as its first template parameter and <code >typename Multi</code>
as its second template parameter. The function template <code >get</code> defines one
function parameter: a reference to a <code >Multi</code>, so it can deduct <code >Multi</code>'s
type by itself. Knowing that it's a <code >Multi</code>, we reason that it is also a
<code >UWrap&lt;nr, PolicyType&gt;</code> and therefore also a <code >PolicyType</code>, as the latter
class is defined as a base class of <code >UWrap</code>.
<p>
Since class type objects can initialize references to their base classes the
<code >PolicyType &amp;</code> can be initialized by an appropriate <code >UWrap</code> reference,
which in turn can be initialized by a <code >Multi</code> object. Since we can
determine <code >PolicyType</code> using <code >TypeAt</code> (note that evaluating <code >typename
typeAt&lt;idx, Multi&gt;::Type</code> is a purely compile-time matter), the <code >get</code>
function can very well be implemented <em >inline</em> by a single <code >return</code>
statement:
        <pre>
    template &lt;size_t idx, typename Multi&gt;
    inline typename typeAt&lt;idx, Multi&gt;::Type &amp;get(Multi &amp;multi)
    {
        return static_cast&lt;
                UWrap&lt;idx, typename typeAt&lt;idx, Multi&gt;::Type&gt; &amp;&gt;(multi);
    }
</pre>
    The intermediate <code >UWrap</code> cast is required to disambiguate between
identical policy types (like two <code >vector&lt;int&gt;</code> types). As <code >UWrap</code> is
uniquely determined by its <code >nr</code> template argument and this is the number
argument that is passed to <code >get</code> ambiguities can easily be prevented.
<p>
<a name="l634"></a>
<h3 >23.10.4: Using Multi</h3>
    Now that <code >Multi</code> and its support templates have been developed, how can a
<code >Multi</code> be used?
<p>
A word of warning is in place. To reduce the size of the developed classes
they were designed in a minimalist way. For example, the <code >get</code> function
template cannot be used with <code >Multi const</code> objects and there is no default,
or move constructor available for <code >Multi</code> types. <code >Multi</code> was designed to
illustrate some of the possibilities of template meta programming and
hopefully <code >Multi</code>'s implementation served that purpose well. But can it be
used? If so, how?
<p>
This section provides some annotated examples. They may be concatenated to
define a series of statements that could be placed in a <code >main</code> function's
body, which would result in a working program.
<p>
<ul>
    <li> A simple <code >Policy</code> could be defined:
        <pre>
    template &lt;typename Type&gt;
    struct Policy
    {
        Type d_type;
        Policy(Type &amp;&amp;type)
        :
            d_type(std::forward&lt;Type&gt;(type))
        {}
    };
</pre>
    <code >Policy</code> defines a data member and it can be used to define <code >Multi</code>
objects:
        <pre>
    Multi&lt;Policy, string&gt; ms{ Policy&lt;string&gt;{ "hello" } };
    Multi&lt;Policy, string, string&gt; ms2s{ Policy&lt;string&gt;{ "hello" },
                                       Policy&lt;string&gt;{ "world" } };


     typedef Multi&lt;Policy, string, int&gt; MPSI;
     MPSI mpsi{ string{ "hello" }, 4 };
</pre>
<p>
<li> To obtain the number of types defined by a <code >Multi</code> class or object
    either use the <code >::size</code> enum value (using the <code >Multi</code> class) or the
<code >.size</code> member (using the <code >Multi</code> object):
        <pre>
    cout &lt;&lt; "There are " &lt;&lt; MPSI::size &lt;&lt; " types in MPSI\n"
            "There are " &lt;&lt; mpsi.size &lt;&lt; " types in mpsi\n";
</pre>
<p>
<li> Variables of constituting types can be defined using <code >plainTypeAt</code>:
        <pre>
    plainTypeAt&lt;0, MPSI&gt;::Type sx = "String type";
    plainTypeAt&lt;1, MPSI&gt;::Type ix = 12;
</pre>
<p>
<li> Raw static casts can be used to obtain the constituent type:
        <pre>
    cout &lt;&lt; static_cast&lt;Policy&lt;string&gt; &amp;&gt;(mpsi).d_type &lt;&lt; '\n' &lt;&lt;
            static_cast&lt;Policy&lt;int&gt; &amp;&gt;(mpsi).d_type &lt;&lt; '\n';
</pre>
<p>
<li> However, this won't work when the template parameter pack contains
identical types, as a cast can't distinguish between identical
<code >Policy&lt;Type&gt;</code> types. In that case <code >get</code> still works fine:
        <pre>
    typedef Multi&lt;Policy, int, int&gt; MPII;
    MPII mpii{ 4, 18 };

    cout &lt;&lt; get&lt;0&gt;(mpii).d_type &lt;&lt; ' ' &lt;&lt; get&lt;1&gt;(mpii).d_type &lt;&lt; '\n';
</pre>
<p>
<li> Here is an example wrapping a <code >std::vector</code> in a <code >Vector</code>:
        <pre>
    typedef Multi&lt;Vector, int, double&gt; MVID;
    MVID mi{ {1, 2, 3}, {1.2, 3.4, 5.6, 7.8} };
</pre>
<p>
<li> Such a vector can be defined by its <code >Multi</code> type:
        <pre>
    typeAt&lt;0, Multi&lt;Vector, int&gt;&gt;::Type vi = {1, 2, 3};
</pre>
<p>
<li> Knowing that a <code >Vector</code> is a <code >std::vector</code>, the reference
returned by <code >get</code> support index operators that can be used as left hand side
or right hand side operands:
        <pre>
    cout &lt;&lt; get&lt;0&gt;(mi)[2] &lt;&lt; '\n';
    get&lt;1&gt;(mi)[3] = get&lt;0&gt;(mi)[0];
    cout &lt;&lt; get&lt;1&gt;(mi)[3] &lt;&lt; '\n';
</pre>
    </ul>
<p>
<a name="l635"></a>
<h2 >23.11: Expression Templates</h2>

<p>
Assume we are processing <code >std::vector</code> objects. Vectors may be assigned to
each other, but that's about it. We've seen (cf. section <a href="cplusplus12.html#VECTOR">12.4.2</a>) that its
member functions tend to operate on the current vector, but arithmetic
operations like addition, subtraction, multiplication and the like cannot
be applied to pairs of vectors.
<p>
Furtunately implementing, e.g., the addition operator for vectors is not
particularly difficult. If <code >VecType</code> is our vector type, then implementing
free functions like
    <code >VecType &amp;&amp;operator+(VecType const &amp;lhs, VecType const &amp;rhs)</code> and 
    <code >VecType &amp;&amp;operator+(VecType &amp;&amp;lhs, VecType const &amp;rhs)</code> 
        performing the additions is a simple exercise (cf. chapter
<a href="cplusplus11.html#OVERLOADING">11</a>).
<p>
Now consider an expression like <code >one + two + three + four</code>. It takes four
steps to compute this sum: first, <code >tmp = one</code> is computed, creating the
eventual return value. The vector <code >tmp</code> is an (in practice anonymous)
temporary variable. Then <code >tmp += two</code> is computed, followed by <code >tmp +=
three</code>, and finally by <code >tmp += four</code>, obtaining the final result (of course
we shouldn't implement <code >std::vector::operator+=</code> as the std namespace is
off-limits to us, and we shouldn't derive a class from <code >std::vector</code>
offering <code >operator+=</code> according to Liskov's Substitution Principle
(cf. section <a href="cplusplus14.html#INHERITWHY">14.7</a>), but we could get around that, 
     
    and here we simply assume <code >operator+=</code> is available).
<p>
Here's how we might implement <code >operator+=</code> for <code >VecType</code>:
        <pre>
    VecType &amp;VecType::operator+=(VecType const &amp;rhs)
    {
        for (size_t idx = 0, end = size(); idx != end; ++idx)
            (*this)[idx] += rhs[idx];
        return *this;
    }
</pre>
    Consider this implementation: once we add a <code >VecType</code> object and such
objects have <code >n</code> elements then we have to perform <code >2 * n</code> index
evaluations. When adding <code >k VecType</code> objects this sums up to about <code >2 * k
* n</code> index expression evaluations: a lot of evaluations if we're adding many
and/or big vectors.
<p>
If instead we could manage to perform the evaluations `row by row', each
vector element would be accessed only once. This would dramatically cut down
on our index evaluations. We would only need to perform approx. <code >n * k</code>
index expression evaluations.
<p>
Expression templates 
    <a name="an3233"></a><a name="an3234"></a> 
    allow us to achieve precisely this kind of optimization. We'll have a look
at their design and implementation in the coming sections.
<p>
<a name="l636"></a>
<h3 >23.11.1: Designing an Expression Template</h3>
    As we've seen, when using a standard implementation of an expression like
<code >one + two + three + four</code>, where the objects are vectors having <code >n</code>
elements, then if we have <code >k</code> vectors we have to perform a total of <code >k * 2
* n</code> index evaluations.
<p>
Expression templates allow us to avoid many of these evaluations. When using
expression templates these templates may access the vectors, but their
elements are not accessed during addition operations. 
<p>
Assuming our expression template is named ET, and we want to add <code >one + two
+ three</code>, then the first <code >+</code> operator merely creates <code >ET(one, two)</code>. Note
that no addition is actually performed, <code >ET</code> merely stores (constant)
references to <code >one</code> (becoming <code >ET's lhs</code> data member) and <code >two</code>
(becoming <code >ET's rhs</code> data member). In general, <code >ET</code> stores references to
the two arguments that are passed to its constructor.
<p>
At the next addition operator another <code >ET</code> is created. Its constructor
arguments are, respectively, the <code >ET</code> object that has just been constructed
for <code >one</code> and <code >two</code>, and the vector <code >three</code>. Again, no addition is
performed by the ET objects.
<p>
This algorithm easily generalizes to any number of vectors. Parentheses can
also be used. E.g., <code >(one + two) + (three + four)</code> results in
        <pre>
    ET(ET(one, two), ET(three, four))
</pre>
<p>
Presumably, at some point we want to obtain the sum of the vectors. For this
the expression template is provided with a conversion operator, converting the
<code >ET</code> object to a vector, or maybe an assignment operator doing the same.
<p>
The conversion operator looks like this:
        <pre>
    operator ET::VecType() const
    {                                                        
        VecType retVal;
        retVal.reserve(size());

        for (size_t ix = 0, end = size(); ix != end; ++ix)
            new(&amp;retVal[ix]) value_type((*this)[ix]);
                                                     
        return retVal;
    }
</pre>
    Placement new is used for efficiency reasons: there's no need to
initialize <code >retVal</code> with default values first. The really interesting part,
however, is hidden behind the <code >(*this)[idx]</code> expression: at this point the
real addition takes place.
<p>
<code >ET's</code> index operator simply adds the values returned by the
corresponding index expressions of its <code >lhs</code> and <code >rhs</code> data members. If a
data member refers to a vector then the corresponding vector element is used,
adding it to the other data member's value. If a data member itself refers to
an ET object, then that nested <code >ET</code> object's index operator performs the
same addition on its own data members, returning their sum. So, an expression
like <code >(*this)[0]</code> returns <code >first[0] + second[0] + third[0]</code>, and the
computed sum is then stored in <code >retVal[0]</code> using placement new.
<p>
In this case the required number of index expression evaluations are <code >n
* k</code> (for the n elements of the k vectors) plus n (for the n elements of
<code >retVal</code>, adding up to <code >(k + 1) * n</code>). 
<p>
Since <code >(k + 1) * n &lt; 2 * k * n</code> for <code >k &gt; 1</code> expression templates evaluate
the requested addition more efficiently than the traditional implementation of
<code >operator+</code>. An additional benefit of using expression templates is that
they do not create additional temporary vector objects when parenthesized
expressions are used.
<p>
<a name="l637"></a>
<h3 >23.11.2: Implementing an Expression Template</h3>
    In this section we use a <code >typedef std::vector&lt;int&gt; IntVect</code> to illustrate
the construction of an expression template. 
<p>
Starting point is a simple <code >main</code> function, in which several <code >IntVect</code>
objects are added. E.g., 
        <pre>
    int main()
    {
        IntVect one;
        IntVect two;
        IntVect three;
        IntVect four;
        
        // ... assume the IntVects somehow receive values

        four = one + two + three + four;
    }
</pre>
    At this point the code does not suggest that expression templates are
going to be used. However, <code >operator+'s</code> implementation is special: it's a
template merely returning an object constructed by <code >operator+</code>:
        <pre>
    template&lt;typename LHS, typename RHS&gt;
    BinExpr&lt;LHS, RHS, plus&gt; &amp;&amp;operator+(LHS const &amp;lhs, RHS const &amp;rhs)
    {
        return BinExpr&lt;LHS, RHS, plus&gt;{ lhs, rhs };
    }
</pre>
<p>
Our expression template is called <code >BinExpr</code>. It has three template type
parameters: two object types and a template template parameter performing the
requested operation. Its declaration looks like this:
        <pre>
    template&lt;typename LHS, typename RHS, template&lt;typename&gt; class Operation&gt;
    struct BinExpr;
</pre>
    Since <code >LHS</code> and <code >RHS</code> can either be the data type that is processed by
the expression template, or a <code >BinExpr</code> two different typenames are
required. <code >Operation</code> is the operation that is performed by the expression
template. By using a template template parameter we can use <code >BinExpr</code> to
perform any operation we want, not just addition. Predefined function
templates like <code >std::plus</code> can be used for the standard arithmetic
operators; for other operators we can define our own function templates.
<p>
<code >BinExpr's</code> constructor initializes constant references to <code >lhs</code> and
<code >rhs</code>. Its in-class implementation is
        <pre>
    BinExpr(LHS const &amp;lhs, RHS const &amp;rhs)
    :
        d_lhs(lhs),
        d_rhs(rhs)
    {}
</pre>
<p>
To retrieve the resulting <code >IntVect</code> a conversion operator is defined. We
already encountered its implementation (in the previous section). Here is it,
as an in-class implemented <code >BinExpr</code> member:
        <pre>
    operator ObjType() const
    {                                                        
        ObjType retVal;
        retVal.reserve(size());

        for (size_t idx = 0, end = size(); idx != end; ++idx)
            new(&amp;retVal[idx]) value_type((*this)[idx]);
                                                     
        return retVal;
    }
</pre>
    We return to the type <code >ObjType</code> below. At this point it can be
considered an <code >IntVect</code>. The member <code >size()</code> simply returns
<code >d_lhs.size()</code>: in any sequence of <code >IntVect</code> additions <code >LHS</code> eventually
is an <code >IntVect</code>, and so every <code >BinExpr</code> defines a valid <code >size()</code> like
so:
        <pre>
    size_t size() const
    {
        return d_lhs.size();
    }
</pre>
<p>
The only remaining member to implement is <code >operator[]</code>. Since it
receives an index, it only needs to perform the requested operation on the
corresponding index elements of its <code >d_lhs</code> and <code >d_rhs</code> data members. The
beauty of expression templates is that if either one itself is a <code >BinExpr</code>
that expression template in turn calls its <code >operator[]</code>, eventually
performing the requested operation on all corresponding elements of all
<code >IntVect</code> objects. Here is its implementation:
        <pre>
    value_type operator[](size_t ix) const
    {
        static Operation&lt;value_type&gt; operation;

        return operation(d_lhs[ix], d_rhs[ix]);
    }
</pre>
    This implementation uses another type: <code >value_type</code> which is the 
type of the elements of the vector type that is processed by the expression
template. Like <code >ObjType</code> before, its definition is covered below. The static
data member <code >operation</code> simply is an instantiation of the <code >Operation</code> type
that is specified when constructing an <code >ExprType</code> object. 
<p>
So, it's about time to have a look at <code >ObjType</code> and <code >value_type</code>. We do
that in the next section.
<p>
<a name="l638"></a>
<h3 >23.11.3: The BasicType trait class and ordering classes</h3>
    The <code >BinExpr</code> expression template needs to be aware of two types before it
can instantiate objects. First, <code >ObjType</code> must be known, as this is the 
type of object that is handled by the expression template. <code >ObjType</code> objects
contain values, and we require that the type of these values can be determined
as <code >ObjType::value_type</code>. E.g., for our <code >IntVect</code> data type <code >value_type</code>
is <code >int</code>. 
<p>
In expressions like <code >one + two + three</code>, the <code >BinExpr</code> expression template
receives two <code >IntVect</code> objects. This is always true: the <code >BinExpr</code> that is
first constructed receives two <code >IntVect</code> objects. In this case <code >ObjType</code>
is simply <code >LHS</code>, and <code >ObjType::value_type</code> is also available: either
<code >value_type</code> is already defined by <code >LHS</code> or <code >BinExpr</code> <em >requires</em> that
it defines type <code >value_type</code>. 
<p>
Since arguments to <code >BinExpr</code> objects are not <em >always</em> of the basic
<code >ObjType</code> type (<code >BinExpr</code> objects at the next nesting level receive at
least one <code >BinExpr</code> argument) we need a way to determine <code >ObjType</code> from a
<code >BinExpr</code>. For this we use a <em >trait class</em>. The 
trait class <code >BasicType</code> receives a typename template argument, and equates
its type <code >ObjType</code> to the received template type argument:
        <pre>
    template&lt;typename Type&gt;
    struct BasicType
    {
        typedef Type ObjType;
    };
</pre>
    A specialization handles the case where <code >Type</code> in fact is a <code >BinExpr</code>:
    template&lt;typename LHS, typename RHS, template&lt;typename&gt; class Operation&gt;
        <pre>
    template&lt;typename LHS, typename RHS, template&lt;typename&gt; class Operation&gt;
    struct BasicType&lt;BinExpr&lt;LHS, RHS, Operation&gt;&gt;
    {
        typedef typename BinExpr&lt;LHS, RHS, Operation&gt;::ObjType ObjType;
    };
</pre>
<p>
Since <code >BinExpr</code> <em >requires</em> that <code >ObjType::value_type</code> is a defined
type, <code >value_type</code> has automatically been taken care of. 
<p>
As <code >BinExpr</code> refers to <code >BasicType</code> and <code >BasicType</code> refers to
<code >BinExpr</code> somewhere we must provide a forward declaration. As <code >BinExpr's</code>
declaration has already been provided, we start with that declaration,
resulting in:
        <pre>
    BinExpr's declaration

    BasicType's definition

    BasicType's specialization (for BinExpr)

    template&lt;typename LHS, typename RHS, template&lt;typename&gt; class Operation&gt;
    class BinExpr 
    {
        LHS const &amp;d_lhs;
        RHS const &amp;d_rhs;

        public:
            typedef typename BasicType&lt;RHS&gt;::DataType DataType;
            typedef typename DataType::value_type value_type;

            // all BinExpr member functions
    };
</pre>
<p>

<hr>
<ul>
    <li> <a href="cplusplus.html">Table of Contents</a>
    <li> <a href="cplusplus22.html">Previous Chapter</a>
    <li> <a href="cplusplus24.html">Next Chapter</a>
</ul>
<hr>
</body>
</html>
