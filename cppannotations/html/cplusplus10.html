<!DOCTYPE html><html><head>
<meta charset="UTF-8">
<title> C++ Annotations Version 10.8.0 </title>
<link rel="stylesheet" type="text/css" href="cplusplus.css"><style type="text/css">
    figure {text-align: center;}
    img {vertical-align: center;}
</style>
<link rel="stylesheet" type="text/css" href="cplusplus.css"></head>
<body >
<hr>
<ul>
    <li> <a href="cplusplus.html">Table of Contents</a>
    <li> <a href="cplusplus09.html">Previous Chapter</a>
    <li> <a href="cplusplus11.html">Next Chapter</a>
</ul>
<hr>
<a name="EXCEPTIONS"></a><a name="l180"></a>
<h1 >Chapter 10: Exceptions</h1>
<strong >C</strong> supports several ways for a program to react to situations breaking
the normal unhampered flow of a program:
    <ul>
    <li> The function may notice the abnormality and issue a message. This is
probably the least disastrous reaction a program may show.
    <li> The function in which the abnormality is observed may decide to stop
its intended task, returning an <a name="an959"></a>error code to its caller. This is a great
example of <a name="an960"></a>postponing decisions: now the <em >calling function</em> is faced with
a problem. Of course the calling function may act similarly, by passing the
error code up to <em >its</em> caller.
    <li> The function may decide that things are going out of hand, and may
call <a name="an961"></a><code >exit</code> to terminate the program completely. A tough way to handle a
problem if only because the destructors of local objects aren't activated.
    <li> The function may use a combination of the functions <a name="an962"></a><code >setjmp</code> and
<a name="an963"></a><code >longjmp</code> to enforce non-local exits. This mechanism implements a kind
of <a name="an964"></a><code >goto</code> jump, allowing the program to continue at an outer level,
skipping the intermediate levels which would have to be visited if a series of
returns from nested functions would have been used.
    </ul>
    In <strong >C++</strong> all these <a name="an965"></a>flow-breaking methods are still
available. However, of the mentioned alternatives, <code >setjmp</code> and
<code >longjmp</code>  isn't frequently encountered in <strong >C++</strong> (or even in <strong >C</strong>)
programs, due to the fact that the program flow is completely disrupted.
<p>
<strong >C++</strong> offers <a name="an966"></a><em >exceptions</em> as the preferred alternative to, e.g.,
<code >setjmp</code> and <code >longjmp</code>. Exceptions allow <strong >C++</strong> programs to perform a
controlled <a name="an967"></a>non-local return, without the disadvantages of <code >longjmp</code> and
<code >setjmp</code>.
<p>
Exceptions are the proper way to bail out of a situation which cannot be
handled easily by a function itself, but which is not disastrous enough for
a program to terminate completely. Also, exceptions provide a flexible layer
of control between the short-range <a name="an968"></a><code >return</code> and the crude <a name="an969"></a><code >exit</code>.
<p>
In this chapter exceptions are covered. First an example is given of the
different impact exceptions and the <code >setjmp/longjmp</code> combination have on
programs. This example is followed by a discussion of the formal aspects
of exceptions. In this part the guarantees our software should be able
to offer when confronted with exceptions are presented. Exceptions and their
guarantees have consequences for constructors and destructors. We'll encounter
these consequences at the end of this chapter.
<p>
<a name="l181"></a>
<h2 >10.1: Exception syntax</h2>
Before contrasting the traditional <strong >C</strong> way of handling non-local gotos with
exceptions let's introduce the  <a name="an970"></a>syntactic elements that are involved when
using exceptions.
    <ul>
    <li> Exceptions are generated by a <a name="an971"></a><code >throw</code> statement. The keyword
<code >throw</code>, followed by an expression of a certain type, throws the expression
value as an exception. In <strong >C++</strong> anything having value semantics may be
thrown as an exception: an <code >int</code>, a <code >bool</code>, a <code >string</code>, etc. However,
there also exists a <em >standard exception</em> type (cf. section <a href="cplusplus10.html#STDEXC">10.8</a>) that
may be used as <em >base class</em> (cf. chapter <a href="cplusplus13.html#INHERITANCE">13</a>) when defining new
exception types.
<p>
<li> Exceptions are generated within a well-defined local environment,
called a <code >try</code>-block. The run-time support system ensures that all of the
program's code is itself surrounded by a <a name="an972"></a><em >global <code >try</code> block</em>. Thus, every
exception generated by our code will always reach the boundary of at least one
<code >try</code>-block.  A program terminates when an exception reaches
the boundary of the global <code >try</code> block, and when this happens destructors of
local and global objects that were alive at the point where the exception was
generated are not called. This is not a desirable situation and therefore all
exceptions should be generated within a <code >try</code>-block explicitly defined by
the program. Here is an example of a string exception thrown from within a
<code >try</code>-block:
    <pre>
try
{
    // any code can be defined here
    if (someConditionIsTrue)
        throw string("this is the std::string exception");
    // any code can be defined here
}
</pre>
<p>
<li><a name="an973"></a><code >catch</code>: Immediately following the <code >try</code>-block, one or more
<code >catch</code>-clauses must be defined. A <code >catch</code>-clause consists of a
catch-header defining the type of the exception it can catch followed by a
compound statement defining what to do with the caught exception:
    <pre>
catch (string const &amp;msg)
{
    // statements in which the caught string object are handled
}
</pre>
    Multiple <code >catch</code> clauses may appear underneath each other, one for each
exception type that has to be caught. In general the <code >catch</code> clauses may
appear in any order, but there are exceptions requiring a specific order. To
avoid confusion it's best to put a <code >catch</code> clause for the most general
exception last. At most <em >one</em> exception clause will be activated. <strong >C++</strong>
does not support a <strong >Java</strong>-style <code >finally</code>-clause activated after
completing a catch clause.
    </ul>
<p>
<a name="BASICEXCEPTION"></a><a name="l182"></a>
<h2 >10.2: An example using exceptions</h2>
In the following examples the same basic program is used. The program uses
two classes, <code >Outer</code> and <code >Inner</code>.
<p>
First, an <code >Outer</code> object is defined in <code >main</code>, and its member
<code >Outer::fun</code> is called.  Then, in <code >Outer::fun</code> an <code >Inner</code> object is
defined. Having defined the <code >Inner</code> object, its member <code >Inner::fun</code> is
called.
<p>
That's about it. The function <code >Outer::fun</code> terminates calling
<code >inner</code>'s destructor. Then the program terminates, activating
<code >outer</code>'s destructor. Here is the basic program:
        <pre>
    #include &lt;iostream&gt;
    using namespace std;

    class Inner
    {
        public:
            Inner();
            ~Inner();
            void fun();
    };
    Inner::Inner()
    {
        cout &lt;&lt; "Inner constructor\n";
    }
    Inner::~Inner()
    {
        cout &lt;&lt; "Inner destructor\n";
    }
    void Inner::fun()
    {
        cout &lt;&lt; "Inner fun\n";
    }

    class Outer
    {
        public:
            Outer();
            ~Outer();
            void fun();
    };
    Outer::Outer()
    {
        cout &lt;&lt; "Outer constructor\n";
    }
    Outer::~Outer()
    {
        cout &lt;&lt; "Outer destructor\n";
    }
    void Outer::fun()
    {
        Inner in;
        cout &lt;&lt; "Outer fun\n";
        in.fun();
    }

    int main()
    {
        Outer out;
        out.fun();
    }

    /*
        Generated output:
    Outer constructor
    Inner constructor
    Outer fun
    Inner fun
    Inner destructor
    Outer destructor
    */
</pre>
    After compiling and running, the program's output is entirely as expected:
the destructors are called in their correct order (reversing the calling
sequence of the constructors).
<p>
Now let's focus our attention on two variants in which we simulate a non-fatal
disastrous event in the <code >Inner::fun</code> function. This event must supposedly be
handled near <code >main</code>'s end.
<p>
We'll consider two variants. In the first variant the event is handled by
<a name="an974"></a><code >setjmp</code> and <a name="an975"></a><code >longjmp</code>; in the second variant the event is handled using
<strong >C++</strong>'s exception mechanism.
<p>
<a name="EXCEPTIONJMP"></a><a name="l183"></a>
<h3 >10.2.1: Anachronisms: `setjmp' and `longjmp'</h3>
    The basic program from the previous section is slightly modified to contain a
variable
 <a name="an976"></a> <code >jmp_buf jmpBuf</code> used by <a name="an977"></a><code >setjmp</code> and <a name="an978"></a><code >longjmp</code>.
<p>
The function <code >Inner::fun</code> calls <code >longjmp</code>, simulating a disastrous
event, to be handled near <code >main</code>'s end. In <code >main</code> a target location for
the long jump is defined through the function <code >setjmp</code>. <code >Setjmp</code>'s zero
return indicates the initialization of the <code >jmp_buf</code> variable, in which case
<code >Outer::fun</code> is called. This situation represents the `normal flow'.
<p>
The program's return value is zero <em >only</em> if <code >Outer::fun</code> terminates
normally. The program, however, is designed in such a way that this won't
happen: <code >Inner::fun</code> calls <code >longjmp</code>. As a result the execution flow
returns to the <code >setjmp</code> function. In this case it does <em >not</em> return a zero
return value. Consequently, after calling <code >Inner::fun</code> from <code >Outer::fun</code>
<code >main</code>'s <code >if</code>-statement is entered and the program terminates with return
value 1.  Try to follow these steps when studying the following program
source, which is a direct modification of the basic program given in section
<a href="cplusplus10.html#BASICEXCEPTION">10.2</a>:
        <pre>
    #include &lt;iostream&gt;
    #include &lt;setjmp.h&gt;
    #include &lt;cstdlib&gt;

    using namespace std;

    jmp_buf jmpBuf;

    class Inner
    {
        public:
            Inner();
            ~Inner();
            void fun();
    };

    Inner::Inner()
    {
        cout &lt;&lt; "Inner constructor\n";
    }
    void Inner::fun()
    {
        cout &lt;&lt; "Inner fun\n";
        longjmp(jmpBuf, 0);
    }
    Inner::~Inner()
    {
        cout &lt;&lt; "Inner destructor\n";
    }

    class Outer
    {
        public:
            Outer();
            ~Outer();
            void fun();
    };

    Outer::Outer()
    {
        cout &lt;&lt; "Outer constructor\n";
    }
    Outer::~Outer()
    {
        cout &lt;&lt; "Outer destructor\n";
    }
    void Outer::fun()
    {
        Inner in;
        cout &lt;&lt; "Outer fun\n";
        in.fun();
    }

    int main()
    {
        Outer out;

        if (setjmp(jmpBuf) != 0)
            return 1;

        out.fun();
    }
    /*
        Generated output:
    Outer constructor
    Inner constructor
    Outer fun
    Inner fun
    Outer destructor
    */
</pre>
    This program's output clearly shows that <code >inner</code>'s destructor is not
called. This is a direct consequence of the non-local jump performed by
<code >longjmp</code>. Processing proceeds immediately from the <code >longjmp</code> call inside
<code >Inner::fun</code> to <code >setjmp</code> in <code >main</code>. There, its return value is unequal
zero, and the program terminates with return value 1. Because of the non-local
jump <code >Inner::~Inner</code> is never executed: upon return to <code >main</code>'s <code >setjmp</code>
the existing stack is simply broken down disregarding any destructors waiting
to be called.
<p>
This example illustrates that the destructors of objects can easily be skipped
when <code >longjmp</code> and <code >setjmp</code> are used and <strong >C++</strong> programs should therefore
avoid those functions like the plague.
<p>
<a name="l184"></a>
<h3 >10.2.2: Exceptions: the preferred alternative</h3>
    Exceptions are <strong >C++</strong>'s answer to the problems caused by <code >setjmp</code> and
<code >longjmp</code>. Here is an example using exceptions. The program is once again
derived from the basic program of section <a href="cplusplus10.html#BASICEXCEPTION">10.2</a>:
        <pre>
    #include &lt;iostream&gt;
    using namespace std;

    class Inner
    {
        public:
            Inner();
            ~Inner();
            void fun();
    };
    Inner::Inner()
    {
        cout &lt;&lt; "Inner constructor\n";
    }
    Inner::~Inner()
    {
        cout &lt;&lt; "Inner destructor\n";
    }
    void Inner::fun()
    {
        cout &lt;&lt; "Inner fun\n";
        throw 1;
        cout &lt;&lt; "This statement is not executed\n";
    }

    class Outer
    {
        public:
            Outer();
            ~Outer();
            void fun();
    };

    Outer::Outer()
    {
        cout &lt;&lt; "Outer constructor\n";
    }
    Outer::~Outer()
    {
        cout &lt;&lt; "Outer destructor\n";
    }
    void Outer::fun()
    {
        Inner in;
        cout &lt;&lt; "Outer fun\n";
        in.fun();
    }

    int main()
    {
        Outer out;
        try
        {
            out.fun();
        }
        catch (int x)
        {}
    }
    /*
        Generated output:
    Outer constructor
    Inner constructor
    Outer fun
    Inner fun
    Inner destructor
    Outer destructor
    */
</pre>
    <code >Inner::fun</code> now throws an <code >int</code> exception where a <code >longjmp</code> was
previously used. Since <code >in.fun</code> is called by <code >out.fun</code>, the exception is
generated within the <code >try</code> block surrounding the <code >out.fun</code> call. As an
<code >int</code> value was thrown this value reappears in the <code >catch</code> clause beyond
the <code >try</code> block.
<p>
Now <code >Inner::fun</code> terminates by throwing an exception instead of calling
<code >longjmp</code>. The exception is caught in <code >main</code>, and the program
terminates. Now we see that <code >inner</code>'s destructor is properly called.  It is
interesting to note that <code >Inner::fun</code>'s execution really terminates at the
<code >throw</code> statement: The <code >cout</code> statement, placed just beyond the <code >throw</code>
statement, isn't executed.
<p>
What did this example teach us?
    <ul>
    <li> Exceptions provide a means to break a function's (and program's)
normal flow without having to use a cascade of <code >return</code>-statements, and
without the need to terminate the program using blunt tools like the function
<a name="an979"></a><code >exit</code>.
    <li> Exceptions do not disrupt the proper activation of destructors. Since
<code >setjmp</code> and <code >longjmp</code> <em >do</em> distrupt the proper activation of
destructors their use is strongly deprecated in <strong >C++</strong>.
    </ul>
<p>
<a name="THROW"></a><a name="l185"></a>
<h2 >10.3: Throwing exceptions</h2>
Exceptions are generated by <a name="an980"></a><code >throw</code> statements. The <code >throw</code> keyword is
followed by an expression, defining the thrown exception value.  Example:
        <pre>
    throw "Hello world";        // throws a char *
    throw 18;                   // throws an int
    throw string{ "hello" };    // throws a string
</pre>
    Local objects cease to exist when a function terminates. This is no
different for exceptions.
<p>
Objects defined locally in functions are automatically destroyed once
exceptions thrown by these functions leave these functions. This also happens
to objects thrown as exceptions. However, just before leaving the function
context the object is copied and it is this copy that eventually reaches the
appropriate <code >catch</code> clause.
<p>
The following examples illustrates this process.
<code >Object::fun</code> defines a local <code >Object toThrow</code>, that is
thrown as an exception. The exception is caught
in <code >main</code>. But by then the object originally thrown doesn't exist anymore,
and <code >main</code> received a copy:
        <pre>
    #include &lt;iostream&gt;
    #include &lt;string&gt;
    using namespace std;

    class Object
    {
        string d_name;

        public:
            Object(string name)
            :
                d_name(name)
            {
                cout &lt;&lt; "Constructor of " &lt;&lt; d_name &lt;&lt; "\n";
            }
            Object(Object const &amp;other)
            :
                d_name(other.d_name + " (copy)")
            {
                cout &lt;&lt; "Copy constructor for " &lt;&lt; d_name &lt;&lt; "\n";
            }
            ~Object()
            {
                cout &lt;&lt; "Destructor of " &lt;&lt; d_name &lt;&lt; "\n";
            }
            void fun()
            {
                Object toThrow("'local object'");
                cout &lt;&lt; "Calling fun of " &lt;&lt; d_name &lt;&lt; "\n";
                throw toThrow;
            }
            void hello()
            {
                cout &lt;&lt; "Hello by " &lt;&lt; d_name &lt;&lt; "\n";
            }
    };

    int main()
    {
        Object out{ "'main object'" };
        try
        {
            out.fun();
        }
        catch (Object o)
        {
            cout &lt;&lt; "Caught exception\n";
            o.hello();
        }
    }
</pre>
    <code >Object</code>'s copy constructor is special in that it defines its name as
the other object's name to which the string <code >" (copy)"</code> is appended. This
allow us to monitor the construction and destruction of objects more closely.
<code >Object::fun</code> generates an exception, and throws its locally defined
object. Just before throwing the exception the program has produced the
following output:
        <pre>
    Constructor of 'main object'
    Constructor of 'local object'
    Calling fun of 'main object'
</pre>
    When  the exception is generated the next line of output is produced:
        <pre>
    Copy constructor for 'local object' (copy)
</pre>
    The local object is passed to <code >throw</code> where it is treated  as a value
argument, creating a copy of <code >toThrow</code>. This copy is thrown as the
exception, and the local <code >toThrow</code> object ceases to exist. The thrown
exception is now caught by the <code >catch</code> clause, defining an
<code >Object</code> value parameter. Since this is a <em >value</em> parameter yet another
copy is created. Thus, the program writes the following text:
        <pre>
    Destructor of 'local object'
    Copy constructor for 'local object' (copy) (copy)
</pre>
    The <code >catch</code> block now displays:
        <pre>
    Caught exception
</pre>
    Following this <code >o</code>'s  <code >hello</code> member is called, showing us that we
indeed received a <em >copy of the copy</em> of the original <code >toThrow</code> object:
        <pre>
    Hello by 'local object' (copy) (copy)
</pre>
    Then the program terminates and its remaining  objects are now
destroyed, reversing  their order of creation:
        <pre>
    Destructor of 'local object' (copy) (copy)
    Destructor of 'local object' (copy)
    Destructor of 'main object'
</pre>
<p>
The copy created by the <code >catch</code> clause clearly is superfluous. It can be
avoided by defining object <em >reference parameters</em> in <code >catch</code> clauses:
`<code >catch (Object &amp;o)</code>'. The program now produces the following output:
        <pre>
    Constructor of 'main object'
    Constructor of 'local object'
    Calling fun of 'main object'
    Copy constructor for 'local object' (copy)
    Destructor of 'local object'
    Caught exception
    Hello by 'local object' (copy)
    Destructor of 'local object' (copy)
    Destructor of 'main object'
</pre>
    Only a single copy of <code >toThrow</code> was created.
<p>
It's a bad idea to <a name="an981"></a> throw a <em >pointer</em> to a locally defined
object. The pointer is thrown, but the object to which the pointer refers
ceases to exist once the exception is thrown. The catcher receives a
<a name="an982"></a>wild pointer. Bad news....
<p>
Let's summarize the above findings:
    <ul>
    <li> Local objects are thrown as copied objects;
    <li> Don't throw pointers to local objects;
    <li> It is possible to throw pointers to <em >dynamically</em> generated
objects. In this case one must take care that the generated object is properly
deleted by the exception handler to prevent a <a name="an983"></a>memory leak.
    </ul>
    Exceptions are thrown in situations where a function can't complete its
assigned task, but the program is still able to continue. Imagine a program
offering an interactive calculator. The program expects numeric expressions,
which are evaluated.  Expressions may show syntactic errors or it may be
mathematically impossible to evaluate them. Maybe the calculator allows us to
define and use variables and the user might refer to non-existing variables:
plenty of reasons for the expression evaluation to fail, and so many reasons
for exceptions to be thrown. None of those should terminate the
program. Instead, the program's user is informed about the nature of the
problem and is invited to enter another expression. Example:
        <pre>
    if (!parse(expressionBuffer))           // parsing failed
        throw "Syntax error in expression";

    if (!lookup(variableName))              // variable not found
        throw "Variable not defined";

    if (divisionByZero())                   // unable to do division
        throw "Division by zero is not defined";
</pre>
    Where these <code >throw</code> statements are located is irrelevant: they may be
found deeply nested inside the program, or at a more superficial level.
Furthermore, <em >functions</em> may be used to generate the exception to be
thrown. An <code >Exception</code> object might support stream-like insertion operations
allowing us to do, e.g.,
        <pre>
    if (!lookup(variableName))
        throw Exception() &lt;&lt; "Undefined variable '" &lt;&lt; variableName &lt;&lt; "';
</pre>
<p>
<a name="EMPTYTHROW"></a><a name="l186"></a>
<h3 >10.3.1: The empty `throw' statement</h3>
    Sometimes it is required to inspect a thrown exception. An exception catcher
may decide to ignore the exception, to process the exception, to rethrow it
after inspection or to change it into another kind of exception. For example,
in a server-client application the client may submit requests to the server by
entering them into a queue. Normally every request is eventually answered by
the server. The server may reply that the request was successfully processed,
or that some sort of error has occurred. On the other hand, the server may
have died, and the client should be able to discover this calamity, by not
waiting indefinitely for the server to reply.
<p>
In this situation an intermediate exception handler is called for. A thrown
exception is first inspected at the middle level. If possible it is processed
there. If it is not possible to process the exception at the middle level, it
is passed on, unaltered, to a more superficial level, where the really tough
exceptions are handled.
<p>
By placing an <a name="an984"></a> <em >empty</em> <code >throw</code> statement in the exception
handler's code the received exception is passed on to the next level that
might be able to process that particular type of exception. The <em >rethrown</em>
exception is never handled by one of its neighboring exception handlers; it
is always transferred to an exception handler at a more superficial level.
<p>
In our server-client situation a function
        <pre>
    initialExceptionHandler(string &amp;exception)
</pre>
    could be designed to handle the <code >string</code> exception. The received message
is inspected. If it's a simple message it's processed, otherwise the exception
is passed on to an outer level. In <code >initialExceptionHandler</code>'s
implementation the empty <code >throw</code> statement is used:
        <pre>
    void initialExceptionHandler(string &amp;exception)
    {
        if (!plainMessage(exception))
            throw;

        handleTheMessage(exception);
    }
</pre>
    Below (section <a href="cplusplus10.html#EXCEPTIONCATCH">10.5</a>), the empty <code >throw</code> statement is used
to pass on the exception received by a <code >catch</code>-block. Therefore, a function
like <code >initialExceptionHandler</code> can be used for a variety of thrown
exceptions, as long as their types match <code >initialExceptionHandler</code>'s
parameter, which is a string.
<p>
The next example jumps slightly ahead, using some of the topics covered in
chapter <a href="cplusplus14.html#POLYMORPHISM">14</a>. The example may be skipped, though, without
loss of continuity.
<p>
A basic exception handling class can be constructed from which specific
exception types are derived.  Suppose we have a class <code >Exception</code>, having a
member function <code >ExceptionType Exception::severity</code>.  This member function
tells us (little wonder!) the severity of a thrown exception. It might be
<code >Info, Notice, Warning, Error</code> or <code >Fatal</code>.  The information contained in
the exception depends on its severity and is processed by a function
<code >handle</code>. In addition, all exceptions support a member function like
<a name="an985"></a><code >textMsg</code>, returning textual information about the exception in a
<code >string</code>.
<p>
By defining a polymorphic function <code >handle</code> it can be made to behave
differently, depending on the nature of a thrown exception, when called
from a basic <code >Exception</code> pointer or reference.
<p>
In this case, a program may throw any of these five exception types.  Assuming
that the classes <code >Message</code> and <code >Warning</code> were derived from the class
<code >Exception</code>, then the <code >handle</code> function matching the exception type will
automatically be called by the following exception catcher:
        <pre>
    //
    catch(Exception &amp;ex)
    {
        cout &lt;&lt; e.textMsg() &lt;&lt; '\n';

        if
        (
            ex.severity() != ExceptionType::Warning
            &amp;&amp;
            ex.severity() != ExceptionType::Message
        )
            throw;              // Pass on other types of Exceptions

        ex.handle();            // Process a message or a warning
    }
</pre>
    Now anywhere in the <code >try</code> block preceding the exception handler
<code >Exception</code> objects or objects of one of its derived classes may be
thrown. All those exceptions will be caught by the above handler. E.g.,
        <pre>
    throw Info{};
    throw Warning{};
    throw Notice{};
    throw Error{};
    throw Fatal{};
</pre>
<p>
<a name="l187"></a>
<h2 >10.4: The try block</h2>
The <a name="an986"></a><code >try</code>-block surrounds <code >throw</code> statements. Remember that a program is
always surrounded by a global <code >try</code> block, so <code >throw</code> statements may
appear anywhere in your code. More often, though, <code >throw</code> statements are
used in function bodies and such functions may be called from within <code >try</code>
blocks.
<p>
A <code >try</code> block is defined by the keyword <code >try</code> followed by a compound
statement. This block, in turn,  <em >must</em> be followed by at least one
<code >catch</code> handler:
        <pre>
    try
    {
                // any statements here
    }
    catch(...)  // at least one catch clause here
    {}
</pre>
    <code >Try</code>-blocks are commonly nested, creating exception <em >levels</em>. For
example, <code >main</code>'s code is surrounded by a <code >try</code>-block, forming an outer
level handling exceptions.  Within <code >main</code>'s <code >try</code>-block functions are
called which may also contain <code >try</code>-blocks, forming the next exception
level. As we have seen (section <a href="cplusplus10.html#EMPTYTHROW">10.3.1</a>), exceptions thrown in
inner level <code >try</code>-blocks may or may not be processed at that level. By
placing an empty <code >throw</code> statement in an exception handler, the
thrown exception is passed on to the next (outer) level.
<p>
<a name="EXCEPTIONCATCH"></a><a name="l188"></a>
<h2 >10.5: Catching exceptions</h2>
A <a name="an987"></a><code >catch</code> clause consists of the keyword <code >catch</code> followed by a parameter
list defining one parameter specifying type and (parameter) name of the
exception caught by that particular <code >catch</code> handler. This name may then be
used as a variable in the compound statement following the <code >catch</code> clause.
Example:
        <pre>
    catch (string &amp;message)
    {
        // code to handle the message
    }
</pre>
    Primitive types and objects may be thrown as exceptions. It's a bad idea
to throw a pointer or reference to a local object, but a pointer to a
<em >dynamically</em> allocated object may be thrown if the exception handler
deletes the allocated memory to prevent a <a name="an988"></a>memory leak. Nevertheless,
throwing such a pointer is dangerous as the exception handler won't be able to
distinguish dynamically allocated memory from non-dynamically allocated
memory, as illustrated by the next example:
        <pre>
    try
    {
        static int x;
        int *xp = &amp;x;

        if (condition1)
            throw xp;

        xp = new int(0);
        if (condition2)
            throw xp;
    }
    catch (int *ptr)
    {
        // delete ptr or not?
    }
</pre>
    Close attention should be paid to the nature of the parameter of the
exception handler, to make sure that when pointers to dynamically allocated
memory are thrown the memory is returned  once the handler has processed
the pointer. In general pointers should not be thrown as exceptions. If
dynamically allocated memory must be passed to an exception handler then the
pointer should be wrapped in a smart pointer, like <code >unique_ptr</code> or
<code >shared_ptr</code> (cf. sections <a href="cplusplus18.html#UNIQUEPTR">18.3</a> and <a href="cplusplus18.html#SHAREDPTR">18.4</a>).
<p>
Multiple <code >catch</code> handlers may follow a <code >try</code> block, each handler
defining its own exception type.  The <em >order</em> <a name="an989"></a>
of the exception handlers is important. When an exception is thrown, the first
exception handler matching the type of the thrown exception is used and
remaining exception handlers are ignored. Eventually at most one exception
handler following a <code >try</code>-block is activated. Normally this is of no
concern as each exception has its own unique type.
<p>
Example: if exception handlers are defined for <code >char *</code>s and <a name="an990"></a><code >void *</code>s
then NTBSs are caught by the former handler. Note that a <code >char
*</code> can also be considered a <code >void *</code>, but the exception type matching
procedure is smart enough to use the <code >char *</code> handler with the thrown
NTBS. Handlers should be designed very type specific to catch the
correspondingly typed exception. For example, <code >int</code>-exceptions are not
caught by <code >double</code>-catchers, <code >char</code>-exceptions are not caught by
<code >int</code>-catchers. Here is a little example illustrating that the order of the
catchers is not important for types not having any hierarchal relationship to
each other (i.e., <code >int</code> is not derived from <code >double</code>; <code >string</code> is not
derived from an NTBS):
        <pre>
#include &lt;iostream&gt;
using namespace std;

int main()
{
    while (true)
    {
        try
        {
            string s;
            cout &lt;&lt; "Enter a,c,i,s for ascii-z, char, int, string "
                                                      "exception\n";
            getline(cin, s);
            switch (s[0])
            {
                case 'a':
                    throw "ascii-z";
                case 'c':
                    throw 'c';
                case 'i':
                    throw 12;
                case 's':
                    throw string();
            }
        }
        catch (string const &amp;)
        {
            cout &lt;&lt; "string caught\n";
        }
        catch (char const *)
        {
            cout &lt;&lt; "ASCII-Z string caught\n";
        }
        catch (double)
        {
            cout &lt;&lt; "isn't caught at all\n";
        }
        catch (int)
        {
            cout &lt;&lt; "int caught\n";
        }
        catch (char)
        {
            cout &lt;&lt; "char caught\n";
        }
    }
}
</pre>
    Rather than defining specific exception handlers a specific class can be
designed whose objects contain information about the exception. Such an
approach was mentioned earlier, in section <a href="cplusplus10.html#EMPTYTHROW">10.3.1</a>. Using this
approach, there's only one handler required, since we <em >know</em> we don't throw
other types of exceptions:
        <pre>
    try
    {
        // code throws only Exception objects
    }
    catch (Exception &amp;ex)
    {
        ex.handle();
    }
</pre>
<p>
When the code of an exception handler has been processed, execution continues
beyond the last exception handler directly following the matching
<code >try</code>-block (assuming the handler doesn't itself use flow control statements
(like <code >return</code> or <code >throw</code>) to break the default flow of execution). The
following cases can be distinguished:
    <ul>
    <li> If <em >no</em> exception was thrown within the <code >try</code>-block no exception
handler is activated, and execution continues from the last statement in
the <code >try</code>-block to the first statement beyond the last <code >catch</code>-block.
    <li> If an exception <em >was</em> thrown within the <code >try</code>-block but neither
the current level nor another level contains an appropriate exception handler,
the program's default exception handler is called, aborting the program.
    <li> If an exception was thrown from the <code >try</code>-block and an appropriate
exception handler is available, then the code of that exception handler is
executed. Following that, the program's execution continues at the first
statement beyond the last <code >catch</code>-block.
    </ul>
    All statements in a <code >try</code> block following an executed
<code >throw</code>-statement are ignored. However, objects that were successfully
constructed within the <code >try</code> block before executing the <code >throw</code> statement
<em >are</em> destroyed before any exception handler's code is executed.
<p>
<a name="l189"></a>
<h3 >10.5.1: The default catcher</h3>
    At a certain level of the program only a limited set of handlers may actually
be required. Exceptions whose types belong to that limited set are processed,
all other exceptions are passed on to exception handlers of an outer level
<code >try</code> block.
<p>
An intermediate type of exception handling may be implemented using the
default exception handler, which must be (due to the hierarchal nature of
exception catchers, discussed in section <a href="cplusplus10.html#EXCEPTIONCATCH">10.5</a>) placed beyond
all other, more specific exception handlers.
<p>
This default exception handler cannot determine the actual type of the thrown
exception and cannot determine the exception's value but it may execute some
statements, and thus do some default processing. Moreover, the caught
exception is not lost, and the default exception handler may use the empty
<code >throw</code> statement (see section <a href="cplusplus10.html#EMPTYTHROW">10.3.1</a>) to pass the exception on to
an outer level, where it's actually processed.  Here is an example showing
this use of a default exception handler:
    <pre>
    #include &lt;iostream&gt;
    using namespace std;

    int main()
    {
        try
        {
            try
            {
                throw 12.25;    // no specific handler for doubles
            }
            catch (int value)
            {
                cout &lt;&lt; "Inner level: caught int\n";
            }
            catch (...)
            {
                cout &lt;&lt; "Inner level: generic handling of exceptions\n";
                throw;
            }
        }
        catch(double d)
        {
            cout &lt;&lt; "Outer level may use the thrown double: " &lt;&lt; d &lt;&lt; '\n';
        }
    }
    /*
        Generated output:
    Inner level: generic handling of exceptions
    Outer level may use the thrown double: 12.25
    */
</pre>
    The program's output illustrates that an empty <code >throw</code> statement in a
default exception handler throws the received exception to the next (outer)
level of exception catchers, keeping type and value of the thrown exception.
<p>
Thus, basic or generic exception handling can be accomplished at an inner
level, while specific handling, based on the type of the thrown expression,
can be provided at an outer level. Additionally, particularly in
multi-threaded programs (cf. chapter <a href="cplusplus20.html#THREADING">20</a>), thrown exceptions can be
transferred between threads after converting <code >std::exception</code> objects to
<code >std::exception_ptr</code> objects. This proceduce can even be used from inside
the default catcher. Refer to section <a href="cplusplus20.html#EXCPTR">20.13.1</a> for further coverage of the
class <code >std::exception_ptr</code>.
<p>
<a name="l190"></a>
<h2 >10.6: Declaring (deprecated) exception throwers</h2>
Once a function has been defined it's commonly called from other functions. If
called functions are not defined in the same source file as calling functions
the called functions must be declared, for which header files are commonly
used. 
<p>
The called functions may throw exceptions. When such functions are declared
their declarations may specify a (now deprecated, see also section
<a href="cplusplus23.html#NOEXCEPT">23.7</a>) <a name="an991"></a> <a name="an992"></a><em >function throw list</em> or
    <a name="an993"></a><em >exception specification list</em> specifying the types of the exceptions
that can be thrown by the called function. For example, a function that may
throw `<code >char *</code>' and `<code >int</code>' exceptions can be declared as
        <pre>
    void exceptionThrower() throw(char *, int);
</pre>
    Function throw lists immediately follow the function header (and their
specifications also follow possible <code >const</code> specifiers).  Throw lists
specify zero or more, comma separated, types, using the following syntax:
        <pre>
    throw ()
    throw (type)
    throw (type1, type2, type3 ...)
</pre>
    where the ellipsis indicates any number of additional, comma separated,
type specifications.
<p>
To indicate that a function is guaranteed not to throw exceptions an
 <a name="an994"></a>empty function throw list can be used. E.g.,
        <pre>
    void noExceptions() throw ();
</pre>
    In all cases, the function header used in the function definition must
exactly match the function header used in the declaration, including a
possibly empty function throw list.
<p>
Once a function throw list has been specified its function may only throw
exceptions of the types mentioned in its throw list. A <a name="an995"></a><em >run-time error</em>
occurs if such a function throws exceptions of types not specified in its
function throw list. Example: the function <code >charPintThrower</code> shown below
clearly throws a <code >char const *</code> exception. Since, according to its function
throw list, <code >intThrower</code> may throw an <code >int</code> exception, the function throw
list of <code >charPintThrower</code> must <em >also</em> contain <code >int</code>.
        <pre>
    #include &lt;iostream&gt;
    using namespace std;

    void charPintThrower() throw(char const *, int);

    class Thrower
    {
        public:
            void intThrower(int) const throw(int);
    };

    void Thrower::intThrower(int x) const throw(int)
    {
        if (x)
            throw x;
    }

    void charPintThrower() throw(char const *, int)
    {
        int x;

        cerr &lt;&lt; "Enter an int: ";
        cin &gt;&gt; x;

        Thrower().intThrower(x);
        throw "this text is thrown if 0 was entered";
    }

    void runTimeError() throw(int)
    {
        throw 12.5;
    }

    int main()
    {
        try
        {
             charPintThrower();
        }
        catch (char const *message)
        {
            cerr &lt;&lt; "Text exception: " &lt;&lt; message &lt;&lt; '\n';
        }
        catch (int value)
        {
            cerr &lt;&lt; "Int exception: " &lt;&lt; value &lt;&lt; '\n';
        }
        try
        {
            cerr &lt;&lt; "Generating a run-time error\n";
            runTimeError();
        }
        catch(...)
        {
            cerr &lt;&lt; "not reached\n";
        }
    }
</pre>
<p>
A function without a throw list may throw any kind of exception.  Without
a function throw list the program's designer is responsible for providing the
correct handlers.
<p>
For various reasons declaring exception throwers is now deprecated. Declaring
exception throwers does not imply that the <em >compiler</em> checks whether an
improper exception is thrown. Rather, the function for which a function throw
list has been specified is surrounded by additional code in which the actually
thrown exception is inspected: if the exception is of a type that is listed in
the function's throw list then that exception is rethrown; otherwise a
run-time error is thrown. Instead of compile-time checks you get run-time
overhead, resulting in additional code (and execution time) that is added to
the function's code. One could write, e.g.,
        <pre>
    void fun() throw (int)
    {
        // code of this function, throwing exceptions
    }
</pre>
    but the function would be compiled to something like this (cf.
section <a href="cplusplus10.html#FUNTRY">10.11</a> for the use of <code >try</code> immediately following the
function's header and section <a href="cplusplus10.html#STDEXC">10.8</a> for a description of
 <a name="an996"></a><code >bad_exception</code>):
        <pre>
    void fun()
    try         // this code resulting from throw(int)
    {
                // the function's code, throwing all kinds of exceptions
    }
    catch (int) // remaining code resulting from throw(int)
    {
        throw;  // rethrow the exception, so it can be caught by the
                // `intended' handler
    }
    catch (...) // catch any other exception
    {
        throw bad_exception{};
    }
</pre>
    Run-time overhead results because the number of thrown and caught
exceptions are doubled. If no function throw list is specified then a thrown
<code >int</code> is simply caught by its intended handler; if a function throw list has
been specified the thrown <code >int</code> is <em >first</em> caught by the `safeguarding'
handler added to the function. In there it is <em >rethrown</em> whereafter it is
caught by its intended handler.
<p>
<a name="l191"></a>
<h3 >10.6.1: noexcept</h3>
    Although function throw lists are deprecated, its younger cousin <a name="an997"></a><code >noexcept</code>
is not. The <code >noexcept</code> keyword is used where previously empty function throw
lists were used (cf. section <a href="cplusplus10.html#SYSTEMERROR">10.9</a> for examples where <code >noexcept</code>
is used). Like empty function throw lists you incur some run-time overhead,
but <code >noexcept</code> is more strict than empty function throw lists when
violations are observed. When violating function throw list specifications a
<code >std::unexpected</code> exception is thrown, when violating <code >noexcept</code> it
results in <code >std::terminate</code>, ending the program.
<p>
In addition, <code >noexcept</code> can be given an argument that is evaluated
compile-time: if the evaluation returns <code >true</code> then the <code >noexcept</code>
requirement is used; if the evaluation returns <code >false</code>, then the
<code >noexcept</code> requirement is ignored. Examples of this advanced use of
<code >noexcept</code> are provided in section <a href="cplusplus23.html#NOEXCEPT">23.7</a>.
<p>
<a name="IOEXCEPTIONS"></a><a name="l192"></a>
<h2 >10.7: Iostreams and exceptions</h2>
The <strong >C++</strong> I/O library was used well before exceptions were available in
<strong >C++</strong>. Hence, normally the classes of the iostream library do not throw
exceptions. However, it is possible to modify that behavior using the
 <a name="an998"></a><code >ios::exceptions</code> member function. This function has two overloaded
versions:
    <ul>
    <li><a name="an999"></a><code >ios::iostate exceptions()</code>:<blockquote ><a name="an1000"></a>this member returns the <a name="an1001"></a>state flags for which the
         stream will throw exceptions;</blockquote>
    <li><code >void exceptions(ios::iostate state)</code>
        <blockquote ><a name="an1002"></a>this member causes the stream to throw an exception
            when state <code >state</code> is observed.</blockquote>
    </ul>
    In the I/O library, exceptions are objects of the class
 <a name="an1003"></a> <code >ios::failure</code>, derived from <a name="an1004"></a>
<code >ios::exception</code>. A <code >std::string const &amp;message</code> may be specified when
defining a <code >failure</code> object. Its message may then be  retrieved using its
 <a name="an1005"></a> <code >virtual char const *what() const</code> member.
<p>
Exceptions should be used in exceptional circumstances. Therefore, we
think it is questionable to have stream objects throw exceptions for fairly
normal situations like <code >EOF</code>. Using exceptions to handle input errors
might be defensible (e.g., in situations where input errors should not occur
and imply a corrupted file) but often aborting the program with an appropriate
error message would probably be the more appropriate action. As an example
consider the following interactive program using exceptions to catch incorrect
input:
        <pre>
    #include &lt;iostream&gt;
    #include &lt;climits&gt;
    using namespace::std;

    int main()
    {
        cin.exceptions(ios::failbit);   // throw exception on fail
        while (true)
        {
            try
            {
                cout &lt;&lt; "enter a number: ";
                int value;
                cin &gt;&gt; value;
                cout &lt;&lt; "you entered " &lt;&lt; value &lt;&lt; '\n';
            }
            catch (ios::failure const &amp;problem)
            {
                cout &lt;&lt; problem.what() &lt;&lt; '\n';
                cin.clear();
                cin.ignore(INT_MAX, '\n');  // ignore the faulty line
            }
        }
    }
</pre>
<p>
By default, exceptions raised from within <code >ostream</code> objects are caught by
these objects, which set their <code >ios::badbit</code> as a result. See also the
<a href="cplusplus14.html#STRBUFLABEL">paragraph on this issue</a> in section <a href="cplusplus14.html#STREAMBUF">14.8</a>.
<p>
<a name="STDEXC"></a><a name="l193"></a>
<h2 >10.8: Standard exceptions</h2>
All data types may be thrown as exceptions. Several additional exception
classes are now defined by the <strong >C++</strong> standard. Before using those additional
exception classes the <a name="an1006"></a><code >&lt;stdexcept&gt;</code> header file must be included.
<p>
All of these <a name="an1007"></a><em >standard exceptions</em>
  <a name="an1008"></a> are class types by themselves, but also offer
all facilities of the <a name="an1009"></a> <code >std::exception</code> class and objects
of the standard exception classes may also be considered objects of the
<code >std::exception</code> class.
<p>
The <code >std::exception</code> class offers the member
        <pre>
    char const *what() const;
</pre>
    <a name="an1010"></a> describing in a short textual message the nature of the
exception.
<p>
<strong >C++</strong> defines the following standard exception classes:
    <ul>
    <li><a name="an1011"></a><code >std::bad_alloc</code> (this requires the <a name="an1012"></a><code >&lt;new&gt;</code> header file):
        thrown when <a name="an1013"></a><code >operator new</code> fails;
    <li><a name="an1014"></a><code >std::bad_exception</code> (this requires the 
        <a name="an1015"></a><code >&lt;exception&gt;</code> header file): thrown when a function tries to
        generate another type of exception than declared in its
        <a name="an1016"></a><a name="an1017"></a>function throw list;
    <li><a name="an1018"></a><code >std::bad_cast</code> (this requires the <a name="an1019"></a><code >&lt;typeinfo&gt;</code> header
        file): thrown in the context of <em >polymorphism</em>
        (see section <a href="cplusplus14.html#DYNAMICCAST">14.6.1</a>);
    <li><a name="an1020"></a><code >std::bad_typeid</code> (this requires the <a name="an1021"></a><code >&lt;typeinfo&gt;</code> header
        file): also thrown in the context of
        <em >polymorphism</em> (see section <a href="cplusplus14.html#TYPEID">14.6.2</a>);
    </ul>
<p>
All additional exception classes were derived from <code >std::exception</code>. The
constructors of all these additional classes accept <code >std::string const &amp;</code>
arguments summarizing the reason for the exception (retrieved by the
<code >exception::what</code> member).  The additionally defined exception classes are:
    <ul>
    <li><a name="an1022"></a><code >std::domain_error</code>: a (mathematical) domain error is
detected;
    <li><a name="an1023"></a><code >std::invalid_argument</code>: the argument of a function
has an invalid value;
    <li><a name="an1024"></a><code >std::length_error</code>: thrown when an object would have
exceeded its maximum permitted length;
    <li><a name="an1025"></a><code >std::logic_error</code>: a logic error should be thrown when a
problem is detected in the internal logic of the program. Example: a function
like <strong >C</strong>'s <code >printf</code> is called with more arguments than there are format
specifiers in its format string;
    <li><a name="an1026"></a><code >std::out_of_range</code>: thrown when an argument exceeds its
permitted range. Example: thrown by <code >at</code> members when their arguments exceed
the range of admissible index values;
    <li><a name="an1027"></a><code >std::overflow_error</code>: an overflow error should be
thrown when an arithmetic overflow is detected. Example: dividing a
value by a very small value;
    <li><a name="an1028"></a><code >std::range_error</code>: a range error should be thrown when
an internal computation results in a value exceeding a permissible range;
    <li><a name="an1029"></a><code >std::runtime_error</code>: a runtime error should be thrown
when a problem is encountered that can only be detected while the program is
being executed.  Example: a non-integral is entered when the program's input
expects an integral value.
    <li><a name="an1030"></a><code >std::underflow_error</code>: an underflow error should be
thrown when an arithmetic underflow is detected. Example: dividing a very
small value by a very large value.
    </ul>
<p>
<a name="l194"></a>
<h3 >10.8.1: Standard exceptions: to use or not to use?</h3>
    Since values of any type may be thrown as exceptions, you may wonder when to
throw values of standard exception types and (if ever) when to throw values of
other types.
<p>
Current practice in the C++ community is to throw exceptions only in
exceptional situations. In that respect C++'s philosophy about using
exceptions differs markedly from the way exceptions are used in, e.g., Java,
where exceptions are often encountered in situations C++ doesn't consider
exceptional. Another common practice is to follow a `conceptual' style when
designing software. A nice characteristic of exceptions is that exceptions can
be thrown at a point where your source shows what's happening: throwing an
<code >std::out_of_range</code> exception is nice for the software maintainer, because
he/she will immediately recognize the reason for the exception.
<p>
At the catch-clause the semantical context usually isn't very relevant anymore
and by catching a std:;exception and showing its what() contents the program's
<em >user</em> is informed about what happened.
<p>
But throwing values of other types can also be useful. What about a situation
where you want to throw an exception and catch it at some shallow level?  In
between there may be various levels of software provided by external software
libraries over which the software engineer has no control.  At those levels
exceptions (std::exceptions) could be generated too, and those exceptions
might also be caught by the library's code. When throwing a standard exception
type it may be hard to convince yourself that that exception isn't caught by
the externally provided software. Assuming that no catch-alls are used (i.e.,
<code >catch (...)</code>)  then throwing an exception from the <code >std::exception</code>
family might not be a very good idea. In such cases throwing a value from a
simple, maybe empty, <code >enum</code> works fine:
        <pre>
    enum HorribleEvent 
    {};      

    ... at some deep level:
        throw HorribleEvent{};

    ... at some shallow level:
    catch (HorribleEvent hs)
    {
        ...
    }
</pre>
    Other examples can easily be found: design a class holding a message and
an error (exit) code: where necessary throw an object of that class, catch it
in the catch clause of main's try block and you can be sure that all objects
defined at intermediate levels are neatly destroyed, and at the end you show
the error message and return the exit code embedded in your non-exception
object.
<p>
So, the advice is to use <code >std::exception</code> types when available, and
clearly do the required job. But if an exception is used to simply bail out
of an unpleasant situation, or if there's a chance that externally provided
code might catch <code >std:exceptions</code> then consider throwing objects or values
of other types.
<p>
<a name="SYSTEMERROR"></a><a name="l195"></a>
<h2 >10.9: System error, error code and error category</h2>
    A <a name="an1031"></a><code >std::system_error</code> can be thrown when an error occurs that has an
associated error code. Such errors are typically encountered when calling
low-level (like operating system) functions.
<p>
Before using <code >system_error</code> the <a name="an1032"></a><code >&lt;system_error&gt;</code> header file must be
included.
<p>
A <code >system_error</code> object can be constructed using the standard textual
description of the nature of the encountered error, but in addition it accepts
an <a name="an1033"></a><em >error_code</em> or <a name="an1034"></a><em >error_category</em> object (see the next two sections),
further clarifying the nature of the error. The <code >error_code</code> and
<code >error_category</code> classes are also declared in the <code >system_error</code> header
file.
<p>
The <code >system_error</code> header file also defines an <a name="an1035"></a><code >enum class errc</code><a name="an1036"></a>
whose values are equal to and describe in a less cryptic way the traditional
error code values as offered by <strong >C</strong> macros, e.g.,
        <pre>
    enum class errc 
    {
        address_family_not_supported, // EAFNOSUPPORT
        address_in_use,               // EADDRINUSE
        address_not_available,        // EADDRNOTAVAIL
        already_connected,            // EISCONN
        argument_list_too_long,       // E2BIG
        argument_out_of_domain,       // EDOM
        bad_address,                  // EFAULT
        ...
    };
</pre>
<p>
In addition to the standard <code >what</code> member, the <code >system_error</code> class also
offers a member <code >code</code> returning a const reference to the exception's error
code. Here is the class's public interface:
        <pre>
class system_error: public runtime_error 
{
    public:
        system_error(error_code ec, string const &amp;what_arg);
        system_error(error_code ec, char const *what_arg);
        system_error(error_code ec);
        system_error(int ev, error_category const &amp;ecat,
                     string const &amp;what_arg);
        system_error(int ev, error_category const &amp;ecat,
                     char const *what_arg);
        system_error(int ev, error_category const &amp;ecat);
        error_code const &amp;code() const noexcept;
        char const *what() const noexcept;
}
</pre>
<p>
The NTBS returned by its <code >what</code> member may be formatted by a
<code >system_error</code> object like this:
        <pre>
    what_arg + ": " + code().message()
</pre>
<p>
Note that, although <code >system_error</code> was derived from <code >runtime_error</code>,
you'll lose the <code >code</code> member when catching a <code >std::exception</code> object. Of
course, downcasting is always possible, but that's a stopgap. Therefore, if a
<code >system_error</code> is thrown, a matching <code >catch(system_error const &amp;)</code> clause
should be provided (for a flexible alternative, see the class 
    <a name="an1037"></a> <code >FBB::Exception</code> in the author's 
        <a href="http://fbb-git.github.io/bobcat/">Bobcat library</a>.<a name="an1038"></a><a name="an1039"></a>)
<p>
<a name="l196"></a>
<h3 >10.9.1: The class `std::error_code'</h3>
    
<p>
Objects of the class <a name="an1040"></a> <code >std:error_code</code> hold <em >error code
values</em>, which may be defined by the operating system or comparable low-level
functions. 
<p>
Before using <code >error_code</code> the <a name="an1041"></a><code >&lt;system_error&gt;</code> header file must be
included.
<p>
The class offers the following constructors, members, and free functions:
<p>
<strong >Constructors</strong>:
    <ul>
    <li><code >error_code() noexcept</code>:<blockquote >the default construction initializes the error code with an error
        <em >value</em> 0 and an error <em >category</em> set to <code >&amp;system_category()</code>;</blockquote>
    <li><code >error_code(ErrorCodeEnum e) noexcept</code>:<blockquote >this is a member template (cf. section <a href="cplusplus22.html#MEMTEMP">22.1.3</a>), defining
        <code >template &lt;class ErrorCodeEnum&gt;</code>. It initializes the object with the
        return value of <code >make_error_code(e)</code>.</blockquote>
    </ul>
    The copy constructor is also available.
<p>
<strong >Members</strong>:
    <ul>
    <li><code >void assign(int val, const error_category&amp; cat)</code>:<blockquote >assigns new values to the current object's <em >value</em> and
        <em >category</em> data members;</blockquote>
<p>
<li><code >error_category const &amp;category() const noexcept</code>:<blockquote >returns a reference to the object's error category;</blockquote>
    <li><code >void clear() noexcept</code>:<blockquote >after calling this member <em >value</em> is set to 0 and the object's error
        <em >category</em> set to <code >&amp;system_category()</code>;</blockquote>
    <li><code >error_condition default_error_condition() const noexcept</code>:<blockquote >returns <code >category().default_error_condition(value())</code>;</blockquote>
    <li><code >string message() const</code>:<blockquote >returns <code >category().message(value())</code>;</blockquote>
    <li><code >errorcode&amp; operator=(ErrorCodeEnum e) noexcept</code>:<blockquote >a member template defining
        <code >template &lt;class ErrorCodeEnum&gt;</code>. It assigns the return value of 
        <code >make_error_code(e)</code> to the current object;</blockquote>
    <li><code >explicit operator bool() const noexcept</code>:<blockquote >returns <code >value() != 0</code>;</blockquote>
    <li><code >int value() const noexcept</code>:<blockquote >returns the object's error value.</blockquote>
    </ul>
<p>
<strong >Free functions</strong>:
    <ul>
    <li><code >error_code make_error_code(errc e) noexcept</code>:<blockquote >returns <code >error_code(static_cast&lt;int&gt;(e), generic_category())</code>;</blockquote>
    <li><code >bool operator&lt;(error_code const &amp;lhs, error_code const &amp;rhs)
        noexcept</code>:<blockquote >returns 
    <pre>
lhs.category() &lt; rhs.category() 
|| 
lhs.category() == rhs.category() &amp;&amp; lhs.value() &lt; rhs.value();
</pre>
</blockquote>
    <li><code >std::ostream &amp;operator&lt;&lt;(std::ostream &amp; os, error_code const &amp;ec)</code>:<blockquote >inserts the following text into <code >os</code>:
    <pre>
os &lt;&lt; ec.category().name() &lt;&lt; ':' &lt;&lt; ec.value().
</pre>
</blockquote>
    </ul>
<p>
<a name="l197"></a>
<h3 >10.9.2: The class `std::error_category'</h3>
    The class <code >std::</code><a name="an1042"></a><code >error_category</code> serves as a base class for types that
identify the source and encoding of a particular categories of error codes.
<p>
Before using <code >error_category</code> the <a name="an1043"></a><code >&lt;system_error&gt;</code> header file must be
included.
<p>
Classes that are derived from <code >error_category</code> should merely support
categories of errors in addition to those that are already available in
<strong >C++</strong>, and the behavior of such derived classes should not differ from the
be behavior of the <code >error_category</code> class itself. Moreover, such derived
classes should not alter <a name="an1044"></a><code >errno</code>'s value, or error states provided by other
libraries.
<p>
The equality of <code >error_category</code> objects is deducted from the equality of
their addresses. As <code >error_category</code> objects are passed by reference,
programs using objects of classes derived from <code >error_category</code> should
ensure that only a single object of each such type is actually used: the class
is designed as a <a name="an1045"></a><em >Singleton</em> (cf. <em >Singleton Design Pattern</em>
    <a name="an1046"></a> (cf. <em >Gamma et al.</em> (1995)
    <a name="an1047"></a> <a name="an1048"></a>Design Patterns, Addison-Wesley)):
    looking at the class's public interface it becomes clear that no
<code >error_category</code> object can immediately be constructed. There is no public
constructor. Nor is it possible to copy an existing <code >error_category</code> object,
as the copy constructor and overloaded assignment operators have been
deleted. Derived classes should enforce these singleton characteristics as
well. Here is the <code >error_category</code>'s non-private class interface:
        <pre>
    class error_category 
    {
        public:
            error_category(error_category const &amp;) = delete;
            virtual ~error_category() noexcept;

            error_category &amp;operator=(error_category const &amp;) = delete;

            virtual char const *name() const noexcept = 0;
            virtual string message(int ev) const = 0;

            virtual error_condition 
                    default_error_condition(int ev) const noexcept;
            virtual bool equivalent(int code, 
                                    error_condition const &amp;condition
                         ) const noexcept;
            virtual bool equivalent(error_code const &amp;code, 
                                    int condition
                         ) const noexcept;

            bool operator==(error_category const &amp;rhs) const noexcept;
            bool operator!=(error_category const &amp;rhs) const noexcept;
            bool operator&lt;(error_category const &amp;rhs) const noexcept;

        protected:
            error_category() noexcept;

    };
    error_category const &amp;generic_category() noexcept;
    error_category const &amp;system_category() noexcept;
</pre>
<p>
Members:
    <ul>
    <li><a name="an1049"></a><code >char const *name() const noexcept</code>:<blockquote >must be overridden, and should return a textual name of the error
        category;</blockquote>
    <li><a name="an1050"></a><code >string message(int ev) const</code>:<blockquote >must be overridden, and should return a string describing the error
        condition denoted by <code >ev</code>;</blockquote>
    <li><a name="an1051"></a><code >error_condition default_error_condition(int ev) const noexcept</code>:<blockquote >returns <code >error_condition(ev, *this)</code> (An object of type
        <code >error_condition</code> that corresponds to <code >ev</code>);</blockquote>
    <li><a name="an1052"></a><code >bool equivalent(int code, error_condition const &amp;condition) const
        noexcept</code>:<blockquote >returns <code >default_error_condition(code) == condition</code> (<code >true</code> if,
        for the category of error represented by <code >*this</code>, <code >code</code> is
        considered equivalent to <code >condition</code>; otherwise <code >false</code>);</blockquote>
    <li><code >bool equivalent(error_code const &amp;code, int condition) const noexcept</code>:<blockquote >returns <code >*this == code.category() &amp;&amp; code.value() == condition</code>
        (<code >true</code> if, for the category of error represented by <code >*this</code>,
        <code >code</code> is considered equivalent to <code >condition</code>; otherwise
        <code >false</code>);</blockquote>
    <li><code >bool operator&lt;(error_category const &amp;rhs) const noexcept</code>:<blockquote >returns <code >less&lt;const error_category*&gt;()(this, &amp;rhs)</code>.</blockquote>
    </ul>
<p>
Free functions:
    <ul>
    <li><a name="an1053"></a><code >error_category const &amp;generic_category() noexcept</code>:<blockquote >returns a reference to an object of a type derived from the class
        <code >error_category</code>. Since <code >error_category</code> and its derived classes
        should be singleton classes, calls to this function must return
        references to the same object.  The returned object's <code >name</code> member
        shall return a pointer to the string <code >"generic"</code>;</blockquote>
    <li><a name="an1054"></a><code >error_category const &amp;system_category() noexcept</code>:<blockquote >returns a reference to an object of a type derived from the class
        <code >error_category</code>. Since <code >error_category</code> and its derived classes
        should be singleton classes, calls to this function must return
        references to the same object.  The object's <code >name</code> member shall
        return a pointer to the string <code >"system"</code>. If the argument <code >ev</code>
        corresponds to a POSIX <code >errno</code> value `<code >posv</code>', then the object's
        <code >default_error_condition</code> member should return
        <code >error-condition(posv, generic_category())</code>. Otherwise,
        <code >error_condition(ev, system_category())</code> shall be returned.</blockquote>
    </ul>
<p>
<a name="l198"></a>
<h2 >10.10: Exception guarantees</h2>
Software should be <a name="an1055"></a><em >exception safe</em>: the program should continue to work
according to its specifications in the face of exceptions. It is not always
easy to realize exception safety. In this section some guidelines and
terminology is introduced when discussing exception safety.
<p>
Since exceptions may be generated from within all <strong >C++</strong> functions,
exceptions may be generated in many situations. Not all of these situations
are immediately and intuitively recognized as situations where exceptions can
be thrown. Consider the following function and ask yourself at which points
exceptions may be thrown:
        <pre>
    void fun()
    {
        X x;
        cout &lt;&lt; x;
        X *xp = new X{ x };
        cout &lt;&lt; (x + *xp);
        delete xp;
    }
</pre>
    If it can be assumed that <code >cout</code> as used above does not throw an
exception there are at least 13 opportunities for exceptions to be thrown:
    <ul>
    <li> <code >X x</code>: the default constructor could throw an exception (#1)
    <li> <code >cout &lt;&lt; x</code>: the overloaded insertion operator could throw an
exception (#2), but its rhs argument might not be an <code >X</code> but, e.g., an
<code >int</code>, and so <code >X::operator int() const</code> could be called which offers yet
another opportunity for an exception (#3).
    <li> <code >*xp = new X{ x }</code>: the copy constructor may throw an exception
(#4) and operator new (#5a) too. But did you realize that this latter
exception might not be thrown from <code >::new</code>, but from, e.g., <code >X</code>'s own
overload of <code >operator new</code>? (#5b)
    <li> <code >cout &lt;&lt; (x + *xp)</code>: we might be seduced into thinking that two
<code >X</code> objects are added. But it doesn't have to be that way. A separate class
Y might exist and <code >X</code> may have a conversion operator <code >operator Y() const</code>,
and <code >operator+(Y const &amp;lhs, X const &amp;rhs), operator+(X const &amp;lhs, Y const
&amp;rhs)</code>, and <code >operator+(X const &amp;lhs, X const &amp;rhs)</code> might all exist. So, if
the conversion operator exists, then depending on the kind of overload of
<code >operator+</code> that is defined either the addition's left-hand side operand
(#6), right-hand side operand (#7), or <code >operator+</code> itself (#8) may throw an
exception. The resulting value may again be of any type and so the overloaded
<code >cout &lt;&lt; return-type-of-operator+</code> operator may throw an exception
(#9). Since <code >operator+</code> returns a temporary object it is destroyed shortly
after its use. <code >X</code>'s destructor <em >could</em> throw an exception (#10).
    <li> <code >delete xp</code>: whenever <code >operator new</code> is overloaded <code >operator
delete</code> should be overloaded as well and may throw an exception (#11). And of
course, <code >X</code>'s destructor might again throw an exception (#12).
    <li> <code >}</code>: when the function terminates the local <code >x</code> object is
destroyed: again an exception could be thrown (#13).
        </ul>
 It is stressed here (and further discussed in section <a href="cplusplus10.html#CONSEXCEPTIONS">10.12</a>)
that although it is possible for exceptions to leave
destructors this would violate the <strong >C++</strong> standard and so it must be
prevented in well-behaving <strong >C++</strong> programs.
<p>
How can we expect to create working programs when exceptions might be thrown
in so many situations?
<p>
Exceptions may be generated in a great many situations, but serious
problems are prevented when we're able to provide at least one of the
following <a name="an1056"></a>exception guarantees:
    <ul>
    <li> The <em >basic guarantee</em>: no resources are leaked. In practice this
means: all allocated memory is properly returned when exceptions are thrown.
    <li> The <em >strong guarantee</em>: the program's state remains unaltered when
an exception is thrown (as an example: the canonical form of the overloaded
assignment operator provides this guarantee)
    <li> The <em >nothrow</em> guarantee: this applies to code for which it can be
proven that no exception can be thrown from it.
    </ul>
<p>
<a name="l199"></a>
<h3 >10.10.1: The basic guarantee</h3>
    The <a name="an1057"></a><em >basic guarantee</em> dictates that functions that fail to complete their
assigned tasks must return all allocated resources, usually memory, before
terminating. Since practically all functions and operators may throw
exceptions and since a function may repeatedly allocate resources the
blueprint of a function allocating resources shown below defines a try block
to catch all exceptions that might be thrown. The catch handler's task is to
return all allocated resources and then rethrow the exception.
        <pre>
    void allocator(X **xDest, Y **yDest)
    {
        X *xp = 0;              // non-throwing preamble
        Y *yp = 0;

        try                     // this part might throw
        {
            xp = new X[nX];     // alternatively: allocate one object
            yp = new Y[nY];
        }
        catch(...)
        {
            delete xp;
            throw;
        }

        delete[] *xDest;        // non-throwing postamble
        *xDest = xp;
        delete[] *yDest;
        *yDest = yp;
    }
</pre>
    In the pre-try code the pointers to receive the addresses returned by the
operator <code >new</code> calls are initialized to 0. Since the catch handler must be
able to return allocated memory they must be available outside of the <code >try</code>
block. If the allocation succeeds the memory pointed to by the destination
pointers is returned and then the pointers are given new values.
<p>
Allocation and or initialization might fail. If allocation fails <code >new</code>
throws a <a name="an1058"></a><code >std::bad_alloc</code> exception and the catch handler
simply deletes 0-pointers which is OK.
<p>
If allocation succeeds but the construction of (some) of the objects fails
by throwing an exception then the following is
    <a name="an1059"></a><a name="an1060"></a> <em >guaranteed</em> to happen:
    <ul>
    <li> The destructors of all successfully allocated objects are called;
    <li> The dynamically allocated memory to contain the objects is returned
    </ul>
<p>
Consequently, there is no memory leak when <code >new</code> fails. Inside the above
<code >try</code> block <code >new X</code> may fail: this does not affect the 0-pointers
and so the catch handler merely deletes 0 pointers. When <code >new Y</code> fails
<code >xp</code> points to allocated memory and so it must be returned. This happens
inside the catch handler. The final pointer (here: <code >yp</code>) will only be
unequal zero when <code >new Y</code> properly completes, so there's no need for the
catch handler to return the memory pointed at by <code >yp</code>.
<p>
<a name="l200"></a>
<h3 >10.10.2: The strong guarantee</h3>
    The <a name="an1061"></a><em >strong guarantee</em> dictates that an object's state should not change in
the face of exceptions. This is realized by performing all operations that
might throw on a separate copy of the data. If all this succeeds then the
current object and its (now successfully modified) copy are swapped. An
example of this approach can be observed in the canonical overloaded
assignment operator:
        <pre>
    Class &amp;operator=(Class const &amp;other)
    {
        Class tmp(other);
        swap(tmp);
        return *this;
    }
</pre>
    The copy construction might throw an exception, but this keeps the current
object's state intact. If the copy construction succeeds <code >swap</code> swaps the
current object's contents with <code >tmp</code>'s contents and returns a reference to
the current object. For this to succeed it must be guaranteed that <code >swap</code>
won't throw an exception. Returning a reference (or a value of a primitive
data type) is also guaranteed not to throw exceptions. The canonical form of
the overloaded assignment operator therefore meets the requirements of the
strong guarantee.
<p>
Some <a name="an1062"></a> rules of thumb were formulated that relate to the
strong guarantee
 (cf. <a name="an1063"></a>Sutter, H., <a name="an1064"></a><em >Exceptional C++</em>, Addison-Wesley, 2000). E.g.,
    <ul>
    <li> All the code that might throw an exception affecting the current
state of an object should perform its tasks separately from the data
controlled by the object. Once this code has performed its tasks without
throwing an exception replace the object's data by the new data.
    <li> Member functions modifying their object's data should not return
original (contained) objects by value.
    </ul>
<p>
The canonical assignment operator is a good example of the first rule of
thumb. Another example is found in classes storing objects. Consider a class
<code >PersonDb</code> storing multiple <code >Person</code> objects. Such a class might offer a
member <code >void add(Person const &amp;next)</code>. A plain implementation of this
function (merely intended to show the application of the first rule of thumb,
but otherwise completely disregarding efficiency considerations) might be:
        <pre>
    void PersonDb::newAppend(Person const &amp;next)
    {
        Person *tmp = 0;
        try
        {
            tmp = new Person[d_size + 1];
            for (size_t idx = 0; idx &lt; d_size; ++idx)
                tmp[idx] = d_data[idx];
            tmp[d_size] = next;
        }
        catch (...)
        {
            delete[] tmp;
            throw;
        }
    }

    void PersonDb::add(Person const &amp;next)
    {
        Person *tmp = newAppend(next);
        delete[] d_data;
        d_data = tmp;
        ++d_size;
    }
</pre>
    The (private) <code >newAppend</code> member's task is to create a copy of the
currently allocated <code >Person</code> objects, including the data of the next
<code >Person</code> object. Its <code >catch</code> handler catches any exception that might be
thrown during the allocation or copy process and  returns all memory
allocated so far, rethrowing the exception at the end. The function is
 <a name="an1065"></a><em >exception neutral</em> as it propagates all its exceptions to its caller. The
function also doesn't modify the <code >PersonDb</code> object's data, so it meets the
strong exception guarantee. Returning from <code >newAppend</code> the member <code >add</code>
may now modify its data. Its existing data are returned and its <code >d_data</code>
pointer is made to point to the newly created array of <code >Person</code>
objects. Finally its <code >d_size</code> is incremented. As these three steps don't
throw exceptions <code >add</code> too meets the strong guarantee.
<p>
The second rule of thumb (member functions modifying their object's data
should not return original (contained) objects by value) may be illustrated
using a member <code >PersonDb::erase(size_t idx)</code>. Here is an implementation
attempting to return the original <code >d_data[idx]</code> object:
        <pre>
    Person PersonData::erase(size_t idx)
    {
        if (idx &gt;= d_size)
            throw string("Array bounds exceeded");
        Person ret(d_data[idx]);
        Person *tmp = copyAllBut(idx);
        delete[] d_data;
        d_data = tmp;
        --d_size;
        return ret;
    }
</pre>
    Although copy elision usually prevents the use of the copy constructor
when returning <code >ret</code>, this is not guaranteed to happen. Furthermore, a copy
constructor <em >may</em> throw an exception. If that happens the function has
irrevocably mutated the <code >PersonDb</code>'s data, thus losing the strong guarantee.
<p>
Rather than returning <code >d_data[idx]</code> by value it might be assigned to an
external <code >Person</code> object before mutating <code >PersonDb</code>'s data:
        <pre>
    void PersonData::erase(Person *dest, size_t idx)
    {
        if (idx &gt;= d_size)
            throw string("Array bounds exceeded");
        *dest = d_data[idx];
        Person *tmp = copyAllBut(idx);
        delete[] d_data;
        d_data = tmp;
        --d_size;
    }
</pre>
    This modification works, but changes the original assignment of creating a
member returning the original object. However, both functions suffer from a
task overload as they modify <code >PersonDb</code>'s data and also return an original
object. In situations like these the <em >one-function-one-responsibility</em>
<a name="an1066"></a>rule of thumb should be kept in mind: a function should have a single, well
defined responsibility.
<p>
The preferred approach is to retrieve <code >PersonDb</code>'s objects using a member
like <code >Person const &amp;at(size_t idx) const</code> and to erase an object using a
member like <code >void PersonData::erase(size_t idx)</code>.
<p>
<a name="l201"></a>
<h3 >10.10.3: The nothrow guarantee</h3>
    Exception safety can only be realized if some functions and operations are
guaranteed <em >not</em> to throw exceptions. This is called the
 <a name="an1067"></a><em >nothrow guarantee</em>. An example of a function that must offer the nothrow
guarantee is the <code >swap</code> function. Consider once again the canonical
overloaded assignment operator:
        <pre>
    Class &amp;operator=(Class const &amp;other)
    {
        Class tmp(other);
        swap(tmp);
        return *this;
    }
</pre>
    If <code >swap</code> were allowed to throw exceptions then it would most likely
leave the current object in a partially swapped state. As a result the current
object's state would most likely have been changed. As <code >tmp</code> has been
destroyed by the time a catch handler receives the thrown exception it becomes
very difficult (as in: impossible) to retrieve the object's original
state. Losing the strong guarantee as a consequence.
<p>
The <a name="an1068"></a><code >swap</code> function must therefore offer the nothrow guarantee. It must
have been designed as if using the following prototype (see also section
<a href="cplusplus23.html#NOEXCEPT">23.7</a>): 
        <pre>
    void Class::swap(Class &amp;other) noexcept;
</pre>
<p>
Likewise, <code >operator delete</code> and <code >operator delete[]</code> offer the nothrow
guarantee, and according to the <strong >C++</strong> standard destructors may themselves
not throw exceptions (if they do their behavior is formally undefined, see
also section <a href="cplusplus10.html#CONSEXCEPTIONS">10.12</a> below).
<p>
Since the <strong >C</strong> programming language does not define the exception concept
functions from the standard <strong >C</strong> library offer the nothrow guarantee
by implication. This allowed us to define the generic <code >swap</code> function in
section <a href="cplusplus09.html#CopyDestroy">9.6</a> using <a name="an1069"></a><code >memcpy</code>.
<p>
Operations on primitive types offer the nothrow guarantee. Pointers may be
reassigned, references may be returned etc. etc. without having to worry about
exceptions that might be thrown.
<p>
<a name="FUNTRY"></a><a name="l202"></a>
<h2 >10.11: Function try blocks</h2>
    Exceptions may be generated from inside constructors. How can exceptions
generated in such situations be caught by the constructor itself, rather than
outside the constructor? The intuitive solution, nesting the object
construction in a <code >try</code> block does not solve the problem. The exception by
then has left the constructor and the object we intended to construct isn't
visible anymore.
<p>
Using a nested <code >try</code> block is illustrated in the next example, where
<code >main</code> defines an object of class <code >PersonDb</code>. Assuming that
<code >PersonDb</code>'s constructor throws an exception, there is no way we can access
the resources that might have been allocated by <code >PersonDb</code>'s constructor
from the catch handler as the <code >pdb</code> object is out of scope:
        <pre>
    int main(int argc, char **argv)
    {
        try
        {
            PersonDb pdb{ argc, argv }; // may throw exceptions
            ...                         // main()'s other code
        }
        catch(...)                      // and/or other handlers
        {
            ...                         // pdb is inaccessible from here
        }
    }
</pre>
<p>
Although all objects and variables defined inside a <code >try</code> block are
inaccessible from its associated catch handlers, object data members were
available before starting the <code >try</code> block and so they may be accessed from a
catch handler. In the following example the catch handler in
<code >PersonDb</code>'s constructor is able to access its <code >d_data</code> member:
        <pre>
    PersonDb::PersonDb(int argc, char **argv)
    :
        d_data(0),
        d_size(0)
    {
        try
        {
            initialize(argc, argv);
        }
        catch(...)
        {
            // d_data, d_size: accessible
        }
    }
</pre>
<p>
Unfortunately, this does not help us much. The <code >initialize</code> member is
unable to reassign <code >d_data</code> and <code >d_size</code> if <code >PersonDb const pdb</code>
was defined; the <code >initialize</code> member should at least offer the basic
exception guarantee and return any resources it has acquired before
terminating due to a thrown exception; and although <code >d_data</code> and <code >d_size</code>
offer the nothrow guarantee as they are of primitive data types a class type
data member might throw an exception, possibly resulting in violation of the
basic guarantee.
<p>
In the next implementation of <code >PersonDb</code> assume that constructor
receives a pointer to an already allocated block of <code >Person</code> objects. The
<code >PersonDb</code> object takes ownership of the allocated memory and it is
therefore responsible for the allocated memory's eventual destruction.
Moreover, <code >d_data</code> and <code >d_size</code> are also used by a composed object
<code >PersonDbSupport</code>, having a constructor expecting a <code >Person const *</code> and
<code >size_t</code> argument. Our next implementation may then look something like
this:
        <pre>
    PersonDb::PersonDb(Person *pData, size_t size)
    :
        d_data(pData),
        d_size(size),
        d_support(d_data, d_size)
    {
        // no further actions
    }
</pre>
    This setup allows us to define a <code >PersonDb const &amp;pdb</code>. Unfortunately,
<code >PersonDb</code> cannot offer the basic guarantee. If <code >PersonDbSupport</code>'s
constructor throws an exception it isn't caught although <code >d_data</code> already
points to allocated memory.
<p>
The <a name="an1070"></a><em >function try block</em> offers a solution for this problem. A function
try block consists of a <code >try</code> block and its associated handlers. The
function <code >try</code> block starts <em >immediately</em> after the function header, and
its block defines the function body. With constructors base class and data
member initializers may be placed between the <code >try</code> keyword and the opening
curly brace. Here is our final implementation of <code >PersonDb</code>, now offering
the basic guarantee:
        <pre>
    PersonDb::PersonDb(Person *pData, size_t size)
    try
    :
        d_data(pData),
        d_size(size),
        d_support(d_data, d_size)
    {}
    catch (...)
    {
        delete[] d_data;
    }
</pre>
<p>
Let's have a look at a stripped-down example. A constructor defines a
function try block. The exception thrown by the <code >Throw</code> object is initially
caught by the object itself. Then it is rethrown. The surrounding
<code >Composer</code>'s constructor also defines a function try block, <code >Throw</code>'s
rethrown exception is properly caught by <code >Composer</code>'s exception handler,
even though the exception was generated from within its member initializer
list:
        <pre>
    #include &lt;iostream&gt;

    class Throw
    {
        public:
            Throw(int value)
            try
            {
                throw value;
            }
            catch(...)
            {
                std::cout &lt;&lt; "Throw's exception handled locally by Throw()\n";
                throw;
            }
    };

    class Composer
    {
        Throw d_t;
        public:
            Composer()
            try             // NOTE: try precedes initializer list
            :
                d_t(5)
            {}
            catch(...)
            {
                std::cout &lt;&lt; "Composer() caught exception as well\n";
            }
    };

    int main()
    {
        Composer c;
    }
</pre>
<p>
When running this example, we're in for a nasty surprise: the program runs
and then breaks with an <a name="an1071"></a><em >abort exception</em>. Here is the output it produces,
the last two lines being added by the system's final catch-all handler,
catching all remaining uncaught exceptions:
        <pre>
    Throw's exception handled locally by Throw()
    Composer() caught exception as well
    terminate called after throwing an instance of 'int'
    Abort
</pre>
    The reason for this is documented in the <strong >C++</strong> standard: at the end of a
catch-handler belonging to a constructor or destructor function try block, the
original exception is automatically rethrown.
<p>
The exception is not rethrown if the handler itself throws another exception,
offering the constructor or destructor a way to
 <a name="an1072"></a> replace a thrown exception by another one. The
exception is only rethrown if it reaches the end of the catch handler of a
constructor or destructor function try block. Exceptions caught by nested
catch handlers are not automatically rethrown.
<p>
As only constructors and destructors rethrow exceptions caught by their
function try block catch handlers the run-time error encountered in the above
example may simply be repaired by providing <code >main</code> with its own function try
block:
        <pre>
    int main()
    try
    {
        Composer c;
    }
    catch (...)
    {}
</pre>
    Now the program runs as planned, producing the following output:
        <pre>
    Throw's exception handled locally by Throw()
    Composer() caught exception as well
</pre>
<p>
A final note: if a function defining a function try block also declares an
exception throw list then only the types of rethrown exceptions must match
the types mentioned in the throw list.
<p>
<a name="CONSEXCEPTIONS"></a><a name="l203"></a>
<h2 >10.12: Exceptions in constructors and destructors</h2>
    Object destructors are only activated for completely constructed objects.
Although this may
sound like a truism, there is a subtlety here. If the construction of an
object fails for some reason, the object's destructor is <em >not</em> called when
the object goes out of scope. This could happen if an exception that is
 <a name="an1073"></a><a name="an1074"></a>
    generated by the constructor is not caught by the constructor. If the
exception is thrown when the object has already allocated some memory, then
that memory is not returned: its destructor isn't called as the object's
construction wasn't successfully completed.
<p>
The following example illustrates this situation in its prototypical
form. The constructor of the class <code >Incomplete</code> first displays a message
and then throws an exception. Its destructor also displays a message:
        <pre>
    class Incomplete
    {
        public:
            Incomplete()
            {
                cerr &lt;&lt; "Allocated some memory\n";
                throw 0;
            }
            ~Incomplete()
            {
                cerr &lt;&lt; "Destroying the allocated memory\n";
            }
    };
</pre>
    Next, <code >main()</code> creates an <code >Incomplete</code> object inside a <code >try</code>
block. Any exception that may be generated is subsequently caught:
        <pre>
    int main()
    {
        try
        {
            cerr &lt;&lt; "Creating `Incomplete' object\n";
            Incomplete{};
            cerr &lt;&lt; "Object constructed\n";
        }
        catch(...)
        {
            cerr &lt;&lt; "Caught exception\n";
        }
    }
</pre>
    When this program is run, it produces the following output:
        <pre>
    Creating `Incomplete' object
    Allocated some memory
    Caught exception
</pre>
    Thus, if <code >Incomplete</code>'s constructor would actually have allocated some
memory, the program would suffer from a memory leak. To prevent this from
happening, the following counter measures are available:
    <ul>
    <li> Prevent the exceptions from leaving the constructor.<br/>
        If part of the constructor's body may generate exceptions, then this
part may be surrounded by a <code >try</code> block, allowing the exception to be caught
by the constructor itself. This approach is defensible when the constructor
is able to repair the cause of the exception and to complete its construction
as a valid object.
    <li> If an exception is generated by a base class constructor or by a
member initializing constructor then a <code >try</code> block within the constructor's
 body won't be able to catch the thrown exception. This <em >always</em> results in
the exception leaving the constructor and the object is not considered to have
been properly constructed. A <code >try</code> block may include the member
initializers, and the <code >try</code> block's compound statement becomes the
constructor's body as in the following example:
    <pre>
class Incomplete2
{
    Composed d_composed;
    public:
        Incomplete2()
        try
        :
            d_composed(/* arguments */)
        {
            // body
        }
        catch (...)
        {}
};
</pre>
    An exception thrown by either the member initializers or the body
results in the execution never reaching the body's closing curly brace. Instead
the catch clause is reached. Since the constructor's body isn't properly
completed the object is not considered properly constructed and eventually the
object's destructor won't be called.
    </ul>
    The catch clause of a constructor's function <code >try</code> block behaves
slightly different than a catch clause of an ordinary function <code >try</code>
block. An exception reaching a constructor's function <code >try</code> block may be
transformed into another exception (which is thrown from the catch clause) but
if no exception is explicitly thrown from the catch clause the exception
originally reaching the catch clause is always rethrown. Consequently, there's
no way to confine an exception thrown from a base class constructor or from a
member initializer to the constructor: such an exception <em >always</em> propagates
to a more shallow block and in that case the object's construction is always
considered incomplete.
<p>
Consequently, if incompletely constructed objects throw exceptions then
the constructor's catch clause is responsible for preventing memory
(generally: resource) leaks. There are several ways to realize this:
    <ul>
    <li> When multiple inheritance is used: if initial base classes have
properly been constructed and a later base class throws, then the initial base
class objects are automatically destroyed (as they are themselves fully
constructed objects)
    <li> When composition is used: already constructed composed objects are
automatically destroyed (as they are fully constructed objects)
    <li> Instead of using plain pointers <em >smart pointers</em> (cf. section
<a href="cplusplus18.html#SHAREDPTR">18.4</a>) should be used to manage dynamically allocated memory. In this
case, if the constructor throws either before or after the allocation of the
dynamic memory, then allocated memory is properly returned as <code >shared_ptr</code>
objects are, after all, objects.
    <li> If plain pointer data members <em >must</em> be used then the constructor's
body should first, in its member initialization section, initialize its plain
pointer data members. Then, in its body it can dynamically allocate memory,
reassigning the plain pointer data members. The constructor must be provided
with a function try block whose generic catch clause deletes the memory
pointed at by the class's plain pointer data members. Example:
    <pre>
class Incomplete2
{
    Composed d_composed;
    char *d_cp;         // plain pointers
    int *d_ip;

    public:
        Incomplete2(size_t nChars, size_t nInts)
        try
        :
            d_composed(/* arguments */),    // might throw
            d_cp(0),
            d_ip(0)
        {
            preamble();                     // might throw
            d_cp = new char[nChars];        // might throw
            d_ip = new int[nChars];         // might throw
            postamble();                    // might throw
        }
        catch (...)
        {
            delete[] d_cp;                  // clean up
            delete[] d_ip;
        }
};
</pre>
    </ul>
<p>
On the other hand, since <strong >C++</strong> supports constructor delegation an object
may have been completely constructed according to the <strong >C++</strong> run-time system,
but yet its constructor may have thrown an exception. This happens if a
delegated constructor successfully completes (after which the object is
considered `completely constructed'), but the constructor itself throws an
exception, as illustrated by the next example:
        <pre>
    class Delegate
    {
        public:
            Delegate()
            :
                Delegate(0)
            {
                throw 12;       // throws but completely constructed
            }
            Delegate(int x)         // completes OK
            {}
    };
    int main()
    try
    {
        Delegate del;           // throws

    } // del's destructor is called here
    catch (...)
    {}
</pre>
    In this example it is the responsibility of <code >Delegate</code>'s designer to
ensure that the throwing default constructor does not invalidate the actions
performed by <code >Delegate</code>'s destructor. E.g., if the delegated constructor
allocates memory to be deleted by the destructor, then the default constructor
should either leave the memory as-is, or it can delete the memory and set the
corresponding pointer to zero thereafter. In any case, it is <code >Delegate</code>'s
responsibility to ensure that the object remains in a valid state, even though
it throws an exception.
<p>
According to the <strong >C++</strong> standard exceptions thrown by destructors may not
leave their bodies. Providing a destructor with a function <code >try</code> block is
therefore a violation of the standard: exceptions caught by a function <code >try</code>
block's catch clause have already left the destructor's body.  If --in
violation of the standard-- the destructor <em >is</em> provided with a function
<code >try</code> block and an exception is caught by the <code >try</code> block then that
exception is rethrown, similar to what happens in catch clauses of
constructor functions' <code >try</code> blocks.
<p>
The consequences of  an exception leaving the destructor's body is not
defined, and may result in unexpected behavior. Consider the following example:
<p>
Assume a carpenter builds a cupboard having a single drawer. The cupboard
is finished, and a customer, buying the cupboard, finds that the cupboard can
be used as expected. Satisfied with the cupboard, the customer asks the
carpenter to build another cupboard, this time having <em >two</em>
drawers. When the second cupboard is finished, the customer takes it home and
is utterly amazed when the second cupboard completely collapses immediately
after it is used for the first time.
<p>
Weird story? Then consider the following program:
        <pre>
    int main()
    {
        try
        {
            cerr &lt;&lt; "Creating Cupboard1\n";
            Cupboard1{};
            cerr &lt;&lt; "Beyond Cupboard1 object\n";
        }
        catch (...)
        {
            cerr &lt;&lt; "Cupboard1 behaves as expected\n";
        }
        try
        {
            cerr &lt;&lt; "Creating Cupboard2\n";
            Cupboard2{};
            cerr &lt;&lt; "Beyond Cupboard2 object\n";
        }
        catch (...)
        {
            cerr &lt;&lt; "Cupboard2 behaves as expected\n";
        }
    }
</pre>
    When this program is run it produces the following output:
        <pre>
    Creating Cupboard1
    Drawer 1 used
    Cupboard1 behaves as expected
    Creating Cupboard2
    Drawer 2 used
    Drawer 1 used
    terminate called after throwing an instance of 'int'
    Abort
</pre>
    The final <code >Abort</code> indicates that the program has aborted instead of
displaying a message like <code >Cupboard2 behaves as expected</code>.
<p>
Let's have a look at the three classes involved. The class <code >Drawer</code> has no
particular characteristics, except that its destructor throws an exception:
        <pre>
    class Drawer
    {
        size_t d_nr;
        public:
            Drawer(size_t nr)
            :
                d_nr(nr)
            {}
            ~Drawer()
            {
                cerr &lt;&lt; "Drawer " &lt;&lt; d_nr &lt;&lt; " used\n";
                throw 0;
            }
    };
</pre>
    The class <code >Cupboard1</code> has no special characteristics at all. It merely
has a single composed <code >Drawer</code> object:
        <pre>
    class Cupboard1
    {
        Drawer left;
        public:
            Cupboard1()
            :
                left(1)
            {}
    };
</pre>
    The class <code >Cupboard2</code> is constructed comparably, but it has two
composed <code >Drawer</code> objects:
        <pre>
    class Cupboard2
    {
        Drawer left;
        Drawer right;
        public:
            Cupboard2()
            :
                left(1),
                right(2)
            {}
    };
</pre>
<p>
When <code >Cupboard1</code>'s destructor is called <code >Drawer</code>'s destructor is
eventually called to destroy its composed object. This destructor throws an
exception, which is caught beyond the program's first <code >try</code> block. This
behavior is completely as expected.
<p>
A subtlety here is that <code >Cupboard1</code>'s destructor (and hence <code >Drawer</code>'s
destructor) is activated <em >immediately</em> subsequent to its construction. Its
destructor is called immediately subsequent to its construction as
<code >Cupboard1()</code> defines an anonymous object. As a result the <code >Beyond
Cupboard1 object</code> text is never inserted into <code >std::cerr</code>.
<p>
Because of <code >Drawer</code>'s destructor throwing an exception a problem occurs
when <code >Cupboard2</code>'s destructor is called. Of its two composed objects, the
second <code >Drawer</code>'s destructor is called first.  This destructor throws an
exception, which ought to be caught beyond the program's second <code >try</code>
block. However, although the flow of control by then has left the context of
<code >Cupboard2</code>'s destructor, that object hasn't completely been destroyed yet
as the destructor of its other (left) <code >Drawer</code> still has to be called.
<p>
Normally that would not be a big problem: once an exception is thrown from
<code >Cupboard2</code>'s destructor any remaining actions would simply be ignored,
albeit that (as both drawers are properly constructed objects) <code >left</code>'s
destructor would still have to be called.
<p>
This happens here too and <code >left</code>'s destructor <em >also</em> needs to throw an
exception. But as we've already left the context of the second <code >try</code> block,
the current flow control is now thoroughly mixed up, and the program has no
other option but to abort. It does so by calling <code >terminate()</code>, which in
turn calls <code >abort()</code>. Here we have our collapsing cupboard having two
drawers, even though the cupboard having one drawer behaves perfectly.
<p>
The program aborts since there are multiple composed objects whose
destructors throw exceptions leaving the destructors. In this situation one of
the composed objects would throw an exception by the time the program's flow
control has already left its proper context causing the program to abort.
<p>
The <strong >C++</strong> standard therefore understandably stipulates that exceptions
may <em >never</em> leave destructors. Here is the skeleton of a destructor whose
 <a name="an1075"></a><a name="an1076"></a> code might throw
exceptions. No function <code >try</code> block but all the destructor's actions are
encapsulated in a <code >try</code> block nested under the destructor's body.
        <pre>
    Class::~Class()
    {
        try
        {
            maybe_throw_exceptions();
        }
        catch (...)
        {}
    }
</pre>
<p>

<hr>
<ul>
    <li> <a href="cplusplus.html">Table of Contents</a>
    <li> <a href="cplusplus09.html">Previous Chapter</a>
    <li> <a href="cplusplus11.html">Next Chapter</a>
</ul>
<hr>
</body>
</html>
