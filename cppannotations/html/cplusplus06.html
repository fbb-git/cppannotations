<!DOCTYPE html><html><head>
<meta charset="UTF-8">
<title> C++ Annotations Version 10.4.1-pre </title>
<link rel="stylesheet" type="text/css" href="cplusplus.css"><style type="text/css">
    figure {text-align: center;}
    img {vertical-align: center;}
</style>
<link rel="stylesheet" type="text/css" href="cplusplus.css"></head>
<body >
<hr>
<ul>
    <li> <a href="cplusplus.html">Table of Contents</a>
    <li> <a href="cplusplus05.html">Previous Chapter</a>
    <li> <a href="cplusplus07.html">Next Chapter</a>
</ul>
<hr>
<a name="IOStreams"></a><a name="l81"></a>
<h1>Chapter 6: The IO-stream Library</h1>
Extending the standard stream (<a name="an370"></a><code>FILE</code>) approach, well known from the
<strong>C</strong> programming language, <strong>C++</strong> offers an <em>input/output</em> (<a name="an371"></a>I/O)
library <a name="an372"></a> based on <code>class</code> concepts.
<p>
All <strong>C++</strong> I/O facilities are defined in the namespace <a name="an373"></a><code>std</code>. The <code>std::</code>
prefix is omitted below, except for situations where this would result in
ambiguities.
<p>
Earlier (in chapter <a href="cplusplus03.html#FirstImpression">3</a>) we've seen several examples of the
use of the <strong>C++</strong> I/O library, in particular showing  insertion
operator (&lt;&lt;) and the extraction operator (&gt;&gt;).
In this chapter we'll cover I/O in more detail.
<p>
The discussion of input and output facilities provided by the <strong>C++</strong>
programming language heavily uses the <code>class</code> concept and the notion of
member functions. Although class construction has not yet been covered (for
that see chapter <a href="cplusplus07.html#Classes">7</a>) and although <em>inheritance</em> is not covered
formally before chapter <a href="cplusplus13.html#INHERITANCE">13</a>, it is quite possible to discuss I/O
facilities long before the technical background of class construction has been
covered.
<p>
Most <strong>C++</strong> I/O classes have names starting with <a name="an374"></a><code>basic_</code> (like
<code>basic_ios</code>). However, these <a name="an375"></a><code>basic_</code> names are not regularly found in
<strong>C++</strong> programs, as most classes are also defined using <a name="an376"></a><code>typedef</code>
definitions like:
        <pre>
        typedef basic_ios&lt;char&gt;       ios;
</pre>
    Since <strong>C++</strong> supports various kinds of character types (e.g., <a name="an377"></a><code>char</code>,
<a name="an378"></a><code>wchar_t</code>), I/O facilities were developed using the <a name="an379"></a><em>template</em> mechanism
allowing for easy conversions to character types other than the traditional
<code>char</code> type. As elaborated in chapter <a href="cplusplus21.html#TEMPLATES">21</a>, this also allows the
construction of <a name="an380"></a>generic software, that could thereupon be used for any
particular type representing characters. So, analogously to the above
<code>typedef</code> there exists a
        <pre>
        typedef basic_ios&lt;wchar_t&gt;    wios;
</pre>
    This type definition can be used for the <code>wchar_t</code> type. Because of the
existence of these type definitions, the <code>basic_</code> prefix was omitted from
the <strong>C++</strong> Annotations without loss of continuity. The <strong>C++</strong> Annotations primarily
focus on the standard 8-bits <code>char</code> type.
<p>
Iostream objects can<em>not</em> be declared  using standard
    <a name="an381"></a>forward declarations, like:
        <pre>
    class std::ostream;     // now erroneous
</pre>
    Instead, to <a name="an382"></a>declare iostream classes the <a name="an383"></a><code>&lt;iosfwd&gt;</code> header file
should be included:
        <pre>
    #include &lt;iosfwd&gt;       // correct way to declare iostream classes
</pre>
<p>
Using <strong>C++</strong> I/O offers the additional advantage of
 <a name="an384"></a><em>type safety</em>. Objects (or plain values) are inserted into
streams. Compare this to the situation commonly encountered in <strong>C</strong> where the
<a name="an385"></a><code>fprintf</code> function is used to indicate by a format string what kind of
value to expect where. Compared to this latter situation <strong>C++</strong>'s
<em>iostream</em> approach immediately uses the objects where their values should
appear, as in
        <pre>
    cout &lt;&lt; "There were " &lt;&lt; nMaidens &lt;&lt; " virgins present\n";
</pre>
The compiler notices the type of the <code>nMaidens</code> variable, inserting
its proper value at the appropriate place in the sentence inserted into
the <code>cout</code> iostream.
<p>
Compare this to the situation encountered in <strong>C</strong>. Although <strong>C</strong> compilers
are getting smarter and smarter, and although a well-designed
<strong>C</strong> compiler may warn you for a mismatch between a format specifier and the
type of a variable encountered in the corresponding position of the argument
list of a <code>printf</code> statement, it can't do much more than <em>warn</em> you.
The <em>type safety</em> seen in <strong>C++</strong> <em>prevents</em> you from making type
mismatches, as there are no types to match.
<p>
Apart from this, <em>iostreams</em> offer more or less the same set of
possibilities as the standard <code>FILE</code>-based I/O used in <strong>C</strong>: files can be
opened, closed, positioned, read, written, etc.. In <strong>C++</strong> the basic <code>FILE</code>
structure, as used in <strong>C</strong>, is still available. But <strong>C++</strong> adds to this I/O
based on classes, resulting in type safety, extensibility, and a clean design.
<p>
In the <a name="an386"></a>ANSI/ISO standard the intent was to create architecture independent
I/O. Previous implementations of the iostreams library did not always comply
with the standard, resulting in many extensions to the standard. The I/O
sections of previously developed software may have to be partially
rewritten. This is tough for those who are now forced to modify old software,
but every feature and extension that was once available can be rebuilt easily
using ANSI/ISO standard conforming I/O. Not all of these reimplementations can
be covered in this chapter, as many reimplementations rely on inheritance and
polymorphism, which topics are formally covered by chapters <a href="cplusplus13.html#INHERITANCE">13</a>
and <a href="cplusplus14.html#POLYMORPHISM">14</a>. Selected reimplementations are provided in chapter
<a href="cplusplus24.html#CONCRETE">24</a>, and in this chapter references to particular sections in other
chapters are given where appropriate.
        <a name="IOCLASSESFIG"></a><p><figure><img src="iostreams/ioclasses.gif" alt="Figure 3 is shown here."/><br/>
<figcaption>Figure 3: Central I/O Classes</figcaption>
</figure></p>

This chapter is organized as follows (see also Figure <a href="cplusplus06.html#IOCLASSESFIG">3</a>):
    <ul>
        <li> The <code>class</code> <a name="an387"></a><code>ios_base</code> is the foundation upon which the
iostreams I/O library was built. It defines the core of all I/O operations and
offers, among other things, facilities for inspecting the
 <a name="an388"></a>state of I/O streams and for <a name="an389"></a>output formatting.
        <li> The class <a name="an390"></a><code>ios</code> was directly derived from <code>ios_base</code>. Every
class of the I/O library doing input or output is itself <em>derived</em> from this
<code>ios</code> class, and so <em>inherits</em> its (and, by implication, <code>ios_base</code>'s)
capabilities. The reader is urged to keep this in mind while reading this
chapter. The concept of inheritance is not discussed here, but rather
in chapter <a href="cplusplus13.html#INHERITANCE">13</a>.
<p>
The class <code>ios</code> is important in that it implements the communication with a
<em>buffer</em> that is used by streams. This buffer is a <a name="an391"></a><code>streambuf</code> object
which is responsible for the actual I/O to/from the underlying
<em>device</em>. Consequently <code>iostream</code> objects do not perform I/O
operations themselves, but leave these to the (stream)buffer objects with
which they are associated.
        <li> Next, basic <strong>C++</strong> output facilities are discussed. The basic
class used for output operations is <a name="an392"></a><code>ostream</code>, defining the
 <a name="an393"></a>insertion operator as well as other facilities writing information to
streams. Apart from inserting information into files it is possible to insert
information into <a name="an394"></a>memory buffers, for which the <a name="an395"></a><code>ostringstream</code> class is
available. Formatting output is to a great extent possible using the
facilities defined in the <code>ios</code> class, but it is also possible to
<em>insert</em> <a name="an396"></a><em>formatting commands</em> directly into streams using
    <a name="an397"></a><em>manipulators</em>. This aspect of <strong>C++</strong> output is
discussed as well.
        <li> Basic <strong>C++</strong> input facilities are implemented by the <a name="an398"></a><code>istream</code>
class. This class defines the <a name="an399"></a>extraction operator and related input
facilities. Comparably to inserting information into memory buffers (using
<code>ostringstream</code>) a class <a name="an400"></a><code>istringstream</code> is available to extract
information from memory buffers.
        <li> Finally, several advanced I/O-related topics are discussed. E.g.,
<a name="an401"></a>reading and writing from the same stream and
    <a name="an402"></a>mixing <strong>C</strong> and <strong>C++</strong> I/O using <a name="an403"></a><code>filebuf</code> objects. Other I/O
related topics are covered elsewhere in the <strong>C++</strong> Annotations, e.g., in chapter
<a href="cplusplus24.html#CONCRETE">24</a>.
    </ul>
    Stream objects have a limited but important role: they are the interface
between, on the one hand, the objects to be input or output and, on the other
hand, the <code>streambuf</code>, which is responsible for the actual input and output
to the <a name="an404"></a>device accessed by a <code>streambuf</code> object.
<p>
This approach allows us to construct a new kind of <code>streambuf</code> for a new
kind of device, and use that streambuf in combination with the `good old'
<code>istream</code>- and <code>ostream</code>-class facilities. It is important to understand
the distinction between the formatting roles of iostream objects and the
buffering interface to an external device as implemented in a <code>streambuf</code>
object. Interfacing to new devices (like <a name="an405"></a><em>sockets</em> or
 <a name="an406"></a><em>file descriptors</em>) requires the construction of a new kind of
<code>streambuf</code>, rather than a new kind of <code>istream</code> or <code>ostream</code> object. A
<a name="an407"></a><em>wrapper class</em> may be constructed around the <code>istream</code> or <code>ostream</code>
classes, though, to ease the access to a special device. This is how the
stringstream classes were constructed.
<p>
<a name="IOHDRS"></a><a name="l82"></a>
<h2>6.1: Special header files</h2>
    Several iostream related <a name="an408"></a>header files are available. Depending on
the situation at hand, the following header files should be used:
    <ul>
    <li><a name="an409"></a><code>iosfwd</code>: sources should include this header file if only a declaration
of the stream classes is required. For example, if a function defines a
reference parameter to an <code>ostream</code> then the compiler does not need to know
exactly what an <code>ostream</code> is. When declaring such a function
the <code>ostream</code> class merely needs to be be declared. One cannot use
        <pre>
class std::ostream; // erroneous declaration

void someFunction(std::ostream &amp;str);
</pre>
    but, instead, one should use:
        <pre>
#include &lt;iosfwd&gt;   // correctly declares class ostream

void someFunction(std::ostream &amp;str);
</pre>
    <li><a name="an410"></a><code>&lt;ios&gt;</code>: sources should include this header file when using
types and facilites (like <code>ios::off_type</code>, see below) defined in the
<code>ios</code> class.
    <li><a name="an411"></a><code>&lt;streambuf&gt;</code>: sources should include this header file when using
<code>streambuf</code> or <a name="an412"></a><code>filebuf</code> classes. See sections <a href="cplusplus14.html#STREAMBUF">14.8</a> and
<a href="cplusplus14.html#FILEBUF">14.8.2</a>.
    <li><a name="an413"></a><code>&lt;istream&gt;</code>: sources should include this preprocessor directive when
using the class <code>istream</code> or when using classes that do both input and
output.  See section <a href="cplusplus06.html#ISTREAM">6.5.1</a>.
    <li><a name="an414"></a><code>&lt;ostream&gt;</code>: sources should include this header file when using the class
<a name="an415"></a><code>ostream</code> class or when using classes that do both input and output.  See
section <a href="cplusplus06.html#OSTREAM">6.4.1</a>.
    <li><a name="an416"></a><code>&lt;iostream&gt;</code>: sources should include this header file when using the
global stream objects (like <a name="an417"></a><code>cin</code> and <a name="an418"></a><code>cout</code>).
    <li><a name="an419"></a><code>&lt;fstream&gt;</code>: sources should include this header file when using the file
stream classes.  See sections <a href="cplusplus06.html#OFSTREAM">6.4.2</a>, <a href="cplusplus06.html#IFSTREAM">6.5.2</a>, and <a href="cplusplus06.html#FSTREAM">6.6.3</a>.
    <li><a name="an420"></a><code>&lt;sstream&gt;</code>: sources should include this header file when using the
string stream classes. See sections <a href="cplusplus06.html#OSTRINGSTREAM">6.4.3</a> and <a href="cplusplus06.html#ISTRINGSTREAM">6.5.3</a>.
    <li><a name="an421"></a><code>&lt;iomanip&gt;</code>: sources should include this header file when using
parameterized manipulators. See section <a href="cplusplus06.html#IOFORMAT">6.3.2</a>.
    </ul>
<p>
<a name="l83"></a>
<h2>6.2: The foundation: the class `ios_base'</h2>
The class <a name="an422"></a><code>std::ios_base</code> forms the foundation of all I/O
operations, and defines, among other things, facilities for inspecting the
    <a name="an423"></a>state of I/O streams and most <a name="an424"></a>output formatting facilities. Every
stream class of the I/O library is, through the class <a name="an425"></a><code>ios</code>, <em>derived</em>
from this class, and <em>inherits</em> its capabilities.  As <code>ios_base</code> is the
foundation on which all <strong>C++</strong> I/O was built, we introduce it here as the
first class of the <strong>C++</strong> I/O library.
<p>
Note that, as in <strong>C</strong>, I/O in <strong>C++</strong> is <em>not</em> part of the language
(although it <em>is</em> part of the <a name="an426"></a>ANSI/ISO standard on <strong>C++</strong>).  Although it
is technically possible to ignore all predefined I/O facilities, nobody does
so, and the I/O library therefore represents a <em>de facto</em> I/O standard for
<strong>C++</strong>. Also note that, as mentioned before, the iostream classes themselves
are not responsible for the eventual I/O, but delegate this to an auxiliary
class: the class <a name="an427"></a><code>streambuf</code> or its derivatives.
<p>
It is neither possible nor required to construct an <code>ios_base</code> object
directly. Its construction is always a side-effect of constructing an object
further down the class hierarchy, like <code>std::ios</code>. <code>Ios</code> is the next
class down the iostream hierarchy (see figure <a href="cplusplus06.html#IOCLASSESFIG">3</a>). Since all
stream classes in turn inherit from <code>ios</code>, and thus also from <code>ios_base</code>,
the distinction between <code>ios_base</code> and <a name="an428"></a><code>ios</code> is in practice not
important. Therefore, facilities actually provided by <code>ios_base</code> will be
discussed as facilities provided by <code>ios</code>. The reader who is interested in
the true class in which a particular facility is defined should consult the
relevant header files (e.g., <a name="an429"></a><code>ios_base.h</code> and <a name="an430"></a><code>basic_ios.h</code>).
<p>
<a name="IOS"></a><a name="l84"></a>
<h2>6.3: Interfacing `streambuf' objects: the class `ios'</h2>
The <a name="an431"></a><code>std::ios</code> class is derived directly from <a name="an432"></a><code>ios_base</code>, and it
defines <em>de facto</em> the foundation for all stream classes of the <strong>C++</strong> I/O
library.
<p>
Although it <em>is</em> possible to construct an <code>ios</code> object
directly, this is seldom done. The purpose of the class <code>ios</code> is to
provide the facilities of the class <code>basic_ios</code>, and to add several new
facilites, all related to the <code>streambuf</code> object which is managed
by objects of the class <code>ios</code>.
<p>
All other stream classes are either directly or indirectly derived from
<code>ios</code>. This implies, as explained in chapter <a href="cplusplus13.html#INHERITANCE">13</a>, that all
facilities of the classes <code>ios</code> and <code>ios_base</code> are also available
to other stream classes. Before discussing these additional stream classes,
the features offered by the class <code>ios</code> (and by implication: by
<code>ios_base</code>) are now introduced.
<p>
In some cases it may be required to include <a name="an433"></a><code>ios</code> explicitly. An example
is the situations where the formatting flags themselves (cf. section
<a href="cplusplus06.html#FORMATFLAGS">6.3.2.2</a>) are referred to in source code.
<p>
The class <code>ios</code> offers several member functions, most of which are related
to <a name="an434"></a>formatting. Other frequently used member functions are:
    <ul>
    <li><a name="an435"></a><code>std::streambuf *ios::rdbuf()</code>:<blockquote>A pointer to the <code>streambuf</code> object forming the interface between
the <code>ios</code> object and the device with which the <code>ios</code> object communicates
is returned. See sections <a href="cplusplus14.html#STREAMBUF">14.8</a> and <a href="cplusplus24.html#STRBUF">24.1.2</a> for more information
about the <code>class streambuf</code>.</blockquote>
    <li><code>std::streambuf *ios::rdbuf(std::streambuf *new)</code>:
        <blockquote>The current <code>ios</code> object is associated with another
<code>streambuf</code> object. A pointer to the <code>ios</code> object's original <code>streambuf</code>
object is returned. The object to which this pointer points is not destroyed
when the <code>stream</code> object goes out of scope, but is owned by the caller of
<code>rdbuf</code>.</blockquote>
    <li><a name="an436"></a><code>std::ostream *ios::tie()</code>:<blockquote>A pointer to the <a name="an437"></a><code>ostream</code> object that is currently tied to the
<code>ios</code> object is returned (see the next member). The return value 0
indicates that currently no <code>ostream</code> object is tied to the <code>ios</code>
object. See section <a href="cplusplus06.html#COUPLING">6.5.5</a> for details.</blockquote>
    <li><code>std::ostream *ios::tie(std::ostream *outs)</code>:
        <blockquote>The ostream object is tied to current <code>ios</code> object. This means
that the <code>ostream</code> object is <em>flushed</em> every time before an input or
output action is performed by the current <code>ios</code> object. A pointer to the
<code>ios</code> object's original <code>ostream</code> object is returned. To break the tie,
pass the argument 0. See section <a href="cplusplus06.html#COUPLING">6.5.5</a> for an example.</blockquote>
    </ul>
<p>
<a name="IOSTATES"></a><a name="l85"></a>
<h3>6.3.1: Condition states</h3>
    Operations on streams may fail for various reasons.  Whenever an operation
fails, further operations on the stream are suspended. It is possible to
inspect, set and possibly clear the
 <a name="an438"></a>condition state of streams, allowing a program to repair the problem
rather than having to abort. The members that are available for interrogating
or manipulating the stream's state are described in the current section.
<p>
Conditions are represented by the following <a name="an439"></a><em>condition flags</em>:
    <ul>
        <li><a name="an440"></a><code>ios::badbit</code>:<blockquote>if this flag has been raised an illegal operation has been
requested at the level of the <code>streambuf</code> object to which the stream
interfaces. See the member functions below for some examples.</blockquote>
        <li><a name="an441"></a><code>ios::eofbit</code>:<blockquote>if this flag has been raised, the <code>ios</code> object has sensed
end of file.</blockquote>
        <li><a name="an442"></a><code>ios::failbit</code>:<blockquote>if this flag has been raised, an operation performed by the
stream object has failed (like an attempt to extract an <code>int</code> when no
numeric characters are available on input). In this case the stream itself
could not perform the operation that was requested of it.</blockquote>
        <li><a name="an443"></a><code>ios::goodbit</code>:<blockquote>this flag is raised when  none of the other three condition
flags were raised.</blockquote>
    </ul>
<p>
Several <a name="an444"></a>condition member functions are available to manipulate or
determine the states of <code>ios</code> objects. Originally they returned <code>int</code>
values, but their current return type is <code>bool</code>:
    <ul>
    <li><a name="an445"></a><code>bool ios::bad()</code>:
            <blockquote>the value <code>true</code> is returned when the stream's
<code>badbit</code> has been set and <code>false</code> otherwise.  If <code>true</code> is
returned it indicates that an illegal operation has been requested at the
level of the <code>streambuf</code> object to which the stream interfaces. What does
this mean? It indicates that the <code>streambuf</code> itself is behaving
unexpectedly. Consider the following example:
        <pre>
std::ostream error(0);
</pre>
    Here an <code>ostream</code> object is constructed <em>without</em> providing it with a
working <code>streambuf</code> object. Since this `<code>streambuf</code>' will never operate
properly, its <code>badbit</code> flag is raised from the very beginning:
<code>error.bad()</code> returns <code>true</code>.
            </blockquote>
    <li><a name="an446"></a><code>bool ios::eof()</code>:
            <blockquote>the value <code>true</code> is returned when end of file
(<code>EOF</code>) has been sensed (i.e., the <code>eofbit</code> flag has been set) and
<code>false</code> otherwise. Assume we're reading lines line-by-line from <code>cin</code>, but
the last line is not terminated by a final <code>\n</code> character. In that case
<a name="an447"></a><code>std::getline</code> attempting to read the <code>\n</code> delimiter hits
end-of-file first. This raises the <code>eofbit</code> flag and <code>cin.eof()</code> returns
<code>true</code>. For example, assume <code>std::string str</code> and <code>main</code> executing the
statements:
        <pre>
getline(cin, str);
cout &lt;&lt; cin.eof();
</pre>
    Then
        <pre>
echo "hello world" | program
</pre>
    prints the value 0 (no EOF sensed). But after
        <pre>
echo -n "hello world" | program
</pre>
    the value 1 (EOF sensed) is printed.</blockquote>
    <li><a name="an448"></a><code>bool ios::fail()</code>:
            <blockquote>the value <code>true</code> is returned when <code>bad</code> returns <code>true</code>
or when the <code>failbit</code> flag was set. The value <code>false</code> is returned
otherwise.  In the above example, <code>cin.fail()</code> returns <code>false</code>,
whether we terminate the final line with a delimiter or not (as we've read
a line). However, executing <em>another</em> <code>getline</code> results in
raising the <code>failbit</code> flag, causing <code>cin::fail()</code> to return
<code>true</code>. In general: <code>fail</code> returns <code>true</code> if the requested stream
operation failed. A simple example showing this consists of an attempt to
extract an <code>int</code> when the input stream contains the text <code>hello
world</code>. The value <code>not fail()</code> is returned by the <code>bool</code>
interpretation of a stream object (see below).</blockquote>
    <li><a name="an449"></a><code>ios::good()</code>:
            <blockquote>the value of the
<code>goodbit</code> flag is returned. It equals <code>true</code> when none of the other
condition flags (<code>badbit, eofbit, failbit</code>) was raised.
    Consider the following little program:
        <pre>
#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

void state()
{
    cout &lt;&lt; "\n"
            "Bad: " &lt;&lt; cin.bad() &lt;&lt; " "
            "Fail: " &lt;&lt; cin.fail() &lt;&lt; " "
            "Eof: " &lt;&lt; cin.eof() &lt;&lt; " "
            "Good: " &lt;&lt; cin.good() &lt;&lt; '\n';
}

int main()
{
    string line;
    int x;

    cin &gt;&gt; x;
    state();

    cin.clear();
    getline(cin, line);
    state();

    getline(cin, line);
    state();
}
</pre>
        When this program processes a file having two lines, containing,
respectively, <code>hello</code> and <code>world</code>, while the second
line is not terminated by a <code>\n</code> character the following is shown:
        <pre>
    Bad: 0 Fail: 1 Eof: 0 Good: 0

    Bad: 0 Fail: 0 Eof: 0 Good: 1

    Bad: 0 Fail: 0 Eof: 1 Good: 0
</pre>
        Thus, extracting <code>x</code> fails (<code>good</code> returning <code>false</code>). Then,
the error state is cleared, and the first line is successfully read
(<code>good</code> returning <code>true</code>). Finally the second line is read
(incompletely): <code>good</code> returning <code>false</code>, and <code>eof</code> returning <code>true</code>.
        </blockquote>
    <li> <a name="an450"></a>
         <a name="an451"></a>
        Interpreting streams as <code>bool</code> values:
            <blockquote>streams may be used in expressions expecting logical
values. Some examples are:
        <pre>
if (cin)                // cin itself interpreted as bool
if (cin &gt;&gt; x)           // cin interpreted as bool after an extraction
if (getline(cin, str))  // getline returning cin
</pre>
        When interpreting a stream as a logical value, it is actually `<code>not
fail()</code>' that is interpreted. The above examples may therefore be rewritten
as:
        <pre>
if (not cin.fail())
if (not (cin &gt;&gt; x).fail())
if (not getline(cin, str).fail())
</pre>
    The former incantation, however, is used almost exclusively.
            </blockquote>
    </ul>
<p>
The following members are available to manage error states:
    <ul>
        <li><a name="an452"></a><code>void ios::clear()</code>:
    <blockquote>When an error condition has occurred, and the condition can be
repaired, then <code>clear</code> can be used to clear the error state of the file. An
overloaded version exists accepting state flags, that are set after first
clearing the current set of flags: <code>clear(int state)</code>. Its return
type is <code>void</code></blockquote>
        <li><a name="an453"></a><code>ios::iostate ios::rdstate()</code>:
        <blockquote><a name="an454"></a><a name="an455"></a>
    The current set of flags that are set for an <code>ios</code> object are returned
(as an <code>int</code>). To test for a particular flag, use the <a name="an456"></a>bitwise and
operator:
        <pre>
if (!(iosObject.rdstate() &amp; ios::failbit))
{
    // last operation didn't fail
}
</pre>
    Note that this test cannot be performed for the <code>goodbit</code> flag as its
value equals zero. To test for `good' use a construction
like:
        <pre>
if (iosObject.rdstate() == ios::goodbit)
{
    // state is `good'
}
</pre>
     </blockquote>
        <li><a name="an457"></a><code>void ios::setstate(ios::iostate state)</code>:
        <blockquote>A stream may be assigned a certain set of states using
<code>setstate</code>. Its return type is <code>void</code>. E.g.,
        <pre>
cin.setstate(ios::failbit);     // set state to `fail'
</pre>
    To set multiple flags in one <code>setstate()</code> call use the <code>bitor</code>
operator:
        <pre>
cin.setstate(ios::failbit | ios::eofbit)
</pre>
        </blockquote>
    The member <code>clear</code> is a shortcut to clear all error
flags.  Of course, clearing the flags doesn't automatically mean the
error condition has been cleared too. The strategy should be:
        <ul>
            <li> An error condition is detected,
            <li> The error is repaired
            <li> The member <code>clear</code> is called.
        </ul>
        </ul>
    <strong>C++</strong> supports an <a name="an458"></a><em>exception</em> mechanism to handle exceptional
situations. According to the <a name="an459"></a>ANSI/ISO standard, exceptions can be used
with stream objects. Exceptions are covered in chapter <a href="cplusplus10.html#EXCEPTIONS">10</a>. Using
exceptions with stream objects is covered in section <a href="cplusplus10.html#IOEXCEPTIONS">10.7</a>.
<p>
<a name="IOFORMAT"></a><a name="l86"></a>
<h3>6.3.2: Formatting output and input</h3>
    The way information is written to streams (or, occasionally, read from
streams) is controlled by <a name="an460"></a><em>formatting flags</em>.
<p>
Formatting is used when it is necessary to, e.g., set the width of an output
field or input buffer and to determine the form (e.g., the <a name="an461"></a><em>radix</em>) in
which values are displayed. Most formatting features belong to the realm of
the <code>ios</code> class. Formatting is controlled by flags, defined by the <code>ios</code>
class.  These flags may be manipulated in two ways: using specialized
member functions or using <em>manipulators</em>, which are directly inserted into
or extracted from streams. There is no special reason for using either
method; usually both methods are possible. In the following overview
the various member functions are first introduced. Following this the flags
and manipulators themselves are covered. Examples are provided showing how
the flags can be manipulated and what their effects are.
<p>
Many manipulators are parameterless and are available once a stream header
file (e.g., <code>iostream</code>) has been included. Some manipulators require
arguments. To use the latter manipulators the header file <a name="an462"></a><code>iomanip</code> must be
included.
<p>
<a name="FORMATMEMBERS"></a><a name="l87"></a>
<h4>6.3.2.1: Format modifying member functions</h4>
        Several <em>member functions</em> are available manipulating the I/O <a name="an463"></a>formatting
flags. Instead of using the members listed below <em>manipulators</em> are often
available that may directly be inserted into or extracted from streams. The
available members are listed in alphabetical order, but the most important
ones in practice are <a href="cplusplus06.html#SETF">setf</a>, <a href="cplusplus06.html#UNSETF">unsetf</a> and
<a href="cplusplus06.html#WIDTH">width</a>.
<p>
<ul>
    <li><a name="an464"></a><code>ios &amp;ios::copyfmt(ios &amp;obj)</code>:<blockquote>all format flags of <code>obj</code> are copied to the current <code>ios</code>
object. The current <code>ios</code> object is returned.</blockquote>
    <li><a name="an465"></a><code>ios::fill() const</code>:<blockquote>the current <a name="an466"></a>padding character is returned. By default, this is the
blank space.</blockquote>
    <li><code>ios::fill(char padding)</code>:
        <blockquote>the padding character is redefined, the <em>previous</em> padding
character is returned. Instead of using this member function the <a name="an467"></a><code>setfill</code>
<em>manipulator</em> may be inserted directly into an <code>ostream</code>. Example:
        <pre>
cout.fill('0');         // use '0' as padding char
cout &lt;&lt; setfill('+');   // use '+' as padding char
</pre>
        </blockquote>
    <li><a name="an468"></a><code>ios::fmtflags ios::flags() const</code>:<blockquote>the current set of flags controlling the format state of the stream
for which the member function is called is returned. To inspect whether a
particular flag was set, use the <code>bit_and</code> operator. Example:
            <pre>
if (cout.flags() &amp; ios::hex)
    cout &lt;&lt; "Integral values are printed as hex numbers\n"
</pre>
</blockquote>
    <li><code>ios::fmtflags ios::flags(ios::fmtflags flagset)</code>:
       <blockquote>the <em>previous</em> set of flags are returned and the new set of
flags are defined by <code>flagset</code>. Multiple flags are specified using the
<code>bitor</code> operator. Example:
        <pre>
        // change the representation to hexadecimal
cout.flags(ios::hex | cout.flags() &amp; ~ios::dec);
</pre>
        </blockquote>
    <li><a name="an469"></a><code>int ios::precision() const</code>:<blockquote>the number of significant digits used when outputting floating point
values is returned (default: 6).</blockquote>
    <li><code>int ios::precision(int signif)</code>:<a name="an470"></a>
        <blockquote>the number of significant digits to use when outputting real
values is set to <code>signif</code>. The previously used number of significant digits
is returned. If the number of required digits exceeds <code>signif</code> then the
number is displayed in `scientific' notation (cf. section
<a href="cplusplus06.html#FORMATFLAGS">6.3.2.2</a>). Manipulator: <a name="an471"></a><code>setprecision</code>. Example:
            <pre>
cout.precision(3);          // 3 digits precision
cout &lt;&lt; setprecision(3);    // same, using the manipulator

cout &lt;&lt; 1.23 &lt;&lt; " " &lt;&lt; 12.3 &lt;&lt; " " &lt;&lt; 123.12 &lt;&lt; " " &lt;&lt; 1234.3 &lt;&lt; '\n';
// displays: 1.23 12.3 123 1.23e+03
</pre>
        </blockquote>
    <li> <a name="an472"></a><a name="SETF"></a><code>ios::fmtflags ios::setf(ios::fmtflags flags)</code>:
        <blockquote>sets one or more formatting flags (use the <code>bitor</code>
operator to combine multiple flags). Already set flags are not affected. The
<em>previous</em> set of flags is returned. Instead of using this member function
the manipulator <a name="an473"></a><code>setiosflags</code> may be used. Examples are provided in the next
section (<a href="cplusplus06.html#FORMATFLAGS">6.3.2.2</a>).</blockquote>
    <li><code>ios::fmtflags ios::setf(ios::fmtflags flags, ios::fmtflags mask)</code>:
            <blockquote>clears all flags mentioned in <code>mask</code> and sets the flags
specified in <code>flags</code>. The <em>previous</em> set of flags is returned. Some
examples are (but see the next section (<a href="cplusplus06.html#FORMATFLAGS">6.3.2.2</a>) for a more thorough
discussion):
            <pre>
            // left-adjust information in wide fields
cout.setf(ios::left, ios::adjustfield);
    // display integral values as hexadecimal numbers
cout.setf(ios::hex, ios::basefield);
    // display floating point values in scientific notation
cout.setf(ios::scientific, ios::floatfield);
</pre>
        </blockquote>
    <li> <a name="an474"></a><a name="UNSETF"></a><code>ios::fmtflags ios::unsetf(fmtflags flags)</code>:
        <blockquote>the specified formatting flags are cleared (leaving the
remaining flags unaltered) and returns the <em>previous</em> set of flags.  A
request to unset an active default flag (e.g., <code>cout.unsetf(ios::dec)</code>)
is ignored. Instead of this member function the manipulator <a name="an475"></a><code>resetiosflags</code>
may also be used. Example:
        <pre>
cout &lt;&lt; 12.24;              // displays  12.24
cout &lt;&lt; setf(ios::fixed);
cout &lt;&lt; 12.24;              // displays  12.240000
cout.unsetf(ios::fixed);    // undo a previous ios::fixed setting.
cout &lt;&lt; 12.24;              // displays  12.24
cout &lt;&lt; resetiosflags(ios::fixed);  // using manipulator rather
                                    // than unsetf
</pre>
    </blockquote>
    <li><a name="an476"></a><a name="an477"></a>
        <a name="WIDTH"></a><code>int ios::width() const</code>:
        <blockquote>the currently active output field width to use on the next
insertion is returned. The default value is 0, meaning `as many characters as
needed to write the value'.</blockquote>
    <li><code>int ios::width(int nchars)</code>:
        <blockquote>the field width of the next insertion operation is set to
<code>nchars</code>, returning the previously used field width. This setting is not
persistent. It is reset to 0 after every insertion operation. Manipulator:
<a name="an478"></a><code>std::setw(int)</code>. Example:
        <pre>
cout.width(5);
cout &lt;&lt; 12;                     // using 5 chars field width
cout &lt;&lt; setw(12) &lt;&lt; "hello";    // using 12 chars field width
</pre>
    </blockquote>
    </ul>
<p>
<a name="FORMATFLAGS"></a><a name="l88"></a>
<h4>6.3.2.2: Formatting flags</h4>
        Most <a name="an479"></a><em>formatting flags</em> are related to outputting information. Information
can be written to output streams in basically two ways: using
 <a name="an480"></a><em>binary output</em> information is written directly to an output stream,
without converting it first to some <a name="an481"></a>human-readable format and using
 <a name="an482"></a><em>formatted output</em> by which values stored in the computer's memory are
converted to human-readable text first. Formatting flags are used to define
the way this conversion takes place. In this section all formatting flags are
covered. Formatting flags may be (un)set using member functions, but often
manipulators having the same effect may also be used. For each of the flags it
is shown how they can be controlled by a member function or -if available- a
manipulator.
<p>
<strong>To display information in wide fields</strong>:
<p>
<ul>
    <li> <a name="an483"></a><a name="an484"></a><code>ios::internal</code>:
        <blockquote>to add <a name="an485"></a>fill characters (blanks by default) between the minus
sign of negative numbers and the value itself. Other values and data types are
right-adjusted. Manipulator: <code>std::internal</code>. Example:
        <pre>
cout.setf(ios::internal, ios::adjustfield);
cout &lt;&lt; internal;       // same, using the manipulator

cout &lt;&lt; '\'' &lt;&lt; setw(5) &lt;&lt; -5 &lt;&lt; "'\n";  // displays '-   5'
</pre>
        </blockquote>
    <li><a name="an486"></a><code>ios::left</code>:<blockquote>to left-adjust values in fields that are wider than needed to display
the values.  Manipulator: <code>std::left</code>. Example:
        <pre>
cout.setf(ios::left, ios::adjustfield);
cout &lt;&lt; left;           // same, using the manipulator

cout &lt;&lt; '\'' &lt;&lt; setw(5) &lt;&lt; "hi" &lt;&lt; "'\n";  // displays 'hi   '
</pre>
        </blockquote>
    <li><a name="an487"></a><code>ios::right</code>:<blockquote>to right-adjust values in fields that are wider than needed to
display the values.  Manipulator: <code>std::right</code>. This is the default.
Example:
        <pre>
cout.setf(ios::right, ios::adjustfield);
cout &lt;&lt; right;          // same, using the manipulator

cout &lt;&lt; '\'' &lt;&lt; setw(5) &lt;&lt; "hi" &lt;&lt; "'\n";  // displays '   hi'
</pre>
        </blockquote>
    </ul>
<p>
<strong>Using various number representations</strong>:
<p>
<ul>
    <li><a name="an488"></a><code>ios::dec</code>:<blockquote>to display integral values as decimal numbers. Manipulator:
<code>std::dec</code>. This is the default. Example:
        <pre>
cout.setf(ios::dec, ios::basefield);
cout &lt;&lt; dec;            // same, using the manipulator
cout &lt;&lt; 0x10;           // displays 16
</pre>
        </blockquote>
    <li><a name="an489"></a><code>ios::hex</code>:<blockquote>to display integral values as hexadecimal numbers. Manipulator:
<code>std::hex</code>. Example:
        <pre>
cout.setf(ios::hex, ios::basefield);
cout &lt;&lt; hex;            // same, using the manipulator
cout &lt;&lt; 16;             // displays 10
</pre>
        </blockquote>
    <li><a name="an490"></a><code>ios::oct</code>:<blockquote>to display integral values as octal numbers. Manipulator:
<code>std::oct</code>. Example:
        <pre>
cout.setf(ios::oct, ios::basefield);
cout &lt;&lt; oct;            // same, using the manipulator
cout &lt;&lt; 16;             // displays 20
</pre>
        </blockquote>
    <li><a name="an491"></a><code>std::setbase(int radix)</code>:<blockquote>This is a manipulator that can be used to change the number
representation to decimal, hexadecimal or octal. Example:
        <pre>
cout &lt;&lt; setbase(8);     // octal numbers, use 10 for
                        // decimal, 16 for hexadecimal
cout &lt;&lt; 16;             // displays 20
</pre>
        </blockquote>
    </ul>
<p>
<strong>Fine-tuning displaying values</strong>:
<p>
<ul>
    <li><a name="an492"></a><code>ios::boolalpha</code>:<blockquote>logical values may be displayed as text using the text `<code>true</code>' for
the <code>true</code> logical value, and `<code>false</code>' for the <code>false</code> logical value
using <code>boolalpha</code>.  By default this flag is not set. Complementary flag:
<code>ios::noboolalpha</code>. Manipulators: <code>std::boolalpha</code> and
<a name="an493"></a><code>std::noboolalpha</code>.  Example:
        <pre>
cout.setf(ios::boolalpha);
cout &lt;&lt; boolalpha;      // same, using the manipulator
cout &lt;&lt; (1 == 1);       // displays true
</pre>
        </blockquote>
    <li><a name="an494"></a><code>ios::showbase</code>:<blockquote>to display the numeric base of integral values. With hexadecimal
values the <code>0x</code> prefix is used, with octal values the prefix <code>0</code>. For the
(default) decimal value no particular prefix is used. Complementary flag:
<code>ios::noshowbase</code>. Manipulators: <code>std::showbase</code> and
<a name="an495"></a><code>std::noshowbase</code>. Example:
        <pre>
cout.setf(ios::showbase);
cout &lt;&lt; showbase;       // same, using the manipulator
cout &lt;&lt; hex &lt;&lt; 16;      // displays 0x10
</pre>
        </blockquote>
    <li><a name="an496"></a><code>ios::showpos</code>:<blockquote>to display the <code>+</code> sign with positive decimal (only)
values. Complementary flag:<br/><code>ios::noshowpos</code>.  Manipulators:
<code>std::showpos</code> and <a name="an497"></a><code>std::noshowpos</code>. Example:
        <pre>
cout.setf(ios::showpos);
cout &lt;&lt; showpos;            // same, using the manipulator
cout &lt;&lt; 16;                 // displays +16
cout.unsetf(ios::showpos);  // Undo showpos
cout &lt;&lt; 16;                 // displays 16
</pre>
        </blockquote>
    <li><a name="an498"></a><code>ios::uppercase</code>:<blockquote>to display letters in hexadecimal values using capital
letters. Complementary flag: <code>ios::nouppercase</code>.  Manipulators:
<code>std::uppercase</code> and <a name="an499"></a><code>std::nouppercase</code>.  By default lower
case letters are used. Example:
        <pre>
cout.setf(ios::uppercase);
cout &lt;&lt; uppercase;            // same, using the manipulator
cout &lt;&lt; hex &lt;&lt; showbase &lt;&lt;
        3735928559;           // displays 0XDEADBEEF
</pre>
        </blockquote>
    </ul>
<p>
<strong>Displaying floating point numbers</strong>
<p>
<ul>
    <li><a name="an500"></a><a name="an501"></a><a name="an502"></a>
        <code>ios::fixed</code>:
        <blockquote>to display real values using a fixed decimal point (e.g., 12.25
rather than 1.225e+01), the <code>fixed</code> formatting flag is used. It can be used
to set a fixed number of digits behind the decimal point. Manipulator:
<code>fixed</code>. Example:
            <pre>
cout.setf(ios::fixed, ios::floatfield);
cout.precision(3);          // 3 digits behind the .

    // Alternatively:
cout &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(3);

cout &lt;&lt; 3.0 &lt;&lt; " " &lt;&lt; 3.01 &lt;&lt; " " &lt;&lt; 3.001 &lt;&lt; '\n';
     &lt;&lt; 3.0004 &lt;&lt; " " &lt;&lt; 3.0005 &lt;&lt; " " &lt;&lt; 3.0006 &lt;&lt; '\n'
    // Results in:
    // 3.000 3.010 3.001
    // 3.000 3.001 3.001
</pre>
    The example shows that 3.0005 is rounded away from zero, becoming
3.001 (likewise -3.0005 becomes -3.001). First setting precision and then
<code>fixed</code> has the same effect.
        </blockquote>
    <li><a name="an503"></a><code>ios::scientific</code>:<blockquote>to display real values in <a name="an504"></a><em>scientific notation</em> (e.g., 1.24e+03).
Manipulator: <code>std::scientific</code>.  Example:
        <pre>
cout.setf(ios::scientific, ios::floatfield);
cout &lt;&lt; scientific;         // same, using the manipulator
cout &lt;&lt; 12.25;              // displays 1.22500e+01
</pre>
        </blockquote>
    <li><a name="an505"></a><code>ios::showpoint</code>:<blockquote>to display a trailing decimal point <em>and</em> trailing decimal zeros
when real numbers are displayed. Complementary flag:
<code>ios::noshowpoint</code>. Manipulators: <code>std::showpoint</code>,
 <a name="an506"></a><code>std::noshowpoint</code>. Example:
        <pre>
cout &lt;&lt; fixed &lt;&lt; setprecision(3);   // 3 digits behind .

cout.setf(ios::showpoint);      // set the flag
cout &lt;&lt; showpoint;              // same, using the manipulator

cout &lt;&lt; 16.0 &lt;&lt; ", " &lt;&lt; 16.1 &lt;&lt; ", " &lt;&lt; 16;
// displays: 16.000, 16.100, 16
</pre>
    Note that the final 16 is an integral rather than a floating point number,
so it has no decimal point. So <code>showpoint</code> has no effect.
    If <code>ios::showpoint</code> is not active trailing zeros are discarded. If
the fraction is zero the decimal point is discarded as well. Example:
        <pre>
cout.unsetf(ios::fixed, ios::showpoint);    // unset the flags

cout &lt;&lt; 16.0 &lt;&lt; ", " &lt;&lt; 16.1;
// displays: 16, 16.1
</pre>
    </blockquote>
    </ul>
<p>
<strong>Handling white space and flushing streams</strong>
<p>
<ul>
    <li><a name="an507"></a><code>std::endl</code>:<blockquote>manipulator inserting a newline character and flushing the
stream. Often flushing the stream is not required and doing so would
needlessly slow down I/O processing. Consequently, using <code>endl</code> should be
avoided (in favor of inserting <code>'\n'</code>) unless flusing the stream is
explicitly intended. Note that streams are automatically flushed when the
program terminates or when a stream is `tied' to another stream (cf. <code>tie</code>
in section <a href="cplusplus06.html#IOS">6.3</a>). Example:
        <pre>
cout &lt;&lt; "hello" &lt;&lt; endl;    // prefer: &lt;&lt; '\n';
</pre>
        </blockquote>
    <li><a name="an508"></a><code>std::ends</code>:<blockquote>manipulator inserting a 0-byte into a stream. It is usually used in
combination with memory-streams (cf. section <a href="cplusplus06.html#OSTRINGSTREAM">6.4.3</a>).
        </blockquote>
    <li><a name="an509"></a><code>std::flush</code>:<blockquote>a stream may be flushed using this member. Often flushing the stream
is not required and doing so would needlessly slow down I/O
processing. Consequently, using <code>flush</code> should be avoided unless it is
explicitly required to do so. Note that streams are automatically flushed when
the program terminates or when a stream is `tied' to another stream
(cf. <code>tie</code> in section <a href="cplusplus06.html#IOS">6.3</a>). Example:
        <pre>
cout &lt;&lt; "hello" &lt;&lt; flush;    // avoid if possible.
</pre>
        </blockquote>
    <li><a name="an510"></a><code>ios::skipws</code>:<blockquote>leading <a name="an511"></a>white space characters (blanks, tabs, newlines, etc.) are
skipped when a value is extracted from a stream. This is the default.  If the
flag is not set, leading white space characters are not skipped.
Manipulator: <code>std::skipws</code>. Example:
        <pre>
cin.setf(ios::skipws);  // to unset, use
                        //  cin.unsetf(ios::skipws)

cin &gt;&gt; skipws;          // same, using the manipulator
int value;
cin &gt;&gt; value;           // skips initial blanks
</pre>
        </blockquote>
    <li><a name="an512"></a><code>ios::unitbuf</code>:<blockquote>the stream for which this flag is set flushes its buffer after
every output operation Often flushing a stream is not required and doing so
would needlessly slow down I/O processing. Consequently, setting <code>unitbuf</code>
should be avoided unless flusing the stream is explicitly intended. Note that
streams are automatically flushed when the program terminates or when a stream
is `tied' to another stream (cf. <code>tie</code> in section <a href="cplusplus06.html#IOS">6.3</a>).  Complementary
flag: <code>ios::nounitbuf</code>. Manipulators: <code>std::unitbuf</code>,
<a name="an513"></a><code>std::nounitbuf</code>. Example:
        <pre>
cout.setf(ios::unitbuf);
cout &lt;&lt; unitbuf;            // same, using the manipulator

cout.write("xyz", 3);       // flush follows write.
</pre>
        </blockquote>
    <li><a name="an514"></a><code>std::ws</code>:<blockquote>manipulator removing all <a name="an515"></a>white space characters
(blanks, tabs, newlines, etc.) at the current file position. White space are
removed if present even if the flag <code>ios::noskipws</code> has been set.
Example (assume the input contains 4 blank characters followed by the
character <code>X</code>):
        <pre>
cin &gt;&gt; ws;      // skip white space
cin.get();      // returns 'X'
</pre>
        </blockquote>
    </ul>
<p>
<a name="l89"></a>
<h2>6.4: Output</h2>
In <strong>C++</strong> output is primarily based on the <a name="an516"></a><code>std::ostream</code>
class. The <code>ostream</code> class defines the basic operators and members inserting
information into streams: the <a name="an517"></a><em>insertion operator</em> (&lt;&lt;), and special
members like <code>write</code> writing unformatted information to streams.
<p>
The class <code>ostream</code> acts as <em>base class</em> for several other classes, all
offering the functionality of the <code>ostream</code> class, but adding their own
specialties. In the upcoming sections the following classes are discussed:
    <ul>
    <li> The class <code>ostream</code>, offering the basic output facilities;
    <li> The class <a name="an518"></a><code>ofstream</code>, allowing us to write files
(comparable to <strong>C</strong>'s <a name="an519"></a> <code>fopen(filename, "w")</code>);
    <li> The class <a name="an520"></a><code>ostringstream</code>, allowing us to write information to
memory (comparable to <strong>C</strong>'s <a name="an521"></a><code>sprintf</code> function).
    </ul>
<p>
<a name="OSTREAM"></a><a name="l90"></a>
<h3>6.4.1: Basic output: the class `ostream'</h3>
    The class <a name="an522"></a><code>ostream</code> defines basic output facilities. The <a name="an523"></a><code>cout</code>, <a name="an524"></a><code>clog</code>
and <a name="an525"></a><code>cerr</code> objects are all <code>ostream</code> objects. All facilities related to
output as defined by the <code>ios</code> class are also available in the <code>ostream</code>
class.
<p>
We may define <code>ostream</code> objects using the following
 <a name="an526"></a><em>ostream constructor</em>:
    <ul>
    <li><code>std::ostream object(std::streambuf *sb)</code>:
        <blockquote>this constructor creates an <code>ostream</code> object which is a
wrapper around an existing <code>std::streambuf</code> object.  It isn't possible to
define a plain <code>ostream</code> object (e.g., using <code>std::ostream out;</code>) that
can thereupon be used for insertions. When <code>cout</code> or its friends are used,
we are actually using a predefined <code>ostream</code> object that has already been
defined for us and interfaces to the standard output stream using a
(also predefined) <code>streambuf</code> object handling the actual interfacing.
<p>
It <em>is</em>, however, possible to define an <code>ostream</code> object passing it
 <a name="an527"></a> a 0-pointer. Such an object cannot be
used for insertions (i.e., it raises its <code>ios::bad</code> flag when something
is inserted into it), but it may be given a <code>streambuf</code> later. Thus it may
be preliminary constructed, suspending its use until an appropriate
<code>streambuf</code> becomes available (see also section <a href="cplusplus14.html#STREAMINIT">14.8.3</a>).
    </blockquote>
    </ul>
    To define the <code>ostream</code> class in <strong>C++</strong> sources, the
    <a name="an528"></a><code>&lt;ostream&gt;</code> header file must be included. To use the predefined
<code>ostream</code> objects (<code>std::cin, std::cout</code> etc.) the <a name="an529"></a><code>&lt;iostream&gt;</code> header
file must be included.
<p>
<a name="l91"></a>
<h4>6.4.1.1: Writing to `ostream' objects</h4>
        The class <a name="an530"></a><code>ostream</code> supports both formatted and <a name="an531"></a><em>binary output</em>.
<p>
The <a name="an532"></a><em>insertion operator</em> (&lt;&lt;) is used to insert values in
a type safe way into <code>ostream</code> objects.  This is called
    <a name="an533"></a>formatted output, as binary values which are stored in the computer's
memory are converted to human-readable <a name="an534"></a>ASCII characters according to
certain formatting rules.
<p>
The insertion operator points to the <code>ostream</code> object to
receive the information.  The normal associativity of &lt;&lt;
remains unaltered, so when a statement like
        <pre>
    cout &lt;&lt; "hello " &lt;&lt; "world";
</pre>
    is encountered, the leftmost two operands are evaluated first (<code>cout</code>
&lt;&lt; <code>"hello "</code>), and an <code>ostream &amp;</code> object, which is actually the
same <code>cout</code> object, is returned. Now, the statement is reduced to
        <pre>
    cout &lt;&lt; "world";
</pre>
    and the second string is inserted into <code>cout</code>.
<p>
The &lt;&lt; operator has a lot of (overloaded) variants, so many types of
variables can be inserted into <code>ostream</code> objects. There is an overloaded
&lt;&lt;-operator expecting an <code>int</code>, a <code>double</code>, a pointer, etc. etc..
Each operator returns the <code>ostream</code> object into which the information so far
has been inserted, and can thus immediately be followed by the next insertion.
<p>
Streams lack facilities for formatted output like <strong>C</strong>'s
<a name="an535"></a><code>printf</code> and <a name="an536"></a><code>vprintf</code> functions. Although it is not difficult to
implement these facilities in the world of streams, <code>printf</code>-like
functionality is hardly ever required in <strong>C++</strong> programs. Furthermore, as it
is potentially type-<em>unsafe</em>, it might be better to avoid this functionality
completely.
<p>
When <a name="an537"></a> binary files must be written, normally no
text-formatting is used or required: an <code>int</code> value should be written as a
series of raw bytes, not as a series of <a name="an538"></a>ASCII numeric characters 0 to
9. The following member functions of <code>ostream</code> objects may be used to
write `binary files':
    <ul>
    <li><a name="an539"></a><code>ostream&amp; put(char c)</code>:<blockquote>to write a single character to the output stream. Since a character
is a byte, this member function could also be used for writing a single
character to a text-file.</blockquote>
     <li><a name="an540"></a><code>ostream&amp; write(char const *buffer, int length)</code>:<blockquote>to write at most <code>length</code> bytes, stored in the <code>char const
*buffer</code> to the <code>ostream</code> object. Bytes are written as they are stored
in the buffer, no formatting is done whatsoever. Note that the first argument
is a <code>char const *</code>: a <em>type cast</em> is required to write any other
type. For example, to write an <code>int</code> as an unformatted series of
byte-values use:
        <pre>
int x;
out.write(reinterpret_cast&lt;char const *&gt;(&amp;x), sizeof(int));
</pre>
        </blockquote>
    The bytes written by the above <code>write</code> call are written to the
<code>ostream</code> in an order depending on the <a name="an541"></a><em>endian</em><em>-ness</em> of the
underlying hardware. Big-endian computers write the most significant byte(s)
of multi-byte values first, little-endian computers first write the least
significant byte(s).
    </ul>
<p>
<a name="OSTREAMPOS"></a><a name="l92"></a>
<h4>6.4.1.2: `ostream' positioning</h4>
        Although not every <code>ostream</code> object supports <a name="an542"></a>repositioning, they usually
do. This means that it is possible to rewrite a section of the stream which
was written earlier. Repositioning is frequently used in database applications
where it must be possible to access the information in the database at random.
<p>
The current position can be obtained and modified using the following members:
    <ul>
    <li><a name="an543"></a><code>ios::pos_type tellp()</code>:<blockquote>the current (absolute) position in the file where the next
write-operation to the stream will take place is returned.</blockquote>
    <li><a name="an544"></a><code>ostream &amp;seekp(ios::off_type step, ios::seekdir org)</code>:<blockquote>modifies a stream's actual position. The function expects an
<a name="an545"></a><code>off_type</code> <code>step</code> representing the number of bytes the current stream
position is moved with respect to <code>org</code>. The <code>step</code> value
may be negative, zero or positive.
<p>
The origin of the step, <code>org</code> is a value in the
<a name="an546"></a><code>ios::seekdir</code> enumeration. Its values are:
        <ul>
        <li><a name="an547"></a><code>ios::beg</code>:<blockquote>the stepsize is computed relative to the beginning of the
stream. This value is used by default.
            </blockquote>
        <li><a name="an548"></a><code>ios::cur</code>:<blockquote>the stepsize is computed relative to the current position of the
stream (as returned by <code>tellp</code>).
            </blockquote>
        <li><a name="an549"></a><code>ios::end</code>:<blockquote>the stepsize is interpreted relative to the current end position
of the stream.</blockquote>
    </ul>
    It is OK to
 <a name="an550"></a><a name="an551"></a>
    seek or write beyond the last file position.  Writing bytes to a location
beyond <code>EOF</code> will pad the intermediate bytes with 0-valued bytes:
<a name="an552"></a>null-bytes.
    Seeking before <code>ios::beg</code> raises the <a name="an553"></a><code>ios::fail</code> flag.
        </blockquote>
    </ul>
<p>
<a name="l93"></a>
<h4>6.4.1.3: `ostream' flushing</h4>
        Unless the <code>ios::unitbuf</code> flag has been set, information written to an
<code>ostream</code> object is not immediately written to the physical stream. Rather,
an internal buffer is filled during the write-operations, and when full it
is flushed.
<p>
The stream's <a name="an554"></a>internal buffer can be flushed under program control:
    <ul>
    <li><a name="an555"></a><code>ostream&amp; flush()</code>:<blockquote>any buffered information stored internally by the <code>ostream</code> object
is flushed to the device to which the <code>ostream</code> object interfaces. A stream
is flushed automatically when:
        <ul>
        <li> the object ceases to exist;
        <li> the <code>endl</code> or <code>flush</code> <em>manipulators</em> (see section
            <a href="cplusplus06.html#FORMATFLAGS">6.3.2.2</a>) are inserted into an <code>ostream</code> object;
        <li> a stream supporting the <a name="an556"></a><code>close</code>-operation is explicitly closed
(e.g., a <code>std::ofstream</code> object, cf. section <a href="cplusplus06.html#OFSTREAM">6.4.2</a>).
<p>
</ul>
    </blockquote>
    </ul>
<p>
<a name="OFSTREAM"></a><a name="l94"></a>
<h3>6.4.2: Output to files: the class `ofstream'</h3>
    The <a name="an557"></a><code>std::ofstream</code> class is derived from the <code>ostream</code> class:
it has the same capabilities as the <code>ostream</code> class, but can be used to
<a name="an558"></a>access files or <a name="an559"></a>create files for writing.
<p>
In order to use the <code>ofstream</code> class  in <strong>C++</strong> sources, the
    <a name="an560"></a><code>&lt;fstream&gt;</code> header file must be included. Including <code>fstream</code> does not
automatically make available the standard streams <code>cin</code>, <code>cout</code> and
<code>cerr</code>. Include <a name="an561"></a><code>iostream</code> to declare these standard streams.
<p>
The following <a name="an562"></a> constructors are available for
<code>ofstream</code> objects:
    <ul>
    <li><code>ofstream object</code>:
        <blockquote>this is the basic constructor. It defines an <code>ofstream</code> object
which may be associated with an actual file later, using its <code>open()</code> member
(see below).
        </blockquote>
    <li><code>ofstream object(char const *name, ios::openmode mode = ios::out)</code>:
        <blockquote>this constructor defines an <code>ofstream</code> object and associates
it immediately with the file named <code>name</code> using output mode
<code>mode</code>. Section <a href="cplusplus06.html#OUTPUTMODES">6.4.2.1</a> provides an overview of available output
modes.  Example:
        <pre>
ofstream out("/tmp/scratch");
</pre>
            </blockquote>
    </ul>
    It is not possible to open an <code>ofstream</code> using a
 <a name="an563"></a><em>file descriptor</em>. The reason for this is (apparently) that file
descriptors are not universally available over different operating systems.
Fortunately, file descriptors can be used (indirectly) with a
<code>std::streambuf</code> object (and in some implementations: with a
<code>std::filebuf</code> object, which is also a <code>streambuf</code>). <code>Streambuf</code> objects
are discussed in section <a href="cplusplus14.html#STREAMBUF">14.8</a>, <code>filebuf</code> objects are discussed in
section <a href="cplusplus14.html#FILEBUF">14.8.2</a>.
<p>
Instead of directly associating an <code>ofstream</code> object with a file, the
object can be constructed first, and opened later.
    <ul>
        <li><a name="an564"></a><code>void open(char const *name,
                            ios::openmode mode = ios::out)</code>:<blockquote>associates an <code>ofstream</code> object with an actual file. If the
<code>ios::fail</code> flag was set before calling <code>open</code> and opening succeeds the
flag is cleared. Opening an already open stream fails. To reassociate a stream
with another file it must first be closed:
        <pre>
ofstream out("/tmp/out");
out &lt;&lt; "hello\n";
out.close();        // flushes and closes out
out.open("/tmp/out2");
out &lt;&lt; "world\n";
</pre>
        </blockquote>
        <li><a name="an565"></a><code>void close()</code>:<blockquote>closes the <code>ofstream</code> object. The function sets the <a name="an566"></a><code>ios::fail</code>
flag of the closed object. Closing the file flushes any buffered information
to the associated file. A file is automatically closed when the associated
<code>ofstream</code> object ceases to exist.
        </blockquote>
        <li><a name="an567"></a><code>bool is_open() const</code>:<blockquote>assume a stream was properly constructed, but it has not yet been
attached to a file. E.g., the statement <code>ofstream ostr</code> was executed. When
we now check its status through <code>good()</code>, a non-zero (i.e., <em>OK</em>) value is
returned.  The `good' status here indicates that the stream object has been
constructed properly. It doesn't mean the file is also open. To test whether a
stream is actually open, <code>is_open</code> should be called. If it returns <a name="an568"></a><code>true</code>,
the stream is open. Example:
        <pre>
    #include &lt;fstream&gt;
    #include &lt;iostream&gt;

    using namespace std;

    int main()
    {
        ofstream of;

        cout &lt;&lt; "of's open state: " &lt;&lt; boolalpha &lt;&lt; of.is_open() &lt;&lt; '\n';

        of.open("/dev/null");       // on Unix systems

        cout &lt;&lt; "of's open state: " &lt;&lt; of.is_open() &lt;&lt; '\n';
    }
    /*
        Generated output:
    of's open state: false
    of's open state: true
    */
</pre>
<p>
</blockquote>
    </ul>
<p>
<a name="OUTPUTMODES"></a><a name="l95"></a>
<h4>6.4.2.1: Modes for opening stream objects</h4>
        The following <a name="an569"></a>file modes or <a name="an570"></a>file flags are available when constructing
or opening <code>ofstream</code> (or <code>istream</code>, see section <a href="cplusplus06.html#IFSTREAM">6.5.2</a>)
objects. The values are of type <a name="an571"></a><code>ios::openmode</code>. Flags may be
combined using the <code>bitor</code> operator.
        <ul>
        <li><a name="an572"></a><code>ios::app</code>:<blockquote>reposition the stream to its end before every output command (see
also <code>ios::ate</code> below). The
file is created if it doesn't yet exist. When opening a stream in this mode
any existing contents of the file are kept.</blockquote>
        <li><a name="an573"></a><code>ios::ate</code>:<blockquote>start initially at the end of the file.  Note that any existing
contents are <em>only</em> kept if some other flag tells the object to do so. For
example <code>ofstream out("gone", ios::ate)</code> <em>rewrites</em> the file <code>gone</code>,
because the implied <code>ios::out</code> causes the rewriting. If rewriting of an
existing file should be prevented, the <code>ios::in</code>
        <a name="an574"></a><a name="an575"></a>
    mode should be specified too. However, when <code>ios::in</code> is specified the
file must already exist. The <code>ate</code> mode only initially positions the file at
the end of file position. After that information may be written in the middle
of the file using <code>seekp</code>. When the <code>app</code> mode is used information is
<em>only</em> written at end of file (effectively ignoring <code>seekp</code> operations).</blockquote>
        <li><a name="an576"></a><code>ios::binary</code>:<blockquote>open a file in <a name="an577"></a>binary mode (used on systems
distinguishing text- and binary files, like <a name="an578"></a>MS-Windows).
        </blockquote>
        <li><a name="an579"></a><code>ios::in</code>:<blockquote>open the file for reading. The file must exist.</blockquote>
        <li><a name="an580"></a><code>ios::out</code>:<blockquote>open the file for writing. Create it if it doesn't yet exist. If
it exists, the <a name="an581"></a>file is rewritten.</blockquote>
        <li><a name="an582"></a><code>ios::trunc</code>:<blockquote>start initially with an empty file.  Any existing contents of the
file are lost.</blockquote>
        </ul>
    The following combinations of file flags have special meanings:
        <pre>
in | out:           The stream may be read and written. However, the
                    file must exist.
in | out | trunc:   The stream may be read and written. It is
                    (re)created empty first.
</pre>
    An interesting subtlety is that the <code>open</code> members of the <code>ifstream,
ofstream</code> and <code>fstream</code> classes have a second parameter of type
<code>ios::openmode</code>. In contrast to this, the <code>bitor</code> operator returns an
<code>int</code> when applied to two enum-values. The question why the <code>bitor</code>
operator may nevertheless be used here is answered in a later chapter
(cf. section <a href="cplusplus11.html#EnumOverload">11.11</a>).
<p>
<a name="OSTRINGSTREAM"></a><a name="l96"></a>
<h3>6.4.3: Output to memory: the class `ostringstream'</h3>
    To <a name="an583"></a> write information to memory using <code>stream</code>
facilities, <a name="an584"></a><code>std::ostringstream</code> objects should be used.
As the class <code>ostringstream</code> is derived from the class <code>ostream</code> all
<code>ostream</code>'s facilities are available to <code>ostringstream</code> objects as
well. To use and define <code>ostringstream</code> objects the header file
<a name="an585"></a><code>&lt;sstream&gt;</code> must be included. In addition the class <code>ostringstream</code> offers
the following constructors and members:
    <ul>
        <li><a name="an586"></a><code>ostringstream ostr(string const &amp;init,
                ios::openmode mode = ios::out)</code>:<blockquote>when specifying <code>openmode</code> as <code>ios::ate</code>, the
<code>ostringstream</code> object is initialized by the <code>string init</code> and remaining
insertions are appended to the contents of the <code>ostringstream</code> object.
            </blockquote>
        <li><code>ostringstream ostr(ios::openmode mode = ios::out)</code>:
        <blockquote>this constructor can also be used as default
constructor. Alternatively it allows, e.g., forced additions at the end of the
information stored in the object so far (using <code>ios::app</code>). Example:
        <pre>
std::ostringstream out;
</pre>
        </blockquote>
        <li><a name="an587"></a><code>std::string str() const</code>:<blockquote>a copy of the string that is stored inside the <code>ostringstream</code>
            object is returned.</blockquote>
        <li><code>void str(std::string const &amp;str)</code>:
        <blockquote>the current object is reinitialized with new initial contents.</blockquote>
    </ul>
    The following example illustrates the use of the <code>ostringstream</code> class:
several values are inserted into the object. Then, the text contained by the
<code>ostringstream</code> object is stored in a <code>std::string</code>, whose length and
contents are thereupon printed.  Such <code>ostringstream</code> objects are most often
used for doing `type to string'<a name="an588"></a> conversions,
like converting <code>int</code> values to text. Formatting flags can be used with
<code>ostringstreams</code> as well, as they are part of the <code>ostream</code> class.
<p>
Here is an example showing an <code>ostringstream</code> object being used:
    <pre>
    #include &lt;iostream&gt;
    #include &lt;sstream&gt;

    using namespace std;

    int main()
    {
        ostringstream ostr("hello ", ios::ate);

        cout &lt;&lt; ostr.str() &lt;&lt; '\n';

        ostr.setf(ios::showbase);
        ostr.setf(ios::hex, ios::basefield);
        ostr &lt;&lt; 12345;

        cout &lt;&lt; ostr.str() &lt;&lt; '\n';

        ostr &lt;&lt; " -- ";
        ostr.unsetf(ios::hex);
        ostr &lt;&lt; 12;

        cout &lt;&lt; ostr.str() &lt;&lt; '\n';

        ostr.str("new text");
        cout &lt;&lt; ostr.str() &lt;&lt; '\n';

        ostr.seekp(4, ios::beg);
        ostr &lt;&lt; "world";
        cout &lt;&lt; ostr.str() &lt;&lt; '\n';
    }
    /*
        Output from this program:
    hello
    hello 0x3039
    hello 0x3039 -- 12
    new text
    new world
    */
</pre>
<p>
<a name="l97"></a>
<h2>6.5: Input</h2>
In <strong>C++</strong> <a name="an589"></a>input is primarily based on the <a name="an590"></a><code>std::istream</code>
class. The <code>istream</code> class defines the basic operators and members
extracting information from streams: the <a name="an591"></a><em>extraction operator</em> (&gt;&gt;),
and special members like <code>istream::read</code> reading unformatted
information from streams.
<p>
The class <code>istream</code> acts as <em>base class</em> for several other classes, all
offering the functionality of the <code>istream</code> class, but adding their own
specialties. In the upcoming sections the following classes are discussed:
    <ul>
    <li> The class <code>istream</code>, offering the basic facilities for doing input;
    <li> The class <a name="an592"></a><code>ifstream</code>, allowing us to read files
(comparable to <strong>C</strong>'s <a name="an593"></a> <code>fopen(filename, "r")</code>);
    <li> The class <a name="an594"></a><code>istringstream</code>, allowing us to read information from
text that is not stored on files (streams) but in memory (comparable to
<strong>C</strong>'s <a name="an595"></a><code>sscanf</code> function).
    </ul>
<p>
<a name="ISTREAM"></a><a name="l98"></a>
<h3>6.5.1: Basic input: the class `istream'</h3>
    The class <a name="an596"></a><code>istream</code> defines basic input facilities. The <a name="an597"></a><code>cin</code> object, is
an <code>istream</code> object.  All facilities related to input as defined by the
<code>ios</code> class are also available in the <code>istream</code> class.
<p>
We may define <code>istream</code> objects using the following
 <a name="an598"></a><em>istream constructor</em>:
    <ul>
        <li><code>istream object(streambuf *sb)</code>:
            <blockquote>this constructor can be used to construct a wrapper around
an existing <code>std::streambuf</code> object. Similarly to <code>ostream</code> objects,
<code>istream</code> objects may be defined by passing it initially
 <a name="an599"></a> a 0-pointer. See section <a href="cplusplus06.html#OSTREAM">6.4.1</a> for
a discussion, see also section <a href="cplusplus14.html#STREAMINIT">14.8.3</a>, and see chapter <a href="cplusplus24.html#CONCRETE">24</a>
for examples.
    </blockquote>
    </ul>
    To define the <code>istream</code> class in <strong>C++</strong> sources, the
    <a name="an600"></a><code>&lt;istream&gt;</code> header file must be included. To use the predefined
<code>istream</code> object <a name="an601"></a><code>cin</code>, the <a name="an602"></a><code>&lt;iostream&gt;</code> header file must be included.
<p>
<a name="ISTREAMREAD"></a><a name="l99"></a>
<h4>6.5.1.1: Reading from `istream' objects</h4>
        The class <code>istream</code> supports both formatted and unformatted
    <a name="an603"></a><em>binary input</em>.  The <a name="an604"></a><em>extraction operator</em> (<a name="an605"></a><code>operator&gt;&gt;</code>) is
used to extract values in a <a name="an606"></a>type safe way from <code>istream</code> objects.  This
is called <a name="an607"></a>formatted input, whereby human-readable <a name="an608"></a>ASCII characters are
converted, according to certain formatting rules, to binary values.
<p>
The extraction operator points to the objects or variables which receive new
values.  The normal associativity of &gt;&gt; remains unaltered, so when a
statement like
        <pre>
    cin &gt;&gt; x &gt;&gt; y;
</pre>
    is encountered, the leftmost two
operands are evaluated first (<code>cin</code> &gt;&gt; <code>x</code>), and an <code>istream &amp;</code>
object, which is actually the same <code>cin</code> object, is returned. Now, the
statement is reduced to
        <pre>
    cin &gt;&gt; y
</pre>
    and the <code>y</code> variable is extracted from <code>cin</code>.
<p>
The &gt;&gt; operator has many (overloaded) variants and thus many types of
variables can be extracted from <code>istream</code> objects. There is an overloaded
&gt;&gt; available for the extraction of an <code>int</code>, of a <code>double</code>, of a
string, of an array of characters, possibly to a pointer, etc. etc.. String or
character array extraction
    <a name="an609"></a> <a name="an610"></a>
    by default first skips all white space characters, and then extracts
all consecutive non-white space characters. Once an extraction operator has
been processed the <code>istream</code> object from which the information was extracted
is returned and it can immediately be used for additional <code>istream</code>
operations that appear in the same expression.
<p>
Streams lack facilities for formatted input (as used by, e.g., <strong>C</strong>'s
<a name="an611"></a><code>scanf</code> and <a name="an612"></a><code>vscanf</code> functions). Although it is not difficult to add these
facilities to the world of streams, <code>scanf</code>-like functionality is hardly
ever required in <strong>C++</strong> programs. Furthermore, as it is potentially
type-<em>unsafe</em>, it might be better to avoid formatted input completely.
<p>
When <a name="an613"></a> binary files must be read, the information should
normally not be formatted: an <code>int</code> value should be read as a series of
unaltered bytes, not as a series of <a name="an614"></a>ASCII numeric characters 0 to 9. The
following member functions for reading information from <code>istream</code> objects
are available:
    <ul>
        <li><a name="an615"></a><code>int gcount() const</code>:<blockquote>the number of characters read from the input stream
by the last unformatted input operation is returned.</blockquote>
        <li><a name="an616"></a><code>int get()</code>:<blockquote>the next available single character is returned
as an unsigned <code>char</code> value using an <code>int</code> return type.
<code>EOF</code> is returned if no more character are available.</blockquote>
        <li><code>istream &amp;get(char &amp;ch)</code>:<blockquote>the next single character read from the input stream is
stored in <code>ch</code>. The member function returns the stream itself which may be
inspected to determine whether a character was obtained or not.</blockquote>
        <li><code>istream&amp; get(char *buffer, int len, char delim = '\n')</code>:<blockquote>At most <code>len - 1</code> characters are read from the input
stream into the array starting at <code>buffer</code>, which should be at least <code>len</code>
bytes long. Reading also stops when the delimiter <code>delim</code> is
encountered. However, the delimiter itself is <em>not removed</em> from the input
stream.
<p>
Having stored the characters into <code>buffer</code>, an 0-valued character is
written beyond the last character stored into the <code>buffer</code>.  The functions
<code>eof</code> and <code>fail</code> (see section <a href="cplusplus06.html#IOSTATES">6.3.1</a>) return 0 (<code>false</code>) if the
delimiter was encountered before reading <code>len - 1</code> characters or if the
delimiter was not encountered after reading <code>len - 1</code> characters.
It is OK to specifiy an 0-valued character delimiter: this way NTB strings
may be read from a (binary) file.
        </blockquote>
        <li><a name="an617"></a><code>istream&amp; getline(char *buffer, int len, char delim = '\n')</code>:<blockquote>this member function operates analogously to the <code>get</code> member
function, but <code>getline</code> removes <code>delim</code> from the stream if it is actually
encountered. The delimiter itself, if encountered, is <em>not</em> stored in the
<code>buffer</code>. If <code>delim</code> was <em>not</em> found (before reading <code>len - 1</code>
characters) the <code>fail</code> member function, and possibly also <code>eof</code> returns
true. Realize that the <code>std::string</code> class also offers a function
<code>std::getline</code> which is generally preferred over this <code>getline</code> member
function that is described here (see section <a href="cplusplus05.html#STRINGMEMBERS">5.2.4</a>).
            </blockquote>
        <li><a name="an618"></a><code>istream&amp; ignore()</code>:<blockquote>one character is skipped from the input stream.</blockquote>
        <li><code>istream&amp; ignore(int n)</code>:<blockquote><code>n</code> characters are skipped from the input stream.</blockquote>
        <li><code>istream&amp; ignore(int n, int delim)</code>:<blockquote>at most <code>n</code> characters are skipped but skipping characters
stops after having removed <code>delim</code> from the input stream.</blockquote>
        <li><a name="an619"></a><code>int peek()</code>:<blockquote>this function returns the next available input character,
but does not actually remove the character from the input stream. <code>EOF</code>
is returned if no more characters are available.</blockquote>
        <li><a name="an620"></a><code>istream&amp; putback(char ch)</code>:<blockquote>The character <code>ch</code> is `pushed back' into the input stream, to
be read again as the next available character. <code>EOF</code> is returned if this
is not allowed. Normally, it is OK to put back one character. Example:
            <pre>
string value;
cin &gt;&gt; value;
cin.putback('X');
                // displays: X
cout &lt;&lt; static_cast&lt;char&gt;(cin.get());
</pre>
            </blockquote>
        <li><a name="an621"></a><code>istream &amp;read(char *buffer, int len)</code>:<blockquote>At most <code>len</code> bytes are read from the input stream into the
buffer. If <code>EOF</code> is encountered first, fewer bytes are read, with the
member function <code>eof</code> returning <code>true</code>. This function is commonly used
when reading <em>binary</em> files. Section <a href="cplusplus06.html#IFSTREAM">6.5.2</a> contains an example in
which this member function is used. The member function <code>gcount()</code> may be
used to determine the number of characters that were retrieved by <code>read</code>.
            </blockquote>
        <li><a name="an622"></a><code>istream&amp; readsome(char *buffer, int len)</code>:<blockquote>at most <code>len</code> bytes are read from the input stream into the
buffer. All available characters are read into the buffer, but if <code>EOF</code>
is encountered, fewer bytes are read, without setting the <code>ios::eofbit</code>
or <code>ios::failbit</code>.
        </blockquote>
        <li><a name="an623"></a><code>istream &amp;unget()</code>:<blockquote>the last character that was read from the stream is put back.</blockquote>
    </ul>
<p>
<a name="ISTREAMPOS"></a><a name="l100"></a>
<h4>6.5.1.2: `istream' positioning</h4>
        Although not every <code>istream</code> object supports <a name="an624"></a>repositioning, some do. This
means that it is possible to read the same section of a stream
repeatedly. Repositioning is frequently used in <a name="an625"></a><em>database applications</em>
where it must be possible to access the information in the database randomly.
<p>
The current position can be obtained and modified using the following members:
    <ul>
    <li><a name="an626"></a><code>ios::pos_type tellg()</code>:<blockquote><a name="an627"></a>the stream's current (absolute) position where the
stream's next read-operation will take place is returned.</blockquote>
    <li><a name="an628"></a><code>istream &amp;seekg(ios::off_type step, ios::seekdir org)</code>:<blockquote>modifies a stream's actual position. The function expects an
<a name="an629"></a><code>off_type</code> <code>step</code> representing the number of bytes the current stream
position is moved with respect to <code>org</code>. The <code>step</code> value may be negative,
zero or positive.
<p>
The origin of the step, <code>org</code> is a value in the
<a name="an630"></a><code>ios::seekdir</code> enumeration. Its values are:
        <ul>
        <li><a name="an631"></a><code>ios::beg</code>:<blockquote>the stepsize is computed relative to the beginning of the
stream. This value is used by default.
            </blockquote>
        <li><a name="an632"></a><code>ios::cur</code>:<blockquote>the stepsize is computed relative to the current position of the
stream (as returned by <code>tellp</code>).
            </blockquote>
        <li><a name="an633"></a><code>ios::end</code>:<blockquote>the stepsize is interpreted relative to the current end position
of the the stream.</blockquote>
    </ul>
    It is OK to <a name="an634"></a> seek beyond the last file
position.  Seeking before <code>ios::beg</code> raises the <a name="an635"></a><code>ios::failbit</code>
flag.
        </blockquote>
    </ul>
<p>
<a name="IFSTREAM"></a><a name="l101"></a>
<h3>6.5.2: Input from files: the class `ifstream'</h3>
    The <a name="an636"></a><code>std::ifstream</code> class is derived from the <code>istream</code> class:
it has the same capabilities as the <code>istream</code> class, but can be used to
<a name="an637"></a>access files  for reading.
<p>
In order to use the <code>ifstream</code> class  in <strong>C++</strong> sources, the
    <a name="an638"></a><code>&lt;fstream&gt;</code> header file must be included. Including <code>fstream</code> does not
automatically make available the standard streams <code>cin</code>, <code>cout</code> and
<code>cerr</code>. Include <a name="an639"></a><code>iostream</code> to declare these standard streams.
<p>
The following <a name="an640"></a> constructors are available for
<code>ifstream</code> objects:
    <ul>
    <li><code>ifstream object</code>:
        <blockquote>this is the basic constructor. It defines an <code>ifstream</code> object
which may be associated with an actual file later, using its <code>open()</code> member
(see below).
        </blockquote>
    <li><code>ifstream object(char const *name, ios::openmode mode = ios::in)</code>:
        <blockquote>this constructor can be used to define an <code>ifstream</code> object
and associate it immediately with the file named <code>name</code> using input mode
<code>mode</code>. Section <a href="cplusplus06.html#OUTPUTMODES">6.4.2.1</a> provides an overview of available input
modes.  Example:
        <pre>
ifstream in("/tmp/input");
</pre>
            </blockquote>
    </ul>
<p>
Instead of directly associating an <code>ifstream</code> object with a file, the
object can be constructed first, and opened later.
    <ul>
        <li><a name="an641"></a><code>void open(char const *name,
                            ios::openmode mode = ios::in)</code>:<blockquote>associates an <code>ifstream</code> object with an actual file. If the
<code>ios::fail</code> flag was set before calling <code>open</code> and opening succeeds the
flag is cleared. Opening an already open stream fails. To reassociate a stream
with another file it must first be closed:
        <pre>
ifstream in("/tmp/in");
in &gt;&gt; variable;
in.close();        // closes in
in.open("/tmp/in2");
in &gt;&gt; anotherVariable;
</pre>
        </blockquote>
        <li><a name="an642"></a><code>void close()</code>:<blockquote>closes the <code>ifstream</code> object. The function sets the <a name="an643"></a><code>ios::fail</code>
flag of the closed object. Closing the file flushes any buffered information
to the associated file. A file is automatically closed when the associated
<code>ifstream</code> object ceases to exist.
        </blockquote>
        <li><a name="an644"></a><code>bool is_open() const</code>:<blockquote>assume a stream was properly constructed, but it has not yet been
attached to a file. E.g., the statement <code>ifstream ostr</code> was executed. When
we now check its status through <code>good()</code>, a non-zero (i.e., <em>OK</em>) value is
returned.  The `good' status here indicates that the stream object has been
constructed properly. It doesn't mean the file is also open. To test whether a
stream is actually open, <code>is_open</code> should be called. If it returns <a name="an645"></a><code>true</code>,
the stream is open.  Also see the example in section <a href="cplusplus06.html#OFSTREAM">6.4.2</a>. The
following example  illustrates reading from a binary file (see also section
<a href="cplusplus06.html#ISTREAMREAD">6.5.1.1</a>):
        <pre>
    #include &lt;fstream&gt;
    using namespace std;

    int main(int argc, char **argv)
    {
        ifstream in(argv[1]);
        double   value;

        // reads double in raw, binary form from file.
        in.read(reinterpret_cast&lt;char *&gt;(&amp;value), sizeof(double));
    }
</pre>
<p>
</blockquote>
    </ul>
<p>
<a name="ISTRINGSTREAM"></a><a name="l102"></a>
<h3>6.5.3: Input from memory: the class `istringstream'</h3>
    To <a name="an646"></a> read information from memory using
<code>stream</code> facilities, <a name="an647"></a><code>std::istringstream</code> objects should
be used.  As the class <code>istringstream</code> is derived from the class <code>istream</code>
all <code>istream</code>'s facilities are available to <code>istringstream</code> objects as
well. To use and define <code>istringstream</code> objects the header file
<a name="an648"></a><code>&lt;sstream&gt;</code> must be included. In addition the class <code>istringstream</code> offers
the following constructors and members:
    <ul>
        <li><a name="an649"></a><code>istringstream istr(string const &amp;init,
                ios::openmode mode = ios::in)</code>:<blockquote>the object is initialized with <code>init</code>'s contents</blockquote>
        <li><code>istringstream istr(ios::openmode mode = ios::in)</code>
        (this constructor is usually used as the default
         constructor. Example:
        <pre>
std::istringstream in;
</pre>
        )
        <li><a name="an650"></a><code>void str(std::string const &amp;str)</code>:<blockquote>the current object is reinitialized with new initial contents.</blockquote>
    </ul>
    The following example illustrates the use of the <code>istringstream</code> class:
several values are extracted from the object. Such <code>istringstream</code> objects
are most often used for doing `string to type'<a name="an651"></a>
conversions, like converting text to <code>int</code> values (cf. <strong>C</strong>'s <a name="an652"></a><code>atoi</code>
function). Formatting flags can be used with <code>istringstreams</code> as well, as
they are part of the <code>istream</code> class.  In the example note especially the
use of the member <code>seekg</code>:
    <pre>
    #include &lt;iostream&gt;
    #include &lt;sstream&gt;
    using namespace std;

    int main()
    {
        istringstream istr("123 345");  // store some text.
        int x;

        istr.seekg(2);              // skip "12"
        istr &gt;&gt; x;                  // extract int
        cout &lt;&lt; x &lt;&lt; '\n';          // write it out
        istr.seekg(0);              // retry from the beginning
        istr &gt;&gt; x;                  // extract int
        cout &lt;&lt; x &lt;&lt; '\n';          // write it out
        istr.str("666");            // store another text
        istr &gt;&gt; x;                  // extract it
        cout &lt;&lt; x &lt;&lt; '\n';          // write it out
    }
    /*
        output of this program:
    3
    123
    666
    */
</pre>
<p>
<a name="CPSTREAM"></a><a name="l103"></a>
<h3>6.5.4: Copying streams</h3>
    Usually, files are copied <a name="an653"></a> either by reading a source file
character by character or line by line. The basic <em>mold</em> to process streams
 <a name="an654"></a> is as follows:
        <ul>
            <li> Continuous loop:
            <ol>
                <li> read from the stream
                <li> if reading did not succeed (i.e., <code>fail</code> returns
                        <code>true</code>), <code>break</code> from the loop
                <li> process the information that was read
            </ol>
        </ul>
    Note that reading must <em>precede</em> testing, as
it is only possible to know after actually attempting to read from a file
whether the reading succeeded or not. Of course, variations are possible:
<code>getline(istream &amp;, string &amp;)</code> (see section <a href="cplusplus06.html#ISTREAMREAD">6.5.1.1</a>) returns an
<code>istream &amp;</code>, so here reading and testing may be contracted using one
expression. Nevertheless, the above mold represents the general case. So,
the following program may be used to copy <code>cin</code> to <code>cout</code>:
        <pre>
#include &lt;iostream&gt;
using namespace::std;

int main()
{
    while (true)
    {
        char c;

        cin.get(c);
        if (cin.fail())
            break;
        cout &lt;&lt; c;
    }
}
</pre>
<p>
Contraction is possible here by combining <code>get</code> with the
<code>if</code>-statement, resulting in:
        <pre>
    if (!cin.get(c))
        break;
</pre>
    Even so, this would still follow the basic rule:
 `<a name="an655"></a>read first, test later'.
<p>
Simply copying a file isn't required very often. More often a situation is
encountered where a file is processed up to a certain point, followed by plain
copying the file's remaining information. The next program illustrates
this. Using <code>ignore</code> to skip the first line (for the sake of the example it
is assumed that the first line is at most 80 characters long), the second
statement uses yet another overloaded version of the &lt;&lt;-operator, in
which a <a name="an656"></a><code>streambuf</code> pointer <a name="an657"></a> is inserted into
a stream. As the member <code>rdbuf</code> returns a stream's <code>streambuf *</code>, we have
a simple means of inserting a stream's contents into an <code>ostream</code>:
        <pre>
    #include &lt;iostream&gt;
    using namespace std;

    int main()
    {
        cin.ignore(80, '\n');   // skip the first line and...
        cout &lt;&lt; cin.rdbuf();    // copy the rest through the streambuf *
    }
</pre>
<p>
This way of copying streams only assumes the existence of a <code>streambuf</code>
object. Consequently it can be used with all specializations of the
<code>streambuf</code> class.
<p>
<a name="COUPLING"></a><a name="l104"></a>
<h3>6.5.5: Coupling streams</h3>
    Ostream objects <a name="an658"></a> can be <em>coupled</em> to <a name="an659"></a><code>ios</code> objects
using the <a name="an660"></a><code>tie</code> member function. Tying results in flushing the <code>ostream</code>'s
buffer whenever an <a name="an661"></a>input or <a name="an662"></a>output operation is performed on the <code>ios</code>
object to which the <code>ostream</code> object is tied.  By default <a name="an663"></a><code>cout</code> is tied
to <a name="an664"></a><code>cin</code> (using <code>cin.tie(cout)</code>).  This tie means that whenever an
operation on <code>cin</code> is requested, <code>cout</code> is flushed first. To break the
tie, <code>ios::tie(0)</code> can be called. In the example: <code>cin.tie(0)</code>.
<p>
Another useful coupling of streams is shown by the tie between <a name="an665"></a><code>cerr</code> and
<a name="an666"></a><code>cout</code>. Because of the tie standard output and error messages written to the
screen are shown in sync with the time at which they were generated:
    <pre>
    #include &lt;iostream&gt;
    using namespace std;

    int main()
    {
        cerr.tie(0);        // untie
        cout &lt;&lt; "first (buffered) line to cout ";
        cerr &lt;&lt; "first (unbuffered) line to cerr\n";
        cout &lt;&lt; "\n";

        cerr.tie(&amp;cout);    // tie cout to cerr
        cout &lt;&lt; "second (buffered) line to cout ";
        cerr &lt;&lt; "second (unbuffered) line to cerr\n";
        cout &lt;&lt; "\n";
    }
    /*
        Generated output:

        first (unbuffered) line to cerr
        first (buffered) line to cout
        second (buffered) line to cout second (unbuffered) line to cerr
    */
</pre>
<p>
An alternative way to couple streams is to make streams use a common
<code>streambuf</code> object. This can be implemented using the <a name="an667"></a>
<code>ios::rdbuf(streambuf *)</code> member function. This way two streams can use,
e.g. their own formatting, one stream can be used for input, the other for
output, and redirection using the stream library rather than operating
system calls can be implemented. See the next sections for examples.
<p>
<a name="ADVANCEDIO"></a><a name="l105"></a>
<h2>6.6: Advanced topics</h2>
<p>
<a name="l106"></a>
<h3>6.6.1: Moving streams</h3>
    Stream classes (e.g.,, all stream classes covered in this chapter)
are movable and can be swapped. This implies that factory functions can be
designed for stream classes. Here is an example:
        <pre>
    ofstream out(string const &amp;name)
    {
        ofstream ret(name);             // construct ofstream
        return ret;                     // return value optimization, but
    }                                   // OK as moving is supported
    
    int main()
    {
        ofstream mine(out("out"));      // return value optimizations, but
                                        // OK as moving is supported

        ofstream base("base");
        ofstream other;

        base.swap(other);               // swapping streams is OK

        other = std::move(base);        // moving streams is OK

        // other = base;                // this would ail: copy assignment
                                        // is not available for streams
    }
</pre>
<p>
<a name="REDIR"></a><a name="l107"></a>
<h3>6.6.2: Redirecting streams</h3>
    Using <a name="an668"></a><code>ios::rdbuf</code> streams can be forced to share their
<code>streambuf</code> objects. Thus information written to one
stream is actually written to another stream; a phenomenon normally
called <a name="an669"></a><em>redirection</em>. Redirection is commonly implemented at the
operating system level, and sometimes that is still necessary (see
section <a href="cplusplus24.html#REDIRECTION">24.2.3</a>).
<p>
A common situation where redirection is useful is when error messages should
be written to file rather than to the standard error stream, usually indicated
by its <a name="an670"></a>file descriptor number 2. In the <a name="an671"></a>Unix operating system using the
<a name="an672"></a><code>bash</code> shell, this can be realized as follows:
        <pre>
    program 2&gt;/tmp/error.log
</pre>
    Following this command any error messages written by <code>program</code> are
saved on the file <code>/tmp/error.log</code>, instead of appearing on the screen.
<p>
Here is an example showing how this can be implemented using <code>streambuf</code>
objects. Assume <code>program</code> expects an argument defining the name
of the file to write the error messages to. It could be called as follows:
        <pre>
    program /tmp/error.log
</pre>
    The program looks like this, an explanation is provided below the
program's source text:
        <pre>
    #include &lt;iostream&gt;
    #include &lt;fstream&gt;
    using namespace std;

    int main(int argc, char **argv)
    {
        ofstream errlog;                                // 1
        streambuf *cerr_buffer = 0;                     // 2

        if (argc == 2)
        {
            errlog.open(argv[1]);                       // 3
            cerr_buffer = cerr.rdbuf(errlog.rdbuf());   // 4
        }
        else
        {
            cerr &lt;&lt; "Missing log filename\n";
            return 1;
        }

        cerr &lt;&lt; "Several messages to stderr, msg 1\n";
        cerr &lt;&lt; "Several messages to stderr, msg 2\n";

        cout &lt;&lt; "Now inspect the contents of " &lt;&lt;
                argv[1] &lt;&lt; "... [Enter] ";
        cin.get();                                      // 5

        cerr &lt;&lt; "Several messages to stderr, msg 3\n";

        cerr.rdbuf(cerr_buffer);                        // 6
        cerr &lt;&lt; "Done\n";                               // 7
    }
    /*
        Generated output on file argv[1]

        at cin.get():

    Several messages to stderr, msg 1
    Several messages to stderr, msg 2

        at the end of the program:

    Several messages to stderr, msg 1
    Several messages to stderr, msg 2
    Several messages to stderr, msg 3
    */
</pre>
<p>
<ul>
    <li> At lines 1-2 local variables are defined: <code>errlog</code> is the
<code>ofstream</code> to write the error messages too, and <code>cerr_buffer</code> is a pointer
to a <code>streambuf</code>, to point to the original <code>cerr</code> buffer.
    <li> At line 3  the alternate error stream is opened.
    <li> At line 4  redirection takes place: <code>cerr</code> now writes to
the <code>streambuf</code> defined by <code>errlog</code>. It is important that
the original buffer used by <code>cerr</code> is saved, as explained below.
    <li> At line 5  we pause. At this point, two lines were written to
the alternate error file. We get a chance to take a look at its contents:
there were indeed two lines written to the file.
    <li> At line 6  the redirection is terminated. This is very important, as
the <code>errlog</code> object is destroyed at the end of <code>main</code>. If <code>cerr</code>'s
buffer would not have been restored, then at that point
<code>cerr</code> would refer to a non-existing <code>streambuf</code> object, which might
produce unexpected results. It is the responsibility of the programmer to
make sure that an original <code>streambuf</code> is saved before redirection, and is
restored when the redirection ends.
    <li> Finally, at line 7, <code>Done</code> is again written to the screen, as
the redirection has been terminated.
    </ul>
<p>
<a name="FSTREAM"></a><a name="l108"></a>
<h3>6.6.3: Reading AND Writing streams</h3>
    In order to both read and write to a stream
    <a name="an673"></a> an <a name="an674"></a><code>std::fstream</code> object must be
created.  As with <code>ifstream</code> and <code>ofstream</code> objects, its constructor
receives the name of the file to be opened:
        <pre>
        fstream inout("iofile", ios::in | ios::out);
</pre>
    Note the use of the constants <a name="an675"></a><code>ios::in</code> and <a name="an676"></a><code>ios::out</code>,
indicating that the file must be opened for both reading and writing. Multiple
mode indicators may be used, concatenated by the <code>bitor</code> operator.
Alternatively, instead of <code>ios::out</code>, <a name="an677"></a><code>ios::app</code> could have been
used and mere writing would become appending (at the end of the file).
<p>
Reading and writing to the same file is always a bit awkward: what to do
when the file may not yet exist, but if it already exists it should not
be rewritten? Having fought with this problem for some time I now use
the following approach:
    <pre>
    #include &lt;fstream&gt;
    #include &lt;iostream&gt;
    #include &lt;string&gt;

    using namespace std;

    int main()
    {
        fstream rw("fname", ios::out | ios::in);

        if (!rw)            // file didn't exist yet
        {
            rw.clear();     // try again, creating it using ios::trunc
            rw.open("fname", ios::out | ios::trunc | ios::in);
        }

        if (!rw)            // can't even create it: bail out
        {
            cerr &lt;&lt; "Opening `fname' failed miserably" &lt;&lt; '\n';
            return 1;
        }

        cerr &lt;&lt; "We're at: " &lt;&lt; rw.tellp() &lt;&lt; '\n';

                            // write something
        rw &lt;&lt; "Hello world" &lt;&lt; '\n';

        rw.seekg(0);        // go back and read what's written

        string s;
        getline(rw, s);

        cout &lt;&lt; "Read: " &lt;&lt; s &lt;&lt; '\n';
    }
</pre>
<p>
Under this approach if the first construction attempt fails <code>fname</code>
doesn't exist yet. But then <code>open</code> can be attempted using the
<a name="an678"></a><code>ios::trunc</code> flag. If the file already existed, the construction
would have succeeded. By specifying <a name="an679"></a><code>ios::ate</code> when defining <code>rw</code>,
the initial read/write action would by default have taken place at
<code>EOF</code>.
<p>
Under <a name="an680"></a> <a name="an681"></a> <strong>DOS</strong>-like operating systems that use the
multiple character sequence <code>\r\n</code> to separate lines in <a name="an682"></a>text files the
flag <a name="an683"></a><code>ios::binary</code> is required to process <a name="an684"></a>binary files ensuring
that <code>\r\n</code> combinations are processed as two characters. In general,
<code>ios::binary</code> should be specified when binary (non-text) files are to be
processed. By default files are opened as text files. <a name="an685"></a>Unix operating
systems do not distinguish text files from binary files.
<p>
With <code>fstream</code> objects, combinations of file flags are used to make sure
that a stream is or is not (re)created empty when opened. See section
<a href="cplusplus06.html#OUTPUTMODES">6.4.2.1</a> for details.
<p>
Once a file has been opened in read and write mode, the &lt;&lt; operator
can be used to insert information into the file, while the &gt;&gt; operator
may be used to extract information from the file. These operations may be
performed in any order, but a <code>seekg</code> or <code>seekp</code> operation is required
when switching between insertions and extractions. The seek operation is used
to activate the stream's data used for reading or those used for writing (and
<em>vice versa</em>). The <code>istream</code> and <code>ostream</code> parts of <code>fstream</code> objects
share the stream's data buffer and by performing the seek operation the stream
either activates its <code>istream</code> or its <code>ostream</code> part. If the seek is
omitted, reading after writing and writing after reading simply fails. The
example shows a white space delimited word being read from a file, writing
another string to the file, just beyond the point where the just read word
terminated. Finally yet another string is read which is found just beyond the
location where the just written strings ended:
        <pre>
    fstream f("filename", ios::in | ios::out);
    string  str;

    f &gt;&gt; str;       // read the first word

                    // write a well known text
    f.seekg(0, ios::cur);
    f &lt;&lt; "hello world";

    f.seekp(0, ios::cur);
    f &gt;&gt; str;       // and read again
</pre>
    Since a <em>seek</em> or <em>clear</em> operation is required when alternating
between read and write (extraction and insertion) operations on the same file
it is not possible to execute a series of &lt;&lt; and &gt;&gt; operations in
one expression statement.
<p>
Of course, random insertions and extractions are hardly ever used. Generally,
insertions and extractions occur at well-known locations in a file.  In those
cases, the position where insertions or extractions are required can be
controlled and monitored by the <code>seekg</code>, <code>seekp, tellg</code> and <code>tellp</code>
members (see sections <a href="cplusplus06.html#OSTREAMPOS">6.4.1.2</a> and <a href="cplusplus06.html#ISTREAMPOS">6.5.1.2</a>).
<p>
Error conditions (see section <a href="cplusplus06.html#IOSTATES">6.3.1</a>) occurring due to, e.g., reading
beyond end of file, reaching end of file, or positioning before begin of file,
can be cleared by the <code>clear</code> member function.  Following <code>clear</code>
processing may continue. E.g.,
        <pre>
    fstream f("filename", ios::in | ios::out);
    string  str;

    f.seekg(-10);   // this fails, but...
    f.clear();      // processing f continues

    f &gt;&gt; str;       // read the first word
</pre>
    A situation where files are both read and written is seen in
    <em>database</em> applications, using files consisting of records having fixed
sizes, and where locations and sizes of pieces of information are known. For
example, the following program adds text lines to a (possibly existing)
file. It can also be used to retrieve a particular line, given its
order-number in the file. A <a name="an686"></a><em>binary file</em> <code>index</code> allows for the quick
retrieval of the location of lines.
        <pre>
    #include &lt;iostream&gt;
    #include &lt;fstream&gt;
    #include &lt;string&gt;
    #include &lt;climits&gt;
    using namespace std;

    void err(char const *msg)
    {
        cout &lt;&lt; msg &lt;&lt; '\n';
    }

    void err(char const *msg, long value)
    {
        cout &lt;&lt; msg &lt;&lt; value &lt;&lt; '\n';
    }

    void read(fstream &amp;index, fstream &amp;strings)
    {
        int idx;

        if (!(cin &gt;&gt; idx))                          // read index
        {
            cin.clear();                            // allow reading again
            cin.ignore(INT_MAX, '\n');              // skip the line
            return err("line number expected");
        }

        index.seekg(idx * sizeof(long));            // go to index-offset

        long offset;

        if
        (
            !index.read                             // read the line-offset
            (
                reinterpret_cast&lt;char *&gt;(&amp;offset),
                sizeof(long)
            )
        )
            return err("no offset for line", idx);

        if (!strings.seekg(offset))                 // go to the line's offset
            return err("can't get string offset ", offset);

        string line;

        if (!getline(strings, line))                // read the line
            return err("no line at ", offset);

        cout &lt;&lt; "Got line: " &lt;&lt; line &lt;&lt; '\n';       // show the line
    }

    void write(fstream &amp;index, fstream &amp;strings)
    {
        string line;

        if (!getline(cin, line))                  // read the line
            return err("line missing");

        strings.seekp(0, ios::end);               // to strings
        index.seekp(0, ios::end);                 // to index

        long offset = strings.tellp();

        if
        (
            !index.write                          // write the offset to index
            (
                reinterpret_cast&lt;char *&gt;(&amp;offset),
                sizeof(long)
            )
        )
            return err("Writing failed to index: ", offset);

        if (!(strings &lt;&lt; line &lt;&lt; '\n'))           // write the line itself
            return err("Writing to `strings' failed");
                                                  // confirm writing the line
        cout &lt;&lt; "Write at offset " &lt;&lt; offset &lt;&lt; " line: " &lt;&lt; line &lt;&lt; '\n';
    }

    int main()
    {
        fstream index("index", ios::trunc | ios::in | ios::out);
        fstream strings("strings", ios::trunc | ios::in | ios::out);

        cout &lt;&lt; "enter `r &lt;number&gt;' to read line &lt;number&gt; or "
                                    "w &lt;line&gt;' to write a line\n"
                "or enter `q' to quit.\n";

        while (true)
        {
            cout &lt;&lt; "r &lt;nr&gt;, w &lt;line&gt;, q ? ";       // show prompt

            index.clear();
            strings.clear();

            string cmd;
            cin &gt;&gt; cmd;                             // read cmd

            if (cmd == "q")                         // process the cmd.
                return 0;

            if (cmd == "r")
                read(index, strings);
            else if (cmd == "w")
                write(index, strings);
            else if (cin.eof())
            {
                cout &lt;&lt; "\n"
                        "Unexpected end-of-file\n";
                return 1;
            }
            else
                cout &lt;&lt; "Unknown command: " &lt;&lt; cmd &lt;&lt; '\n';
        }
    }
</pre>
<p>
Another example showing reading <em>and</em> writing of files is provided by
the next program. It also illustrates the processing of NTB strings:
        <pre>
    #include &lt;iostream&gt;
    #include &lt;fstream&gt;
    using namespace std;

    int main()
    {                                       // r/w the file
        fstream f("hello", ios::in | ios::out | ios::trunc);

        f.write("hello", 6);                // write 2 NTB strings
        f.write("hello", 6);

        f.seekg(0, ios::beg);               // reset to begin of file

        char buffer[100];                   // or: char *buffer = new char[100]
        char c;
                                            // read the first `hello'
        cout &lt;&lt; f.get(buffer, sizeof(buffer), 0).tellg() &lt;&lt; '\n';
        f &gt;&gt; c;                             // read the NTB delim

                                            // and read the second `hello'
        cout &lt;&lt; f.get(buffer + 6, sizeof(buffer) - 6, 0).tellg() &lt;&lt; '\n';

        buffer[5] = ' ';                    // change asciiz to ' '
        cout &lt;&lt; buffer &lt;&lt; '\n';             // show 2 times `hello'
    }
    /*
        Generated output:
    5
    11
    hello hello
    */
</pre>
<p>
A completely different way to read and write streams may be implemented
using <code>streambuf</code> members. All considerations mentioned so far remain valid
(e.g., before a read operation following a write operation <code>seekg</code> must be
used). When  <code>streambuf</code> objects are used, either an
<code>istream</code> is associated with the <code>streambuf</code> object of another <code>ostream</code>
object, or an <code>ostream</code> object is associated with the
<code>streambuf</code> object of another <code>istream</code> object. Here is the previous
program again, now using
    <a name="an687"></a> <em>associated streams</em>:
        <pre>
    #include &lt;iostream&gt;
    #include &lt;fstream&gt;
    #include &lt;string&gt;
    using namespace std;

    void err(char const *msg);      // see earlier example
    void err(char const *msg, long value);

    void read(istream &amp;index, istream &amp;strings)
    {
        index.clear();
        strings.clear();

        // insert the body of the read() function of the earlier example
    }


    void write(ostream &amp;index, ostream &amp;strings)
    {
        index.clear();
        strings.clear();

        // insert the body of the write() function of the earlier example
    }

    int main()
    {
        ifstream index_in("index", ios::trunc | ios::in | ios::out);
        ifstream strings_in("strings", ios::trunc | ios::in | ios::out);
        ostream  index_out(index_in.rdbuf());
        ostream  strings_out(strings_in.rdbuf());

        cout &lt;&lt; "enter `r &lt;number&gt;' to read line &lt;number&gt; or "
                                    "w &lt;line&gt;' to write a line\n"
                "or enter `q' to quit.\n";

        while (true)
        {
            cout &lt;&lt; "r &lt;nr&gt;, w &lt;line&gt;, q ? ";       // show prompt

            string cmd;

            cin &gt;&gt; cmd;                             // read cmd

            if (cmd == "q")                         // process the cmd.
                return 0;

            if (cmd == "r")
                read(index_in, strings_in);
            else if (cmd == "w")
                write(index_out, strings_out);
            else
                cout &lt;&lt; "Unknown command: " &lt;&lt; cmd &lt;&lt; '\n';
        }
    }
</pre>
<p>
In this example
    <ul>
    <li> the streams associated with the <code>streambuf</code> objects of existing
streams are not <a name="an688"></a><code>ifstream</code> or <a name="an689"></a><code>ofstream</code> objects but basic <a name="an690"></a><code>istream</code> and
<a name="an691"></a><code>ostream</code> objects.
    <li> The <code>streambuf</code> object is not defined by an <code>ifstream</code> or
<code>ofstream</code> object. Instead it is defined outside of the streams, using
a <code>filebuf</code> (cf. section <a href="cplusplus14.html#FILEBUF">14.8.2</a>) and constructions like:
        <pre>
filebuf fb("index", ios::in | ios::out | ios::trunc);
istream index_in(&amp;fb);
ostream index_out(&amp;fb);
</pre>
    <li> An <code>ifstream</code> object can be constructed using stream modes normally
used with <code>ofstream</code> objects. Conversely, an <code>ofstream</code> objects can be
constructed using stream modes normally used with <code>ifstream</code> objects.
    <li> If <code>istream</code> and <code>ostreams</code> share a <code>streambuf</code>, then their
read and write pointers (should) point to the shared buffer: they are tightly
coupled.
    <li> The advantage of using an external (separate) <code>streambuf</code> over a
predefined <code>fstream</code> object is (of course) that it opens the possibility of
using <code>stream</code> objects with specialized <code>streambuf</code> objects. These
<code>streambuf</code> objects may specifically be constructed to control and interface
particular devices. Elaborating this (see also section <a href="cplusplus14.html#STREAMBUF">14.8</a>) is left
as an exercise to the reader.
    </ul>
<p>

<hr>
<ul>
    <li> <a href="cplusplus.html">Table of Contents</a>
    <li> <a href="cplusplus05.html">Previous Chapter</a>
    <li> <a href="cplusplus07.html">Next Chapter</a>
</ul>
<hr>
</body>
</html>
