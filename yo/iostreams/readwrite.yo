In order to both i(read and write to a stream) an ti(fstream) object
must be created.  As with tt(ifstream) and tt(ofstream) objects, its
constructor receives the name of the file to be opened:
        centt(fstream inout("iofile", ios::in | ios::out);)
    Note the use of the ti(ios) constants ti(ios::in) and ti(ios::out),
indicating that the file must be opened for both reading and writing. Multiple
mode indicators may be used, concatenated by the binary or operator tt('|').
Alternatively, instead of tt(ios::out), ti(ios::app) could have been used, in
which case writing will always be done at the end of the file.

    Somehow reading and writing to a file is a bit awkward: what to do when
the file may or may not exist yet, but if it already exists it should not be
rewritten? hi(fstream: reading and writing)
    hi(reading and writing fstreams)
    I have been fighting with this problem for some time, and now I use
the following approach:
    verbinclude(iostreams/examples/existingreadwrite.cc)
    In the above example, the constructor fails when tt(fname) doesn't exist
yet. However, in that case the tt(open()) member will normally succeed since
the file is created due to the tt(ios::trunc) flag. If the file already
existed, the constructor will succeed. If the ti(ios::ate) flag would have
been specified as well with tt(rw)'s initial construction, the first
read/write action would by default have take place at endOfFile(). However,
tt(ios::ate) is not ti(ios::app), so it would then still have been possible to
repositioned tt(rw) using tt(seekg()) or tt(seekp()).

Under hi(MS-DOS) hi(MS-WINDOWS) hi(DOS) hi(WINDOWS) bf(DOS)-like operating
systems, using the multiple character tt(\r\n) sentinels to separate lines in
i(text files) the flag ti(ios::binary) is required for processing 
        i(binary files) 
    to ensure that tt(\r\n) combinations are processed as two
characters. In general, tt(ios::binary) should be usd when binary (non-text)
files are to be processed. Text files are assumed when tt(ios::binary) is not
specified. This will leave the proper handling of line-endings to the run-time
support system.

With tt(fstream) objects, combinations of file flags are used to make sure
that a stream is or is not (re)created empty when opened. See section
ref(OUTPUTMODES) for details.

    Once a file has been opened in read and write mode, the lshift() operator
can be used to insert information into the file, while the rshift() operator
may be used to extract information from the file. These operations may be
performed in any order, but a tt(seekg()) or tt(seekp()) operation is required
when switching between insertions and extractions.  The following fragment
will read a blank-delimited word from the file, and will then write a string
to the file, just beyond the point where the string just read terminated,
followed by the reading of yet another string just beyond the location where
the string just written ended (assuming that the file tt(filename) contains
enough information for the extractions to succeed):
        verb(
    fstream f("filename", ios::in | ios::out);
    string  str;

    f >> str;       // read the first word
                    // write a well known text

    f.seekg(0, ios::cur);
    f << "hello world";

    f.seekp(0, ios::cur);
    f >> str;       // and read again
        )
    Since a em(seek) or em(clear) operation is required between alternating
read and write (extraction and insertion) operations on the same file it is
not possible to execute a series of lshift() and rshift() operations in one
expression statement.

Of course, random insertions and extractions are hardly ever used. Generally,
insertions and extractions take place at specific locations in the file.  In
those cases, the position where the insertion or extraction must take place
can be controlled and monitored by the ti(seekg()), ti(seekp()), ti(tellg())
and ti(tellp()) member functions (see sections ref(OSTREAMPOS) and
ref(ISTREAMPOS)).

Error conditions (see section ref(IOSTATES)) occurring due to, e.g., reading
beyond end of file, reaching end of file, or positioning before begin of file,
can be cleared using the ti(clear()) member function.  Following tt(clear())
processing may continue. E.g.,
        verb(
    fstream f("filename", ios::in | ios::out);
    string  str;

    f.seekg(-10);   // this fails, but...
    f.clear();      // processing f continues

    f >> str;       // read the first word
        )
    A common situation in which files are both read and written occurs in
    emi(database) applications, where files consists of records of fixed
size, and where the location and size of pieces of information is well
known. For example, the following program may be used to add lines of text to
a (possibly existing) file, and to retrieve a certain line, based on its
order-number from the file. Note the use of the emi(binary file) tt(index) to
retrieve the location of the first byte of a line.
        verbinclude(iostreams/examples/readwrite.cc)
    As another example of reading and writing files, consider the following
program, which also serves as an illustration of reading an i(ASCII-Z)
delimited string:
        verbinclude(iostreams/examples/asciiz.cc)

    A completely different way to both read and write to streams can be
implemented using the ti(streambuf) members of stream objects. All
considerations mentioned so far remain valid: before a read operation
following a write operation tt(seekg()) must be used, and before a write
operation following a read operation tt(seekp()) must be used. When the
stream's tt(streambuf) objects are used, either an tt(istream) is associated
with the tt(streambuf) object of another tt(ostream) object, or em(vice
versa), an tt(ostream) object is associated with the tt(streambuf) object of
another tt(istream) object. Here is the same program as before, now using
    hi(streams: associating) em(associated streams):
        verbinclude(iostreams/examples/readwrite2.cc)
    Please note:
    itemization(
    it() The streams to associate with the tt(streambuf) objects of
existing streams are not ti(ifstream) or ti(ofstream) objects (or, for that
matter, tt(istringstream) or tt(ostringstream) objects), but basic
ti(istream) and ti(ostream) objects.
    it() The tt(streambuf) object does not have to be defined in an
tt(ifstream) or ti(ofstream) object: it can be defined outside of the streams,
using constructions like:
        verb(
    filebuf fb("index", ios::in | ios::out | ios::trunc);
    istream index_in(&fb);
    ostream index_out(&fb);
        )
    it() Note that an tt(ifstream) object can be constructed using stream
modes normally used for writing to files. Conversely, tt(ofstream) objects can
be constructed using stream modes normally used for reading from files.
    it() If tt(istream) and tt(ostreams) are associated through a common
tt(streambuf), then the read and write pointers (should) point to the same
locations: they are tightly coupled.
    it() The advantage of using a separate tt(streambuf) over a predefined
tt(fstream) object is (of course) that it opens the possibility of using
tt(stream) objects with specialized tt(streambuf) objects. These tt(streambuf)
objects may then specifically be constructed to interface particular
devices. Elaborating this is left as an i(exercise) to the reader.
    )
