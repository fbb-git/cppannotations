As an extension to the standard stream (ti(FILE)) approach, well known from the
bf(C) programming language, bf(C++) offers an em(input/output) (i(I/O))
library hi(I/O library) based on tt(class) concepts.

Earlier (in chapter ref(FirstImpression)) we've already seen examples of the
use of the bf(C++) I/O library, especially the use of the insertion
operator (lshift()) and the extraction operator (rshift()).
In this chapter we'll cover the library in more detail.

The discussion of input and output facilities provided by the bf(C++)
programming language heavily uses the tt(class) concept, and the notion of
member functions. Although the construction of classes will be covered in the
upcoming chapter ref(Classes), and em(inheritance) will formally be introduced
in chapter ref(INHERITANCE), we think it is quite possible to introduce input
and output (I/O) facilities long before the technical background of
these topics is actually covered.

Most bf(C++) I/O classes have names starting with ti(basic_) (like
tt(basic_ios)). However, these ti(basic_) names are not regularly found in
bf(C++) programs, as most classes are also defined using ti(typedef)
definitions like:
        centt(typedef basic_ios<char>       ios;)
    Since bf(C++) defines both the ti(char) and ti(wchar_t) types, I/O
facilities were developed using the emi(template) mechanism. As will be
further elaborated in chapter ref(TEMPLATES), this way it was possible to
construct i(generic software), which could thereupon be used for both the
tt(char) and tt(wchar_t) types. So, analogously to the above tt(typedef) there
exists a
        centt(typedef basic_ios<wchar_t>    wios;)
    This type definition can be used for the tt(wchar_t) type. Because of the
existence of these type definitions, the tt(basic_) prefix can be omitted from
the Annotations without loss of continuity. In the Annotations the emphasis is
primarily on the standard 8-bits tt(char) type.

    As a i(side effect) to this implementation it must be stressed that it is
em(not) anymore correct to declare iostream objects using standard
    i(forward declarations), like:
        verb(
    class ostream;          // now erroneous
        )
    Instead, sources that must i(declare iostream classes) must
    hi(#include <iosfwd>)
        verb(
    #include <iosfwd>       // correct way to declare iostream classes
        )

    Using the bf(C++) I/O library offers the additional advantage of
    emi(type safety). Objects (or plain values) are inserted into
streams. Compare this to the situation commonly encountered in bf(C) where the
ti(fprintf()) function is used to indicate by a format string what kind of
value to expect where. Compared to this latter situation bf(C++)'s
em(iostream) approach immediately uses the objects where their values should
appear, as in
        verb(
    cout << "There were " << nMaidens << " virgins present\n";
        )
The compiler notices the type of the tt(nMaidens) variable, inserting
its proper value at the appropriate place in the sentence inserted into
the tt(cout) iostream.

Compare this to the situation encountered in bf(C). Although bf(C) compilers
are getting smarter and smarter over the years, and although a well-designed
bf(C) compiler may warn you for a mismatch between a format specifier and the
type of a variable encountered in the corresponding position of the argument
list of a ti(printf()) statement, it can't do much more than em(warn) you.
The em(type safety) seen in bf(C++) em(prevents) you from making type
mismatches, as there are no types to match.

Apart from this, em(iostreams) offer more or less the same set of
possibilities as the standard tt(FILE)-based I/O used in bf(C): files can be
opened, closed, positioned, read, written, etc.. In bf(C++) the basic tt(FILE)
structure, as used in bf(C), is still available. bf(C++) adds I/O based on
classes to tt(FILE)-based I/O, resulting in type safety, extensibility, and a
clean design. In the i(ANSI/ISO) standard the intent was to construct
architecture independent I/O. Previous implementations of the iostreams
library did not always comply with the standard, resulting in many extensions
to the standard. Software developed earlier may have to be partially rewritten
with respect to I/O. This is tough for those who are now forced to modify
existing software, but every feature and extension that was available in
previous implementations can be reconstructed easily using the ANSI/ISO
standard conforming I/O library. Not all of these re-implementations
can be covered in this chapter, as most use inheritance and polymorphism,
topics that will be covered in chapters ref(INHERITANCE) and
ref(POLYMORPHISM), respectively. Selected re-implementations will be provided
in chapter ref(CONCRETE), and below references to particular sections in that
chapter will be given where appropriate.
        figure(iostreams/ioclasses)(Central I/O Classes)(IOCLASSESFIG)
This chapter is organized as follows (see also fig(IOCLASSESFIG)):
    itemization(
        it() The tt(class) ti(ios_base) is the foundation upon which the
iostreams I/O library was built. It defines the core of all I/O operations and
offers, among other things, facilities for inspecting the
    i(state of I/O streams) and for
    i(output formatting).
        it() The class ti(ios) was directly derived from tt(ios_base). Every
class of the I/O library doing input or output is em(derived) from this
tt(ios) class, and em(inherits) its (and, by implication, tt(ios_base)'s)
capabilities. The reader is urged to keep this feature in mind while reading
this chapter. The concept of inheritance is not discussed further here, but
rather in chapter ref(INHERITANCE).

An important function of the class tt(ios) is to define the communication with
the emi(buffer) that is used by streams. The buffer is a ti(streambuf) object
(or is derived from the class tt(streambuf)) and is responsible for the actual
input and/or output. This means that tt(iostream) objects do not perform
input/output operations themselves, but leave these to the (stream)buffer
objects with which they are associated.
        it() Next, basic bf(C++) output facilities are discussed. The basic
class used for output is ti(ostream), defining the i(insertion operator) as
well as other facilities for writing information to streams. Apart from
inserting information into files it is possible to insert information into
i(memory buffers), for which the ti(ostringstream) class is
available. Formatting of the output is to a great extent possible using the
facilities defined in the tt(ios) class, but it is also possible to
    emi(insert formatting commands) directly into streams using
    emi(manipulators). This aspect of bf(C++) output is discussed as well.
        it() Basic bf(C++) input facilities are available in the ti(istream)
class. This class defines the i(extraction operator) and related facilities for
input. Analogous to the tt(ostringstream) a class ti(istringstream) class is
available to extract information from memory buffers.
        it() Finally, several advanced I/O-related topics are discussed:
other topics, i(combined reading and writing using streams) and
    i(mixing bf(C) and bf(C++) I/O) using ti(filebuf) ojects. Other I/O
related topics are covered elsewhere in the Annotations, e.g., in chapter
ref(CONCRETE).
    )
    In the iostream library the stream objects have a limited role: they form
the interface between, on the one hand, the objects to be input or output and,
on the other hand, the tt(streambuf), which is responsible for the actual
input and output to the i(device) for which the tt(streambuf) object was
created in the first place. This approach allows us to construct a new kind of
tt(streambuf) for a new kind of device, and use that streambuf in combination
with the `good old' tt(istream)- or tt(ostream)-class facilities. It is
important to understand the distinction between the formatting roles of the
iostream objects and the buffering interface to an external device as
implemented in a tt(streambuf). Interfacing to new devices (like emi(sockets)
or emi(file descriptors)) requires us to construct a new kind of tt(streambuf),
not a new kind of tt(istream) or tt(ostream) object. A emi(wrapper class) may
be constructed around the tt(istream) or tt(ostream) classes, though, to ease
the access to a special device. This is how the stringstream classes were
constructed.
