    The C++0x standard offers a series of i(mutex) classes to protect shared
data.  Before using mutexes the tthi(mutex) header file must have been
included.

Mutexes should be used when multiple threads needs access to common data to
prevent data corruption. For (a very simple) example, unless mutexes are used
the following could happen when two threads access a common int variable (a
emi(context switch) occurs when the operating system switches between
threads. With a mult-processor system the threads can really be executed
in parallel. To keep the example simple, assume multi threading is used on a
single-core computer, switching between multi-threads):
        verb(
Time step:    Thread1:      var        Thread2:        description
---------------------------------------------------------------------------
    0                        5
    1           starts                                  T1 active
    2           writes var                              T1 commences writing
    3           stopped                                 Context switch
    4                                   starts          T2 active
    5                                   writes var      T2 commences writing
    6                       10          assigns 10      T2 writes 10
    7                                   stopped         Context switch
    8           assigns 12                              T1 writes 12
    9                       12
----------------------------------------------------------------------------
    )
    The above is just a very simple illustration of what may go wrong when
multiple threads access the same data without using mutexes. Thread 2 clearly
thinks (and may proceed on the assumption) that tt(var) equals 10, but after
step 9 tt(var) holds the value 12. Mutexes are used to prevent these kinds of
problems by using data `atomic': as long as a thread holds a mutex for the
data it is operating on, other threads cannot access the data. All this
depends on cooperation between the threads, however. If thread 1 uses mutexes,
but thread 2 doesn't then thread 2 may access the common data any which way it
wants to. Of course that's bad practice, and mutexes allow us to write program
not behaving badly in this respect. It is stressed here that although using
mutexes is the programmer's responsibility, their implementation isn't. A
user-program is unable to accomplish the locking atomicity mutexes offer. The
bottom line is that if we try to implement a mutex-like facility in our
programs then each statement will be compiled into several machine
instructions and in between each of these instructions the operating system
may do a context switch, rendering the instructions non-atomic.  Mutexes offer
the required atomicity and when requesting a mutex-lock the thread is
suspended (i.e., the mutex statement does not return) until the lock has been
obtained by the thread.  More information about mutexes can be found in the
link(mentioned O'Reilly book)(PTHREADS) and in general in the extensive
literature on this topic. It is not a topic that is discussed further in the
annotations(). The available facilities for using mutexes, however, em(are)
covered in this section.

Apart from the tt(std::mutex) class hi(recursive_mutex)
tt(std::recursive_mutex) is offered.  When a tt(recursive_mutex) is called
multiple times by the same thread it will increase its lock-count. Before
other threads may access the protected data the recursive mutex must be
unlocked again that number of times. In addition the classes hi(timed_mutex)
tt(std::timed_mutex) and
 hi(recursive_timed_mutex)tt(std::recursive_timed_mutex) are available. Their
locks will (also) expire after a preset amount of time.

    In many situations locks will be released at the end of some action
block. To simplify locking additional template classes
 hi(unique_lock) tt(std::unique_lock<>) and hi(lock_guard)
tt(std::lock_guard<>) are provided. As their constructors lock the data and
their destructors unlock the data they can be defined as local variables,
unlocking their data once their scope terminates.  Here is a simple example
showing the use of a tt(lock_guard). Once tt(safeProcess) ends tt(guard) is
destroyed, thereby releasing the lock on tt(data):
        verb(
    std::mutex dataMutex;
    Data data;

    void safeProcess()
    {
        std::lock_guard<std::mutex> guard(dataMutex);
        process(data);
    }
        )
    tt(Unique_lock) is used similarly, but is used when timeouts must be
considered as well. So a tt(unique_lock) not only returns when the lock is
obtained but also after a specified amount of time:
        verb(
    std::timed_mutex dataMutex;
    Data data;

    void safeProcess()
    {
        std::unique_lock<std::timed_mutex>
            guard(dataMutex, std::chrono::milliseconds(3));
        if (guard)
            process(data);
    }
        )
    In the above example tt(guard) tries to obtain the lock during three
milliseconds. If tt(guard)'s tt(operator bool) returns tt(true) the lock was
obtained and tt(data) can be processed safely.
