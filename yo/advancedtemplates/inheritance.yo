Now that tt(Conversion) has be defined it's easy to determine whether a type
tt(Base) is a (public) base class of a type tt(Derived). To determine
inheritance convertability of (const) pointers is examined. tt(Derived const
*) can be converted to tt(Base const *) if:
    itemization(
    it() Both types are identical;
    it() tt(Base) is a public and unambiguous base class of tt(Derived);
    it() and also, but usually not intended: if tt(Base) is void.
    )
    Preventing the latter, inheritance is determined by inspecting
tt(Conversion<Derived const *, Base const *>::exists):
    COMMENT(Can't use verbinsert here because of the trailing \ (BSSP)
            Do not remove the blanks following the backslashes in the next two
            verb macros:)
        verb(
    #define BASE_1st_DERIVED_2nd(Base, Derived) BSSP
        (Conversion<Derived const *, Base const *>::exists && BSSP
         not Conversion<Base const *, void const *>::sameType)
        )

    If code should not consider a class to be its own base class, then the
following stricted test is possible, which adds a test for type-equality:
        verb(
    #define BASE_1st_DERIVED_2nd_STRICT(Base, Derived) BSSP
        (BASE_1st_DERIVED_2nd(Base, Derived) && BSSP
         not Conversion<Base const *, Derived const *>::sameType)
        )

The following example writes tt(1: 0, 2: 1, 3: 0, 4: 1, 5: 0) when run from a
tt(main()) function:
        verbinsert(INHERITANCE)(advancedtemplates/examples/conversion.cc)
