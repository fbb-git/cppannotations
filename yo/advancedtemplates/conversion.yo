In what situations can a type tt(T) be used as a `stand in' for another type
tt(U)? Since bf(C++) is a strongly typed language the answer is surprisingly
simple: tt(T)s can be used instead of tt(U)s if a tt(T) is accepted as
argument in cases where tt(U)s are requested.

This reasoning is behind the following class which can be used to determine
whether a type tt(T) can be used where a type tt(U) is expected. The
interesting part, however, is that no code is actually generated or executed:
all decisions can be made by the compiler.

In the second part of this section it will be shown how the code developed in
the first part can be used to detect whether a class tt(B) is a base class of
another clas tt(D). The code developed here closely follows the example
provided by Alexandrescu hi(Alexandrescu, H.) (2001, p. 35).

First, a function is conceived of that will accept a type tt(U) to which
an alternative type tt(T) will be compared. This function returns a value of
the as yet unsepcified type tt(Convertible):
        verb(
    Convertible test(U const &);
        )

The function tt(test()) is not implemented; it is merely declared. The idea is
that if a type tt(T) can be used instead of a type tt(U) it can be passed as
argument to the above tt(test()) function.

If tt(T) cannot be used where a tt(U) is expected, then the above function
will not be used by the compiler. Of course, getting a compiler error is not
the kind of `answer' we're looking for and so the next question is what
alternative we can offer to the compiler in cases where a tt(T) cannot be used
as argument to the above function.

bf(C) (and bf(C++)) offer a very general parameter list, a parameter list that
will always be considered acceptable. This parameter list consists of the
        emi(ellipsis)
    which actually is the em(worst) situation the compiler may encounter: if
everything else fails, then the function defining an ellipsis as its parameter
list is selected. Normally that's not a productive and i(type-safe)
alternative, but in the current situation it is em(exactly) what is
needed. When confronted with two alternative function calls, one of which
defines the ellipsis parameter list, the compiler will only select the
function defining the ellipsis if the alternative(s) can't be used. So we
declare an alternative function tt(test()), having the ellipsis as its
parameter list, and returning another type, e.g., tt(NotConvertible):
        verb(
    NotConvertible test(...);
        )

Now, if code passes a value of type tt(T) to the tt(test) function, the return
type will be tt(Convertible) if tt(T) can be converted to tt(U), and
tt(NotConvertible) if conversion is not possible.

Two problems still need to be solved: how do we obtain a tt(T) argument? The
problems here are firstly, that it might not be possible to define a tt(T), as
a type tt(T) might hide all its constructors and secondly, how can the two
return values be distinguished?

Although it might be impossoble to construct a tt(T) object, it is fortunately
not necessary to construct a tt(T). After all, the intent is to decide
        emi(compile time)
    whether a type is convertible to another type and not actually to
construct such a tt(T) value. So another function is em(declared):
        verb(
    T makeT();
        )
    This mysterious function has the magical power of enticing the compiler
into thinking that a tt(T) object will come out of it. So, what will happen
when the compiler is shown the following code:
        verb(
    test(makeT())
        )

    If tt(T) can be converted to tt(U) the first function tt(Convertible test(U
const &)) will be selected by the compiler; otherwise the function tt(NotConvertible
test(...)) will be selected.

    If it is now possible to distinguish tt(Convertible) from
tt(NotConvertible) compile-time then it is possible to determine whether tt(T)
is convertible to tt(U).

    Since tt(Convertible) and tt(NotConvertible) are values, their sizes are
known. If these sizes differ, then the tt(sizeof) operator can be used to
distinguish the two types; hence it is possible to determine which tt(test())
function was selected and hence it is known whether tt(T) can be converted to
tt(U) or not. E.g., if the following expression evaluates as tt(true) tt(T) is
convertible to tt(U):
        verb(
    sizeof(test(makeT())) == sizeof(Convertible);
        )

    The size of a tt(char) is well known. By definition it is 1. Using a
tt(typedef) tt(Convertible) can be defined as a synonym of tt(char), thus
having size 1. Now tt(NotConvertible) must be defined so that it has a
different type. E.g.,
        verb(
    struct NotConvertible
    {
        char array[2];
    };
        )
    Note there that a simple tt(typedef char NotConvertible[2]) does not work:
functions cannot return arrays, but they can return arrays embedded in a
structs.

    The above can be wrapped up in a template class, having two template type
parameters:
        verbinsert(CONVERSION)(advancedtemplates/examples/conversion.h)

    The above class em(never) results in em(any) emi(run-time) execution of
code. When used, it merely defines the values 1 or 0 for its tt(exist) enum
value, depending whether the conversion exists or not. The following example
writes tt(1 0 1 0) when run from a tt(main()) function:
        verbinsert(CONVERSION)(advancedtemplates/examples/conversion.cc)
