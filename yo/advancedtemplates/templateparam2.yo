Template hi(template template parameter) template parameters allow us to
specify a em(class template) as a template parameter. By specifying a class
template, it is possible to add a certain kind of behavior, called a
emi(policy) to an existing class template.

Consider the class tt(Storage), introduced at the beginning of this section.
Also consider the allocation classes discussed in the previous section. To
allow us to specify an em(allocation policy) for the class tt(Storage) its
definition starts as follows:
        verb(
    template <typename Data, template <typename> class Policy>
    class Storage ...
        )
    The second template parameter is the
    em(template template parameter). It consists of the following elements:
        itemization(
        it() The keyword tt(template), starting the template
            template parameter;
        it() The keyword tt(template) is followed (between pointed brackets)
            by a list of template parameters that must be specified for the
            template template parameter. These parameters em(may) be given
            names, but names are usually omitted as those names cannot be used
            in subsequent template definitions. On the other hand, providing
            formal names may help the reader of the template to understand the
            kind of templates that must be specified with the template
            template parameter.
        it() Template template parameters must match, in numbers and types
            (i.e., template type parameters, template non-type parameters,
            template template parameters) the template parameters that must be
            specified for the policy. This can be tricky, as some templates
            use default parameters that are hardly ever changed (like the
            allocation schemes for containers). Programmers may not
            immediately realize that these defaults exist and be confused when
            the compiler rejects such templates when trying to pass them as
            template template parameters for which these additional (default)
            parameters weren't specified.
        it() Following the bracketed list the keyword ti(class) em(must) be
            specified. In this case, tt(typename)
                hi(typename vs. class)
            can em(not) be used.
        it() All parameters may be provided with default arguments. This is
            shown in the next example of a hypothetical class template:
        verb(
    template <
        template <
            typename = std::string,
            int = 12,
            template <typename = int> class Inner = std::vector
        >
        class Policy
    >
    class Demo
    {
        ...
    };
        ) 
           Here, the class template tt(Demo) expects a template template
            parameter named tt(Policy), expecting three template parameters: a
            template type parameter (by default tt(std::string)); a template
            non-type parameter (by default having value 12); and tt(Policy)
            itself expects a template template parameter, called tt(Inner), by
            default using an tt(int) as its template type parameter.
        )
    Policy classes often are an inherent part of the class under
consideration. Thus they are often deployed as base classes. In the example:
tt(Policy) could be used as a base class of tt(Storage).

    The policy operates on the class tt(Storage)'s data type. Therefore the
policy is informed about that data type as well. From this we reach the
following setup:
        verb(
    template <typename Data, template <typename> class Policy>
    class Storage: public Policy<Data>
        )
    This scheme allows us to use tt(Policy)'s members when implementing the
members of the class tt(Storage).

    The allocation classes shown before do not really provide us with many
useful members. Except for the extraction operator they offer no immediate
access to the data. This can easily be repaired by providing additional
members. E.g., the class tt(NewAlloc) could be provided with the following
operators, allowing access to and modification of stored data:
            verb(
        operator Data &()   // optionally add a `const' member too
        {
            return *d_data;
        }
        NewAlloc &operator=(Data const &data)
        {
            *d_data = data;
        }
            )
    Other allocation classes can be given comparable members.

    Let's now use the allocation schemes in some real code. The following
example shows how a storage can be defined using some data type and an
allocation scheme. First, define a class tt(Storage):
        verb(
    template <typename Data, template <typename> class Allocate>
    class Storage: public std::vector<Allocate<Data> >
    {};
        )
    That's all we have to do. All required functionality is offered by the
tt(vector) base class, while the policy is `factored into the equation' via
the template template parameter. Here's an example showing its use:
        verb(
    Storage<std::string, NewAlloc> storage;

    copy(istream_iterator<std::string>(cin), istream_iterator<std::string>(),
            back_inserter(storage));

    cout << "Element index 1 is " << storage[1] << '\n';
    storage[1] = "hello";

    copy(storage.begin(), storage.end(),
         ostream_iterator<NewAlloc<std::string> >(cout, "\n"));
        )
   Now the STL tt(copy) function can be used in combination with the
em(back_inserter) iterator to add some data to tt(storage). Its elements can
both directly be accessed and modified using the index operator. Then
tt(NewAlloc<std::string>) objects are inserted into tt(cout) (also using the
tt(copy) function).

    Interestingly, this is not the end of the story. After all, the intention
was to create a class allowing us to specify the em(storage type) as
well. What if we don't want to use a tt(vector), but instead would like to use
a tt(list)?

    It's easy to change tt(Storage)'s setup so that a completely different
storage type can be used on request, like a tt(deque). To implement this, the
storage class is parameterized as well, using yet another template template
parameter:
        verb(
    template <typename Data, template <typename> class Policy,
                             template <typename> class Container =
                                                        std::vector>
    class Storage: public Container<Policy<Data>>
    {
    };
        )
    The earlier example using a tt(Storage) object can be used again without
requiring any modifications at all (except for the above redefinition). It
clearly can't be used with a tt(list) container, as the tt(list) lacks
tt(operator[]). But that's immediately recognized by the compiler, producing
an error if an attempt is made to use tt(operator[]) on, e.g., a
    tt(list)footnote(A complete example showing the definition of the
allocation classes and the class tt(Storage) as well as its use is provided in
the Annotation's distribution in the file
tt(yo/advancedtemplates/examples/storage.cc).).
