    Templates can not only be constructed for functions but also for complete
classes. Constructing a i(class template) can be considered when the class
should be able to handle different types of data. Class templates are
frequently used in bf(C++): chapter ref(CONTAINERS) discusses data structures
like tt(vector, stack) and tt(queue), which are implemented as em(class
templates). With class templates, the hi(algorithm) algorithms and the data on
which the algorithms operate are completely separated from each other. To use
a particular i(data structure), operating on a particular data type, only the
i(data type) needs to be specified when the class template object is defined
or declared, e.g., tt(stack<int> iStack).

In this chapter constructing and using class templates is discussed. In a
sense, class templates compete with
        i(object oriented programming)
    (cf. chapter ref(POLYMORPHISM)), where a mechanism somewhat similar to
templates is seen. Polymorphism
        hi(polymorphism)
    allows the programmer to postpone the definitions of algorithms, by
deriving classes from a i(base class) in which the algorithm is only partially
implemented, while the data upon which the algorithms operate may first be
defined in i(derived class)es, together with member functions that were
defined as
    i(pure virtual functions) in the base class to handle the data. On the
other hand, templates allow the programmer to postpone the specification of
the data upon which the algorithms operate. This is most clearly seen with the
abstract containers, completely specifying the algorithms but at the same time
leaving the data type on which the algorithms operate completely
unspecified.

The correspondence between class templates and polymorphic classes is
well-known. In their book bf(C++ Coding Standards) (Addison-Wesley, 2005)
        hi(Sutter, H.)hi(Alexandrescu, A.)
    Sutter and Alexandrescu (2005) refer to
        emi(static polymorphism)hi(polymorphism: static) and
        hi(polymorphism: dynamic)emi(dynamic polymorphism).
    em(Dynamic) polymorphism is what we use when overriding virtual members:
Using the emi(vtable) construction the function that's actually called depends
on the type of object a (base) class pointer points to. em(Static)
polymorphism is used when templates are used: depending on the actual types,
the compiler em(creates) the code, compile time, that's appropriate for those
particular types. There's no need to consider static and dynamic polymorphism
as mutually exlusive variants of polymorphism. Rather, both can be used
together, combining their strengths. A warning is in place, though. When a
class template defines virtual members em(all) virtual members are
instantiated for every instantiated type. This has to happen, since the
compiler must be able to construct the class's tt(vtable).

Generally, class templates are easier to use. It is certainly easier to write
tt(stack<int> istack) to create a stack of tt(ints) than to derive a new
class tt(Istack: public stack) and to implement all necessary member functions
to be able to create a similar stack of tt(ints) using object oriented
programming. On the other hand, for each different type that is used with a
class template the complete class is reinstantiated, whereas in the context of
object oriented programming the derived classes em(use), rather than em(copy),
the functions that are already available in the base class (but see also
section ref(DERIVEDTEMPCLASS)).
