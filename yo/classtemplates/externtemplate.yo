In bf(C++) templates
    hi(template: when instantiated)
 are instantiated when the address of a function template or class template
object is taken or when a function template or class template is used. As
described in section ref(DECLCLASSTEMP) it is possible to (forward) declare a
class template to allow the definition of a pointer or reference to
that template class or to allow it being used as a return type.

In other situations templates are instantiated when they are being used.  If
this happens many times (i.e., in many different source files) then this may
slow down the compilation process considerably. The C++0x standard allows
programmers to em(prevent) templates
    hi(template: preventing instantiation)
 from being instantiated. For this the C++0x standard introduces the
ti(extern template) syntax. Example:
        verb(
    extern template class std::vector<int>;
        )
    Having declared the class template it can be used in its translation
unit. E.g., the following function will properly compile:
        verbinclude(examples/extern.cc)
    But be careful:
    itemization(
    it() The declaration by itself does not make the class definition
available. The tt(vector) header file still needs to be included to make the
features of the class vector known to the compiler. But due to the tt(extern
template) declaration none of the used members will be instantiated for the
current compilation unit;
    it() The compiler em(assumes) (as it always does) that what's declared is
implemented elsewhere. In this case the compiler encounters an em(implicit
declaration): the features of the vector class that are actually used by the
above program are not individually declared but they are declared as a group,
using the ti(extern template) declaration. This not only holds true for
explicitly used members but hidden members (copy constructors, move
constructors, conversion operators, constructors called during promotions, to
name a few): all are assumed by the compiler to have been instantiated
elsewhere;
    it() The above source file will em(compile) but the compiler must find the
instantiations before its linker can produce a final program. To accomplish
this one or more sourcefiles may be constructed in which all required
instantiations are made available.

    In a stand-alone program one might postpone defining the required members
and wait for the linker to complain about unresolved external
references. These may then be used to create a series of instantiation
declarations which are then linked to the program to satisfy the linker. Not
a very simple task, though, as the declarations must strictly match the way
the members are declared in the class interface. An easier approach is to
define an emi(instantiation source) em(file) in which all facilities that
are used by the program are actually instantiated in a function that is never
called by the program. By adding this i(instantiation function) to the source
file containing tt(main) we can be sure that all required members will be
instantiated as well. Here is an example of how this can be done:
        verbinclude(examples/extern2.cc)
    )
