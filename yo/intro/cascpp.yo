    For the sake of completeness, it must be mentioned here that bf(C++) is
not a perfect superset of bf(C). There are some differences you might
encounter when you simply rename a file to a file having the extension tt(.cc)
and run it through a bf(C++) compiler:
    itemization(
    it() In bf(C), ti(sizeof)tt(('c')) equals tt(sizeof(int)), tt('c') being
any ASCII character.  The underlying philosophy is probably that tt(char)s,
when passed as arguments to functions, are passed as integers
anyway. Furthermore, the bf(C) compiler handles a character constant like
tt('c') as an integer constant. Hence, in bf(C), the function calls
        verb(
    putchar(10);
        )
    and
        verb(
    putchar('\n');
        )
    are synonyms.

    In contrast, in bf(C++), tt(sizeof('c')) is always 1 (but see also section
ref(WCHAR)), while an tt(int) is still an tt(int). As we shall see later (see
section ref(FunctionOverloading)), the two function calls
        verb(
    somefunc(10);
        )
    and
        verb(
    somefunc('\n');
        )
    may be handled by quite separate functions: bf(C++) distinguishes
functions not only by their names, but also by their argument types, which are
different in these two calls: one call using an tt(int) argument, the other
one using a tt(char).
    it() bf(C++) requires very strict i(prototyping) of external
functions. E.g., a prototype like
        verb(
    extern void func();
        )
    in bf(C) means that a function tt(func()) exists, which returns no
value. The declaration doesn't specify which arguments (if any) the function
takes.

    In contrast, such a declaration in bf(C++) means that the function
tt(func()) takes no arguments at all: passing arguments to it results in a
compile-time error.

    Note that the keyword ti(extern) is not required when declaring
functions. A function definition becomes a function declaration by simply
replacing a function's body by a semicolon. The keyword tt(extern) em(is)
required, though, when declaring variables.
    )
