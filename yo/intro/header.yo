The combination of the predefined symbol ti(__cplusplus) and of the
possibility to define ti(extern "C") functions offers the ability to
create header files for both bf(C) and bf(C++). Such a header file might,
e.g., declare a group of functions which are to be used in both bf(C) and
bf(C++) programs.

The setup of such a header file is as follows:
        verb(
    #ifdef __cplusplus
    extern "C"
    {
    #endif
        /* declaration of C-data and functions are inserted here. E.g., */
        void *xmalloc(size_t size);

    #ifdef __cplusplus
    }
    #endif
        )
    Using this setup, a normal bf(C) header file is enclosed by
    tt(extern "C") tt({) which occurs at the start of the file and by tt(}),
which occurs at the end of the file. The ti(#ifdef) directives test for the
type of the compilation: bf(C) or bf(C++). The `standard' bf(C) header files,
such as ti(stdio.h), are built in this manner and are therefore usable for
both bf(C) and bf(C++).

In addition to this, bf(C++) headers should support emi(include guard)em(s).
In bf(C++) it is usually undesirable to include the same header file twice in
the same source file. Such i(multiple inclusions) can easily be avoided by
including an ti(#ifndef) directive in the header file.  For example:
        verb(
    #ifndef MYHEADER_H_
    #define MYHEADER_H_
        // declarations of the header file is inserted here,
        // using #ifdef __cplusplus etc. directives
    #endif
        )
    When this file is scanned for the first time by the preprocessor, the
symbol tt(MYHEADER_H_) is not yet defined. The tt(#ifndef) condition
succeeds and all declarations are scanned. In addition, the symbol
tt(MYHEADER_H_) is defined.

    When this file is scanned for a second time during the same compilation,
the symbol tt(MYHEADER_H_) has been defined and consequently all information
between the tt(#ifndef) and tt(#endif) directives is skipped by the compiler.

    In this context the symbol name tt(MYHEADER_H_) serves only for
recognition purposes. E.g., the name of the header file can be used for this
purpose, in capitals, with an underscore character instead of a dot.

    Apart from all this, the custom has evolved to give bf(C) header files the
extension ti(.h), and to give tt(C++) header files em(no) extension. For
example, the standard em(iostreams) tt(cin, cout) and tt(cerr) are available
after including the preprocessor directive ti(#include <iostream>), rather
than tt(#include <iostream.h>) in a source. In the Annotations this convention
is used with the standard bf(C++) header files, but not everywhere else
(Frankly, we tend not to follow this convention: our bf(C++) header files
still have the tt(.h) extension, and apparently nobody cares...).

There is more to be said about header files. In section ref(CLASSHEADER) the
preferred organization of bf(C++) header files is discussed.
