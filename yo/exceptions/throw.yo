Exceptions may be generated in a ti(throw) statement. The tt(throw) keyword is
followed by an expression, resulting in a value of a certain type. For
example:
        verb(
    throw "Hello world";        // throws a char *
    throw 18;                   // throws an int
    throw string("hello");      // throws a string
        )
    Objects defined locally in functions are automatically destroyed once
exceptions thrown by these functions leave these functions. However, if the
object itself is thrown, the exception catcher receives
        hi(throw: copy of objects)
    a em(copy) of the thrown object. This copy is constructed just before the
local object is destroyed.

    The next example illustrates this point. Within the function
tt(Object::fun()) a local tt(Object toThrow) is created, which is thereupon
thrown as an exception. The exception is caught outside of tt(Object::fun()),
in tt(main()). At this point the thrown object doesn't actually exist anymore,
Let's first take a look at the sourcetext:
        verbinclude(exceptions/examples/throw.cc)
    The class tt(Object) defines several simple constructors and members. The
copy constructor is special in that it adds the text tt(" (copy)") to the
received name, to allow us to monitor the construction and destruction of
objects more closely. The member function tt(Object::fun()) generates the
exception, and throws its locally defined object. Just before the exception
the following output is generated by the program:
        verb(
    Object constructor of 'main object'
    Object constructor of 'local object'
    Object fun() of 'main object'
        )
    Now the exception is generated, resulting in the next line of output:
        verb(
    Copy constructor for 'local object' (copy)
        )
    The tt(throw) clause receives the local object, and treats it as a value
argument: it creates a copy of the local object. Following this, the exception
is processed: the local object is destroyed, and the catcher catches an
tt(Object), again a i(value parameter). Hence, another copy is
created. Threfore, we see the following lines:
        verb(
    Object destructor of 'local object'
    Copy constructor for 'local object' (copy) (copy)
        )
    Now we are inside the catcher, who displays its message:
        verb(
    Caught exception
        )
    followed by the calling of the tt(hello()) member of the received
object. This member also shows us that we received a em(copy of the copy of
the local object) of the tt(Object::fun()) member function:
        verb(
    Hello by 'local object' (copy) (copy)
        )
    Finally the program terminates, and its still living objects are now
destroyed in their reversed order of creation:
        verb(
    Object destructor of 'local object' (copy) (copy)
    Object destructor of 'local object' (copy)
    Object destructor of 'main object'
        )

    If the catcher would have been implemented so as to receive a
em(reference) to an object (which you could do by using `tt(catch (Object
&o))'), then repeatedly calling the copy constructor would have been
avoided. In that case the output of the program would have been:
        verb(
    Object constructor of 'main object'
    Object constructor of 'local object'
    Object fun() of 'main object'
    Copy constructor for 'local object' (copy)
    Object destructor of 'local object'
    Caught exception
    Hello by 'local object' (copy)
    Object destructor of 'local object' (copy)
    Object destructor of 'main object'
        )
    This shows us that only a single copy of the local object has been used.

Of course, it's a bad idea to hi(throw: pointer to a local object) throw a
em(pointer) to a locally defined object: the pointer is thrown, but the object
to which the pointer refers dies once the exception is thrown, and the catcher
receives a i(wild pointer). Bad news....

Summarizing:
    itemization(
    it() hi(throw: local objects) Local objects are thrown as copied
objects,
    it() Pointers to local objects should not be thrown.
    it() However, it is hi(throw: pointer to a dynamically generated object)
possible to throw pointers or references to em(dynamically) generated
objects. In this case one must take care that the generated object is properly
deleted when the generated exception is caught, to prevent a i(memory leak).
    )
    Exceptions hi(exceptions: when) are thrown in situations where a function
can't continue its normal task anymore, although the program is still able to
continue. Imagine a program which is an interactive calculator. The program
continuously requests expressions, which are then evaluated. In this case the
parsing of the expression may show syntactical errors; and the evaluation of
the expression may result in expressions which can't be evaluated, e.g.,
because of the expression resulting in a i(division by zero). Also, the
calculator might allow the use of variables, and the user might refer to
i(non-existing variables): plenty of reasons for exceptions to be thrown, but
no overwhelming reason to terminate the program. In the program, the following
code may be used, all throwing exceptions:
        verb(
    if (!parse(expressionBuffer))           // parsing failed
        throw "Syntax error in expression";

    if (!lookup(variableName))              // variable not found
        throw "Variable not defined";

    if (divisionByZero())                   // unable to do division
        throw "Division by zero is not defined";
        )
    The hi(location of throw statements) location of these tt(throw)
statements is immaterial: they may be placed deeply nested within the program,
or at a more superficial level.  Furthermore, em(functions) may be used to
generate hi(throw: function return values) the expression which is then
thrown. A function
        centt(char const *formatMessage(char const *fmt, ...);)
    would allow us to throw more specific messages, like
        verb(
    if (!lookup(variableName))
        throw formatMessage("Variable '%s' not defined", variableName);
        )
