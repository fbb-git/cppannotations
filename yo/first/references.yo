In addition to the well known ways to define variables, plain variables or
pointers, bf(C++) allows
`i(references)' to be defined as synonyms for variables. A reference to a
variable is like an em(alias); the variable and the reference can
both be used in statements involving the variable:
        verb(
    int int_value;
    int &ref = int_value;
        )
    In the above example a variable tt(int_value) is defined. Subsequently a
reference tt(ref) is defined, which (due to its initialization) refers to the
same memory location as tt(int_value). In the definition of
tt(ref), the reference operator tt(&) indicates that tt(ref) is not
itself an integer but a reference to one. The two statements
        verb(
    int_value++;            // alternative 1
    ref++;                  // alternative 2
        )
    have the same effect, as expected. At some memory location an tt(int)
value is increased by one. Whether that location is called tt(int_value) or
tt(ref) does not matter.

    References serve an important function in bf(C++) as a means to pass
arguments which can be modified. E.g., in standard bf(C), a function that
increases the value of its argument by five but returns nothing
(tt(void)), needs a pointer parameter:
        verb(
    void increase(int *valp)    // expects a pointer
    {                           // to an int
        *valp += 5;
    }

    int main()
    {
        int x;

        increase(&x)            // the address of x is
        return 0;               // passed as argument
    }
        )
    This construction can em(also) be used in bf(C++) but the same effect
can also be achieved using a reference:
        verb(
    void increase(int &valr)    // expects a reference
    {                           // to an int
        valr += 5;
    }

    int main()
    {
        int x;

        increase(x);            // a reference to x is
        return 0;               // passed as argument
    }
        )
    It can be argued whether code such as the above is clear: the statement
tt(increase) tt((x)) in the tt(main()) function suggests that not tt(x)
itself but a em(copy) is passed. Yet the value of tt(x) changes because of
the way tt(increase()) is defined.

    Actually, references are implemented using pointers. So, references in
bf(C++) are just pointers, as far as the compiler is concerned.  However, the
programmer does not need to know or to bother about levels of
indirection. Nevertheless, pointers and references em(should) be
distinguished: once initialized, references can never refer to another
variable, whereas the values of pointer variables can be changed, which will
result in the pointer variable pointing to another location in memory. For
example:
        verb(
    extern int *ip;
    extern int &ir;

    ip = 0;     // reassigns ip, now a 0-pointer
    ir = 0;     // ir unchanged, the int variable it refers to
                // is now 0.
        )

In order to prevent confusion, we suggest you adhere to the following:
    itemization(
    it() In those situations where a called function does not alter its
arguments of primitive types, a copy of the variables can be passed:
            verb(
        void some_func(int val)
        {
            cout << val << endl;
        }

        int main()
        {
            int x;

            some_func(x);       // a copy is passed, so
            return 0;           // x won't be changed
        }
            )
    it() When a function changes the values of its arguments, a pointer
parameter is preferred. These pointer parameters should preferably be the
initial parameters of the function. This is called `return by argument'.
            verb(
        void by_pointer(int *valp)
        {
            *valp += 5;
        }
            )
    it() When a function doesn't change the value of its class- or struct-type
arguments, or if the modification of the argument is a trivial side-effect
(e.g., the argument is a stream), references can be used. Const-references
should be used if the function does not modify the argument:
            verb(
        void by_reference(string const &str)
        {
            cout << str;
        }

        int main ()
        {
            int x = 7;
            string str("hello");

            by_pointer(&x);         // a pointer is passed
            by_reference(str);      // str is not altered
            return 0;               // x might be changed
        }
            )
    References play an important role in cases where the argument will not be
changed by the function, but where it is undesirable to use the argument to
initialize the parameter. Such a situation occurs when a large variable, e.g.,
a tt(struct), is passed as argument, or is returned by the function.  In these
cases the copying operation tends to become a significant factor, as the
entire structure must be copied. So, in those cases references are
preferred. If the argument isn't changed by the function, or if the caller
shouldn't change the returned information, the tt(const) keyword
should be used. Consider the following example:
        verb(
    struct Person                   // some large structure
    {
        char    name[80];
        char    address[90];
        double  salary;
    };

    Person person[50];          // database of persons
                                // printperson expects a
    void printperson (Person const &p)
    {                           // reference to a structure
                                // but won't change it
        cout << "Name: " << p.name << endl <<
                "Address: " << p.address << endl;

    }
                                // get a person by indexvalue
    Person const &person(int index)
    {
        return person[index];   // a reference is returned,
    }                           // not a copy of person[index]

    int main()
    {
        Person boss;

        printperson (boss);     // no pointer is passed,
                                // so variable won't be
                                // altered by the function
        printperson(person(5));
                                // references, not copies
                                // are passed here
        return 0;
    }
        )
    it() Furthermore, it should be noted that there is yet another reason to
use references when passing objects as function arguments: when passing a
reference to an object, the activation of the so called em(copy constructor)
is avoided. Copy constructors will be covered in chapter ref(MEMORY).
    )
    References may result in extremely `ugly' code. A function may
return a reference to a variable, as in the following example:
        verb(
    int &func()
    {
        static int value;
        return value;
    }
        )
    This allows the following constructions:
        verb(
    func() = 20;
    func() += func();
        )
    It is probably superfluous to note that such constructions should normally
not be used. Nonetheless, there are situations where it is useful to return a
reference.  We have actually already seen an example of this phenomenon at our
previous discussion of the streams. In a statement like tt(cout) lshift()
tt("Hello") lshift() tt(endl;), the insertion operator returns a reference to
tt(cout). So, in this statement first the tt("Hello") is inserted into
tt(cout), producing a reference to tt(cout). Via this reference the tt(endl)
is then inserted in the tt(cout) object, again producing a reference to
tt(cout). This latter reference is not further used.

A number of differences between pointers and references is pointed out in the
list below:
    startit()
    it() A reference cannot exist by itself, i.e., without something to
refer to. A declaration of a reference like
        center(tt(int &ref;))
    is not allowed; what would tt(ref) refer to?
    it() References can, however, be declared as tt(external).  These
references were initialized elsewhere.
    it() References may exist as parameters of functions: they are initialized
when the function is called.
    it() References may be used in the return types of functions. In those
cases the function determines to what the return value will refer.
    it() References may be used as data members of classes. We will return
to this usage later.
    it() In contrast, pointers are variables by themselves. They point at
something concrete or just ``at nothing''.
    it() References are aliases for other variables and cannot be re-aliased
to another variable. Once a reference is defined, it refers to its particular
variable.
    it() In contrast, pointers can be reassigned to point to different
variables.
    it() When an address-of operator tt(&) is used with a reference, the
expression yields the address of the variable to which the reference
applies. In contrast, ordinary pointers are variables themselves, so the
address of a pointer variable has nothing to do with the address of the
variable pointed to.
    endit()
