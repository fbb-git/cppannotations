The ti(size_t) type is not really a built-in primitive data type, but a data
type that is promoted by bi(POSIX) as a typename to be used for non-negative 
integral values. It is not a specific bf(C++) type, but also available in,
e.g., bf(C). It should be used instead of ti(unsigned int). Usually it is
defined implictly when a system header file is included. The header file
`officially' defining tt(size_t) in the context of bf(C++) is ti(cstddef).

Using tt(size_t) has the advantage of being a em(conceptual) type, rather than
a standard type that is then modified by a modifier. Thus, it improves 
the self-documenting value of source code. 

The type tt(size_t) should be used in all situations where non-negative
integral values are intended. Sometimes functions explictly require
tt(unsigned int) to be used. E.g., on ti(amd)-architectures the i(X-windows)
function ti(XQueryPointer) explicitly requires a pointer to a tt(unsigned int)
variable as one of its arguments. In this particular situation a pointer to a
tt(size_t) variable can't be used. This situation is exceptional,
though. Usually a tt(size_t) can (and should) be used where unsigned values
are intended.
