It is not strictly necessary to i(define members of namespaces) within a
namespace region. By prefixing the member by its namespace or namespaces a
member can be defined outside of a namespace region. This may be done at the
global level, or at intermediate levels in the case of nested namespaces. So
while it is not possible to define a member of namespace tt(A) within the
region of namespace tt(C), it is possible to define a member of namespace
tt(A::B) within the region of namespace tt(A).

    Note, however, that when a member of a namespace is defined outside of a
namespace region, it must em(still be declared within) the region.

    Assume the type tt(int INT8[8]) is defined in the
tt(CppAnnotations::Virtual) namespace.

    Now suppose we want to define a member function tt(funny), inside the
namespace tt(CppAnnotations::Virtual), returning a pointer to
tt(CppAnnotations::Virtual::INT8). After first defining everything
inside the tt(CppAnnotations::)tt(Virtual) namespace, such a function could be
defined as follows (the examples below use the memory allocation operator
tt(new[]) which will formally be introduced in chapter ref(MEMORY)). At this
point it can be assumed to behave somewhat like bf(C)'s memory allocation
function tt(malloc()):
        verb(
    namespace CppAnnotations
    {
        namespace Virtual
        {
            void *pointer;

            typedef int INT8[8];

            INT8 *funny()
            {
                INT8 *ip = new INT8[1];

                for (int idx = 0; idx < sizeof(INT8) / sizeof(int); ++idx)
                    (*ip)[idx] = (idx + 1) * (idx + 1);

                return ip;
            }
        }
    }
        )
    The function tt(funny()) defines an array of one tt(INT8) vector, and
returns its address after initializing the vector by the squares of the first
eight natural numbers.

    Now the function tt(funny()) can be defined outside of the
tt(CppAnnotations::)tt(Virtual) namespace as follows:
        verb(
    namespace CppAnnotations
    {
        namespace Virtual
        {
            void *pointer;

            typedef int INT8[8];

            INT8 *funny();
        }
    }

    CppAnnotations::Virtual::INT8 *CppAnnotations::Virtual::funny()
    {
        INT8 *ip = new INT8[1];

        for (int idx = 0; idx < sizeof(INT8) / sizeof(int); ++idx)
            (*ip)[idx] = (idx + 1) * (idx + 1);

        return ip;
    }
        )
    In the final code fragment note the following:
    itemization(
    itt(funny()) is declared inside of the tt(CppAnnotations::Virtual)
namespace.
    itt() The definition outside of the namespace region requires us to use
the fully qualified name of the function em(and) of its return type.
    itt() em(Inside) the block of the function tt(funny) we are within the
tt(CppAnnotations::)tt(Virtual) namespace, so inside the function fully
qualified names (e.g., for tt(INT8)) are not required any more.
    )

    Finally, note that the function could also have been defined in the
tt(CppAnnotations) region. It that case the tt(Virtual) namespace would have
been required when defining tt(funny()) and when specifying its return type,
while the internals of the function would remain the same:
        verb(
    namespace CppAnnotations
    {
        namespace Virtual
        {
            void *pointer;

            typedef int INT8[8];

            INT8 *funny();
        }

        Virtual::INT8 *Virtual::funny()
        {
            INT8 *ip = new INT8[1];

            for (int idx = 0; idx < sizeof(INT8) / sizeof(int); ++idx)
                (*ip)[idx] = (idx + 1) * (idx + 1);

            return ip;
        }
    }
        )
