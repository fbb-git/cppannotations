    In various classes overloading binary operators (like ti(operator+())) can
be a very natural extension of the class's functionality. For example, the
tt(std::string) class has various overloaded forms of tt(operator+()) as have
most em(abstract containers), covered in chapter ref(Containers).

    Most binary operators come in two flavors: the plain binary operator (like
the tt(+) operator) and the arithmetic assignment variant (like the tt(+=)
operator). Whereas the plain binary operators return const expression values,
the arithmetic assignment operators return a (non-const) reference to the
object to which the operator was applied. For example, with
tt(std::string) objects the following code (annotated below the example)
may be used:
        verbinclude(overloading/examples/binarystring.cc)
    itemization(
    it() at tt(// 1) the contents of tt(s3) is added to tt(s2). Next, tt(s2)
is returned, and its new contents are assigned to tt(s1). Note that tt(+=)
returns tt(s2) itself.
    it() at tt(// 2) the contents of tt(s3) is also added to tt(s2), but as
tt(+=) returns tt(s2) itself, it's possible to add some more to tt(s2)
    it() at tt(// 3) the tt(+) operator returns a tt(std::string) containing
the concatenation of the text tt(prefix) and the contents of tt(s3). This
string returned by the tt(+) operator is thereupon assigned to tt(s1).
    it() at tt(// 4) the tt(+) operator is applied twice. The effect is:
        enumeration(
        eit() The first tt(+) returns a tt(std::string) containing
the concatenation of the text tt(prefix) and the contents of tt(s3).
        eit() The second tt(+) operator takes this returned string as its left
hand value, and returns a string containing the concatenated text of its left
and right hand operands.
        eit() The string returned by the second tt(+) operator represents the
value of the expression.
        )
    it() statement tt(// 5) should not compile (although it does compile with
the ti(Gnu) compiler version 3.1.1). It should not compile, as the tt(+)
operator should return a tt(const) string, thereby preventing its modification
by the subsequent tt(+=) operator. Below we will consequently follow this line
of reasoning, and will ensure that overloaded binary operators will always
return tt(const) values.
    )

    Now consider the following code, in which a class tt(Binary) supports
an overloaded tt(operator+()):
        verbinclude(overloading/examples/binary1.cc)
    Compilation of this little program fails for statement tt(// 2), with the
compiler reporting an error like:
        verb(
    error: no match for 'operator+' in '3 + b2'
        )
    Why is statement tt(// 1) compiled correctly whereas statement tt(// 2)
won't compile?

    In order to understand this, the notion of a emi(promotion) is
introduced. As we have seen in section ref(EXPLICIT), constructors requiring
a single argument may be implicitly activated when an object is apparently
initialized by an argument of a corresponding type. We've encountered this
repeatedly with tt(std::string) objects, when an tt(ASCII-Z) string was used
to initialize a tt(std::string) object.

    In situations where a member function expects a tt(const &) to an object
of its own class (like the tt(Binary const &) that was specified in the
declaration of the tt(Binary::operator+()) member mentioned above), the type
of the actually used argument may also be any type that can be used as an
argument for a single-argument constructor of that class. This implicit call
of a constructor to obtain an object of the proper type is called a
em(promotion).

    So, in statement tt(// 1), the tt(+) operator is called for the tt(b2)
object. This operator expects another tt(Binary) object as its right hand
operand. However, an tt(int) is provided. As a constructor tt(Binary(int))
exists, the tt(int) value is first promoted to a tt(Binary) object. Next, this
tt(Binary) object is passed as argument to the tt(operator+()) member.

    Note that no promotions are possibly in statement tt(// 2): here the tt(+)
operator is applied to an tt(int) typed value, which has no concept of a
`constructor', `member function' or `promotion'.

    How, then, are promotions of left-hand operands implemented in statements
like tt("prefix " + s3)? Since promotions are applied to function arguments,
we must make sure that both operands of binary operators are arguments. This
means that binary operators are declared as emi(classless functions), also
called emi(free functions). However, they conceptually belong to the class for
which they implement the binary operator, and so they should be declared in
the class's header file. We will cover their implementations shortly, but here
is our first revision of the declaration of the class tt(Binary), declaring an
overloaded tt(+) operator as a free function:
        verbinclude(overloading/examples/binary1.h)

    By defining binary operators as free functions, the following promotions
are possible:
    itemization(
    it() If the left-hand operand is of the intended class type, the right
hand argument will be promoted whenever possible
    it() If the right-hand operand is of the intended class type, the left
hand argument will be promoted whenever possible
    it() No promotions occur when none of the operands are of the intended
class type
    it() An ambiguity occurs when promotions to different classes are possible
for the two operands. For example:
        verbinclude(overloading/examples/binaryambigu.cc)
    Here, both overloaded tt(+) operators are possible when compiling
the statement tt(a + a). The ambiguity must be solved by explicitly promoting
one of the arguments, e.g., tt(a + B(a)) will allow the compiler to resolve
the ambiguity to the first overloaded tt(+) operator.
    )

    The next step is to implement the corresponding
overloaded arithmetic assignment operator. As this operator em(always) has a
left-hand operand which is an object of its own class, it is implemented as a
true member function. Furthermore, the arithmetic assignment operator should
return a reference to the object to which the arithmetic operation applies, as
the object might be modified in the same statement. E.g.,
    tt((s2 += s3) + " postfix"). Here is our second revision of the class
tt(Binary), showing both the declaration of the plain binary operator and the
corresponding arithmetic assignment operator:
        verbinclude(overloading/examples/binary2.h)

    Finally, having available the arithmetic assignment operator, the
implementation of the plain binary operator turns out to be extremely
simple. It contains of a single return statement, in which an anonymous object
is constructed to which the arithmetic assignment operator is applied. This
anonymous object is then returned by the plain binary operator as its
tt(const) return value. Since its implementation consists of merely one
statement it is usually provided in-line, adding to its efficiency:
        verbinclude(overloading/examples/binary3.h)
    One might wonder where the temporary value is located. Most compilers
apply in these cases a procedure called `emi(return value optimization)': the
anonymous object is created at the location where the eventual returned object
will be stored. So, rather than first creating a separate temporary object,
and then copying this object later on to the return value, it initializes the
return value using the tt(l_hand) argument, and then applies the tt(+=)
operator to add the tt(r_hand) argument to it. Without return value
optimization it would have to:
    itemization(
    it() create separate room to accomodate the return value
    it() initialize a temporary object using tt(l_hand)
    it() Add tt(r_hand) to it
    it() Use the copy constructor to copy the temporary object to the return
        value.
    )
    Return value optimization is not required, but optionally available to
compilers. As it has no negative side effects, most compiler use it.
