    The compiler uses the following i(algorithm) to deduce the actual types of
        hi(template parameter deduction)
its template type parameters:
    itemization(
    it() In turn, the function template's parameters are identified using the
arguments of the called function.
    it() For each template parameter used in the function template's parameter
list, the template type parameter is matched with the corresponding argument's
type (e.g., tt(Type) is tt(int) if the argument is tt(int x), and the
function's parameter is tt(Type &value)).
    it() While matching the argument types to the template type parameters,
the three allowed transformations (see section ref(TEMPFUNARGS)) for template
type parameters are applied where necessary.
    it() If identic template type parameters
        hi(template parameters: identic types)
    are used with multiple function parameters, the deduced template types
must be exactly the same. So, the next function template cannot be called with
an tt(int) and a tt(double) argument:
        verb(
    template <typename Type>
    Type add(Type const &lvalue, Type const &rvalue)
    {
        return lvalue + rvalue;
    }
        )
    When calling this function template, two identic types must be used
(albeit that the three standard transformations are of course allowed). If the
template deduction mechanism does not come up with identic actual types for
identic template types, then the function template will not be instantiated.
    )
