    Earlier, in section ref(REDIR), it was noted that within a bf(C++)
program, streams could be hi(redirection) redirected using the
ti(ios::rdbuf()) member function. By assigning the tt(streambuf) of a stream
to another stream, both stream objects access the same tt(streambuf), thus
implementing redirection at the level of the programming language itself.

    Note that this is fine within the context of the bf(C++)
program, but if that context is left, the redirection terminates, as the
operating system does not know about tt(streambuf) objects. This happens,
e.g., when a program uses a ti(system()) call to start a subprogram. The
program at the end of this section uses bf(C++) redirection to redirect the
information inserted into ti(cout) to a file, and then calls
        verb(
    system("echo hello world")
        )
    to echo a well-known line of text. Since tt(echo) writes its information
to the standard output, this would be the program's redirected file if
bf(C++)'s redirection would be recognized by the operating system.

    Actually, this doesn't happen; and tt(hello world) still appears at the
program's standard output instead of the redirected file. A solution of this
problem involves redirection at the operating system level, for which some
operating systems (e.g., i(Unix) and friends) provide system calls like
ti(dup()) and ti(dup2()). Examples of these system calls are given in section
ref(PIPE).

    Here is the example of the em(failing redirection) at the system level
following  bf(C++) redirection using tt(streambuf) redirection:
        verbinclude(concrete/examples/noredir.cc)
