    The code associated with the i(regular expression) rules is located inside
the class ti(yyFlexLexer). However, we of course want to use the derived
class's members in this code. This causes a small problem. How does a
base-class member know about members of classes derived from it?

Inheritance helps us to overcome this problem. In the specification of
the class tt(yyFlexLexer), we notice that the function ti(yylex) is a
emi(virtual) function. The header file tt(FlexLexer.h) declares the
tt(virtual) member tt(int yylex):
        verb(
    class yyFlexLexer: public FlexLexer
    {
        public:
            yyFlexLexer( istream* arg_yyin = 0, ostream* arg_yyout = 0 );

            virtual ~yyFlexLexer();

            void yy_switch_to_buffer( struct yy_buffer_state* new_buffer );
            struct yy_buffer_state* yy_create_buffer( istream* s, int size );
            void yy_delete_buffer( struct yy_buffer_state* b );
            void yyrestart( istream* s );

            virtual int yylex();

            virtual void switch_streams( istream* new_in, ostream* new_out );
    };
        )
    As this function is virtual it can be overridden by a em(derived)
class. In that case the overridden function will be called from its
base class (i.e., tt(yyFlexLexer)) code. Since the derived class's
tt(yylex()) is called, it will now have access to the members of the derived
class, and also to the public and protected members of its base class.

    By default, the context in which the generated scanner is placed is the
function hi(yylex)tt(yyFlexLexer::yylex). This context changes if we use a
derived class, e.g., tt(Scanner). To derive tt(Scanner) from tt(yyFlexLexer),
generated by tt(flex), do as follows:
    itemization(
    it() The function tt(yylex) must be declared in the derived class
tt(Scanner).
    it() em(Options) (see below) are used to inform tt(flex) about the derived
class's name.
    )

    Looking at the regular expressions themselves, notice that we need rules
to recognize comment, ti(#include) directives, and all remaining characters.
This is all fairly standard practice. When an tt(#include) directive is
sensed, the directive is parsed by the scanner. This too is common
practice. Here is what our lexical scanner will do:
    itemization(
    it() As usual, i(preprocessor directive)s are not
analyzed by a parser, but by the lexical scanner;
    it() The scanner uses a i(mini scanner) to extract the filename from the
directive, throwing a tt(Scanner::Error) value (tt(invalidInclude)) if this
fails;
    it() If the filename could be extracted, it is stored in tt(nextSource);
    it() When the tt(#include) directive has been processed, tt(pushSource) is
called to perform the switch to another file;
    it() When the end of the file (endOfFile()) is reached, the derived class's
member function tt(popSource) is called, popping the previously
pushed file and returning ti(true);
    it() Once the file-stack is empty, tt(popSource) returns ti(false),
resulting in calling tt(yyterminate), terminating the scanner.
    )

    The i(lexical scanner specification file) is organized similarly as the
one used for tt(flex) in bf(C) contexts. However, in bf(C++) contexts,
tt(flex) may create a class (tt(yyFlexLexer)) from which another class (e.g.,
tt(Scanner)) can be derived. Flex's specification file itself has three
sections:
    itemization(
    it() The lexer specification file's first section is a bf(C++)
em(preamble), containing code which can be used in the code defining the
actions that are performed once a regular expression has been matched. In the
current setup, where each class has its own em(internal header file), the
internal header file includes the file tt(scanner.h), in turn including
ti(FlexLexer.h), which is part of the tt(flex) distribution.  tt(FlexLexer.h)
has a peculiar setup, due to which it should not be read twice by the code
generated by tt(flex). So, we now have the following situation:
        itemization(
        it() First we look at the lexer specification file. It contains a
preamble including tt(scanner.ih). The class tt(Scanner) is declared in
tt(scanner.h), which is read by tt(scanner.ih). Therefore tt(Scanner)'s
members are known and can be called from the code associated with the regular
expressions defined in the lexer specification file.
        it() However, in tt(scanner.h), defining tt(class Scanner), the header
file tt(FlexLexer.h), declaring tt(Scanner)'s base class, em(must) have been
read by the compiler before the class tt(Scanner) itself is defined.
        it() Code generated by tt(flex) already includes tt(FlexLexer.h), and
as mentioned, tt(FlexLexer.h) may not be read twice. Unfortunately, tt(flex)
also inserts the specification file's preamble into the code it generates.
        it() Since this preamble includes tt(scanner.ih), and so
tt(scanner.h), and so tt(FlexLexer.h), we now em(do) include tt(FlexLexer.h)
twice in code generated by tt(flex). This must be prevented.
        )
        This is how  multiple inclusions of tt(FlexLexer.h) can be prevented:
        itemization(
        it() Although tt(scanner.ih) includes tt(scanner.h), tt(scanner.h)
itself is modified such that it includes tt(FlexLexer.h), em(unless) the bf(C)
preprocesser variable ti(SKIP_FLEXLEXER_) is defined.
        it() In tt(flex)' specification file tt(SKIP_FLEXLEXER_) is defined
just prior to including tt(scanner.ih).
        )
        Using this scheme, code generated by tt(flex) now re-includes
tt(FlexLexer.h). At the same time the compilation of tt(Scanner)'s members
proceeds independently of the lexer specification file's preamble, so here
tt(FlexLexer.h) is properly included too. Here is the specification files'
preamble:
            verbCinsert(PREAMBLE)(lexer/scanner/lexer)
    it() The specification file's second section is a tt(flex)
        emi(symbol area), used to define symbols, like a i(mini scanner), or
emi(options). The following options are suggested:
        itemization(
        it() ti(%option 8bit): allowing the generated lexical scanner to
read 8-bit characters (rather than 7-bit, which is the default).
        it() ti(%option c++): this results in tt(flex) generating bf(C++)
code.
        it() ti(%option debug): includes em(debugging)
        hi(flex: debugging code) code into the code generated by
tt(flex). Calling the member function hi(set_debug)hi(flex: set_debug)
tt(set_debug(true)) activates this debugging code at run-time. When activated,
information about which rules are matched is written to the standard error
stream. To suppress the execution of debug code the member function
tt(set_debug(false)) may be called.
        it() ti(%option noyywrap): when the scanner reaches the end of file,
it will (by default) call a function tt(yywrap) which may perform the switch
to another file. Calling this function is suppressed when tt(%option noyywrap)
is specified. Since there exist alternatives which render this function
superfluous (see below), it is suggested to specify this option as well.
        it() ti(%option outfile)tt(="yylex.cc"): this defines tt(yylex.cc) as
the name of the generated bf(C++) source file.
        it() ti(%option warn): this option is strongly suggested by the
tt(flex) documentation, so it's mentioned here as well. See tt(flex)'
documentation for details.
        it() ti(%option yyclass)tt(="Scanner"): this defines tt(Scanner) as
the name of the class derived from tt(yyFlexLexer).
        it() ti(%option yylineno): this option causes the lexical scanner to
keep track of the line numbers of the files it is scanning. When processing
nested files the variable tt(yylineno) is not automatically reset to the last
line number of a file when tt(yylex) returns to a partially processed file. In
those cases, tt(yylineno) must explicitly  be reset to a former
value. If specified, the current line number is returned by the public member
ti(lineno), returning an tt(int).
        )
    Here is the specification files' symbol area:
            verbCinsert(SYMBOLS)(lexer/scanner/lexer)
    it() The specification file's third section is a em(rules section), in
which the regular expressions and their associated actions are defined.
    In the example developed here,  the lexer should
copy information from the hi(yyin) tt(istream *yyin) to the
    hi(yyout) ti(ostream *yyout). For this  the predefined macro
    ti(ECHO) can be used.  Here is the used symbol area:
            verbCinsert(RULES)(lexer/scanner/lexer)
    )
    Since the derived class's members may now access the information stored
in the lexical scanner itself (it can even access the information
em(directly), since tt(yyFlexLexer)'s data members of are i(protected), and
thus accessible to derived classes), most processing can be left to the
derived class's member functions.  This results in a very clean setup of the
lexer specification file, requiring no or hardly any code in the em(preamble).
