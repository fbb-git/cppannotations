    The example discussed in this section digs into the peculiarities of using
a i(parser)- and i(scanner) generator generating bf(C++) sources. Once the
input for a program exceeds a certain level of complexity, it's advantageous
to use a scanner- and parser-generator to create the code which does the
actual input recognition.

The current example assumes that the reader knows how to use the
    i(scanner generator) ti(flex) and the i(parser generator) ti(bison). Both
tt(bison) and tt(flex) are well documented elsewhere. The original
predecessors of tt(bison) and tt(flex), called ti(yacc) and ti(lex) are
described in several books, e.g. in
    hi(http://www.oreilly.com/catalog/lex)
    O'Reilly's book url(`lex & yacc')
    (http://www.oreilly.com/catalog/lex).

However, scanner- and parser generators are also (and maybe even more
commonly, nowadays) available as free software. Both tt(bison) and tt(flex)
are usually part of software distributions or they can be obtained from
    hi(ftp::/prep.ai.mit.edu/pub/non-gnu)
    tlurl(ftp://prep.ai.mit.edu/pub/non-gnu). tt(Flex) creates a tt(C++) class
when ti(%option c++) is specified.

For parser generators the program ti(bison) is available. Back in the early
90's em(Alain Coetmeur) (url(coetmeur@icdc.fr)(mailto:coetmeur@icdc.fr))
created a bf(C++) variant (ti(bison++)) creating a parser class. Although
tt(bison++) program produces code that can be used in bf(C++) programs it also
shows many characteristics that are more appropriate in a bf(C) context than
in a bf(C++) context. In January 2005 I rewrote parts of Alain's tt(bison++)
program, resulting in the original version of the program bi(bisonc++). Then,
in May 2005 a complete rewrite of the tt(bisonc++) parser generator was
completed, which is available on the Internet having version numbers 0.98 and
beyond. tt(Bisonc++) can be downloaded from
    tlurl(http://bisoncpp.sourceforge.net/), where it is available as source
archive and as binary (i386) url(Debian)(http://www.debian.org) binary package
(including tt(bisonc++)'s documentation). tt(Bisonc++) creates a cleaner
parser class setup than tt(bison++). In particular, it derives the parser
class from a base-class, containing the parser's token- and type-definitions
as well as all member functions which should not be (re)defined by the
programmer. Most of these members might also be defined directly in the parser
class. Because of this approach, the resulting parser class is very small,
declaring only members that are actually defined by the programmer (as well as
some other members, generated by tt(bisonc++) itself, implementing the
parser's ti(parse()) member). Actually, tt(parse()) is initially the em(only)
public member of tt(bisonc++)'s generated parser class. Remaining members are
private. The only member which is em(not) implemented by default is tt(lex()),
producing the next lexical token. When the directive tt(%scanner) (see section
ref(BISONDEF)) is used, tt(bisonc++) will generate a standard implementation
for this member; otherwise it must be implemented by the programmer.

In this section of the Annotations we will focus on tt(bisonc++) as our
emi(parser generator).

Using tt(flex) and tt(bisonc++) tt(class)-based scanners and parsers can be
generated. The advantage of this approach is that the interface to the scanner
and the parser tends to become cleaner than without using the tt(class)
interface. Furthermore, classes allow us to get rid of most if not all global
variables, making it easy to use multiple parsers in one program.

Below two examples are elaborated. The first example only uses tt(flex). The
scanner it generates monitors the production of a file from several
parts. This example focuses on the lexical scanner, and on switching files
while churning through the information. The second example uses both tt(flex)
and tt(bisonc++) to generate a scanner and a parser transforming standard
arithmetic expressions to their postfix notations, commonly used in
code generated by compilers and in tt(HP)-calculators.  In the second example
the emphasis is mainly on tt(bisonc++) and on composing a scanner object
inside a generated parser.
