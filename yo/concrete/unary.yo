As an opening example, let's assume we have a class tt(Strings) holding a
tt(vector<string> d_vs) data member. We would like to change all occurrences
of a specified set of letters found in the strings stored in tt(d_vs) into
uppercase characters, and we would like to insert the original em(and) modified
strings into a configurable tt(ostream) object.  To accomplish this, our class
offers a member tt(uppercase(ostream &out, char const *letters)).

We would like to use the tt(for_each()) generic algorithm. This algorithm may
be given a function object. The function object will be initialized with a
local context consisting of the tt(ostream) object and the set of letters to
be used. The following support class is constructed:
        verbinclude(concrete/wrap/support.h)
    Note that the implementation of tt(operator()()) contains another tt(for)
statement, which em(should) be replaced by another tt(for_each) call. This
suggests that either another function object must be constructed or that an
overloaded version of tt(operator()()) must be defined. Both alternatives are
not very attractive: constructing large numbers of small function object
classes soon becomes a nuisance and there's a limit imposed by the parameter
types to the number of overloaded tt(operator()()) members that can be
defined, let alone that the self-documenting value of the purpose of
`tt(operator()())' is very limited.

    For now an anonymous tt(Support) class object is used in the
implementation of the class tt(Strings). Here is an example of its definition
and use:
        verbinclude(concrete/wrap/strings1.cc)

To `templatize' the tt(Support) class using the considerations discussed
previously, we perform the following steps:
    itemization(
    it() The local context will be put in a tt(struct), which is then passed
to the template's constructor, so of the template
type parameters should be defined as a reference (or pointer, if that's
preferred) to a context struct.
    it() The implementation of the template's tt(operator()()) is
standardized: it will call a function, receiving the tt(operator()())'s
argument (which also becomes a template parameter) and a reference to the
context as its arguments. The address of the function to call may be stored in
a local variable of the function template object. In the tt(Support) class,
tt(operator()()) uses a tt(void) return type. This type is usually
appropriate, but when defining predicates a tt(bool) may be
required. Therefore, the return type of the template's tt(operator()()) (and
thus the return type of the called function) is made configurable as well,
offering a default type tt(void) for convenience. Thus, we get the following
definition of the variable holding the address of the function to call:
        verb(
    ReturnType (*d_fun)(Type, Context);
        )
    and the template's tt(operator()()),  coining the classname
tt(FnWrap1c) for `function object wrapper of a unary (1) function object,
accepting context information',  becomes:
        verb(
    template<typename Type, typename Context, typename ReturnType = void>
    inline ReturnType FnWrap1c<Type, Context, ReturnType>::operator()(
                                                Type param) const
    {
        return (*d_fun)(param, d_context);
    }
        )
    it() The template's constructor is given two arguments: a function address
and the local context:
        verb(
    template <typename Type, typename Context, typename ReturnType>
    FnWrap1c<Type, Context, ReturnType>::FnWrap1c(
                    ReturnType fun(Type, Context),  Context context)
    :
        d_fun(fun),
        d_context(context)
    {}
        )
    )
    Now we're ready to construct the full class template tt(FnWrap1c) using
the tt(TypeTraits) class to determine the em(argument_type) and
tt(result_type):
        verbinclude(concrete/wrap/fnwrap1.h)

    Now the template can be used. The class tt(Support) is abandoned. Instead
of using a separate class, all members required to transform the strings of
tt(Strings) objects will be defined as static members inside tt(Strings)
itself. This neatly localizes the actions where they belong: inside the class
that wants to transform its own data. So, the original dedicated
implementation of tt(Support::operator()()) is now defined as a static
member tt(xform) inside the class tt(Strings). The class also defines a
context struct tt(Context), containing a reference to the tt(ostream) to use
and a set of characters to capitalize. The public function tt(uppercase) now
simply initializes the context struct, and creates an tt(FnWrap1c) object,
calling tt(xform), which is passed to the tt(for_each) call. Note that
tt(FnWrap1c)'s template type arguments exactly mirror tt(xform)'s parameter
types. This is a general characteristic of the function object wrappers that
are introduced in this and the coming section.

    It is the purpose of tt(xform) to transform the characters of an
individual string. What better procedure than to call tt(for_each) again, this
time using the string's tt(begin()) and tt(end()) members to define another
iterator range. In this case the letter set must be known, and so it is passed
as the local context to tt(FnWrap1c) defined inside tt(xform). This latter
tt(FnWrap1c) object calls the static function tt(foundToUpper) to capitalize
individual characters of the strings if necessary. Here is the
new implementation of the class tt(Strings), now using tt(FnWrap1c):
        verbinclude(concrete/wrap/strings2.cc)

    To illustrate the use of the tt(ReturnType) template parameter, let's
assume that the transformations are only required up to the first empty
string. In this case, the tt(find_if) generic algorithm comes in handy, since
it stops once a predicate returns tt(true). In that case the tt(xform())
function should return a tt(bool) value, and the tt(uppercase())
implementation specifies an explicit type (tt(bool)) for the tt(ReturnType)
template parameter. The next implementation of the class tt(Strings) merely
shows the required modifications, the remainder is not altered:
        verbinclude(concrete/wrap/strings3.cc)
