In this chapter several concrete examples of bf(C++) programs, classes and
templates will be presented.  Topics covered by this document such as virtual
functions, tt(static) members, etc. are illustrated in this chapter. The
examples roughly follow the organization of earlier chapters.

    First, examples using tt(stream) classes are presented, including some
detailed examples illustrating polymorphism.  With the advent of the
i(ANSI/ISO) standard, classes supporting streams based on hi(file descriptor)
em(file descriptors) are no longer available, including the i(Gnu) tt(procbuf)
extension. These classes were frequently used in older bf(C++) programs. This
section of the bf(C++) Annotations develops an alternative: classes extending
tt(streambuf), allowing the use of file descriptors, and classes around the
ti(fork()) i(system call).

COMMENT(
    Next, several templates will be developed, both function templates and
full class templates. In addition to these templates Jesse van den Kieboom,
while attending the 2006-2007 edition of my bf(C++) course, wrote a neat
tt(auto_ptr) class using reference counting. His implementation
(tt(refcountautoptr.h)) is provided url(here)(contrib/concrete).
END)

    Finally, we'll touch the subjects of i(scanner) and i(parser) generators,
and show how these tools may be used in bf(C++) programs. These final examples
assume a certain familiarity with the concepts underlying these tools, like
grammars, parse-trees and
        hi(grammar)
        hi(parse-tree)
    parse-tree decoration. Once the input for a program exceeds a certain
level of complexity, it's advantageous to use scanner- and parser-generators
to produce code doing the actual input recognition. One of the
link(examples)(BisonAndFlex) in this chapter describes the usage of these
tools in a bf(C++) environment.
