    The i(declaration section) contains several declarations, among which all
tokens used in the grammar and the i(priority rules) of the mathematical
operators. Moreover, several new and important specifications can be used
here. Those that are relevant to our current example and only available in
tt(bisonc++) are discussed here. The reader is referred to tt(bisonc++)'s
em(man-page) hi(bisonc++: man-page) for a full description.
    itemization(
    it() bi(%baseclass-header) tt(header) nl()
          Defines the pathname of the file to contain (or containing) the
           parser's base class. Defaults to the name of the parser class plus
           the suffix tt(base.h).
    it() bi(%baseclass-preinclude) tt(header)nl()
          Use tt(header) as the pathname to the file pre-included in the
           parser's base-class header.  This declaration is useful in
           situations where the base class header file refers to types which
           might not yet be known. E.g., with bf(%union) a bf(std::string *)
           field might be used. Since the class bf(std::string) might not yet
           be known to the compiler once it processes the base class header
           file we need a way to inform the compiler about these classes and
           types. The suggested procedure is to use a pre-include header file
           declaring the required types. By default tt(header) will be
           surrounded by double quotes (using, e.g., tt(#include "header")).
           When the argument is surrounded by angle brackets tt(#include
           <header>) will be included. In the latter case, quotes might be
           required to escape interpretation by the shell (e.g., using tt(-H
           '<header>')).
    it() bi(%class-header) tt(header) nl()
          Defines the pathname of the file to contain (or containing) the
           parser class. Defaults to the name of the parser class plus the
           suffix tt(.h)
    it() bi(%class-name) tt(parser-class-name) nl()
          Declares the class name of this parser. This declaration replaces
           the bf(%name) declaration previously used by tt(bison++). It
           defines the name of the bf(C++) class that will be
           generated. Contrary to tt(bison++)'s bf(%name) declaration,
           bf(%class-name) may appear anywhere in the first section of the
           grammar specification file. It may be defined only once. If no
           bf(%class-name) is specified the default class name tt(Parser) will
           be used.
    it() bf(%debug) nl()
           Provide bf(parse()) and its support functions with debugging code,
            showing the actual parsing process on the standard output
            stream. When included, the debugging output is active by default,
            but its activity may be controlled using the bf(setDebug(bool
            on-off)) member. Note that no tt(#ifdef DEBUG) macros are used
            anymore. By rerunning tt(bisonc++) without the bf(--debug) option
            an equivalent parser is generated not containing the debugging
            code.
    it() bi(%filenames) tt(header) nl()
           Defines the generic name of all generated files, unless overridden
            by specific names. By default the generated files use the
           class-name as the generic file name.
    it() bi(%implementation-header) tt(header) nl()
          Defines the pathname of the file to contain (or containing) the
           implementation header. Defaults to the name of the generated parser
           class plus the suffix tt(.ih). The implementation header should
           contain all directives and declarations em(only) used by the
           implementations of the parser's member functions. It is the only
           header file that is included by the source file containing
           tt(parse())'s implementation. It is suggested that user defined
           implementations of other class members use the same convention,
           thus concentrating all directives and declarations that are
           required for the compilation of other source files belonging to the
           parser class in one header file.
    it() bi(%parsefun-source) tt(source) nl()
           Defines the pathname of the file containing the parser member
            bf(parse()). Defaults to tt(parse.cc).
    it() bf(%scanner) tt(header)nl()
           Use tt(header) as the pathname to the file pre-included in the
            parser's class header. This file should define a class
            bf(Scanner), offering a member tt(int yylex()) producing the next
            token from the input stream to be analyzed by the parser generated
            by tt(bisonc++). When this option is used the parser's member
            tt(int lex()) will be predefined as
                verb(
    int lex()
    {
        return d_scanner.yylex();
    }
                )
           and an object tt(Scanner d_scanner) will be composed into the
            parser. The tt(d_scanner) object will be constructed using its
            default constructor. If another constructor is required, the
            parser class may be provided with an appropriate (overloaded)
            parser constructor after having constructed the default parser
            class header file using tt(bisonc++).  By default tt(header) will
            be surrounded by double quotes (using, e.g., tt(#include
            "header")).  When the argument is surrounded by angle brackets
            tt(#include <header>) will be included.
    it() bi(%stype typename) nl()
           The type of the semantic value of tokens.  The specification
            tt(typename) should be the name of an unstructured type (e.g.,
            tt(unsigned)). By default it is tt(int). See bf(YYSTYPE) in
            tt(bison).  It should not be used if a bf(%union) specification is
            used.  Within the parser class, this type may be used as
            tt(STYPE).
    it() bi(%union) tt(union-definition) nl()
           Acts identically to the tt(bison) declaration.  As with tt(bison)
            this generates a union for the parser's semantic type.  The union
            type is named tt(STYPE). If no bf(%union) is declared, a simple
            stack-type may be defined using the bf(%stype) declaration. If no
            bf(%stype) declaration is used, the default stacktype (tt(int)) is
            used.
    )
    An example of a tt(%union) declaration is:
        verb(
    %union
    {
        int     i;
        double  d;
    };
        )
    A union hi(union: without objects) cannot contain objects as its fields,
as hi(union: and constructors) hi(constructors: and unions) constructors
cannot be called when a union is created. This means that
    hi(string: as union member) a tt(string) cannot be a member of the
union. A tt(string *), however, em(is) a possible union member. By the way:
the i(lexical scanner) does not have to know about such a union. The scanner
can simply pass its scanned text to the parser through its ti(YYText())
hi(bisonc++: using YYText()) member function. For example, using
a statement like
        verb(
    $$.i = A2x(scanner.YYText());
        )
    i(matched text) may be converted to a value of an appropriate type.

    Tokens and non-terminals can be associated with union fields. This is
strongly advised, as it prevents type mismatches, since the compiler will be
able to check for type correctness. At the same time, the bison specific
variabels tt($$), tt($1), tt($2), etc. may be used, rather than the full field
specification (like tt($$.i)).  A non-terminal or a token may be associated
with a union field using the
        hi(bisonc++: <fieldname>)
        hi(bisonc++: %token)
        hi(bisonc++: %type)
    tt(<fieldname>) specification. E.g.,
        verb(
    %token <i> INT          // token association (deprecated, see below)
           <d> DOUBLE
    %type  <i> intExpr      // non-terminal association
        )
    In the example developed here, note that both the tokens and the
non-terminals can be associated with a field of the union. However, as noted
before, the lexical scanner does not have to know about all this. In our
opinion, it is cleaner to let the scanner do just one thing: scan texts. The
em(parser), knowing what the input is all about, may then convert strings like
tt("123") to an integer value. Consequently, the association of a union field
and a token is discouraged.
        hi(bisonc++: associating token and union field)
    In the upcoming description of the rules of the grammar this will be
illustrated further.

    In the tt(%union) discussion the
        hi(bisonc++: %token)
        hi(bisonc++: %type)
    tt(%token) and tt(%type) specifications should be noted. They are used to
specify the tokens (i(terminal symbols)) that can be returned by
the lexical scanner, and to specify the return types of
non-terminals.  Apart from tt(%token) the i(token indicators)
        hi(bisonc++: %left) tt(%left),
        hi(bisonc++: %right) tt(%right) and
        hi(bisonc++: %nonassoc) tt(%nonassoc)
        hi(operators: associativity)
    may be used to specify the i(associativity of operators). The tokens
mentioned at these indicators are interpreted as tokens indicating operators,
associating in the indicated direction. The i(precedence of operators)
        hi(operators: precedence)hi(priority rules)hi(operators: priority)
 is given by their order: the first specification has the lowest priority. To
overrule a certain precedence in a certain context, hi(bisonc++: %prec)
tt(%prec) can be used. As all this is standard tt(bisonc++) practice, it isn't
further elaborated here. The documentation provided with tt(bisonc++)'s
distribution should be consulted for further reference.

    Here is the specification of the calculator's declaration section:
        verbinsert(DECLARATION)(concrete/bisonc++/parser/grammar)
    In the declaration section tt(%type) specifiers are used, associating the
tt(intExpr) rule's value (see the next section) to the tt(i)-field of the
semantic-value union, and associating tt(doubleExpr)'s value to the
tt(d)-field. At first sight this may look complex, since the expression rules
must be included for each individual return type. On the other hand, if the
union itself would have been used, we would still have had to specify
somewhere in the returned semantic values what field to use: less rules, but
more complex and error-prone code.

COMMENT(Also, note hi(scanner: as parser member) that the lexical scanner is
defined as a data-member of the parser. Actually, a separate tt(Scanner) class
is a bit overdone in the current example, but by doing so the general approach
we're advocating here is illustrated fully . In the current situation, the
declaration of the scanner class is rather simple:
        verbinclude(concrete/bisonc++/scanner/scanner.h)
    Usually the scanner can (and should) be defined as a (private) member of
the parser's class, as it's not used outside of the parser. The parser's
(virtual) destructor is included as a member to prevent the compiler from
complaining about the parser having a non-virtual destructor. E.g.,
        verb(
    warning: `class Parser' has virtual functions but non-virtual destructor
        )
END COMMENT)
