The program's code is generated in the same way as with programs using
tt(bison) and tt(flex). The files
tt(parser.cc) and tt(parser.h) are generated by  the command:
        verb(
    bisonc++ -V grammar
        )
    The option tt(-V) produces the file tt(parser.output) showing information
about the internal structure of the provided grammar (among which its
states). It is useful for debugging purposes and can be omitted if no
debugging is required.

tt(Bisonc++) may detect conflicts
    (i(shift-reduce) conflicts and/or i(reduce-reduce) conflicts) in the
provided grammar. These conflicts may be resolved explicitly using
disambiguating rules or they are `resolved' by default. By default, a
shift-reduce conflict is resolved by shifting (i.e., the next token is
consumed). By default a reduce-reduce conflict is resolved by using the first
of two competing production rules. tt(Bisonc++)'s
    i(conflict resolution) procedures are identical to tt(bison)'s procedures.

    Once a parser class and a parsing member function has been constructed
ti(flex) may be used to create a lexical scanner using, e.g., the command
        verb(
    flex -I lexer
        )

    On i(Unix) systems a command like
        verb(
    g++ -o calc -Wall *.cc -s
        )
    can be used to compile and link the source of the main program and
the sources produced by the scanner and parser generators.

    Finally, here is a source file in which the tt(main) function and the
parser object is defined. The parser features the lexical scanner as one of
its data members:
        verbinclude(bisonc++/parser.cc)

    tt(Bisonc++) can be downloaded from hi(http://bisoncpp.sourceforge.net/)
    tlurl(http://bisoncpp.sourceforge.net/). It requires the tt(bobcat)
library, which can be downloaded from hi(http://bobcat.sourceforge.net/)
    tlurl(http://bobcat.sourceforge.net/).
