The i(grammar specification file) required by ti(bisonc++) is comparable to
the specification file required by ti(bison). Differences are related to the
class nature of the resulting parser. Our calculator will distinguish real
numbers from integers, and will support a basic set of arithmetic operators.

tt(Bisonc++) should be used as follows:
    itemization(
    it() As usual, a grammar must be defined. With tt(bisonc++) this is no
        different, and tt(bisonc++) grammar definitions are for all practical
        purposes identic to tt(bison)'s grammar definitions.
    it() Having specified the grammar and (usually) some declarations
        tt(bisonc++) is able to generate files defining the parser class and
        the implementation of the member function tt(parse()).
    it() All class members (except those that are required for the proper
        functioning of the member tt(parse())) must be
        implemented by the programmer.  Of course, they should also be
        declared in the parser class's header.  At the very least the member
        ti(lex()) must be implemented. This member is called by tt(parse()) to
        obtain the next available token.  However, tt(bisonc++) offers a
        facility providing a standard implementation of the function
        bf(lex()). The member function
            ti(error(char const *msg))
       is given a simple default implementation which may be modified by the
        programmer. The member function tt(error()) is called when tt(parse())
        detects (syntactic) errors.
    it() The parser can now be used in a program. A very simple example would
        be:
        verb(
    int main()
    {
        Parser parser;
        return parser.parse();
    }
        )
    )

The tt(bisonc++) specification file consists of two sections:
    itemization(
    it() The hi(bisonc++: declaration section) emi(declaration section). In
        this section bison's tokens, and the i(priority rules) for the
        operators are declared. However, tt(bisonc++) also supports several
        new declarations.  These new declarations are important and are
        discussed below.
    it() The hi(bisonc++: rules section) em(rules section). The
       i(grammatical rules) define the grammar. This section is identic to
        the one required by tt(bison), albeit that some members that were
        available in tt(bison) and tt(bison++) are considered obsolete in
        tt(bisonc++), while other members can now be used in a wider context.
        For example, bf(ACCEPT()) and bf(ABORT()) can be called from any
        member called from the parser's action blocks to terminate the parsing
        process.
    )
Readers familiar with tt(bison) should note that there is no
    emi(header section) anymore. Header sections are used by bison to provide
for the necessary declarations allowing the compiler to compile the bf(C)
function generated by tt(bison). In bf(C++) declarations are part of or
already used by class definitions. Therefore, a parser generator generating a
bf(C++) class and some of its member functions does not require a header
section anymore.


COMMENT(Here is an example showing the first section of a tt(bisonc++) grammar
definition file:
    verbinclude(concrete/parser/parser/gramspec/header.gr0)
END)
