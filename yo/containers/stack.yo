The ti(stack) class implements a i(stack data structure).  Before tt(stack)
containers can be used the following preprocessor directive must have been
specified: hi(#include <stack>)
        verb(
    #include <stack>
        )
    A stack is also called a i(first in, last out) (i(FILO) or i(LIFO)) data
structure, as the first item to enter the stack is the last item to leave.  A
stack is an extremely useful data structure in situations where data must
temporarily remain available. For example, programs maintain a stack to store
i(local variables) of functions: the i(lifetime) of these variables is
determined by the time these functions are active, contrary to
        hi(global variables)
    global (or static
        hi(static local variables)
    local) variables, which live for as long as the program itself
lives. Another example is found in i(calculators) using the
        emi(Reverse Polish Notation) (i(RPN)),
    in which the operands of operators are entered in the stack, whereas
operators pop their operands off the stack and push the results of their work
back onto the stack.

As an example of the use of a stack, consider figure ref(StackFig), in which
the contents of the stack is shown while the expression tt((3 + 4) * 2) is
evaluated. In the RPN this expression becomes tt(3 4 + 2 *), and figure
ref(StackFig) shows the stack contents after each emi(token) (i.e., the
operands and the operators) is read from the input. Notice that each operand
is indeed pushed on the stack, while each operator changes the contents of the
stack.
    figure(containers/stack/stack)
    (The contents of a stack while evaluating tt(3 4 + 2 *))
    (StackFig)
    The i(expression) is evaluated in five steps. The caret between the tokens
in the expressions shown on the first line of figure ref(StackFig) shows what
token has just been read. The next line shows the actual stack-contents, and
the final line shows the steps for referential purposes. Note that at step 2,
two numbers have been pushed on the stack. The first number (tt(3)) is now at
the bottom of the stack. Next, in step 3, the tt(+) operator is read. The
operator pops two operands (so that the stack is empty at that moment),
calculates their sum, and pushes the resulting value (tt(7)) on the
stack. Then, in step 4, the number tt(2) is read, which is dutifully pushed on
the stack again. Finally, in step 5 the final operator tt(*) is read, which
pops the values tt(2) and tt(7) from the stack, computes their product, and
pushes the result back on the stack. This result (tt(14)) could then be popped
to be displayed on some medium.

From figure ref(StackFig) we see that a stack has one point (the emi(top))
where items can be pushed onto and popped off the stack. This top element is
the stack's only immediately visible element. It may be accessed and modified
directly.

Bearing this model of the stack in mind, let's see what we can formally do
with it using the tt(stack) container. For the tt(stack), the following
constructors, operators, and member functions are available:
    itemization(
    it() hi(stack constructors) Constructors:
        itemization(
        it() A tt(stack) may be constructed empty:
        verb(
    stack<string> object;
        )
        it() A stack may be initialized using a i(copy constructor):
        verb(
    extern stack<string> container;
    stack<string> object(container);
        )
    )
    it() Only the basic set of container operators are supported by the
tt(stack)
    it() The following i(member functions) are available for stacks:
        itemization(
        ithtq(stack::empty())(bool stack::empty())(this
member returns tt(true) if the stack contains no elements.)
        ithtq(stack::push())(void stack::push(value))(this member places
tt(value) at the top of the stack, hiding the other elements from view.)
        ithtq(stack::pop())(void stack::pop())(this member removes the element
at the top of the stack. Note that the popped element is em(not) returned by
this member. Nothing happens if tt(pop()) is used with an empty stack. See
section ref(QUEUE) for a discussion about the reason why tt(pop()) has return
type tt(void).)
        ithtq(stack::size())(size_t stack::size())(this
member returns the number of elements in the stack.)
        ithtq(stack::top())(Type &stack::top())(this member
returns a reference to the stack's top (and only visible) element. It is the
    i(responsibility of the programmer) to use this member only if the stack
is not empty.)
        )
    )
    Note that the stack does not support iterators or a subscript
operator. The only elements that can be accessed is its top element.
  A stack can be emptied by:
    itemization(
    it() repeatedly removing its front element;
    it() assigning an empty stack using the same data type to it;
    it() having its destructor called.
    )
