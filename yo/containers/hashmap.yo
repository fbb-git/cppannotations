The map is a sorted data structure. The keys in maps are sorted using the
ti(operator<()) of the key's i(data type). Generally, this is not the fastest
way to either store or retrieve data.  The main benefit of sorting is that a
listing of sorted keys appeals more to humans than an unsorted list.  However,
a by far faster method to store and retrieve data is to use emi(hashing).

Hashing uses a function (called the emi(hash function)) to compute an
(unsigned) number from the key, which number is thereupon used as an index in
the table in which the keys are stored. Retrieval of a key is as simple as
computing the i(hash value) of the provided key, and looking in the table at
the computed index location: if the key is present, it is stored in the table,
and its value can be returned. If it's not present, the key is not stored.

Collisions hi(collision) occur when a computed index position is already
occupied by another element. For these situations the abstract containers have
solutions available, but that topic is beyond the subject of this chapter.

The i(Gnu) i(g++) compiler supports the em(hash_(multi)map) and
tt(hash_(multi)set) containers. Below the ti(hash_map) container is
discussed.  Other containers using hashing (ti(hash_multimap),
ti(hash_set) and ti(hash_multiset)) operate correspondingly.


Concentrating on the tt(hash_map), its constructor needs a emi(key type), a
i(value type), an object creating a hash value for the key, and an object
comparing two keys for equality.  Hash functions are available for
    ti(char const *) keys, and for all the
    i(scalar numeric types) tt(char, short, int) etc.. If another data type
is used, a hash function and an equality test must be implemented,
possibly using hi(function object) em(function objects) (see section
ref(FUNOBJ)). For both situations examples are given below.

The class implementing the hash function could be called tt(hash).  Its
i(function call operator) (ti(operator()())) returns the hash value of the key
that is passed as its argument.

A em(generic algorithm) (see chapter ref(STL)) exists for the test of equality
(i.e., tt(equal_to())), which can be used if the key's data type supports the
equality operator. Alternatively, a specialized i(function object) could be
constructed here, supporting the equality test of two keys. Again, both
situations are illustrated below.

The tt(hash_map) class implements an i(associative array) in which the key is
stored according to some hashing scheme. Before tt(hash_map) containers can be
used the following preprocessor directive must have been specified:
    hi(#include <ext/hash_map>)
        verb(
    #include <ext/hash_map>
        )
    The tt(hash_(multi)map) is not yet part of the i(ANSI/ISO) standard.  Once
this container becomes part of the standard, it is likely that the tt(ext/)
prefix in the tt(#include) preprocessor directive can be removed. Note that
starting with the
    i(Gnu) ti(g++) i(compiler) version 3.2 the ti(__gnu_cxx) namespace is used
for symbols defined in the tt(ext/) header files. See also section
ref(WHATSNEW).

    Constructors, operators and member functions available for the tt(map) are
also available for the tt(hash_map). The tt(map) and tt(hash_map) support
the same set of operators and member functions. However, the
emi(efficiency) of a tt(hash_map) in terms of speed should greatly exceed the
efficiency of the tt(map). Comparable conclusions may be drawn for the
tt(hash_set), tt(hash_multimap) and the tt(hash_multiset).

Compared to the tt(map) container, the tt(hash_map) has an additional
constructor:
        verb(
        hash_map<...> hash(n);
        )
    where tt(n) is a tt(size_t) value, may be used to construct a
tt(hash_map) consisting of an initial number of at least tt(n) empty slots to
put key/value combinations in. This number is automatically extended when
needed.

The hashed key type is almost always text. So, a tt(hash_map) in which the
key's data type is either tt(char const *) or a tt(string) occurs most often.
If the following i(header file) is installed in the bf(C++) compiler's
ti(INCLUDE path) as the file ti(hashclasses.h), sources may specify the
following preprocessor directive to make a set of classes available that can
be used to instantiate hi(instantiation) a hash table
    hi(#include <hashclasses.h>)
        verb(
    #include <hashclasses.h>
        )
    Otherwise, sources must specify the following preprocessor directive:
        verb(
    #include <ext/hash_map>
        )
        verbinclude(containers/examples/hashclasses.h)
    The following program defines a hash_map containing the names of the
months of the year and the number of days these months (usually) have. Then,
using the subscript operator the days in several months are displayed. The
equality operator used the generic algorithm tt(equal_to<string>), which is
the default fourth argument of the tt(hash_map) constructor:
        verbinclude(containers/examples/hashstring.cc)

The tt(hash_multimap, hash_set) and tt(hash_multiset) containers are used
analogously. For these containers the tt(equal) and tt(hash) classes must also
be defined. The tt(hash_multimap) also requires the tt(hash_map) header file.

Before the tt(hash_set) and tt(hash_multiset) containers can be used the
following preprocessor directive must have been specified:
    hi(#include <ext/hash_set>)
        verb(
    #include <ext/hash_set>
        )
