The ti(map) class offers a (sorted) i(associative array). Before using a
tt(map) container the tthi(map) header file must have been included.

    A tt(map) is filled with emi(key/value) pairs, which may be of any
container-accepted type. Since types are associated with both the key and the
value, we must specify em(two types) in the angle bracket notation, comparable
to the specification we've seen with the tt(pair) container (cf. section
ref(PAIR)). The first type represents the key's type, the second type
represents the value's type. For example, a tt(map) in which the key is a
tt(string) and the value is a tt(double) can be defined as follows:
        verb(
    map<string, double> object;
        )
    The emi(key) is used to access its associated information. That
information is called the emi(value). For example, a phone book uses the
names of people as the key, and uses the telephone number and maybe other
information (e.g., the zip-code, the address, the profession) as
value. Since a tt(map) sorts its keys, the tt(key)'s ti(operator<) must be
defined, and it must be sensible to use it. For example, it is generally a bad
idea to use pointers for keys, as sorting pointers is something different than
sorting the values pointed at by those pointers.

    The two fundamental operations on maps are the storage of em(Key/Value)
combinations, and the retrieval of values, given their keys. The index
operator using a key as the index, can be used for both. If the index operator
is used as em(lvalue), the expression's tt(rvalue) is inserted into the
map. If it is used as em(rvalue), the key's associated value is retrieved.
Each key can be stored only once in a tt(map). If the same key is entered
again, the new value replaces the formerly stored value, which is lost.

A specific key/value combination can implicitly or explicitly be inserted into
a tt(map). If explicit insertion is required, the key/value combination
must be constructed first. For this, every tt(map) defines a ti(value_type)
which may be used to create values that can be stored in the tt(map). For
example, a value for a tt(map<string, int>) can be constructed as follows:
        verb(
    map<string, int>::value_type siValue("Hello", 1);
        )
    The tt(value_type) is associated with the tt(map<string, int>): the
type of the key is tt(string), the type of the value is tt(int). Anonymous
tt(value_type) objects are also often used. E.g.,
        verb(
    map<string, int>::value_type("Hello", 1);
        )
    Instead of using the line tt(map<string, int>::value_type(...)) over and
over again, a ti(typedef) is frequently used to reduce typing and to improve
readability:
        verb(
    typedef map<string, int>::value_type StringIntValue
        )
    Using this typedef, values for the tt(map<string, int>) may now be
constructed using:
        verb(
    StringIntValue("Hello", 1);
        )
    Alternatively, tt(pairs) may be used to represent key/value combinations
used by maps:
        verb(
    pair<string, int>("Hello", 1);
        )











